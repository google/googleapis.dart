// This is a generated file (see the discoveryapis_generator project).

// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: file_names
// ignore_for_file: library_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_expression_function_bodies
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_string_interpolations

/// Compute Engine API - v1
///
/// Creates and runs virtual machines on Google Cloud Platform.
///
/// For more information, see <https://cloud.google.com/compute/>
///
/// Create an instance of [ComputeApi] to access these resources:
///
/// - [AcceleratorTypesResource]
/// - [AddressesResource]
/// - [AutoscalersResource]
/// - [BackendBucketsResource]
/// - [BackendServicesResource]
/// - [DiskTypesResource]
/// - [DisksResource]
/// - [ExternalVpnGatewaysResource]
/// - [FirewallPoliciesResource]
/// - [FirewallsResource]
/// - [ForwardingRulesResource]
/// - [GlobalAddressesResource]
/// - [GlobalForwardingRulesResource]
/// - [GlobalNetworkEndpointGroupsResource]
/// - [GlobalOperationsResource]
/// - [GlobalOrganizationOperationsResource]
/// - [GlobalPublicDelegatedPrefixesResource]
/// - [HealthChecksResource]
/// - [HttpHealthChecksResource]
/// - [HttpsHealthChecksResource]
/// - [ImageFamilyViewsResource]
/// - [ImagesResource]
/// - [InstanceGroupManagersResource]
/// - [InstanceGroupsResource]
/// - [InstanceTemplatesResource]
/// - [InstancesResource]
/// - [InterconnectAttachmentsResource]
/// - [InterconnectLocationsResource]
/// - [InterconnectsResource]
/// - [LicenseCodesResource]
/// - [LicensesResource]
/// - [MachineTypesResource]
/// - [NetworkEndpointGroupsResource]
/// - [NetworksResource]
/// - [NodeGroupsResource]
/// - [NodeTemplatesResource]
/// - [NodeTypesResource]
/// - [PacketMirroringsResource]
/// - [ProjectsResource]
/// - [PublicAdvertisedPrefixesResource]
/// - [PublicDelegatedPrefixesResource]
/// - [RegionAutoscalersResource]
/// - [RegionBackendServicesResource]
/// - [RegionCommitmentsResource]
/// - [RegionDiskTypesResource]
/// - [RegionDisksResource]
/// - [RegionHealthCheckServicesResource]
/// - [RegionHealthChecksResource]
/// - [RegionInstanceGroupManagersResource]
/// - [RegionInstanceGroupsResource]
/// - [RegionInstancesResource]
/// - [RegionNetworkEndpointGroupsResource]
/// - [RegionNotificationEndpointsResource]
/// - [RegionOperationsResource]
/// - [RegionSslCertificatesResource]
/// - [RegionTargetHttpProxiesResource]
/// - [RegionTargetHttpsProxiesResource]
/// - [RegionUrlMapsResource]
/// - [RegionsResource]
/// - [ReservationsResource]
/// - [ResourcePoliciesResource]
/// - [RoutersResource]
/// - [RoutesResource]
/// - [SecurityPoliciesResource]
/// - [ServiceAttachmentsResource]
/// - [SnapshotsResource]
/// - [SslCertificatesResource]
/// - [SslPoliciesResource]
/// - [SubnetworksResource]
/// - [TargetGrpcProxiesResource]
/// - [TargetHttpProxiesResource]
/// - [TargetHttpsProxiesResource]
/// - [TargetInstancesResource]
/// - [TargetPoolsResource]
/// - [TargetSslProxiesResource]
/// - [TargetTcpProxiesResource]
/// - [TargetVpnGatewaysResource]
/// - [UrlMapsResource]
/// - [VpnGatewaysResource]
/// - [VpnTunnelsResource]
/// - [ZoneOperationsResource]
/// - [ZonesResource]
library compute.v1;

import 'dart:async' as async;
import 'dart:convert' as convert;
import 'dart:core' as core;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

import '../src/user_agent.dart';

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show ApiRequestError, DetailedApiRequestError;

/// Creates and runs virtual machines on Google Cloud Platform.
class ComputeApi {
  /// See, edit, configure, and delete your Google Cloud data and see the email
  /// address for your Google Account.
  static const cloudPlatformScope =
      'https://www.googleapis.com/auth/cloud-platform';

  /// View and manage your Google Compute Engine resources
  static const computeScope = 'https://www.googleapis.com/auth/compute';

  /// View your Google Compute Engine resources
  static const computeReadonlyScope =
      'https://www.googleapis.com/auth/compute.readonly';

  /// Manage your data and permissions in Cloud Storage and see the email
  /// address for your Google Account
  static const devstorageFullControlScope =
      'https://www.googleapis.com/auth/devstorage.full_control';

  /// View your data in Google Cloud Storage
  static const devstorageReadOnlyScope =
      'https://www.googleapis.com/auth/devstorage.read_only';

  /// Manage your data in Cloud Storage and see the email address of your Google
  /// Account
  static const devstorageReadWriteScope =
      'https://www.googleapis.com/auth/devstorage.read_write';

  final commons.ApiRequester _requester;

  AcceleratorTypesResource get acceleratorTypes =>
      AcceleratorTypesResource(_requester);
  AddressesResource get addresses => AddressesResource(_requester);
  AutoscalersResource get autoscalers => AutoscalersResource(_requester);
  BackendBucketsResource get backendBuckets =>
      BackendBucketsResource(_requester);
  BackendServicesResource get backendServices =>
      BackendServicesResource(_requester);
  DiskTypesResource get diskTypes => DiskTypesResource(_requester);
  DisksResource get disks => DisksResource(_requester);
  ExternalVpnGatewaysResource get externalVpnGateways =>
      ExternalVpnGatewaysResource(_requester);
  FirewallPoliciesResource get firewallPolicies =>
      FirewallPoliciesResource(_requester);
  FirewallsResource get firewalls => FirewallsResource(_requester);
  ForwardingRulesResource get forwardingRules =>
      ForwardingRulesResource(_requester);
  GlobalAddressesResource get globalAddresses =>
      GlobalAddressesResource(_requester);
  GlobalForwardingRulesResource get globalForwardingRules =>
      GlobalForwardingRulesResource(_requester);
  GlobalNetworkEndpointGroupsResource get globalNetworkEndpointGroups =>
      GlobalNetworkEndpointGroupsResource(_requester);
  GlobalOperationsResource get globalOperations =>
      GlobalOperationsResource(_requester);
  GlobalOrganizationOperationsResource get globalOrganizationOperations =>
      GlobalOrganizationOperationsResource(_requester);
  GlobalPublicDelegatedPrefixesResource get globalPublicDelegatedPrefixes =>
      GlobalPublicDelegatedPrefixesResource(_requester);
  HealthChecksResource get healthChecks => HealthChecksResource(_requester);
  HttpHealthChecksResource get httpHealthChecks =>
      HttpHealthChecksResource(_requester);
  HttpsHealthChecksResource get httpsHealthChecks =>
      HttpsHealthChecksResource(_requester);
  ImageFamilyViewsResource get imageFamilyViews =>
      ImageFamilyViewsResource(_requester);
  ImagesResource get images => ImagesResource(_requester);
  InstanceGroupManagersResource get instanceGroupManagers =>
      InstanceGroupManagersResource(_requester);
  InstanceGroupsResource get instanceGroups =>
      InstanceGroupsResource(_requester);
  InstanceTemplatesResource get instanceTemplates =>
      InstanceTemplatesResource(_requester);
  InstancesResource get instances => InstancesResource(_requester);
  InterconnectAttachmentsResource get interconnectAttachments =>
      InterconnectAttachmentsResource(_requester);
  InterconnectLocationsResource get interconnectLocations =>
      InterconnectLocationsResource(_requester);
  InterconnectsResource get interconnects => InterconnectsResource(_requester);
  LicenseCodesResource get licenseCodes => LicenseCodesResource(_requester);
  LicensesResource get licenses => LicensesResource(_requester);
  MachineTypesResource get machineTypes => MachineTypesResource(_requester);
  NetworkEndpointGroupsResource get networkEndpointGroups =>
      NetworkEndpointGroupsResource(_requester);
  NetworksResource get networks => NetworksResource(_requester);
  NodeGroupsResource get nodeGroups => NodeGroupsResource(_requester);
  NodeTemplatesResource get nodeTemplates => NodeTemplatesResource(_requester);
  NodeTypesResource get nodeTypes => NodeTypesResource(_requester);
  PacketMirroringsResource get packetMirrorings =>
      PacketMirroringsResource(_requester);
  ProjectsResource get projects => ProjectsResource(_requester);
  PublicAdvertisedPrefixesResource get publicAdvertisedPrefixes =>
      PublicAdvertisedPrefixesResource(_requester);
  PublicDelegatedPrefixesResource get publicDelegatedPrefixes =>
      PublicDelegatedPrefixesResource(_requester);
  RegionAutoscalersResource get regionAutoscalers =>
      RegionAutoscalersResource(_requester);
  RegionBackendServicesResource get regionBackendServices =>
      RegionBackendServicesResource(_requester);
  RegionCommitmentsResource get regionCommitments =>
      RegionCommitmentsResource(_requester);
  RegionDiskTypesResource get regionDiskTypes =>
      RegionDiskTypesResource(_requester);
  RegionDisksResource get regionDisks => RegionDisksResource(_requester);
  RegionHealthCheckServicesResource get regionHealthCheckServices =>
      RegionHealthCheckServicesResource(_requester);
  RegionHealthChecksResource get regionHealthChecks =>
      RegionHealthChecksResource(_requester);
  RegionInstanceGroupManagersResource get regionInstanceGroupManagers =>
      RegionInstanceGroupManagersResource(_requester);
  RegionInstanceGroupsResource get regionInstanceGroups =>
      RegionInstanceGroupsResource(_requester);
  RegionInstancesResource get regionInstances =>
      RegionInstancesResource(_requester);
  RegionNetworkEndpointGroupsResource get regionNetworkEndpointGroups =>
      RegionNetworkEndpointGroupsResource(_requester);
  RegionNotificationEndpointsResource get regionNotificationEndpoints =>
      RegionNotificationEndpointsResource(_requester);
  RegionOperationsResource get regionOperations =>
      RegionOperationsResource(_requester);
  RegionSslCertificatesResource get regionSslCertificates =>
      RegionSslCertificatesResource(_requester);
  RegionTargetHttpProxiesResource get regionTargetHttpProxies =>
      RegionTargetHttpProxiesResource(_requester);
  RegionTargetHttpsProxiesResource get regionTargetHttpsProxies =>
      RegionTargetHttpsProxiesResource(_requester);
  RegionUrlMapsResource get regionUrlMaps => RegionUrlMapsResource(_requester);
  RegionsResource get regions => RegionsResource(_requester);
  ReservationsResource get reservations => ReservationsResource(_requester);
  ResourcePoliciesResource get resourcePolicies =>
      ResourcePoliciesResource(_requester);
  RoutersResource get routers => RoutersResource(_requester);
  RoutesResource get routes => RoutesResource(_requester);
  SecurityPoliciesResource get securityPolicies =>
      SecurityPoliciesResource(_requester);
  ServiceAttachmentsResource get serviceAttachments =>
      ServiceAttachmentsResource(_requester);
  SnapshotsResource get snapshots => SnapshotsResource(_requester);
  SslCertificatesResource get sslCertificates =>
      SslCertificatesResource(_requester);
  SslPoliciesResource get sslPolicies => SslPoliciesResource(_requester);
  SubnetworksResource get subnetworks => SubnetworksResource(_requester);
  TargetGrpcProxiesResource get targetGrpcProxies =>
      TargetGrpcProxiesResource(_requester);
  TargetHttpProxiesResource get targetHttpProxies =>
      TargetHttpProxiesResource(_requester);
  TargetHttpsProxiesResource get targetHttpsProxies =>
      TargetHttpsProxiesResource(_requester);
  TargetInstancesResource get targetInstances =>
      TargetInstancesResource(_requester);
  TargetPoolsResource get targetPools => TargetPoolsResource(_requester);
  TargetSslProxiesResource get targetSslProxies =>
      TargetSslProxiesResource(_requester);
  TargetTcpProxiesResource get targetTcpProxies =>
      TargetTcpProxiesResource(_requester);
  TargetVpnGatewaysResource get targetVpnGateways =>
      TargetVpnGatewaysResource(_requester);
  UrlMapsResource get urlMaps => UrlMapsResource(_requester);
  VpnGatewaysResource get vpnGateways => VpnGatewaysResource(_requester);
  VpnTunnelsResource get vpnTunnels => VpnTunnelsResource(_requester);
  ZoneOperationsResource get zoneOperations =>
      ZoneOperationsResource(_requester);
  ZonesResource get zones => ZonesResource(_requester);

  ComputeApi(http.Client client,
      {core.String rootUrl = 'https://compute.googleapis.com/',
      core.String servicePath = 'compute/v1/'})
      : _requester =
            commons.ApiRequester(client, rootUrl, servicePath, requestHeaders);
}

class AcceleratorTypesResource {
  final commons.ApiRequester _requester;

  AcceleratorTypesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of accelerator types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/acceleratorTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AcceleratorTypeAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified accelerator type.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [acceleratorType] - Name of the accelerator type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorType> get(
    core.String project,
    core.String zone,
    core.String acceleratorType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/acceleratorTypes/' +
        commons.escapeVariable('$acceleratorType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AcceleratorType.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of accelerator types that are available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/acceleratorTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AcceleratorTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class AddressesResource {
  final commons.ApiRequester _requester;

  AddressesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/addresses';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AddressAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String address, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/addresses/' +
        commons.escapeVariable('$address');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(
    core.String project,
    core.String region,
    core.String address, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/addresses/' +
        commons.escapeVariable('$address');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Address.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an address resource in the specified project by using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Address request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/addresses';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of addresses contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/addresses';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AddressList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class AutoscalersResource {
  final commons.ApiRequester _requester;

  AutoscalersResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of autoscalers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/autoscalers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AutoscalerAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String autoscaler, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers/' +
        commons.escapeVariable('$autoscaler');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified autoscaler resource.
  ///
  /// Gets a list of available autoscalers by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
    core.String project,
    core.String zone,
    core.String autoscaler, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers/' +
        commons.escapeVariable('$autoscaler');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Autoscaler.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of autoscalers contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AutoscalerList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String? autoscaler,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (autoscaler != null) 'autoscaler': [autoscaler],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String? autoscaler,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (autoscaler != null) 'autoscaler': [autoscaler],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class BackendBucketsResource {
  final commons.ApiRequester _requester;

  BackendBucketsResource(commons.ApiRequester client) : _requester = client;

  /// Adds a key for validating requests with signed URLs for this backend
  /// bucket.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addSignedUrlKey(
    SignedUrlKey request,
    core.String project,
    core.String backendBucket, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket') +
        '/addSignedUrlKey';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified BackendBucket resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String backendBucket, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a key for validating requests with signed URLs for this backend
  /// bucket.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [keyName] - The name of the Signed URL Key to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteSignedUrlKey(
    core.String project,
    core.String backendBucket,
    core.String keyName, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'keyName': [keyName],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket') +
        '/deleteSignedUrlKey';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified BackendBucket resource.
  ///
  /// Gets a list of available backend buckets by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucket].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucket> get(
    core.String project,
    core.String backendBucket, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendBucket.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a BackendBucket resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendBucket request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of BackendBucket resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucketList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucketList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendBucketList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendBucket request,
    core.String project,
    core.String backendBucket, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendBucket request,
    core.String project,
    core.String backendBucket, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class BackendServicesResource {
  final commons.ApiRequester _requester;

  BackendServicesResource(commons.ApiRequester client) : _requester = client;

  /// Adds a key for validating requests with signed URLs for this backend
  /// service.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addSignedUrlKey(
    SignedUrlKey request,
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/addSignedUrlKey';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of all BackendService resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/backendServices';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendServiceAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a key for validating requests with signed URLs for this backend
  /// service.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [keyName] - The name of the Signed URL Key to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteSignedUrlKey(
    core.String project,
    core.String backendService,
    core.String keyName, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'keyName': [keyName],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/deleteSignedUrlKey';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified BackendService resource.
  ///
  /// Gets a list of available backend services.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
    core.String project,
    core.String backendService, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendService.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the most recent health check results for this BackendService.
  ///
  /// Example request body: { "group":
  /// "/zones/us-east1-b/instanceGroups/lb-backend-example" }
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// queried instance belongs.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
    ResourceGroupReference request,
    core.String project,
    core.String backendService, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/getHealth';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return BackendServiceGroupHealth.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a BackendService resource in the specified project using the data
  /// included in the request.
  ///
  /// For more information, see Backend services overview .
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendService request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of BackendService resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendServiceList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified BackendService resource with the data included in
  /// the request.
  ///
  /// For more information, see Backend services overview. This method supports
  /// PATCH semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendService request,
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the Google Cloud Armor security policy for the specified backend
  /// service.
  ///
  /// For more information, see Google Cloud Armor Overview
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// security policy should be set. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSecurityPolicy(
    SecurityPolicyReference request,
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/setSecurityPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified BackendService resource with the data included in
  /// the request.
  ///
  /// For more information, see Backend services overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendService request,
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class DiskTypesResource {
  final commons.ApiRequester _requester;

  DiskTypesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of disk types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/diskTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskTypeAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified disk type.
  ///
  /// Gets a list of available disk types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
    core.String project,
    core.String zone,
    core.String diskType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/diskTypes/' +
        commons.escapeVariable('$diskType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskType.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of disk types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/diskTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class DisksResource {
  final commons.ApiRequester _requester;

  DisksResource(commons.ApiRequester client) : _requester = client;

  /// Adds existing resource policies to a disk.
  ///
  /// You can only add one policy which will be applied to this disk for
  /// scheduling snapshot creation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    DisksAddResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/addResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves an aggregated list of persistent disks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/aggregated/disks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a snapshot of a specified persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the persistent disk to snapshot.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [guestFlush] - \[Input Only\] Whether to attempt an application consistent
  /// snapshot by informing the OS to prepare for the snapshot process.
  /// Currently only supported on Windows instances using the Volume Shadow Copy
  /// Service (VSS).
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(
    Snapshot request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.bool? guestFlush,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (guestFlush != null) 'guestFlush': ['${guestFlush}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/createSnapshot';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified persistent disk.
  ///
  /// Deleting a disk removes its data permanently and is irreversible. However,
  /// deleting a disk does not delete any snapshots previously made from the
  /// disk. You must separately delete snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns a specified persistent disk.
  ///
  /// Gets a list of available persistent disks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the persistent disk to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Disk.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a persistent disk in the specified project using the data in the
  /// request.
  ///
  /// You can create a disk from a source (sourceImage, sourceSnapshot, or
  /// sourceDisk) or create an empty 500 GB data disk by omitting all
  /// properties. You can also create a disk that is larger than the default
  /// size by specifying the sizeGb property.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Source image to restore onto a disk. This field is
  /// optional.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Disk request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? sourceImage,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (sourceImage != null) 'sourceImage': [sourceImage],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of persistent disks contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes resource policies from a disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    DisksRemoveResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/removeResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Resizes the specified persistent disk.
  ///
  /// You can only increase the size of the disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The name of the persistent disk.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    DisksResizeRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on a disk.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    ZoneSetLabelsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ExternalVpnGatewaysResource {
  final commons.ApiRequester _requester;

  ExternalVpnGatewaysResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified externalVpnGateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [externalVpnGateway] - Name of the externalVpnGateways to delete.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String externalVpnGateway, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.escapeVariable('$externalVpnGateway');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified externalVpnGateway.
  ///
  /// Get a list of available externalVpnGateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [externalVpnGateway] - Name of the externalVpnGateway to return.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExternalVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExternalVpnGateway> get(
    core.String project,
    core.String externalVpnGateway, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.escapeVariable('$externalVpnGateway');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ExternalVpnGateway.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a ExternalVpnGateway in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ExternalVpnGateway request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of ExternalVpnGateway available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExternalVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExternalVpnGatewayList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ExternalVpnGatewayList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on an ExternalVpnGateway.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class FirewallPoliciesResource {
  final commons.ApiRequester _requester;

  FirewallPoliciesResource(commons.ApiRequester client) : _requester = client;

  /// Inserts an association for the specified firewall policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [replaceExistingAssociation] - Indicates whether or not to replace it if
  /// an association of the attachment already exists. This is false by default,
  /// in which case an error will be returned if an association already exists.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addAssociation(
    FirewallPolicyAssociation request,
    core.String firewallPolicy, {
    core.bool? replaceExistingAssociation,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (replaceExistingAssociation != null)
        'replaceExistingAssociation': ['${replaceExistingAssociation}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/addAssociation';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts a rule into a firewall policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addRule(
    FirewallPolicyRule request,
    core.String firewallPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/addRule';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Copies rules to the specified firewall policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceFirewallPolicy] - The firewall policy from which to copy rules.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> cloneRules(
    core.String firewallPolicy, {
    core.String? requestId,
    core.String? sourceFirewallPolicy,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (sourceFirewallPolicy != null)
        'sourceFirewallPolicy': [sourceFirewallPolicy],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/cloneRules';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to delete.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String firewallPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified firewall policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to get.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPolicy> get(
    core.String firewallPolicy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPolicy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets an association with the specified name.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to which the queried rule
  /// belongs.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [name] - The name of the association to get from the firewall policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPolicyAssociation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPolicyAssociation> getAssociation(
    core.String firewallPolicy, {
    core.String? name,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (name != null) 'name': [name],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/getAssociation';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPolicyAssociation.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets a rule of the specified priority.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to which the queried rule
  /// belongs.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [priority] - The priority of the rule to get from the firewall policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPolicyRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPolicyRule> getRule(
    core.String firewallPolicy, {
    core.int? priority,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/getRule';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPolicyRule.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new policy in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parentId] - Parent ID for this request. The ID can be either be
  /// "folders/\[FOLDER_ID\]" if the parent is a folder or
  /// "organizations/\[ORGANIZATION_ID\]" if the parent is an organization.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    FirewallPolicy request, {
    core.String? parentId,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (parentId != null) 'parentId': [parentId],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    const _url = 'locations/global/firewallPolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all the policies that have been configured for the specified folder
  /// or organization.
  ///
  /// Request parameters:
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [parentId] - Parent ID for this request.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPolicyList> list({
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.String? parentId,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (parentId != null) 'parentId': [parentId],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    const _url = 'locations/global/firewallPolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPolicyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists associations of a specified target, i.e., organization or folder.
  ///
  /// Request parameters:
  ///
  /// [targetResource] - The target resource to list associations. It is an
  /// organization, or a folder.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPoliciesListAssociationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPoliciesListAssociationsResponse> listAssociations({
    core.String? targetResource,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (targetResource != null) 'targetResource': [targetResource],
      if ($fields != null) 'fields': [$fields],
    };

    const _url = 'locations/global/firewallPolicies/listAssociations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPoliciesListAssociationsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Moves the specified firewall policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [parentId] - The new parent of the firewall policy.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> move(
    core.String firewallPolicy, {
    core.String? parentId,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (parentId != null) 'parentId': [parentId],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/move';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified policy with the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    FirewallPolicy request,
    core.String firewallPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Patches a rule of the specified priority.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [priority] - The priority of the rule to patch.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchRule(
    FirewallPolicyRule request,
    core.String firewallPolicy, {
    core.int? priority,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/patchRule';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes an association for the specified firewall policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [name] - Name for the attachment that will be removed.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeAssociation(
    core.String firewallPolicy, {
    core.String? name,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (name != null) 'name': [name],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/removeAssociation';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a rule of the specified priority.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [priority] - The priority of the rule to remove from the firewall policy.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeRule(
    core.String firewallPolicy, {
    core.int? priority,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/removeRule';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalOrganizationSetPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class FirewallsResource {
  final commons.ApiRequester _requester;

  FirewallsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [firewall] - Name of the firewall rule to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String firewall, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/firewalls/' +
        commons.escapeVariable('$firewall');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [firewall] - Name of the firewall rule to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Firewall].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Firewall> get(
    core.String project,
    core.String firewall, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/firewalls/' +
        commons.escapeVariable('$firewall');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Firewall.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a firewall rule in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Firewall request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/firewalls';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of firewall rules available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/firewalls';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified firewall rule with the data included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [firewall] - Name of the firewall rule to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Firewall request,
    core.String project,
    core.String firewall, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/firewalls/' +
        commons.escapeVariable('$firewall');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified firewall rule with the data included in the request.
  ///
  /// Note that all fields will be updated if using PUT, even fields that are
  /// not specified. To update individual fields, please use PATCH instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [firewall] - Name of the firewall rule to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Firewall request,
    core.String project,
    core.String firewall, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/firewalls/' +
        commons.escapeVariable('$firewall');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class ForwardingRulesResource {
  final commons.ApiRequester _requester;

  ForwardingRulesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of forwarding rules.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/forwardingRules';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRuleAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRule.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a ForwardingRule resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ForwardingRule request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of ForwardingRule resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRuleList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified forwarding rule with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules. Currently, you can only patch the network_tier
  /// field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    ForwardingRule request,
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on the specified resource.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    RegionSetLabelsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes target URL for forwarding rule.
  ///
  /// The new target should be of the same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(
    TargetReference request,
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$forwardingRule') +
        '/setTarget';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalAddressesResource {
  final commons.ApiRequester _requester;

  GlobalAddressesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String address, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/addresses/' +
        commons.escapeVariable('$address');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified address resource.
  ///
  /// Gets a list of available addresses by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(
    core.String project,
    core.String address, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/addresses/' +
        commons.escapeVariable('$address');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Address.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an address resource in the specified project by using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Address request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/addresses';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of global addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/addresses';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AddressList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalForwardingRulesResource {
  final commons.ApiRequester _requester;

  GlobalForwardingRulesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified GlobalForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified GlobalForwardingRule resource.
  ///
  /// Gets a list of available forwarding rules by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
    core.String project,
    core.String forwardingRule, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRule.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a GlobalForwardingRule resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ForwardingRule request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of GlobalForwardingRule resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRuleList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified forwarding rule with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules. Currently, you can only patch the network_tier
  /// field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    ForwardingRule request,
    core.String project,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on the specified resource.
  ///
  /// To learn more about labels, read the Labeling resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes target URL for the GlobalForwardingRule resource.
  ///
  /// The new target should be of the same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(
    TargetReference request,
    core.String project,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$forwardingRule') +
        '/setTarget';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalNetworkEndpointGroupsResource {
  final commons.ApiRequester _requester;

  GlobalNetworkEndpointGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Attach a network endpoint to the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are attaching network endpoints to. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachNetworkEndpoints(
    GlobalNetworkEndpointGroupsAttachEndpointsRequest request,
    core.String project,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/attachNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified network endpoint group.Note that the NEG cannot be
  /// deleted if there are backend services referencing it.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Detach the network endpoint from the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are removing network endpoints. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachNetworkEndpoints(
    GlobalNetworkEndpointGroupsDetachEndpointsRequest request,
    core.String project,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/detachNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified network endpoint group.
  ///
  /// Gets a list of available network endpoint groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String networkEndpointGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of network endpoint groups that are located in the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the network endpoints in the specified network endpoint group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group from which
  /// you want to generate a list of included network endpoints. It should
  /// comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupsListNetworkEndpoints].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupsListNetworkEndpoints> listNetworkEndpoints(
    core.String project,
    core.String networkEndpointGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/listNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupsListNetworkEndpoints.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalOperationsResource {
  final commons.ApiRequester _requester;

  GlobalOperationsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of all operations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> delete(
    core.String project,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/operations/' +
        commons.escapeVariable('$operation');

    await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Retrieves the specified Operations resource.
  ///
  /// Gets a list of operations by making a `list()` request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/operations/' +
        commons.escapeVariable('$operation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource.
  ///
  /// This method differs from the `GET` method in that it waits for no more
  /// than the default deadline (2 minutes) and then returns the current state
  /// of the operation, which might be `DONE` or still in progress. This method
  /// is called on a best-effort basis. Specifically: - In uncommon cases, when
  /// the server is overloaded, the request might return before the default
  /// deadline is reached, or might return after zero seconds. - If the default
  /// deadline is reached, there is no guarantee that the operation is actually
  /// done when the method returns. Be prepared to retry if the operation is not
  /// `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/operations/' +
        commons.escapeVariable('$operation') +
        '/wait';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalOrganizationOperationsResource {
  final commons.ApiRequester _requester;

  GlobalOrganizationOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified Operations resource.
  ///
  /// Request parameters:
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [parentId] - Parent ID for this request.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> delete(
    core.String operation, {
    core.String? parentId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (parentId != null) 'parentId': [parentId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'locations/global/operations/' + commons.escapeVariable('$operation');

    await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Retrieves the specified Operations resource.
  ///
  /// Gets a list of operations by making a `list()` request.
  ///
  /// Request parameters:
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [parentId] - Parent ID for this request.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String operation, {
    core.String? parentId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (parentId != null) 'parentId': [parentId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'locations/global/operations/' + commons.escapeVariable('$operation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// organization.
  ///
  /// Request parameters:
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [parentId] - Parent ID for this request.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list({
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.String? parentId,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (parentId != null) 'parentId': [parentId],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    const _url = 'locations/global/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalPublicDelegatedPrefixesResource {
  final commons.ApiRequester _requester;

  GlobalPublicDelegatedPrefixesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified global PublicDelegatedPrefix.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [publicDelegatedPrefix] - Name of the PublicDelegatedPrefix resource to
  /// delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String publicDelegatedPrefix, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicDelegatedPrefixes/' +
        commons.escapeVariable('$publicDelegatedPrefix');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified global PublicDelegatedPrefix resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [publicDelegatedPrefix] - Name of the PublicDelegatedPrefix resource to
  /// return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PublicDelegatedPrefix].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PublicDelegatedPrefix> get(
    core.String project,
    core.String publicDelegatedPrefix, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicDelegatedPrefixes/' +
        commons.escapeVariable('$publicDelegatedPrefix');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PublicDelegatedPrefix.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a global PublicDelegatedPrefix in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    PublicDelegatedPrefix request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicDelegatedPrefixes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the global PublicDelegatedPrefixes for a project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PublicDelegatedPrefixList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PublicDelegatedPrefixList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicDelegatedPrefixes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PublicDelegatedPrefixList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified global PublicDelegatedPrefix resource with the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [publicDelegatedPrefix] - Name of the PublicDelegatedPrefix resource to
  /// patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    PublicDelegatedPrefix request,
    core.String project,
    core.String publicDelegatedPrefix, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicDelegatedPrefixes/' +
        commons.escapeVariable('$publicDelegatedPrefix');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class HealthChecksResource {
  final commons.ApiRequester _requester;

  HealthChecksResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all HealthCheck resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthChecksAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthChecksAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/healthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthChecksAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified HealthCheck resource.
  ///
  /// Gets a list of available health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(
    core.String project,
    core.String healthCheck, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheck.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheck request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheckList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheck request,
    core.String project,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HealthCheck request,
    core.String project,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class HttpHealthChecksResource {
  final commons.ApiRequester _requester;

  HttpHealthChecksResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified HttpHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String httpHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.escapeVariable('$httpHealthCheck');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified HttpHealthCheck resource.
  ///
  /// Gets a list of available HTTP health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheck> get(
    core.String project,
    core.String httpHealthCheck, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.escapeVariable('$httpHealthCheck');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HttpHealthCheck.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HttpHealthCheck request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of HttpHealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheckList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HttpHealthCheckList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HttpHealthCheck request,
    core.String project,
    core.String httpHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.escapeVariable('$httpHealthCheck');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HttpHealthCheck request,
    core.String project,
    core.String httpHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.escapeVariable('$httpHealthCheck');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class HttpsHealthChecksResource {
  final commons.ApiRequester _requester;

  HttpsHealthChecksResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified HttpsHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String httpsHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.escapeVariable('$httpsHealthCheck');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified HttpsHealthCheck resource.
  ///
  /// Gets a list of available HTTPS health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheck> get(
    core.String project,
    core.String httpsHealthCheck, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.escapeVariable('$httpsHealthCheck');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HttpsHealthCheck.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HttpsHealthCheck request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of HttpsHealthCheck resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheckList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HttpsHealthCheckList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HttpsHealthCheck request,
    core.String project,
    core.String httpsHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.escapeVariable('$httpsHealthCheck');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HttpsHealthCheck request,
    core.String project,
    core.String httpsHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.escapeVariable('$httpsHealthCheck');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class ImageFamilyViewsResource {
  final commons.ApiRequester _requester;

  ImageFamilyViewsResource(commons.ApiRequester client) : _requester = client;

  /// Returns the latest image that is part of an image family, is not
  /// deprecated and is rolled out in the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [family] - Name of the image family to search for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ImageFamilyView].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ImageFamilyView> get(
    core.String project,
    core.String zone,
    core.String family, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/imageFamilyViews/' +
        commons.escapeVariable('$family');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ImageFamilyView.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ImagesResource {
  final commons.ApiRequester _requester;

  ImagesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified image.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [image] - Name of the image resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String image, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$image');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the deprecation status of an image.
  ///
  /// If an empty request body is given, clears the deprecation status instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [image] - Image name.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deprecate(
    DeprecationStatus request,
    core.String project,
    core.String image, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$image') +
        '/deprecate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified image.
  ///
  /// Gets a list of available images by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [image] - Name of the image resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> get(
    core.String project,
    core.String image, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$image');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Image.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the latest image that is part of an image family and is not
  /// deprecated.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [family] - Name of the image family to search for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> getFromFamily(
    core.String project,
    core.String family, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/family/' +
        commons.escapeVariable('$family');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Image.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an image in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forceCreate] - Force image creation if true.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Image request,
    core.String project, {
    core.bool? forceCreate,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (forceCreate != null) 'forceCreate': ['${forceCreate}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/images';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of custom images available to the specified project.
  ///
  /// Custom images are images you create that belong to your project. This
  /// method does not get any images that belong to other projects, including
  /// publicly-available images, like Debian 8. If you want to get a list of
  /// publicly-available images, use this method to make a request to the
  /// respective image project, such as debian-cloud or windows-cloud.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ImageList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ImageList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/images';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ImageList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified image with the data included in the request.
  ///
  /// Only the following fields can be modified: family, description,
  /// deprecation status.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [image] - Name of the image resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Image request,
    core.String project,
    core.String image, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$image');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on an image.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class InstanceGroupManagersResource {
  final commons.ApiRequester _requester;

  InstanceGroupManagersResource(commons.ApiRequester client)
      : _requester = client;

  /// Flags the specified instances to be removed from the managed instance
  /// group.
  ///
  /// Abandoning an instance does not delete the instance, but it does remove
  /// the instance from any target pools that are applied by the managed
  /// instance group. This method reduces the targetSize of the managed instance
  /// group by the number of instances that you abandon. This operation is
  /// marked as DONE when the action is scheduled even if the instances have not
  /// yet been removed from the group. You must separately verify the status of
  /// the abandoning action with the listmanagedinstances method. If the group
  /// is part of a backend service that has enabled connection draining, it can
  /// take up to 60 seconds after the connection draining duration has elapsed
  /// before the VM instance is removed or deleted. You can specify a maximum of
  /// 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
    InstanceGroupManagersAbandonInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of managed instance groups and groups them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManagerAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Applies changes to selected instances on the managed instance group.
  ///
  /// This method can be used to apply new overrides and/or new versions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// Should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group, should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> applyUpdatesToInstances(
    InstanceGroupManagersApplyUpdatesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/applyUpdatesToInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates instances with per-instance configs in this managed instance
  /// group.
  ///
  /// Instances are created using the current instance template. The create
  /// instances operation is marked DONE if the createInstances request is
  /// successful. The underlying actions take additional time. You must
  /// separately verify the status of the creating or actions with the
  /// listmanagedinstances method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. The request ID must
  /// be a valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createInstances(
    InstanceGroupManagersCreateInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/createInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group.
  ///
  /// Note that the instance group must not belong to a backend service. Read
  /// Deleting an instance group for more information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Flags the specified instances in the managed instance group for immediate
  /// deletion.
  ///
  /// The instances are also removed from any target pools of which they were a
  /// member. This method reduces the targetSize of the managed instance group
  /// by the number of instances that you delete. This operation is marked as
  /// DONE when the action is scheduled even if the instances are still being
  /// deleted. You must separately verify the status of the deleting action with
  /// the listmanagedinstances method. If the group is part of a backend service
  /// that has enabled connection draining, it can take up to 60 seconds after
  /// the connection draining duration has elapsed before the VM instance is
  /// removed or deleted. You can specify a maximum of 1000 instances with this
  /// method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
    InstanceGroupManagersDeleteInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes selected per-instance configs for the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deletePerInstanceConfigs(
    InstanceGroupManagersDeletePerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/deletePerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns all of the details about the specified managed instance group.
  ///
  /// Gets a list of available managed instance groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManager.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request.
  ///
  /// After the group is created, instances in the group are created using the
  /// specified instance template. This operation is marked as DONE when the
  /// group is created even if the instances in the group have not yet been
  /// created. You must separately verify the status of the individual instances
  /// with the listmanagedinstances method. A managed instance group can have up
  /// to 1000 VM instances per group. Please contact Cloud Support if you need
  /// an increase in this limit.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroupManager request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of managed instance groups that are contained within the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManagerList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all errors thrown by actions on instances for a given managed
  /// instance group.
  ///
  /// The filter and orderBy query parameters are not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It must
  /// be a string that meets the requirements in RFC1035, or an unsigned long
  /// integer: must match regexp pattern:
  /// (?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?)|1-9{0,19}.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListErrorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListErrorsResponse> listErrors(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listErrors';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManagersListErrorsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all of the instances in the managed instance group.
  ///
  /// Each instance in the list has a currentAction, which indicates the action
  /// that the managed instance group is performing on the instance. For
  /// example, if the group is still creating an instance, the currentAction is
  /// CREATING. If a previous action failed, the list displays the errors for
  /// that failed action. The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListManagedInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListManagedInstancesResponse>
      listManagedInstances(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return InstanceGroupManagersListManagedInstancesResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all of the per-instance configs defined for the managed instance
  /// group.
  ///
  /// The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListPerInstanceConfigsResp].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListPerInstanceConfigsResp>
      listPerInstanceConfigs(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listPerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return InstanceGroupManagersListPerInstanceConfigsResp.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a managed instance group using the information that you specify in
  /// the request.
  ///
  /// This operation is marked as DONE when the group is patched even if the
  /// instances in the group are still in the process of being patched. You must
  /// separately verify the status of the individual instances with the
  /// listManagedInstances method. This method supports PATCH semantics and uses
  /// the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [instanceGroupManager] - The name of the instance group manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InstanceGroupManager request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts or patches per-instance configs for the managed instance group.
  ///
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchPerInstanceConfigs(
    InstanceGroupManagersPatchPerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/patchPerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Flags the specified VM instances in the managed instance group to be
  /// immediately recreated.
  ///
  /// Each instance is recreated using the group's current configuration. This
  /// operation is marked as DONE when the flag is set even if the instances
  /// have not yet been recreated. You must separately verify the status of each
  /// instance by checking its currentAction field; for more information, see
  /// Checking the status of managed instances. If the group is part of a
  /// backend service that has enabled connection draining, it can take up to 60
  /// seconds after the connection draining duration has elapsed before the VM
  /// instance is removed or deleted. You can specify a maximum of 1000
  /// instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
    InstanceGroupManagersRecreateInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Resizes the managed instance group.
  ///
  /// If you increase the size, the group creates new instances using the
  /// current instance template. If you decrease the size, the group deletes
  /// instances. The resize operation is marked DONE when the resize actions are
  /// scheduled even if the group has not yet added or deleted any instances.
  /// You must separately verify the status of the creating or deleting actions
  /// with the listmanagedinstances method. When resizing down, the instance
  /// group arbitrarily chooses the order in which VMs are deleted. The group
  /// takes into account some VM attributes when making the selection including:
  /// + The status of the VM instance. + The health of the VM instance. + The
  /// instance template version the VM is based on. + For regional managed
  /// instance groups, the location of the VM instance. This list is subject to
  /// change. If the group is part of a backend service that has enabled
  /// connection draining, it can take up to 60 seconds after the connection
  /// draining duration has elapsed before the VM instance is removed or
  /// deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [size] - The number of running instances that the managed instance group
  /// should maintain at any given time. The group automatically adds or removes
  /// instances to maintain the number of instances specified by this parameter.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    core.String project,
    core.String zone,
    core.String instanceGroupManager,
    core.int size, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'size': ['${size}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Specifies the instance template to use when creating new instances in this
  /// group.
  ///
  /// The templates for existing instances in the group do not change unless you
  /// run recreateInstances, run applyUpdatesToInstances, or set the group's
  /// updatePolicy.type to PROACTIVE.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
    InstanceGroupManagersSetInstanceTemplateRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Modifies the target pools to which all instances in this managed instance
  /// group are assigned.
  ///
  /// The target pools automatically apply to all of the instances in the
  /// managed instance group. This operation is marked DONE when you make the
  /// request even if the instances have not yet been added to their target
  /// pools. The change might take some time to apply to all of the instances in
  /// the group depending on the size of the group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
    InstanceGroupManagersSetTargetPoolsRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts or updates per-instance configs for the managed instance group.
  ///
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePerInstanceConfigs(
    InstanceGroupManagersUpdatePerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/updatePerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class InstanceGroupsResource {
  final commons.ApiRequester _requester;

  InstanceGroupsResource(commons.ApiRequester client) : _requester = client;

  /// Adds a list of instances to the specified instance group.
  ///
  /// All of the instances in the instance group must be in the same
  /// network/subnetwork. Read Adding instances for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where you are adding
  /// instances.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstances(
    InstanceGroupsAddInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/addInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of instance groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/instanceGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified instance group.
  ///
  /// The instances in the group are not deleted. Note that instance group must
  /// not belong to a backend service. Read Deleting an instance group for more
  /// information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified zonal instance group.
  ///
  /// Get a list of available zonal instance groups by making a list() request.
  /// For managed instance groups, use the instanceGroupManagers or
  /// regionInstanceGroupManagers methods instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an instance group in the specified project using the parameters
  /// that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where you want to create the instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroup request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of zonal instance group resources contained within the
  /// specified zone.
  ///
  /// For managed instance groups, use the instanceGroupManagers or
  /// regionInstanceGroupManagers methods instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the instances in the specified instance group.
  ///
  /// The orderBy query parameter is not supported.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group from which you want to
  /// generate a list of included instances.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupsListInstances> listInstances(
    InstanceGroupsListInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/listInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return InstanceGroupsListInstances.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Removes one or more instances from the specified instance group, but does
  /// not delete those instances.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration before the VM instance is removed or deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the specified
  /// instances will be removed.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstances(
    InstanceGroupsRemoveInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/removeInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the named ports for the specified instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the named ports are
  /// updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
    InstanceGroupsSetNamedPortsRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/setNamedPorts';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class InstanceTemplatesResource {
  final commons.ApiRequester _requester;

  InstanceTemplatesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified instance template.
  ///
  /// Deleting an instance template is permanent and cannot be undone. It is not
  /// possible to delete templates that are already in use by a managed instance
  /// group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [instanceTemplate] - The name of the instance template to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String instanceTemplate, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$instanceTemplate');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified instance template.
  ///
  /// Gets a list of available instance templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [instanceTemplate] - The name of the instance template.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplate> get(
    core.String project,
    core.String instanceTemplate, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$instanceTemplate');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceTemplate.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an instance template in the specified project using the data that
  /// is included in the request.
  ///
  /// If you are creating a new template to update an existing instance group,
  /// your new instance template must use the same network or, if applicable,
  /// the same subnetwork as the original template.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceTemplate request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of instance templates that are contained within the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplateList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceTemplateList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class InstancesResource {
  final commons.ApiRequester _requester;

  InstancesResource(commons.ApiRequester client) : _requester = client;

  /// Adds an access config to an instance's network interface.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [networkInterface] - The name of the network interface to add to this
  /// instance.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addAccessConfig(
    AccessConfig request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      'networkInterface': [networkInterface],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/addAccessConfig';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Adds existing resource policies to an instance.
  ///
  /// You can only add one policy right now which will be applied to this
  /// instance for scheduling live migrations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    InstancesAddResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/addResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves aggregated list of all of the instances in your project across
  /// all regions and zones.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/instances';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Attaches an existing Disk resource to an instance.
  ///
  /// You must first create the disk before you can attach it. It is not
  /// possible to create and attach a disk at the same time. For more
  /// information, read Adding a persistent disk to your instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [forceAttach] - Whether to force attach the regional disk even if it's
  /// currently attached to another instance. If you try to force attach a zonal
  /// disk to an instance, you will receive an error.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachDisk(
    AttachedDisk request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.bool? forceAttach,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (forceAttach != null) 'forceAttach': ['${forceAttach}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/attachDisk';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates multiple instances.
  ///
  /// Count specifies the number of instances to create.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> bulkInsert(
    BulkInsertInstanceResource request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/bulkInsert';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified Instance resource.
  ///
  /// For more information, see Deleting an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an access config from an instance's network interface.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [accessConfig] - The name of the access config to delete.
  ///
  /// [networkInterface] - The name of the network interface.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteAccessConfig(
    core.String project,
    core.String zone,
    core.String instance,
    core.String accessConfig,
    core.String networkInterface, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'accessConfig': [accessConfig],
      'networkInterface': [networkInterface],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/deleteAccessConfig';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Detaches a disk from an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [deviceName] - The device name of the disk to detach. Make a get() request
  /// on the instance to view currently attached disks and device names.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachDisk(
    core.String project,
    core.String zone,
    core.String instance,
    core.String deviceName, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'deviceName': [deviceName],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/detachDisk';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Instance resource.
  ///
  /// Gets a list of available instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Instance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Instance> get(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Instance.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns effective firewalls applied to an interface of the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [networkInterface] - The name of the network interface to get the
  /// effective firewalls.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstancesGetEffectiveFirewallsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstancesGetEffectiveFirewallsResponse> getEffectiveFirewalls(
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'networkInterface': [networkInterface],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/getEffectiveFirewalls';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstancesGetEffectiveFirewallsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified guest attributes entry.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [queryPath] - Specifies the guest attributes path to be queried.
  ///
  /// [variableKey] - Specifies the key for the guest attributes entry.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GuestAttributes].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GuestAttributes> getGuestAttributes(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? queryPath,
    core.String? variableKey,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (queryPath != null) 'queryPath': [queryPath],
      if (variableKey != null) 'variableKey': [variableKey],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/getGuestAttributes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return GuestAttributes.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the screenshot from the specified instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Screenshot].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Screenshot> getScreenshot(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/screenshot';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Screenshot.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the last 1 MB of serial port output from the specified instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [port] - Specifies which COM or serial port to retrieve data from.
  /// Value must be between "1" and "4".
  ///
  /// [start_1] - Specifies the starting byte position of the output to return.
  /// To start with the first byte of output to the specified port, omit this
  /// field or set it to `0`. If the output for that byte position is available,
  /// this field matches the `start` parameter sent with the request. If the
  /// amount of serial console output exceeds the size of the buffer (1 MB), the
  /// oldest output is discarded and is no longer available. If the requested
  /// start position refers to discarded output, the start position is adjusted
  /// to the oldest output still available, and the adjusted start position is
  /// returned as the `start` property value. You can also provide a negative
  /// start position, which translates to the most recent number of bytes
  /// written to the serial port. For example, -3 is interpreted as the most
  /// recent 3 bytes written to the serial console.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SerialPortOutput].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SerialPortOutput> getSerialPortOutput(
    core.String project,
    core.String zone,
    core.String instance, {
    core.int? port,
    core.String? start_1,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (port != null) 'port': ['${port}'],
      if (start_1 != null) 'start': [start_1],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/serialPort';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SerialPortOutput.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the Shielded Instance Identity of an instance
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ShieldedInstanceIdentity].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ShieldedInstanceIdentity> getShieldedInstanceIdentity(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/getShieldedInstanceIdentity';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ShieldedInstanceIdentity.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an instance resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceInstanceTemplate] - Specifies instance template to create the
  /// instance. This field is optional. It can be a full or partial URL. For
  /// example, the following are all valid URLs to an instance template: -
  /// https://www.googleapis.com/compute/v1/projects/project
  /// /global/instanceTemplates/instanceTemplate -
  /// projects/project/global/instanceTemplates/instanceTemplate -
  /// global/instanceTemplates/instanceTemplate
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Instance request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? sourceInstanceTemplate,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (sourceInstanceTemplate != null)
        'sourceInstanceTemplate': [sourceInstanceTemplate],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of instances contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of resources that refer to the VM instance specified in
  /// the request.
  ///
  /// For example, if the VM instance is part of a managed or unmanaged instance
  /// group, the referrers list includes the instance group. For more
  /// information, read Viewing referrers to VM instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the target instance scoping this request, or '-' if
  /// the request should span over all instances in the container.
  /// Value must have pattern
  /// `-|\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceListReferrers].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceListReferrers> listReferrers(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/referrers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceListReferrers.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Removes resource policies from an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    InstancesRemoveResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/removeResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Performs a reset on the instance.
  ///
  /// This is a hard reset the VM does not do a graceful shutdown. For more
  /// information, see Resetting an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> reset(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/reset';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sends diagnostic interrupt to the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> sendDiagnosticInterrupt(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/sendDiagnosticInterrupt';

    await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Sets deletion protection on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [deletionProtection] - Whether the resource should be protected against
  /// deletion.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDeletionProtection(
    core.String project,
    core.String zone,
    core.String resource, {
    core.bool? deletionProtection,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (deletionProtection != null)
        'deletionProtection': ['${deletionProtection}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$resource') +
        '/setDeletionProtection';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the auto-delete flag for a disk attached to an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [autoDelete] - Whether to auto-delete the disk when the instance is
  /// deleted.
  ///
  /// [deviceName] - The device name of the disk to modify. Make a get() request
  /// on the instance to view currently attached disks and device names.
  /// Value must have pattern `\w\[\w.-\]{0,254}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDiskAutoDelete(
    core.String project,
    core.String zone,
    core.String instance,
    core.bool autoDelete,
    core.String deviceName, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'autoDelete': ['${autoDelete}'],
      'deviceName': [deviceName],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setDiskAutoDelete';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets labels on an instance.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    InstancesSetLabelsRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the number and/or type of accelerator for a stopped instance to
  /// the values specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineResources(
    InstancesSetMachineResourcesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setMachineResources';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the machine type for a stopped instance to the machine type
  /// specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineType(
    InstancesSetMachineTypeRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setMachineType';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets metadata for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMetadata(
    Metadata request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setMetadata';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the minimum CPU platform that this instance should use.
  ///
  /// This method can only be called on a stopped instance. For more
  /// information, read Specifying a Minimum CPU Platform.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMinCpuPlatform(
    InstancesSetMinCpuPlatformRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setMinCpuPlatform';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets an instance's scheduling options.
  ///
  /// You can only call this method on a stopped instance, that is, a VM
  /// instance that is in a `TERMINATED` state. See Instance Life Cycle for more
  /// information on the possible instance states.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setScheduling(
    Scheduling request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setScheduling';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the service account on the instance.
  ///
  /// For more information, read Changing the service account and access scopes
  /// for an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setServiceAccount(
    InstancesSetServiceAccountRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setServiceAccount';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the Shielded Instance integrity policy for an instance.
  ///
  /// You can only use this method on a running instance. This method supports
  /// PATCH semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setShieldedInstanceIntegrityPolicy(
    ShieldedInstanceIntegrityPolicy request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setShieldedInstanceIntegrityPolicy';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets network tags for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTags(
    Tags request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setTags';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Simulates a maintenance event on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> simulateMaintenanceEvent(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/simulateMaintenanceEvent';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Starts an instance that was stopped using the instances().stop method.
  ///
  /// For more information, see Restart an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> start(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/start';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Starts an instance that was stopped using the instances().stop method.
  ///
  /// For more information, see Restart an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> startWithEncryptionKey(
    InstancesStartWithEncryptionKeyRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/startWithEncryptionKey';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Stops a running instance, shutting it down cleanly, and allows you to
  /// restart the instance at a later time.
  ///
  /// Stopped instances do not incur VM usage charges while they are stopped.
  /// However, resources that the VM is using, such as persistent disks and
  /// static IP addresses, will continue to be charged until they are deleted.
  /// For more information, see Stopping an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to stop.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> stop(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/stop';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an instance only if the necessary resources are available.
  ///
  /// This method can update only a specific set of instance properties. See
  /// Updating a running instance for a list of updatable instance properties.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [minimalAction] - Specifies the action to take when updating an instance
  /// even if the updated properties do not require it. If not specified, then
  /// Compute Engine acts based on the minimum action that the updated
  /// properties require.
  /// Possible string values are:
  /// - "INVALID"
  /// - "NO_EFFECT" : No changes can be made to the instance.
  /// - "REFRESH" : The instance will not restart.
  /// - "RESTART" : The instance will restart.
  ///
  /// [mostDisruptiveAllowedAction] - Specifies the most disruptive action that
  /// can be taken on the instance as part of the update. Compute Engine returns
  /// an error if the instance properties require a more disruptive action as
  /// part of the instance update. Valid options from lowest to highest are
  /// NO_EFFECT, REFRESH, and RESTART.
  /// Possible string values are:
  /// - "INVALID"
  /// - "NO_EFFECT" : No changes can be made to the instance.
  /// - "REFRESH" : The instance will not restart.
  /// - "RESTART" : The instance will restart.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Instance request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? minimalAction,
    core.String? mostDisruptiveAllowedAction,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (minimalAction != null) 'minimalAction': [minimalAction],
      if (mostDisruptiveAllowedAction != null)
        'mostDisruptiveAllowedAction': [mostDisruptiveAllowedAction],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified access config from an instance's network interface
  /// with the data included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [networkInterface] - The name of the network interface where the access
  /// config is attached.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateAccessConfig(
    AccessConfig request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      'networkInterface': [networkInterface],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/updateAccessConfig';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the Display config for a VM instance.
  ///
  /// You can only use this method on a stopped VM instance. This method
  /// supports PATCH semantics and uses the JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateDisplayDevice(
    DisplayDevice request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/updateDisplayDevice';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an instance's network interface.
  ///
  /// This method can only update an interface's alias IP range and attached
  /// network. See Modifying alias IP ranges for an existing instance for
  /// instructions on changing alias IP ranges. See Migrating a VM between
  /// networks for instructions on migrating an interface. This method follows
  /// PATCH semantics.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [networkInterface] - The name of the network interface to update.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateNetworkInterface(
    NetworkInterface request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      'networkInterface': [networkInterface],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/updateNetworkInterface';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the Shielded Instance config for an instance.
  ///
  /// You can only use this method on a stopped instance. This method supports
  /// PATCH semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateShieldedInstanceConfig(
    ShieldedInstanceConfig request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/updateShieldedInstanceConfig';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class InterconnectAttachmentsResource {
  final commons.ApiRequester _requester;

  InterconnectAttachmentsResource(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of interconnect attachments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/interconnectAttachments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectAttachmentAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.escapeVariable('$interconnectAttachment');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachment> get(
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.escapeVariable('$interconnectAttachment');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectAttachment.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an InterconnectAttachment in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [validateOnly] - If true, the request will not be committed.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InterconnectAttachment request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.bool? validateOnly,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (validateOnly != null) 'validateOnly': ['${validateOnly}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of interconnect attachments contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectAttachmentList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified interconnect attachment with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InterconnectAttachment request,
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.escapeVariable('$interconnectAttachment');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class InterconnectLocationsResource {
  final commons.ApiRequester _requester;

  InterconnectLocationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Returns the details for the specified interconnect location.
  ///
  /// Gets a list of available interconnect locations by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnectLocation] - Name of the interconnect location to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocation> get(
    core.String project,
    core.String interconnectLocation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnectLocations/' +
        commons.escapeVariable('$interconnectLocation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectLocation.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of interconnect locations available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocationList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnectLocations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectLocationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class InterconnectsResource {
  final commons.ApiRequester _requester;

  InterconnectsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnect] - Name of the interconnect to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String interconnect, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects/' +
        commons.escapeVariable('$interconnect');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified interconnect.
  ///
  /// Get a list of available interconnects by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnect] - Name of the interconnect to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Interconnect].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Interconnect> get(
    core.String project,
    core.String interconnect, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects/' +
        commons.escapeVariable('$interconnect');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Interconnect.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the interconnectDiagnostics for the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnect] - Name of the interconnect resource to query.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectsGetDiagnosticsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectsGetDiagnosticsResponse> getDiagnostics(
    core.String project,
    core.String interconnect, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects/' +
        commons.escapeVariable('$interconnect') +
        '/getDiagnostics';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectsGetDiagnosticsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Interconnect in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Interconnect request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of interconnect available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified interconnect with the data included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnect] - Name of the interconnect to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Interconnect request,
    core.String project,
    core.String interconnect, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects/' +
        commons.escapeVariable('$interconnect');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class LicenseCodesResource {
  final commons.ApiRequester _requester;

  LicenseCodesResource(commons.ApiRequester client) : _requester = client;

  /// Return a specified license code.
  ///
  /// License codes are mirrored across all projects that have permissions to
  /// read the License Code. *Caution* This resource is intended for use only by
  /// third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [licenseCode] - Number corresponding to the License code resource to
  /// return.
  /// Value must have pattern `\[0-9\]{0,61}?`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [LicenseCode].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<LicenseCode> get(
    core.String project,
    core.String licenseCode, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenseCodes/' +
        commons.escapeVariable('$licenseCode');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return LicenseCode.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// *Caution* This resource is intended for use only by third-party partners
  /// who are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenseCodes/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class LicensesResource {
  final commons.ApiRequester _requester;

  LicensesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified license.
  ///
  /// *Caution* This resource is intended for use only by third-party partners
  /// who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [license] - Name of the license resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String license, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$license');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified License resource.
  ///
  /// *Caution* This resource is intended for use only by third-party partners
  /// who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [license] - Name of the License resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [License].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<License> get(
    core.String project,
    core.String license, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$license');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return License.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists. *Caution* This resource
  /// is intended for use only by third-party partners who are creating Cloud
  /// Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Create a License resource in the specified project.
  ///
  /// *Caution* This resource is intended for use only by third-party partners
  /// who are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    License request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/licenses';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of licenses available in the specified project.
  ///
  /// This method does not get any licenses that belong to other projects,
  /// including licenses attached to publicly-available images, like Debian 9.
  /// If you want to get a list of publicly-available licenses, use this method
  /// to make a request to the respective image project, such as debian-cloud or
  /// windows-cloud. *Caution* This resource is intended for use only by
  /// third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [LicensesListResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<LicensesListResponse> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/licenses';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return LicensesListResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. *Caution* This resource is intended for use
  /// only by third-party partners who are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// *Caution* This resource is intended for use only by third-party partners
  /// who are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class MachineTypesResource {
  final commons.ApiRequester _requester;

  MachineTypesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of machine types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/machineTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return MachineTypeAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified machine type.
  ///
  /// Gets a list of available machine types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [machineType] - Name of the machine type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineType> get(
    core.String project,
    core.String zone,
    core.String machineType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/machineTypes/' +
        commons.escapeVariable('$machineType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return MachineType.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of machine types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/machineTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return MachineTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class NetworkEndpointGroupsResource {
  final commons.ApiRequester _requester;

  NetworkEndpointGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves the list of network endpoint groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Attach a list of network endpoints to the specified network endpoint
  /// group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are attaching network endpoints to. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachNetworkEndpoints(
    NetworkEndpointGroupsAttachEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/attachNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified network endpoint group.
  ///
  /// The network endpoints in the NEG and the VM instances they belong to are
  /// not terminated when the NEG is deleted. Note that the NEG cannot be
  /// deleted if there are backend services referencing it.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Detach a list of network endpoints from the specified network endpoint
  /// group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are removing network endpoints. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachNetworkEndpoints(
    NetworkEndpointGroupsDetachEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/detachNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified network endpoint group.
  ///
  /// Gets a list of available network endpoint groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where you want to create the network
  /// endpoint group. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of network endpoint groups that are located in the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the network endpoints in the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group from which
  /// you want to generate a list of included network endpoints. It should
  /// comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupsListNetworkEndpoints].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupsListNetworkEndpoints> listNetworkEndpoints(
    NetworkEndpointGroupsListEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/listNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupsListNetworkEndpoints.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class NetworksResource {
  final commons.ApiRequester _requester;

  NetworksResource(commons.ApiRequester client) : _requester = client;

  /// Adds a peering to the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network resource to add peering to.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addPeering(
    NetworksAddPeeringRequest request,
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/addPeering';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified network.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified network.
  ///
  /// Gets a list of available networks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Network].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Network> get(
    core.String project,
    core.String network, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Network.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the effective firewalls on a given network.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworksGetEffectiveFirewallsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworksGetEffectiveFirewallsResponse> getEffectiveFirewalls(
    core.String project,
    core.String network, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/getEffectiveFirewalls';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworksGetEffectiveFirewallsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a network in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Network request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/networks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of networks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/networks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the peering routes exchanged over peering connection.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [direction] - The direction of the exchanged routes.
  /// Possible string values are:
  /// - "INCOMING" : For routes exported from peer network.
  /// - "OUTGOING" : For routes exported from local network.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [peeringName] - The response will show routes exchanged over the given
  /// peering connection.
  ///
  /// [region] - The region of the request. The response will include all subnet
  /// routes, static routes and dynamic routes in the region.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExchangedPeeringRoutesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExchangedPeeringRoutesList> listPeeringRoutes(
    core.String project,
    core.String network, {
    core.String? direction,
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.String? peeringName,
    core.String? region,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (direction != null) 'direction': [direction],
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (peeringName != null) 'peeringName': [peeringName],
      if (region != null) 'region': [region],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/listPeeringRoutes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ExchangedPeeringRoutesList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified network with the data included in the request.
  ///
  /// Only the following fields can be modified: routingConfig.routingMode.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Network request,
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes a peering from the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network resource to remove peering from.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removePeering(
    NetworksRemovePeeringRequest request,
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/removePeering';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Switches the network mode from auto subnet mode to custom subnet mode.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network to be updated.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> switchToCustomMode(
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/switchToCustomMode';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified network peering with the data included in the
  /// request.
  ///
  /// You can only modify the NetworkPeering.export_custom_routes field and the
  /// NetworkPeering.import_custom_routes field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network resource which the updated peering is
  /// belonging to.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePeering(
    NetworksUpdatePeeringRequest request,
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/updatePeering';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class NodeGroupsResource {
  final commons.ApiRequester _requester;

  NodeGroupsResource(commons.ApiRequester client) : _requester = client;

  /// Adds specified number of nodes to the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addNodes(
    NodeGroupsAddNodesRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup') +
        '/addNodes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves an aggregated list of node groups.
  ///
  /// Note: use nodeGroups.listNodes for more details about each group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/nodeGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeGroupAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified NodeGroup resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes specified nodes from the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource whose nodes will be deleted.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteNodes(
    NodeGroupsDeleteNodesRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup') +
        '/deleteNodes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified NodeGroup.
  ///
  /// Get a list of available NodeGroups by making a list() request. Note: the
  /// "nodes" field should not be used. Use nodeGroups.listNodes instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the node group to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroup> get(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeGroup.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a NodeGroup resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [initialNodeCount] - Initial count of nodes in the node group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NodeGroup request,
    core.String project,
    core.String zone,
    core.int initialNodeCount, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      'initialNodeCount': ['${initialNodeCount}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of node groups available to the specified project.
  ///
  /// Note: use nodeGroups.listNodes for more details about each group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists nodes in the node group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource whose nodes you want to list.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupsListNodes].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupsListNodes> listNodes(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup') +
        '/listNodes';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return NodeGroupsListNodes.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    NodeGroup request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the node template of the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNodeTemplate(
    NodeGroupsSetNodeTemplateRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup') +
        '/setNodeTemplate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class NodeTemplatesResource {
  final commons.ApiRequester _requester;

  NodeTemplatesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of node templates.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplateAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplateAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/nodeTemplates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTemplateAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified NodeTemplate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeTemplate] - Name of the NodeTemplate resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String nodeTemplate, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$nodeTemplate');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified node template.
  ///
  /// Gets a list of available node templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeTemplate] - Name of the node template to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplate> get(
    core.String project,
    core.String region,
    core.String nodeTemplate, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$nodeTemplate');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTemplate.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a NodeTemplate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NodeTemplate request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of node templates available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplateList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTemplateList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class NodeTypesResource {
  final commons.ApiRequester _requester;

  NodeTypesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of node types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/nodeTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTypeAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified node type.
  ///
  /// Gets a list of available node types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeType] - Name of the node type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeType> get(
    core.String project,
    core.String zone,
    core.String nodeType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeTypes/' +
        commons.escapeVariable('$nodeType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeType.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of node types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTypeList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class PacketMirroringsResource {
  final commons.ApiRequester _requester;

  PacketMirroringsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of packetMirrorings.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroringAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroringAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/packetMirrorings';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PacketMirroringAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified PacketMirroring resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings/' +
        commons.escapeVariable('$packetMirroring');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified PacketMirroring resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroring].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroring> get(
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings/' +
        commons.escapeVariable('$packetMirroring');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PacketMirroring.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a PacketMirroring resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    PacketMirroring request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of PacketMirroring resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroringList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroringList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PacketMirroringList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified PacketMirroring resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    PacketMirroring request,
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings/' +
        commons.escapeVariable('$packetMirroring');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsResource {
  final commons.ApiRequester _requester;

  ProjectsResource(commons.ApiRequester client) : _requester = client;

  /// Disable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnHost(
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/disableXpnHost';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Disable a service resource (also known as service project) associated with
  /// this host project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnResource(
    ProjectsDisableXpnResourceRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/disableXpnResource';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Enable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnHost(
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/enableXpnHost';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Enable service resource (a.k.a service project) for a host project, so
  /// that subnets in the host project can be used by instances in the service
  /// project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnResource(
    ProjectsEnableXpnResourceRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/enableXpnResource';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Project resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> get(
    core.String project, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' + commons.escapeVariable('$project');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Project.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the shared VPC host project that this project links to.
  ///
  /// May be empty if no link exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> getXpnHost(
    core.String project, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/getXpnHost';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Project.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets service resources (a.k.a service project) associated with this host
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ProjectsGetXpnResources].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ProjectsGetXpnResources> getXpnResources(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/getXpnResources';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ProjectsGetXpnResources.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all shared VPC host projects visible to the user in an organization.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [XpnHostList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<XpnHostList> listXpnHosts(
    ProjectsListXpnHostsRequest request,
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/listXpnHosts';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return XpnHostList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Moves a persistent disk from one zone to another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveDisk(
    DiskMoveRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' + commons.escapeVariable('$project') + '/moveDisk';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Moves an instance and its attached persistent disks from one zone to
  /// another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveInstance(
    InstanceMoveRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/moveInstance';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets metadata common to all instances within the specified project using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setCommonInstanceMetadata(
    Metadata request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/setCommonInstanceMetadata';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the default network tier of the project.
  ///
  /// The default network tier is used when an address/forwardingRule/instance
  /// is created without specifying the network tier field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDefaultNetworkTier(
    ProjectsSetDefaultNetworkTierRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/setDefaultNetworkTier';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Enables the usage export feature and sets the usage export bucket where
  /// reports are stored.
  ///
  /// If you provide an empty request body using this method, the usage export
  /// feature will be disabled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUsageExportBucket(
    UsageExportLocation request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/setUsageExportBucket';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class PublicAdvertisedPrefixesResource {
  final commons.ApiRequester _requester;

  PublicAdvertisedPrefixesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified PublicAdvertisedPrefix
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [publicAdvertisedPrefix] - Name of the PublicAdvertisedPrefix resource to
  /// delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String publicAdvertisedPrefix, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicAdvertisedPrefixes/' +
        commons.escapeVariable('$publicAdvertisedPrefix');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified PublicAdvertisedPrefix resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [publicAdvertisedPrefix] - Name of the PublicAdvertisedPrefix resource to
  /// return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PublicAdvertisedPrefix].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PublicAdvertisedPrefix> get(
    core.String project,
    core.String publicAdvertisedPrefix, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicAdvertisedPrefixes/' +
        commons.escapeVariable('$publicAdvertisedPrefix');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PublicAdvertisedPrefix.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a PublicAdvertisedPrefix in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    PublicAdvertisedPrefix request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicAdvertisedPrefixes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the PublicAdvertisedPrefixes for a project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PublicAdvertisedPrefixList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PublicAdvertisedPrefixList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicAdvertisedPrefixes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PublicAdvertisedPrefixList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified Router resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [publicAdvertisedPrefix] - Name of the PublicAdvertisedPrefix resource to
  /// patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    PublicAdvertisedPrefix request,
    core.String project,
    core.String publicAdvertisedPrefix, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/publicAdvertisedPrefixes/' +
        commons.escapeVariable('$publicAdvertisedPrefix');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class PublicDelegatedPrefixesResource {
  final commons.ApiRequester _requester;

  PublicDelegatedPrefixesResource(commons.ApiRequester client)
      : _requester = client;

  /// Lists all PublicDelegatedPrefix resources owned by the specific project
  /// across all scopes.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PublicDelegatedPrefixAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PublicDelegatedPrefixAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/publicDelegatedPrefixes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PublicDelegatedPrefixAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified PublicDelegatedPrefix in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region of this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [publicDelegatedPrefix] - Name of the PublicDelegatedPrefix resource to
  /// delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String publicDelegatedPrefix, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/publicDelegatedPrefixes/' +
        commons.escapeVariable('$publicDelegatedPrefix');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified PublicDelegatedPrefix resource in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region of this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [publicDelegatedPrefix] - Name of the PublicDelegatedPrefix resource to
  /// return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PublicDelegatedPrefix].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PublicDelegatedPrefix> get(
    core.String project,
    core.String region,
    core.String publicDelegatedPrefix, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/publicDelegatedPrefixes/' +
        commons.escapeVariable('$publicDelegatedPrefix');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PublicDelegatedPrefix.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a PublicDelegatedPrefix in the specified project in the given
  /// region using the parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region of this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    PublicDelegatedPrefix request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/publicDelegatedPrefixes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the PublicDelegatedPrefixes for a project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region of this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PublicDelegatedPrefixList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PublicDelegatedPrefixList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/publicDelegatedPrefixes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PublicDelegatedPrefixList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified PublicDelegatedPrefix resource with the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [publicDelegatedPrefix] - Name of the PublicDelegatedPrefix resource to
  /// patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    PublicDelegatedPrefix request,
    core.String project,
    core.String region,
    core.String publicDelegatedPrefix, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/publicDelegatedPrefixes/' +
        commons.escapeVariable('$publicDelegatedPrefix');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionAutoscalersResource {
  final commons.ApiRequester _requester;

  RegionAutoscalersResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String autoscaler, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers/' +
        commons.escapeVariable('$autoscaler');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
    core.String project,
    core.String region,
    core.String autoscaler, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers/' +
        commons.escapeVariable('$autoscaler');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Autoscaler.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of autoscalers contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionAutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionAutoscalerList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionAutoscalerList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String? autoscaler,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (autoscaler != null) 'autoscaler': [autoscaler],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String? autoscaler,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (autoscaler != null) 'autoscaler': [autoscaler],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionBackendServicesResource {
  final commons.ApiRequester _requester;

  RegionBackendServicesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendService.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the most recent health check results for this regional
  /// BackendService.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource for which to get
  /// health.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
    ResourceGroupReference request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/getHealth';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return BackendServiceGroupHealth.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a regional BackendService resource in the specified project using
  /// the data included in the request.
  ///
  /// For more information, see Backend services overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendService request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of regional BackendService resources available to the
  /// specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendServiceList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request.
  ///
  /// For more information, see Understanding backend services This method
  /// supports PATCH semantics and uses the JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendService request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request.
  ///
  /// For more information, see Backend services overview .
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendService request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionCommitmentsResource {
  final commons.ApiRequester _requester;

  RegionCommitmentsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of commitments by region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/commitments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return CommitmentAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified commitment resource.
  ///
  /// Gets a list of available commitments by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [commitment] - Name of the commitment to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Commitment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Commitment> get(
    core.String project,
    core.String region,
    core.String commitment, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/commitments/' +
        commons.escapeVariable('$commitment');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Commitment.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a commitment in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Commitment request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/commitments';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of commitments contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/commitments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return CommitmentList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionDiskTypesResource {
  final commons.ApiRequester _requester;

  RegionDiskTypesResource(commons.ApiRequester client) : _requester = client;

  /// Returns the specified regional disk type.
  ///
  /// Gets a list of available disk types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
    core.String project,
    core.String region,
    core.String diskType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/diskTypes/' +
        commons.escapeVariable('$diskType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskType.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of regional disk types available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionDiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionDiskTypeList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/diskTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionDiskTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionDisksResource {
  final commons.ApiRequester _requester;

  RegionDisksResource(commons.ApiRequester client) : _requester = client;

  /// Adds existing resource policies to a regional disk.
  ///
  /// You can only add one policy which will be applied to this disk for
  /// scheduling snapshot creation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    RegionDisksAddResourcePoliciesRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/addResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a snapshot of this regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the regional persistent disk to snapshot.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(
    Snapshot request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/createSnapshot';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified regional persistent disk.
  ///
  /// Deleting a regional disk removes all the replicas of its data permanently
  /// and is irreversible. However, deleting a disk does not delete any
  /// snapshots previously made from the disk. You must separately delete
  /// snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the regional persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns a specified regional persistent disk.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the regional persistent disk to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
    core.String project,
    core.String region,
    core.String disk, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Disk.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a persistent regional disk in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Source image to restore onto a disk. This field is
  /// optional.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Disk request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? sourceImage,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (sourceImage != null) 'sourceImage': [sourceImage],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of persistent disks contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes resource policies from a regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    RegionDisksRemoveResourcePoliciesRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/removeResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Resizes the specified regional persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - The project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the regional persistent disk.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    RegionDisksResizeRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on the target regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    RegionSetLabelsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionHealthCheckServicesResource {
  final commons.ApiRequester _requester;

  RegionHealthCheckServicesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified regional HealthCheckService.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheckService] - Name of the HealthCheckService to delete. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices/' +
        commons.escapeVariable('$healthCheckService');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified regional HealthCheckService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheckService] - Name of the HealthCheckService to update. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckService> get(
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices/' +
        commons.escapeVariable('$healthCheckService');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheckService.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a regional HealthCheckService resource in the specified project
  /// and region using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheckService request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all the HealthCheckService resources that have been configured for
  /// the specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckServicesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckServicesList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheckServicesList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified regional HealthCheckService resource with the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheckService] - Name of the HealthCheckService to update. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheckService request,
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices/' +
        commons.escapeVariable('$healthCheckService');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionHealthChecksResource {
  final commons.ApiRequester _requester;

  RegionHealthChecksResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified HealthCheck resource.
  ///
  /// Gets a list of available health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheck.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheck request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheckList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheck request,
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HealthCheck request,
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionInstanceGroupManagersResource {
  final commons.ApiRequester _requester;

  RegionInstanceGroupManagersResource(commons.ApiRequester client)
      : _requester = client;

  /// Flags the specified instances to be immediately removed from the managed
  /// instance group.
  ///
  /// Abandoning an instance does not delete the instance, but it does remove
  /// the instance from any target pools that are applied by the managed
  /// instance group. This method reduces the targetSize of the managed instance
  /// group by the number of instances that you abandon. This operation is
  /// marked as DONE when the action is scheduled even if the instances have not
  /// yet been removed from the group. You must separately verify the status of
  /// the abandoning action with the listmanagedinstances method. If the group
  /// is part of a backend service that has enabled connection draining, it can
  /// take up to 60 seconds after the connection draining duration has elapsed
  /// before the VM instance is removed or deleted. You can specify a maximum of
  /// 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
    RegionInstanceGroupManagersAbandonInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Apply updates to selected instances the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group, should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> applyUpdatesToInstances(
    RegionInstanceGroupManagersApplyUpdatesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/applyUpdatesToInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates instances with per-instance configs in this regional managed
  /// instance group.
  ///
  /// Instances are created using the current instance template. The create
  /// instances operation is marked DONE if the createInstances request is
  /// successful. The underlying actions take additional time. You must
  /// separately verify the status of the creating or actions with the
  /// listmanagedinstances method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where the managed instance group is
  /// located. It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. The request ID must
  /// be a valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createInstances(
    RegionInstanceGroupManagersCreateInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/createInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately deleted.
  ///
  /// The instances are also removed from any target pools of which they were a
  /// member. This method reduces the targetSize of the managed instance group
  /// by the number of instances that you delete. The deleteInstances operation
  /// is marked DONE if the deleteInstances request is successful. The
  /// underlying actions take additional time. You must separately verify the
  /// status of the deleting action with the listmanagedinstances method. If the
  /// group is part of a backend service that has enabled connection draining,
  /// it can take up to 60 seconds after the connection draining duration has
  /// elapsed before the VM instance is removed or deleted. You can specify a
  /// maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
    RegionInstanceGroupManagersDeleteInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes selected per-instance configs for the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deletePerInstanceConfigs(
    RegionInstanceGroupManagerDeleteInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/deletePerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns all of the details about the specified managed instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManager.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request.
  ///
  /// After the group is created, instances in the group are created using the
  /// specified instance template. This operation is marked as DONE when the
  /// group is created even if the instances in the group have not yet been
  /// created. You must separately verify the status of the individual instances
  /// with the listmanagedinstances method. A regional managed instance group
  /// can contain up to 2000 instances.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroupManager request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of managed instance groups that are contained within
  /// the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagerList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupManagerList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all errors thrown by actions on instances for a given regional
  /// managed instance group.
  ///
  /// The filter and orderBy query parameters are not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request. This should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It must
  /// be a string that meets the requirements in RFC1035, or an unsigned long
  /// integer: must match regexp pattern:
  /// (?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?)|1-9{0,19}.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListErrorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListErrorsResponse> listErrors(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listErrors';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupManagersListErrorsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the instances in the managed instance group and instances that are
  /// scheduled to be created.
  ///
  /// The list includes any current actions that the group has scheduled for its
  /// instances. The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListInstancesResponse>
      listManagedInstances(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupManagersListInstancesResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all of the per-instance configs defined for the managed instance
  /// group.
  ///
  /// The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListInstanceConfigsResp].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListInstanceConfigsResp>
      listPerInstanceConfigs(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listPerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupManagersListInstanceConfigsResp.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a managed instance group using the information that you specify in
  /// the request.
  ///
  /// This operation is marked as DONE when the group is patched even if the
  /// instances in the group are still in the process of being patched. You must
  /// separately verify the status of the individual instances with the
  /// listmanagedinstances method. This method supports PATCH semantics and uses
  /// the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the instance group manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InstanceGroupManager request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts or patches per-instance configs for the managed instance group.
  ///
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchPerInstanceConfigs(
    RegionInstanceGroupManagerPatchInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/patchPerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Flags the specified VM instances in the managed instance group to be
  /// immediately recreated.
  ///
  /// Each instance is recreated using the group's current configuration. This
  /// operation is marked as DONE when the flag is set even if the instances
  /// have not yet been recreated. You must separately verify the status of each
  /// instance by checking its currentAction field; for more information, see
  /// Checking the status of managed instances. If the group is part of a
  /// backend service that has enabled connection draining, it can take up to 60
  /// seconds after the connection draining duration has elapsed before the VM
  /// instance is removed or deleted. You can specify a maximum of 1000
  /// instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
    RegionInstanceGroupManagersRecreateRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the intended size of the managed instance group.
  ///
  /// If you increase the size, the group creates new instances using the
  /// current instance template. If you decrease the size, the group deletes one
  /// or more instances. The resize operation is marked DONE if the resize
  /// request is successful. The underlying actions take additional time. You
  /// must separately verify the status of the creating or deleting actions with
  /// the listmanagedinstances method. If the group is part of a backend service
  /// that has enabled connection draining, it can take up to 60 seconds after
  /// the connection draining duration has elapsed before the VM instance is
  /// removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [size] - Number of instances that should exist in this instance group
  /// manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    core.String project,
    core.String region,
    core.String instanceGroupManager,
    core.int size, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'size': ['${size}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the instance template to use when creating new instances or
  /// recreating instances in this group.
  ///
  /// Existing instances are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
    RegionInstanceGroupManagersSetTemplateRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Modifies the target pools to which all new instances in this group are
  /// assigned.
  ///
  /// Existing instances in the group are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
    RegionInstanceGroupManagersSetTargetPoolsRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts or updates per-instance configs for the managed instance group.
  ///
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePerInstanceConfigs(
    RegionInstanceGroupManagerUpdateInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/updatePerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionInstanceGroupsResource {
  final commons.ApiRequester _requester;

  RegionInstanceGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Returns the specified instance group resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the instance group resource to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of instance group resources contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the instances in the specified instance group and displays
  /// information about the named ports.
  ///
  /// Depending on the specified options, this method can list all instances or
  /// only the instances that are running. The orderBy query parameter is not
  /// supported.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the regional instance group for which we want to
  /// list the instances.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupsListInstances> listInstances(
    RegionInstanceGroupsListInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/listInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return RegionInstanceGroupsListInstances.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the named ports for the specified regional instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - The name of the regional instance group where the named
  /// ports are updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
    RegionInstanceGroupsSetNamedPortsRequest request,
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/setNamedPorts';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionInstancesResource {
  final commons.ApiRequester _requester;

  RegionInstancesResource(commons.ApiRequester client) : _requester = client;

  /// Creates multiple instances in a given region.
  ///
  /// Count specifies the number of instances to create.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> bulkInsert(
    BulkInsertInstanceResource request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instances/bulkInsert';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionNetworkEndpointGroupsResource {
  final commons.ApiRequester _requester;

  RegionNetworkEndpointGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified network endpoint group.
  ///
  /// Note that the NEG cannot be deleted if it is configured as a backend of a
  /// backend service.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified network endpoint group.
  ///
  /// Gets a list of available network endpoint groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String region,
    core.String networkEndpointGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where you want to create the network
  /// endpoint group. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of regional network endpoint groups available to the
  /// specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionNotificationEndpointsResource {
  final commons.ApiRequester _requester;

  RegionNotificationEndpointsResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified NotificationEndpoint in the given region
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [notificationEndpoint] - Name of the NotificationEndpoint resource to
  /// delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String notificationEndpoint, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/notificationEndpoints/' +
        commons.escapeVariable('$notificationEndpoint');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified NotificationEndpoint resource in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [notificationEndpoint] - Name of the NotificationEndpoint resource to
  /// return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NotificationEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NotificationEndpoint> get(
    core.String project,
    core.String region,
    core.String notificationEndpoint, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/notificationEndpoints/' +
        commons.escapeVariable('$notificationEndpoint');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NotificationEndpoint.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Create a NotificationEndpoint in the specified project in the given region
  /// using the parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NotificationEndpoint request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/notificationEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the NotificationEndpoints for a project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NotificationEndpointList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NotificationEndpointList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/notificationEndpoints';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NotificationEndpointList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionOperationsResource {
  final commons.ApiRequester _requester;

  RegionOperationsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> delete(
    core.String project,
    core.String region,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/operations/' +
        commons.escapeVariable('$operation');

    await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Retrieves the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String region,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/operations/' +
        commons.escapeVariable('$operation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource.
  ///
  /// This method differs from the `GET` method in that it waits for no more
  /// than the default deadline (2 minutes) and then returns the current state
  /// of the operation, which might be `DONE` or still in progress. This method
  /// is called on a best-effort basis. Specifically: - In uncommon cases, when
  /// the server is overloaded, the request might return before the default
  /// deadline is reached, or might return after zero seconds. - If the default
  /// deadline is reached, there is no guarantee that the operation is actually
  /// done when the method returns. Be prepared to retry if the operation is not
  /// `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String region,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/operations/' +
        commons.escapeVariable('$operation') +
        '/wait';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionSslCertificatesResource {
  final commons.ApiRequester _requester;

  RegionSslCertificatesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified SslCertificate resource in the region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String sslCertificate, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/sslCertificates/' +
        commons.escapeVariable('$sslCertificate');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified SslCertificate resource in the specified region.
  ///
  /// Get a list of available SSL certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
    core.String project,
    core.String region,
    core.String sslCertificate, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/sslCertificates/' +
        commons.escapeVariable('$sslCertificate');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificate.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a SslCertificate resource in the specified project and region
  /// using the data included in the request
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslCertificate request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/sslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/sslCertificates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificateList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionTargetHttpProxiesResource {
  final commons.ApiRequester _requester;

  RegionTargetHttpProxiesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetHttpProxy resource in the specified region.
  ///
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetHttpProxy resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpProxy request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionTargetHttpsProxiesResource {
  final commons.ApiRequester _requester;

  RegionTargetHttpsProxiesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetHttpsProxy resource in the specified region.
  ///
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetHttpsProxy resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpsProxy request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    RegionTargetHttpsProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy to set a URL map for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionUrlMapsResource {
  final commons.ApiRequester _requester;

  RegionUrlMapsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified UrlMap resource.
  ///
  /// Gets a list of available URL maps by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMap.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    UrlMap request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of UrlMap resources available to the specified project
  /// in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMapList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    UrlMap request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    UrlMap request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Runs static validation for the UrlMap.
  ///
  /// In particular, the tests of the provided UrlMap will be run. Calling this
  /// method does NOT create the UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
    RegionUrlMapsValidateRequest request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap') +
        '/validate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return UrlMapsValidateResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionsResource {
  final commons.ApiRequester _requester;

  RegionsResource(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Region resource.
  ///
  /// Gets a list of available regions by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Region].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Region> get(
    core.String project,
    core.String region, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Region.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of region resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' + commons.escapeVariable('$project') + '/regions';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ReservationsResource {
  final commons.ApiRequester _requester;

  ReservationsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of reservations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ReservationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ReservationAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/reservations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ReservationAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified reservation.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [reservation] - Name of the reservation to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$reservation');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves information about the specified reservation.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [reservation] - Name of the reservation to retrieve.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Reservation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Reservation> get(
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$reservation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Reservation.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new reservation.
  ///
  /// For more information, read Reserving zonal resources.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Reservation request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// A list of all the reservations that have been configured for the specified
  /// project in specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ReservationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ReservationList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ReservationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Resizes the reservation (applicable to standalone reservations only).
  ///
  /// For more information, read Modifying reservations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [reservation] - Name of the reservation to update.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    ReservationsResizeRequest request,
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$reservation') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ResourcePoliciesResource {
  final commons.ApiRequester _requester;

  ResourcePoliciesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of resource policies.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicyAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/resourcePolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ResourcePolicyAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified resource policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resourcePolicy] - Name of the resource policy to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String resourcePolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resourcePolicy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves all information of the specified resource policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resourcePolicy] - Name of the resource policy to retrieve.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicy> get(
    core.String project,
    core.String region,
    core.String resourcePolicy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resourcePolicy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ResourcePolicy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new resource policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ResourcePolicy request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// A list all the resource policies that have been configured for the
  /// specified project in specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicyList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ResourcePolicyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RoutersResource {
  final commons.ApiRequester _requester;

  RoutersResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of routers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/routers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RouterAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified Router resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String router, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Router resource.
  ///
  /// Gets a list of available routers by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Router].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Router> get(
    core.String project,
    core.String region,
    core.String router, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Router.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves runtime Nat mapping information of VM endpoints.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to query for Nat Mapping
  /// information of VM endpoints.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VmEndpointNatMappingsList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VmEndpointNatMappingsList> getNatMappingInfo(
    core.String project,
    core.String region,
    core.String router, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router') +
        '/getNatMappingInfo';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VmEndpointNatMappingsList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves runtime information of the specified router.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterStatusResponse> getRouterStatus(
    core.String project,
    core.String region,
    core.String router, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router') +
        '/getRouterStatus';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RouterStatusResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Router resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Router request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Router resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RouterList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified Router resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Preview fields auto-generated during router create and update operations.
  ///
  /// Calling this method does NOT create or update the router.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RoutersPreviewResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RoutersPreviewResponse> preview(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router') +
        '/preview';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return RoutersPreviewResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified Router resource with the data included in the
  /// request.
  ///
  /// This method conforms to PUT semantics, which requests that the state of
  /// the target resource be created or replaced with the state defined by the
  /// representation enclosed in the request message payload.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RoutesResource {
  final commons.ApiRequester _requester;

  RoutesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Route resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [route] - Name of the Route resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String route, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/routes/' +
        commons.escapeVariable('$route');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Route resource.
  ///
  /// Gets a list of available routes by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [route] - Name of the Route resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Route].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Route> get(
    core.String project,
    core.String route, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/routes/' +
        commons.escapeVariable('$route');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Route.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Route resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Route request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/routes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of Route resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouteList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouteList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/routes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RouteList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class SecurityPoliciesResource {
  final commons.ApiRequester _requester;

  SecurityPoliciesResource(commons.ApiRequester client) : _requester = client;

  /// Inserts a rule into a security policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addRule(
    SecurityPolicyRule request,
    core.String project,
    core.String securityPolicy, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy') +
        '/addRule';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String securityPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// List all of the ordered rules present in a single specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to get.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicy> get(
    core.String project,
    core.String securityPolicy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SecurityPolicy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets a rule at the specified priority.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to which the queried rule
  /// belongs.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [priority] - The priority of the rule to get from the security policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicyRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicyRule> getRule(
    core.String project,
    core.String securityPolicy, {
    core.int? priority,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy') +
        '/getRule';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SecurityPolicyRule.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new policy in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SecurityPolicy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// List all the policies that have been configured for the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SecurityPolicyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the current list of preconfigured Web Application Firewall (WAF)
  /// expressions.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [SecurityPoliciesListPreconfiguredExpressionSetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPoliciesListPreconfiguredExpressionSetsResponse>
      listPreconfiguredExpressionSets(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/listPreconfiguredExpressionSets';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SecurityPoliciesListPreconfiguredExpressionSetsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified policy with the data included in the request.
  ///
  /// This cannot be used to be update the rules in the policy. Please use the
  /// per rule methods like addRule, patchRule, and removeRule instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    SecurityPolicy request,
    core.String project,
    core.String securityPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Patches a rule at the specified priority.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [priority] - The priority of the rule to patch.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchRule(
    SecurityPolicyRule request,
    core.String project,
    core.String securityPolicy, {
    core.int? priority,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy') +
        '/patchRule';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a rule at the specified priority.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [priority] - The priority of the rule to remove from the security policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeRule(
    core.String project,
    core.String securityPolicy, {
    core.int? priority,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy') +
        '/removeRule';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class ServiceAttachmentsResource {
  final commons.ApiRequester _requester;

  ServiceAttachmentsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all ServiceAttachment resources, regional and
  /// global, available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ServiceAttachmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ServiceAttachmentAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/serviceAttachments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ServiceAttachmentAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified ServiceAttachment in the given scope
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region of this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [serviceAttachment] - Name of the ServiceAttachment resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String serviceAttachment, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/serviceAttachments/' +
        commons.escapeVariable('$serviceAttachment');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified ServiceAttachment resource in the given scope.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region of this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [serviceAttachment] - Name of the ServiceAttachment resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ServiceAttachment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ServiceAttachment> get(
    core.String project,
    core.String region,
    core.String serviceAttachment, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/serviceAttachments/' +
        commons.escapeVariable('$serviceAttachment');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ServiceAttachment.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/serviceAttachments/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a ServiceAttachment in the specified project in the given scope
  /// using the parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region of this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ServiceAttachment request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/serviceAttachments';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the ServiceAttachments for a project in the given scope.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region of this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ServiceAttachmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ServiceAttachmentList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/serviceAttachments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ServiceAttachmentList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified ServiceAttachment resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The region scoping this request and should conform to RFC1035.
  ///
  /// [serviceAttachment] - The resource id of the ServiceAttachment to patch.
  /// It should conform to RFC1035 resource name or be a string form on an
  /// unsigned long number.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    ServiceAttachment request,
    core.String project,
    core.String region,
    core.String serviceAttachment, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/serviceAttachments/' +
        commons.escapeVariable('$serviceAttachment');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/serviceAttachments/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/serviceAttachments/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class SnapshotsResource {
  final commons.ApiRequester _requester;

  SnapshotsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Snapshot resource.
  ///
  /// Keep in mind that deleting a single snapshot might not necessarily delete
  /// all the data on that snapshot. If any data on the snapshot that is marked
  /// for deletion is needed for subsequent snapshots, the data will be moved to
  /// the next corresponding snapshot. For more information, see Deleting
  /// snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [snapshot] - Name of the Snapshot resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String snapshot, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$snapshot');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Snapshot resource.
  ///
  /// Gets a list of available snapshots by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [snapshot] - Name of the Snapshot resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Snapshot].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Snapshot> get(
    core.String project,
    core.String snapshot, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$snapshot');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Snapshot.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of Snapshot resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SnapshotList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SnapshotList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/snapshots';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SnapshotList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on a snapshot.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class SslCertificatesResource {
  final commons.ApiRequester _requester;

  SslCertificatesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all SslCertificate resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/sslCertificates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificateAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified SslCertificate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String sslCertificate, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.escapeVariable('$sslCertificate');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified SslCertificate resource.
  ///
  /// Gets a list of available SSL certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
    core.String project,
    core.String sslCertificate, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.escapeVariable('$sslCertificate');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificate.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a SslCertificate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslCertificate request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslCertificates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificateList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class SslPoliciesResource {
  final commons.ApiRequester _requester;

  SslPoliciesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified SSL policy.
  ///
  /// The SSL policy resource can be deleted only if it is not in use by any
  /// TargetHttpsProxy or TargetSslProxy resources.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslPolicy] - Name of the SSL policy to delete. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String sslPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.escapeVariable('$sslPolicy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all of the ordered rules present in a single specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslPolicy] - Name of the SSL policy to update. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPolicy> get(
    core.String project,
    core.String sslPolicy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.escapeVariable('$sslPolicy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslPolicy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified SSL policy resource.
  ///
  /// Gets a list of available SSL policies by making a list() request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslPolicy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all the SSL policies that have been configured for the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPoliciesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPoliciesList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslPoliciesList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all features that can be specified in the SSL policy when using
  /// custom profile.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPoliciesListAvailableFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPoliciesListAvailableFeaturesResponse> listAvailableFeatures(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies/listAvailableFeatures';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslPoliciesListAvailableFeaturesResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified SSL policy with the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslPolicy] - Name of the SSL policy to update. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    SslPolicy request,
    core.String project,
    core.String sslPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.escapeVariable('$sslPolicy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class SubnetworksResource {
  final commons.ApiRequester _requester;

  SubnetworksResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of subnetworks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/subnetworks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SubnetworkAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified subnetwork.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Expands the IP CIDR range of the subnetwork to a specified value.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> expandIpCidrRange(
    SubnetworksExpandIpCidrRangeRequest request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork') +
        '/expandIpCidrRange';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified subnetwork.
  ///
  /// Gets a list of available subnetworks list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Subnetwork].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Subnetwork> get(
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Subnetwork.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a subnetwork in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Subnetwork request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of subnetworks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SubnetworkList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves an aggregated list of all usable subnetworks in the project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UsableSubnetworksAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UsableSubnetworksAggregatedList> listUsable(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/subnetworks/listUsable';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UsableSubnetworksAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified subnetwork with the data included in the request.
  ///
  /// Only certain fields can be updated with a patch request as indicated in
  /// the field descriptions. You must specify the current fingerprint of the
  /// subnetwork resource being patched.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [drainTimeoutSeconds] - The drain timeout specifies the upper bound in
  /// seconds on the amount of time allowed to drain connections from the
  /// current ACTIVE subnetwork to the current BACKUP subnetwork. The drain
  /// timeout is only applicable when the following conditions are true: - the
  /// subnetwork being patched has purpose = INTERNAL_HTTPS_LOAD_BALANCER - the
  /// subnetwork being patched has role = BACKUP - the patch request is setting
  /// the role to ACTIVE. Note that after this patch operation the roles of the
  /// ACTIVE and BACKUP subnetworks will be swapped.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Subnetwork request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.int? drainTimeoutSeconds,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (drainTimeoutSeconds != null)
        'drainTimeoutSeconds': ['${drainTimeoutSeconds}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Set whether VMs in this subnet can access Google services without
  /// assigning external IP addresses through Private Google Access.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setPrivateIpGoogleAccess(
    SubnetworksSetPrivateIpGoogleAccessRequest request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork') +
        '/setPrivateIpGoogleAccess';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class TargetGrpcProxiesResource {
  final commons.ApiRequester _requester;

  TargetGrpcProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified TargetGrpcProxy in the given scope
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetGrpcProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.escapeVariable('$targetGrpcProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetGrpcProxy resource in the given scope.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetGrpcProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetGrpcProxy> get(
    core.String project,
    core.String targetGrpcProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.escapeVariable('$targetGrpcProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetGrpcProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetGrpcProxy in the specified project in the given scope
  /// using the parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetGrpcProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the TargetGrpcProxies for a project in the given scope.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetGrpcProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetGrpcProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetGrpcProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified TargetGrpcProxy resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    TargetGrpcProxy request,
    core.String project,
    core.String targetGrpcProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.escapeVariable('$targetGrpcProxy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetHttpProxiesResource {
  final commons.ApiRequester _requester;

  TargetHttpProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all TargetHttpProxy resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxyAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetHttpProxy resource.
  ///
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
    core.String project,
    core.String targetHttpProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetHttpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified TargetHttpProxy resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    TargetHttpProxy request,
    core.String project,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetHttpsProxiesResource {
  final commons.ApiRequester _requester;

  TargetHttpsProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all TargetHttpsProxy resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxyAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetHttpsProxy resource.
  ///
  /// Gets a list of available target HTTPS proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
    core.String project,
    core.String targetHttpsProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetHttpsProxy resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpsProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified TargetHttpsProxy resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000). end_interface:
  /// MixerMutationRequestBuilder
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    TargetHttpsProxy request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the QUIC override policy for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set the QUIC
  /// override policy for. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setQuicOverride(
    TargetHttpsProxiesSetQuicOverrideRequest request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setQuicOverride';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    TargetHttpsProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the SSL policy for TargetHttpsProxy.
  ///
  /// The SSL policy specifies the server-side support for SSL features. This
  /// affects connections between clients and the HTTPS proxy load balancer.
  /// They do not affect the connection between the load balancer and the
  /// backends.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose SSL
  /// policy is to be set. The name must be 1-63 characters long, and comply
  /// with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslPolicy(
    SslPolicyReference request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setSslPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose URL map
  /// is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetInstancesResource {
  final commons.ApiRequester _requester;

  TargetInstancesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of target instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetInstances';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetInstanceAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified TargetInstance resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetInstance] - Name of the TargetInstance resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String targetInstance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/targetInstances/' +
        commons.escapeVariable('$targetInstance');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetInstance resource.
  ///
  /// Gets a list of available target instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetInstance] - Name of the TargetInstance resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstance> get(
    core.String project,
    core.String zone,
    core.String targetInstance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/targetInstances/' +
        commons.escapeVariable('$targetInstance');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetInstance.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetInstance resource in the specified project and zone using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetInstance request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/targetInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of TargetInstance resources available to the specified
  /// project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/targetInstances';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetInstanceList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class TargetPoolsResource {
  final commons.ApiRequester _requester;

  TargetPoolsResource(commons.ApiRequester client) : _requester = client;

  /// Adds health check URLs to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the target pool to add a health check to.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addHealthCheck(
    TargetPoolsAddHealthCheckRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/addHealthCheck';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Adds an instance to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to add instances to.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstance(
    TargetPoolsAddInstanceRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/addInstance';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves an aggregated list of target pools.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetPools';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetPoolAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified target pool.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified target pool.
  ///
  /// Gets a list of available target pools by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPool> get(
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetPool.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the most recent health check results for each IP for the instance
  /// that is referenced by the given target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to which the queried
  /// instance belongs.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolInstanceHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolInstanceHealth> getHealth(
    InstanceReference request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/getHealth';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TargetPoolInstanceHealth.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a target pool in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetPool request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of target pools available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetPoolList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Removes health check URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the target pool to remove health checks from.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeHealthCheck(
    TargetPoolsRemoveHealthCheckRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/removeHealthCheck';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes instance URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to remove instances from.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstance(
    TargetPoolsRemoveInstanceRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/removeInstance';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes a backup target pool's configurations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to set a backup pool for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [failoverRatio] - New failoverRatio value for the target pool.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackup(
    TargetReference request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.double? failoverRatio,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (failoverRatio != null) 'failoverRatio': ['${failoverRatio}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/setBackup';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetSslProxiesResource {
  final commons.ApiRequester _requester;

  TargetSslProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified TargetSslProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetSslProxy resource.
  ///
  /// Gets a list of available target SSL proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxy> get(
    core.String project,
    core.String targetSslProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetSslProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetSslProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetSslProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetSslProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetSslProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the BackendService for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
    TargetSslProxiesSetBackendServiceRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy') +
        '/setBackendService';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the ProxyHeaderType for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
    TargetSslProxiesSetProxyHeaderRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy') +
        '/setProxyHeader';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes SslCertificates for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// SslCertificate resource is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    TargetSslProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy') +
        '/setSslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the SSL policy for TargetSslProxy.
  ///
  /// The SSL policy specifies the server-side support for SSL features. This
  /// affects connections between clients and the SSL proxy load balancer. They
  /// do not affect the connection between the load balancer and the backends.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose SSL policy is
  /// to be set. The name must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslPolicy(
    SslPolicyReference request,
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy') +
        '/setSslPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetTcpProxiesResource {
  final commons.ApiRequester _requester;

  TargetTcpProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified TargetTcpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetTcpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.escapeVariable('$targetTcpProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetTcpProxy resource.
  ///
  /// Gets a list of available target TCP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxy> get(
    core.String project,
    core.String targetTcpProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.escapeVariable('$targetTcpProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetTcpProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetTcpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetTcpProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetTcpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetTcpProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the BackendService for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
    TargetTcpProxiesSetBackendServiceRequest request,
    core.String project,
    core.String targetTcpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.escapeVariable('$targetTcpProxy') +
        '/setBackendService';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the ProxyHeaderType for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
    TargetTcpProxiesSetProxyHeaderRequest request,
    core.String project,
    core.String targetTcpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.escapeVariable('$targetTcpProxy') +
        '/setProxyHeader';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetVpnGatewaysResource {
  final commons.ApiRequester _requester;

  TargetVpnGatewaysResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of target VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetVpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetVpnGatewayAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified target VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetVpnGateway, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.escapeVariable('$targetVpnGateway');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified target VPN gateway.
  ///
  /// Gets a list of available target VPN gateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGateway> get(
    core.String project,
    core.String region,
    core.String targetVpnGateway, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.escapeVariable('$targetVpnGateway');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetVpnGateway.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a target VPN gateway in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetVpnGateway request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetVpnGateways';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of target VPN gateways available to the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetVpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetVpnGatewayList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class UrlMapsResource {
  final commons.ApiRequester _requester;

  UrlMapsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all UrlMap resources, regional and global, available
  /// to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/urlMaps';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMapsAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified UrlMap resource.
  ///
  /// Gets a list of available URL maps by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(
    core.String project,
    core.String urlMap, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMap.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    UrlMap request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/urlMaps';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Initiates a cache invalidation operation, invalidating the specified path,
  /// scoped to the specified UrlMap.
  ///
  /// For more information, see \[Invalidating cached
  /// content\](/cdn/docs/invalidating-cached-content).
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> invalidateCache(
    CacheInvalidationRule request,
    core.String project,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap') +
        '/invalidateCache';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of UrlMap resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/urlMaps';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMapList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    UrlMap request,
    core.String project,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    UrlMap request,
    core.String project,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Runs static validation for the UrlMap.
  ///
  /// In particular, the tests of the provided UrlMap will be run. Calling this
  /// method does NOT create the UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
    UrlMapsValidateRequest request,
    core.String project,
    core.String urlMap, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap') +
        '/validate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return UrlMapsValidateResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class VpnGatewaysResource {
  final commons.ApiRequester _requester;

  VpnGatewaysResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewayAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/vpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnGatewayAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnGateway] - Name of the VPN gateway to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$vpnGateway');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified VPN gateway.
  ///
  /// Gets a list of available VPN gateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnGateway] - Name of the VPN gateway to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGateway> get(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$vpnGateway');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnGateway.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the status for the specified VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnGateway] - Name of the VPN gateway to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewaysGetStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewaysGetStatusResponse> getStatus(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$vpnGateway') +
        '/getStatus';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnGatewaysGetStatusResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a VPN gateway in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    VpnGateway request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of VPN gateways available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewayList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnGatewayList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on a VpnGateway.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    RegionSetLabelsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class VpnTunnelsResource {
  final commons.ApiRequester _requester;

  VpnTunnelsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN tunnels.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/vpnTunnels';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnTunnelAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified VpnTunnel resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String vpnTunnel, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnTunnels/' +
        commons.escapeVariable('$vpnTunnel');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified VpnTunnel resource.
  ///
  /// Gets a list of available VPN tunnels by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnel].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnel> get(
    core.String project,
    core.String region,
    core.String vpnTunnel, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnTunnels/' +
        commons.escapeVariable('$vpnTunnel');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnTunnel.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a VpnTunnel resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed. For example,
  /// consider a situation where you make an initial request and the request
  /// times out. If you make the request again with the same request ID, the
  /// server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported (
  /// 00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    VpnTunnel request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnTunnels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of VpnTunnel resources contained in the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnTunnels';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnTunnelList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ZoneOperationsResource {
  final commons.ApiRequester _requester;

  ZoneOperationsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> delete(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/operations/' +
        commons.escapeVariable('$operation');

    await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Retrieves the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/operations/' +
        commons.escapeVariable('$operation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource.
  ///
  /// This method differs from the `GET` method in that it waits for no more
  /// than the default deadline (2 minutes) and then returns the current state
  /// of the operation, which might be `DONE` or still in progress. This method
  /// is called on a best-effort basis. Specifically: - In uncommon cases, when
  /// the server is overloaded, the request might return before the default
  /// deadline is reached, or might return after zero seconds. - If the default
  /// deadline is reached, there is no guarantee that the operation is actually
  /// done when the method returns. Be prepared to retry if the operation is not
  /// `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/operations/' +
        commons.escapeVariable('$operation') +
        '/wait';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class ZonesResource {
  final commons.ApiRequester _requester;

  ZonesResource(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Zone resource.
  ///
  /// Gets a list of available zones by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Zone].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Zone> get(
    core.String project,
    core.String zone, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Zone.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of Zone resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`. For example, if you are filtering Compute
  /// Engine instances, you can exclude instances named `example-instance` by
  /// specifying `name != example-instance`. You can also filter nested fields.
  /// For example, you could specify `scheduling.automaticRestart = false` to
  /// include instances only if they are not scheduled for automatic restarts.
  /// You can use filtering on nested fields to filter based on resource labels.
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name. You can also
  /// sort results in descending order based on the creation timestamp using
  /// `orderBy="creationTimestamp desc"`. This sorts results based on the
  /// `creationTimestamp` field in reverse chronological order (newest result
  /// first). Use this to sort resources like operations so that the newest
  /// operation is returned first. Currently, only sorting by `name` or
  /// `creationTimestamp desc` is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ZoneList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ZoneList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' + commons.escapeVariable('$project') + '/zones';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ZoneList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

/// A specification of the type and number of accelerator cards attached to the
/// instance.
class AcceleratorConfig {
  /// The number of the guest accelerator cards exposed to this instance.
  core.int? acceleratorCount;

  /// Full or partial URL of the accelerator type resource to attach to this
  /// instance.
  ///
  /// For example:
  /// projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100
  /// If you are creating an instance template, specify only the accelerator
  /// name. See GPUs on Compute Engine for a full list of accelerator types.
  core.String? acceleratorType;

  AcceleratorConfig({
    this.acceleratorCount,
    this.acceleratorType,
  });

  AcceleratorConfig.fromJson(core.Map _json)
      : this(
          acceleratorCount: _json.containsKey('acceleratorCount')
              ? _json['acceleratorCount'] as core.int
              : null,
          acceleratorType: _json.containsKey('acceleratorType')
              ? _json['acceleratorType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (acceleratorCount != null) 'acceleratorCount': acceleratorCount!,
        if (acceleratorType != null) 'acceleratorType': acceleratorType!,
      };
}

/// Represents an Accelerator Type resource.
///
/// Google Cloud Platform provides graphics processing units (accelerators) that
/// you can add to VM instances to improve or accelerate performance when
/// working with intensive workloads. For more information, read GPUs on Compute
/// Engine.
class AcceleratorType {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this accelerator type.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// An optional textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The type of the resource.
  ///
  /// Always compute#acceleratorType for accelerator types.
  ///
  /// Output only.
  core.String? kind;

  /// Maximum number of accelerator cards allowed per instance.
  ///
  /// Output only.
  core.int? maximumCardsPerInstance;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// Server-defined, fully qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The name of the zone where the accelerator type resides, such as
  /// us-central1-a.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  AcceleratorType({
    this.creationTimestamp,
    this.deprecated,
    this.description,
    this.id,
    this.kind,
    this.maximumCardsPerInstance,
    this.name,
    this.selfLink,
    this.zone,
  });

  AcceleratorType.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          deprecated: _json.containsKey('deprecated')
              ? DeprecationStatus.fromJson(
                  _json['deprecated'] as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          maximumCardsPerInstance: _json.containsKey('maximumCardsPerInstance')
              ? _json['maximumCardsPerInstance'] as core.int
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (maximumCardsPerInstance != null)
          'maximumCardsPerInstance': maximumCardsPerInstance!,
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (zone != null) 'zone': zone!,
      };
}

class AcceleratorTypeAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AcceleratorTypeAggregatedListWarningData({
    this.key,
    this.value,
  });

  AcceleratorTypeAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AcceleratorTypeAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AcceleratorTypeAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AcceleratorTypeAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  AcceleratorTypeAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AcceleratorTypeAggregatedListWarningData>((value) =>
                      AcceleratorTypeAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AcceleratorTypeAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of AcceleratorTypesScopedList resources.
  core.Map<core.String, AcceleratorTypesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#acceleratorTypeAggregatedList for aggregated lists of
  /// accelerator types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  AcceleratorTypeAggregatedListWarning? warning;

  AcceleratorTypeAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  AcceleratorTypeAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    AcceleratorTypesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? AcceleratorTypeAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AcceleratorTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AcceleratorTypeListWarningData({
    this.key,
    this.value,
  });

  AcceleratorTypeListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AcceleratorTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AcceleratorTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AcceleratorTypeListWarning({
    this.code,
    this.data,
    this.message,
  });

  AcceleratorTypeListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AcceleratorTypeListWarningData>((value) =>
                      AcceleratorTypeListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of accelerator types.
class AcceleratorTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of AcceleratorType resources.
  core.List<AcceleratorType>? items;

  /// Type of resource.
  ///
  /// Always compute#acceleratorTypeList for lists of accelerator types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  AcceleratorTypeListWarning? warning;

  AcceleratorTypeList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  AcceleratorTypeList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<AcceleratorType>((value) => AcceleratorType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? AcceleratorTypeListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AcceleratorTypesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AcceleratorTypesScopedListWarningData({
    this.key,
    this.value,
  });

  AcceleratorTypesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the accelerator types list is
/// empty.
///
/// Output only.
class AcceleratorTypesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AcceleratorTypesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AcceleratorTypesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  AcceleratorTypesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AcceleratorTypesScopedListWarningData>((value) =>
                      AcceleratorTypesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AcceleratorTypesScopedList {
  /// A list of accelerator types contained in this scope.
  ///
  /// Output only.
  core.List<AcceleratorType>? acceleratorTypes;

  /// An informational warning that appears when the accelerator types list is
  /// empty.
  ///
  /// Output only.
  AcceleratorTypesScopedListWarning? warning;

  AcceleratorTypesScopedList({
    this.acceleratorTypes,
    this.warning,
  });

  AcceleratorTypesScopedList.fromJson(core.Map _json)
      : this(
          acceleratorTypes: _json.containsKey('acceleratorTypes')
              ? (_json['acceleratorTypes'] as core.List)
                  .map<AcceleratorType>((value) => AcceleratorType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? AcceleratorTypesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (acceleratorTypes != null)
          'acceleratorTypes':
              acceleratorTypes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// An access configuration attached to an instance's network interface.
///
/// Only one access config per instance is supported.
class AccessConfig {
  /// The first IPv6 address of the external IPv6 range associated with this
  /// instance, prefix length is stored in externalIpv6PrefixLength in
  /// ipv6AccessConfig.
  ///
  /// The field is output only, an IPv6 address from a subnetwork associated
  /// with the instance will be allocated dynamically.
  ///
  /// Output only.
  core.String? externalIpv6;

  /// The prefix length of the external IPv6 range.
  ///
  /// Output only.
  core.int? externalIpv6PrefixLength;

  /// Type of the resource.
  ///
  /// Always compute#accessConfig for access configs.
  ///
  /// Output only.
  core.String? kind;

  /// The name of this access configuration.
  ///
  /// The default and recommended name is External NAT, but you can use any
  /// arbitrary string, such as My external IP or Network Access.
  core.String? name;

  /// An external IP address associated with this instance.
  ///
  /// Specify an unused static external IP address available to the project or
  /// leave this field undefined to use an IP from a shared ephemeral IP address
  /// pool. If you specify a static external IP address, it must live in the
  /// same region as the zone of the instance.
  core.String? natIP;

  /// This signifies the networking tier used for configuring this access
  /// configuration and can only take the following values: PREMIUM, STANDARD.
  ///
  /// If an AccessConfig is specified without a valid external IP address, an
  /// ephemeral IP will be created with this networkTier. If an AccessConfig
  /// with a valid external IP address is specified, it must match that of the
  /// networkTier associated with the Address resource owning that IP.
  /// Possible string values are:
  /// - "PREMIUM" : High quality, Google-grade network tier, support for all
  /// networking products.
  /// - "STANDARD" : Public internet quality, only limited support for other
  /// networking products.
  core.String? networkTier;

  /// The DNS domain name for the public PTR record.
  ///
  /// You can set this field only if the `setPublicPtr` field is enabled.
  core.String? publicPtrDomainName;

  /// Specifies whether a public DNS 'PTR' record should be created to map the
  /// external IP address of the instance to a DNS domain name.
  core.bool? setPublicPtr;

  /// The type of configuration.
  ///
  /// The default and only option is ONE_TO_ONE_NAT.
  /// Possible string values are:
  /// - "DIRECT_IPV6"
  /// - "ONE_TO_ONE_NAT"
  core.String? type;

  AccessConfig({
    this.externalIpv6,
    this.externalIpv6PrefixLength,
    this.kind,
    this.name,
    this.natIP,
    this.networkTier,
    this.publicPtrDomainName,
    this.setPublicPtr,
    this.type,
  });

  AccessConfig.fromJson(core.Map _json)
      : this(
          externalIpv6: _json.containsKey('externalIpv6')
              ? _json['externalIpv6'] as core.String
              : null,
          externalIpv6PrefixLength:
              _json.containsKey('externalIpv6PrefixLength')
                  ? _json['externalIpv6PrefixLength'] as core.int
                  : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          natIP:
              _json.containsKey('natIP') ? _json['natIP'] as core.String : null,
          networkTier: _json.containsKey('networkTier')
              ? _json['networkTier'] as core.String
              : null,
          publicPtrDomainName: _json.containsKey('publicPtrDomainName')
              ? _json['publicPtrDomainName'] as core.String
              : null,
          setPublicPtr: _json.containsKey('setPublicPtr')
              ? _json['setPublicPtr'] as core.bool
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (externalIpv6 != null) 'externalIpv6': externalIpv6!,
        if (externalIpv6PrefixLength != null)
          'externalIpv6PrefixLength': externalIpv6PrefixLength!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (natIP != null) 'natIP': natIP!,
        if (networkTier != null) 'networkTier': networkTier!,
        if (publicPtrDomainName != null)
          'publicPtrDomainName': publicPtrDomainName!,
        if (setPublicPtr != null) 'setPublicPtr': setPublicPtr!,
        if (type != null) 'type': type!,
      };
}

/// Represents an IP Address resource.
///
/// Google Compute Engine has two IP Address resources: * \[Global (external and
/// internal)\](https://cloud.google.com/compute/docs/reference/rest/v1/globalAddresses)
/// * \[Regional (external and
/// internal)\](https://cloud.google.com/compute/docs/reference/rest/v1/addresses)
/// For more information, see Reserving a static external IP address.
class Address {
  /// The static IP address represented by this resource.
  core.String? address;

  /// The type of address to reserve, either INTERNAL or EXTERNAL.
  ///
  /// If unspecified, defaults to EXTERNAL.
  /// Possible string values are:
  /// - "EXTERNAL" : A publicly visible external IP address.
  /// - "INTERNAL" : A private network IP address, for use with an Instance or
  /// Internal Load Balancer forwarding rule.
  /// - "UNSPECIFIED_TYPE"
  core.String? addressType;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The IP version that will be used by this address.
  ///
  /// Valid options are IPV4 or IPV6. This can only be specified for a global
  /// address.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String? ipVersion;

  /// Type of the resource.
  ///
  /// Always compute#address for addresses.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase
  /// letter, and all following characters (except for the last character) must
  /// be a dash, lowercase letter, or digit. The last character must be a
  /// lowercase letter or digit.
  core.String? name;

  /// The URL of the network in which to reserve the address.
  ///
  /// This field can only be used with INTERNAL type with the VPC_PEERING
  /// purpose.
  core.String? network;

  /// This signifies the networking tier used for configuring this address and
  /// can only take the following values: PREMIUM or STANDARD.
  ///
  /// Internal IP addresses are always Premium Tier; global external IP
  /// addresses are always Premium Tier; regional external IP addresses can be
  /// either Standard or Premium Tier. If this field is not specified, it is
  /// assumed to be PREMIUM.
  /// Possible string values are:
  /// - "PREMIUM" : High quality, Google-grade network tier, support for all
  /// networking products.
  /// - "STANDARD" : Public internet quality, only limited support for other
  /// networking products.
  core.String? networkTier;

  /// The prefix length if the resource represents an IP range.
  core.int? prefixLength;

  /// The purpose of this resource, which can be one of the following values: -
  /// GCE_ENDPOINT for addresses that are used by VM instances, alias IP ranges,
  /// load balancers, and similar resources.
  ///
  /// - DNS_RESOLVER for a DNS resolver address in a subnetwork for a Cloud DNS
  /// inbound forwarder IP addresses (regional internal IP address in a subnet
  /// of a VPC network) - VPC_PEERING for global internal IP addresses used for
  /// private services access allocated ranges. - NAT_AUTO for the regional
  /// external IP addresses used by Cloud NAT when allocating addresses using .
  /// - IPSEC_INTERCONNECT for addresses created from a private IP range that
  /// are reserved for a VLAN attachment in an *IPsec-encrypted Cloud
  /// Interconnect* configuration. These addresses are regional resources. Not
  /// currently available publicly. - `SHARED_LOADBALANCER_VIP` for an internal
  /// IP address that is assigned to multiple internal forwarding rules. -
  /// `PRIVATE_SERVICE_CONNECT` for a private network address that is used to
  /// configure Private Service Connect. Only global internal addresses can use
  /// this purpose.
  /// Possible string values are:
  /// - "DNS_RESOLVER" : DNS resolver address in the subnetwork.
  /// - "GCE_ENDPOINT" : VM internal/alias IP, Internal LB service IP, etc.
  /// - "IPSEC_INTERCONNECT" : A regional internal IP address range reserved for
  /// the VLAN attachment that is used in IPsec-encrypted Cloud Interconnect.
  /// This regional internal IP address range must not overlap with any IP
  /// address range of subnet/route in the VPC network and its peering networks.
  /// After the VLAN attachment is created with the reserved IP address range,
  /// when creating a new VPN gateway, its interface IP address is allocated
  /// from the associated VLAN attachment’s IP address range.
  /// - "NAT_AUTO" : External IP automatically reserved for Cloud NAT.
  /// - "PRIVATE_SERVICE_CONNECT" : A private network IP address that can be
  /// used to configure Private Service Connect. This purpose can be specified
  /// only for GLOBAL addresses of Type INTERNAL
  /// - "SHARED_LOADBALANCER_VIP" : A private network IP address that can be
  /// shared by multiple Internal Load Balancer forwarding rules.
  /// - "VPC_PEERING" : IP range for peer networks.
  core.String? purpose;

  /// The URL of the region where a regional address resides.
  ///
  /// For regional addresses, you must specify the region as a path parameter in
  /// the HTTP request URL. *This field is not applicable to global addresses.*
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the address, which can be one of RESERVING, RESERVED, or
  /// IN_USE.
  ///
  /// An address that is RESERVING is currently in the process of being
  /// reserved. A RESERVED address is currently reserved and available to use.
  /// An IN_USE address is currently being used by another resource and is not
  /// available.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "IN_USE" : Address is being used by another resource and is not
  /// available.
  /// - "RESERVED" : Address is reserved and available to use.
  /// - "RESERVING" : Address is being reserved.
  core.String? status;

  /// The URL of the subnetwork in which to reserve the address.
  ///
  /// If an IP address is specified, it must be within the subnetwork's IP
  /// range. This field can only be used with INTERNAL type with a GCE_ENDPOINT
  /// or DNS_RESOLVER purpose.
  core.String? subnetwork;

  /// The URLs of the resources that are using this address.
  ///
  /// Output only.
  core.List<core.String>? users;

  Address({
    this.address,
    this.addressType,
    this.creationTimestamp,
    this.description,
    this.id,
    this.ipVersion,
    this.kind,
    this.name,
    this.network,
    this.networkTier,
    this.prefixLength,
    this.purpose,
    this.region,
    this.selfLink,
    this.status,
    this.subnetwork,
    this.users,
  });

  Address.fromJson(core.Map _json)
      : this(
          address: _json.containsKey('address')
              ? _json['address'] as core.String
              : null,
          addressType: _json.containsKey('addressType')
              ? _json['addressType'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          ipVersion: _json.containsKey('ipVersion')
              ? _json['ipVersion'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          networkTier: _json.containsKey('networkTier')
              ? _json['networkTier'] as core.String
              : null,
          prefixLength: _json.containsKey('prefixLength')
              ? _json['prefixLength'] as core.int
              : null,
          purpose: _json.containsKey('purpose')
              ? _json['purpose'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          subnetwork: _json.containsKey('subnetwork')
              ? _json['subnetwork'] as core.String
              : null,
          users: _json.containsKey('users')
              ? (_json['users'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (address != null) 'address': address!,
        if (addressType != null) 'addressType': addressType!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (ipVersion != null) 'ipVersion': ipVersion!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (networkTier != null) 'networkTier': networkTier!,
        if (prefixLength != null) 'prefixLength': prefixLength!,
        if (purpose != null) 'purpose': purpose!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
        if (users != null) 'users': users!,
      };
}

class AddressAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AddressAggregatedListWarningData({
    this.key,
    this.value,
  });

  AddressAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AddressAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AddressAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AddressAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  AddressAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AddressAggregatedListWarningData>((value) =>
                      AddressAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AddressAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of AddressesScopedList resources.
  core.Map<core.String, AddressesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#addressAggregatedList for aggregated lists of addresses.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  AddressAggregatedListWarning? warning;

  AddressAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  AddressAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    AddressesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? AddressAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AddressListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AddressListWarningData({
    this.key,
    this.value,
  });

  AddressListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AddressListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AddressListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AddressListWarning({
    this.code,
    this.data,
    this.message,
  });

  AddressListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AddressListWarningData>((value) =>
                      AddressListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of addresses.
class AddressList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Address resources.
  core.List<Address>? items;

  /// Type of resource.
  ///
  /// Always compute#addressList for lists of addresses.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  AddressListWarning? warning;

  AddressList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  AddressList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Address>((value) => Address.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? AddressListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AddressesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AddressesScopedListWarningData({
    this.key,
    this.value,
  });

  AddressesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
///
/// Output only.
class AddressesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AddressesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AddressesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  AddressesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AddressesScopedListWarningData>((value) =>
                      AddressesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AddressesScopedList {
  /// A list of addresses contained in this scope.
  ///
  /// Output only.
  core.List<Address>? addresses;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  ///
  /// Output only.
  AddressesScopedListWarning? warning;

  AddressesScopedList({
    this.addresses,
    this.warning,
  });

  AddressesScopedList.fromJson(core.Map _json)
      : this(
          addresses: _json.containsKey('addresses')
              ? (_json['addresses'] as core.List)
                  .map<Address>((value) => Address.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? AddressesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (addresses != null)
          'addresses': addresses!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Specifies options for controlling advanced machine features.
///
/// Options that would traditionally be configured in a BIOS belong here.
/// Features that require operating system support may have corresponding
/// entries in the GuestOsFeatures of an Image (e.g., whether or not the OS in
/// the Image supports nested virtualization being enabled or disabled).
class AdvancedMachineFeatures {
  /// Whether to enable nested virtualization or not (default is false).
  core.bool? enableNestedVirtualization;

  /// The number of threads per physical core.
  ///
  /// To disable simultaneous multithreading (SMT) set this to 1. If unset, the
  /// maximum number of threads supported per core by the underlying processor
  /// is assumed.
  core.int? threadsPerCore;

  AdvancedMachineFeatures({
    this.enableNestedVirtualization,
    this.threadsPerCore,
  });

  AdvancedMachineFeatures.fromJson(core.Map _json)
      : this(
          enableNestedVirtualization:
              _json.containsKey('enableNestedVirtualization')
                  ? _json['enableNestedVirtualization'] as core.bool
                  : null,
          threadsPerCore: _json.containsKey('threadsPerCore')
              ? _json['threadsPerCore'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableNestedVirtualization != null)
          'enableNestedVirtualization': enableNestedVirtualization!,
        if (threadsPerCore != null) 'threadsPerCore': threadsPerCore!,
      };
}

/// An alias IP range attached to an instance's network interface.
class AliasIpRange {
  /// The IP alias ranges to allocate for this interface.
  ///
  /// This IP CIDR range must belong to the specified subnetwork and cannot
  /// contain IP addresses reserved by system or used by other network
  /// interfaces. This range may be a single IP address (such as 10.2.3.4), a
  /// netmask (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
  core.String? ipCidrRange;

  /// The name of a subnetwork secondary IP range from which to allocate an IP
  /// alias range.
  ///
  /// If not specified, the primary range of the subnetwork is used.
  core.String? subnetworkRangeName;

  AliasIpRange({
    this.ipCidrRange,
    this.subnetworkRangeName,
  });

  AliasIpRange.fromJson(core.Map _json)
      : this(
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
          subnetworkRangeName: _json.containsKey('subnetworkRangeName')
              ? _json['subnetworkRangeName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (subnetworkRangeName != null)
          'subnetworkRangeName': subnetworkRangeName!,
      };
}

class AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk {
  /// Specifies the size of the disk in base-2 GB.
  core.String? diskSizeGb;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME.
  ///
  /// The default is SCSI. For performance characteristics of SCSI over NVMe,
  /// see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String? interface;

  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk({
    this.diskSizeGb,
    this.interface,
  });

  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk.fromJson(
      core.Map _json)
      : this(
          diskSizeGb: _json.containsKey('diskSizeGb')
              ? _json['diskSizeGb'] as core.String
              : null,
          interface: _json.containsKey('interface')
              ? _json['interface'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (interface != null) 'interface': interface!,
      };
}

/// Properties of the SKU instances being reserved.
///
/// Next ID: 9
class AllocationSpecificSKUAllocationReservedInstanceProperties {
  /// Specifies accelerator type and count.
  core.List<AcceleratorConfig>? guestAccelerators;

  /// Specifies amount of local ssd to reserve with each instance.
  ///
  /// The type of disk is local-ssd.
  core.List<
          AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk>?
      localSsds;

  /// An opaque location hint used to place the allocation close to other
  /// resources.
  ///
  /// This field is for use by internal tools that use the public API.
  core.String? locationHint;

  /// Specifies type of machine (name only) which has fixed number of vCPUs and
  /// fixed amount of memory.
  ///
  /// This also includes specifying custom machine type following
  /// custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
  core.String? machineType;

  /// Minimum cpu platform the reservation.
  core.String? minCpuPlatform;

  AllocationSpecificSKUAllocationReservedInstanceProperties({
    this.guestAccelerators,
    this.localSsds,
    this.locationHint,
    this.machineType,
    this.minCpuPlatform,
  });

  AllocationSpecificSKUAllocationReservedInstanceProperties.fromJson(
      core.Map _json)
      : this(
          guestAccelerators: _json.containsKey('guestAccelerators')
              ? (_json['guestAccelerators'] as core.List)
                  .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          localSsds: _json.containsKey('localSsds')
              ? (_json['localSsds'] as core.List)
                  .map<AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk>(
                      (value) =>
                          AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          locationHint: _json.containsKey('locationHint')
              ? _json['locationHint'] as core.String
              : null,
          machineType: _json.containsKey('machineType')
              ? _json['machineType'] as core.String
              : null,
          minCpuPlatform: _json.containsKey('minCpuPlatform')
              ? _json['minCpuPlatform'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (guestAccelerators != null)
          'guestAccelerators':
              guestAccelerators!.map((value) => value.toJson()).toList(),
        if (localSsds != null)
          'localSsds': localSsds!.map((value) => value.toJson()).toList(),
        if (locationHint != null) 'locationHint': locationHint!,
        if (machineType != null) 'machineType': machineType!,
        if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
      };
}

/// This reservation type allows to pre allocate specific instance
/// configuration.
///
/// Next ID: 5
class AllocationSpecificSKUReservation {
  /// Specifies the number of resources that are allocated.
  core.String? count;

  /// Indicates how many instances are in use.
  ///
  /// Output only.
  core.String? inUseCount;

  /// The instance properties for the reservation.
  AllocationSpecificSKUAllocationReservedInstanceProperties? instanceProperties;

  AllocationSpecificSKUReservation({
    this.count,
    this.inUseCount,
    this.instanceProperties,
  });

  AllocationSpecificSKUReservation.fromJson(core.Map _json)
      : this(
          count:
              _json.containsKey('count') ? _json['count'] as core.String : null,
          inUseCount: _json.containsKey('inUseCount')
              ? _json['inUseCount'] as core.String
              : null,
          instanceProperties: _json.containsKey('instanceProperties')
              ? AllocationSpecificSKUAllocationReservedInstanceProperties
                  .fromJson(_json['instanceProperties']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (count != null) 'count': count!,
        if (inUseCount != null) 'inUseCount': inUseCount!,
        if (instanceProperties != null)
          'instanceProperties': instanceProperties!.toJson(),
      };
}

/// An instance-attached disk resource.
class AttachedDisk {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool? autoDelete;

  /// Indicates that this is a boot disk.
  ///
  /// The virtual machine will use the first partition of the disk for its root
  /// filesystem.
  core.bool? boot;

  /// Specifies a unique device name of your choice that is reflected into the
  /// /dev/disk/by-id/google-* tree of a Linux operating system running within
  /// the instance.
  ///
  /// This name can be used to reference the device for mounting, resizing, and
  /// so on, from within the instance. If not specified, the server chooses a
  /// default device name to apply to this disk, in the form persistent-disk-x,
  /// where x is a number assigned by Google Compute Engine. This field is only
  /// applicable for persistent disks.
  core.String? deviceName;

  /// Encrypts or decrypts a disk using a customer-supplied encryption key.
  ///
  /// If you are creating a new disk, this field encrypts the new disk using an
  /// encryption key that you provide. If you are attaching an existing disk
  /// that is already encrypted, this field decrypts the disk using the
  /// customer-supplied encryption key. If you encrypt a disk using a
  /// customer-supplied key, you must provide the same key again when you
  /// attempt to use this resource at a later time. For example, you must
  /// provide the key when you create a snapshot or an image from the disk or
  /// when you attach the disk to a virtual machine instance. If you do not
  /// provide an encryption key, then the disk will be encrypted using an
  /// automatically generated key and you do not need to provide a key to use
  /// the disk later. Instance templates do not store customer-supplied
  /// encryption keys, so you cannot use your own keys to encrypt disks in a
  /// managed instance group.
  CustomerEncryptionKey? diskEncryptionKey;

  /// The size of the disk in GB.
  core.String? diskSizeGb;

  /// A list of features to enable on the guest operating system.
  ///
  /// Applicable only for bootable images. Read Enabling guest operating system
  /// features to see a list of available options.
  core.List<GuestOsFeature>? guestOsFeatures;

  /// A zero-based index to this disk, where 0 is reserved for the boot disk.
  ///
  /// If you have many disks attached to an instance, each disk would have a
  /// unique index number.
  ///
  /// Output only.
  core.int? index;

  /// \[Input Only\] Specifies the parameters for a new disk that will be
  /// created alongside the new instance.
  ///
  /// Use initialization parameters to create boot disks or local SSDs attached
  /// to the new instance. This property is mutually exclusive with the source
  /// property; you can only define one or the other, but not both.
  AttachedDiskInitializeParams? initializeParams;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME.
  ///
  /// The default is SCSI. Persistent disks must always use SCSI and the request
  /// will fail if you attempt to attach a persistent disk in any other format
  /// than SCSI. Local SSDs can use either NVME or SCSI. For performance
  /// characteristics of SCSI over NVMe, see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String? interface;

  /// Type of the resource.
  ///
  /// Always compute#attachedDisk for attached disks.
  ///
  /// Output only.
  core.String? kind;

  /// Any valid publicly visible licenses.
  ///
  /// Output only.
  core.List<core.String>? licenses;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
  ///
  /// If not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY" : Attaches this disk in read-only mode. Multiple virtual
  /// machines can use a disk in read-only mode at a time.
  /// - "READ_WRITE" : *\[Default\]* Attaches this disk in read-write mode. Only
  /// one virtual machine at a time can be attached to a disk in read-write
  /// mode.
  core.String? mode;

  /// shielded vm initial state stored on disk
  ///
  /// Output only.
  InitialStateConfig? shieldedInstanceInitialState;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource.
  ///
  /// When creating a new instance, one of initializeParams.sourceImage or
  /// initializeParams.sourceSnapshot or disks.source is required except for
  /// local SSD. If desired, you can also attach existing non-root persistent
  /// disks using this property. This field is only applicable for persistent
  /// disks. Note that for InstanceTemplate, specify the disk name, not the URL
  /// for the disk.
  core.String? source;

  /// Specifies the type of the disk, either SCRATCH or PERSISTENT.
  ///
  /// If not specified, the default is PERSISTENT.
  /// Possible string values are:
  /// - "PERSISTENT"
  /// - "SCRATCH"
  core.String? type;

  AttachedDisk({
    this.autoDelete,
    this.boot,
    this.deviceName,
    this.diskEncryptionKey,
    this.diskSizeGb,
    this.guestOsFeatures,
    this.index,
    this.initializeParams,
    this.interface,
    this.kind,
    this.licenses,
    this.mode,
    this.shieldedInstanceInitialState,
    this.source,
    this.type,
  });

  AttachedDisk.fromJson(core.Map _json)
      : this(
          autoDelete: _json.containsKey('autoDelete')
              ? _json['autoDelete'] as core.bool
              : null,
          boot: _json.containsKey('boot') ? _json['boot'] as core.bool : null,
          deviceName: _json.containsKey('deviceName')
              ? _json['deviceName'] as core.String
              : null,
          diskEncryptionKey: _json.containsKey('diskEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['diskEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          diskSizeGb: _json.containsKey('diskSizeGb')
              ? _json['diskSizeGb'] as core.String
              : null,
          guestOsFeatures: _json.containsKey('guestOsFeatures')
              ? (_json['guestOsFeatures'] as core.List)
                  .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          index: _json.containsKey('index') ? _json['index'] as core.int : null,
          initializeParams: _json.containsKey('initializeParams')
              ? AttachedDiskInitializeParams.fromJson(_json['initializeParams']
                  as core.Map<core.String, core.dynamic>)
              : null,
          interface: _json.containsKey('interface')
              ? _json['interface'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          licenses: _json.containsKey('licenses')
              ? (_json['licenses'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          mode: _json.containsKey('mode') ? _json['mode'] as core.String : null,
          shieldedInstanceInitialState:
              _json.containsKey('shieldedInstanceInitialState')
                  ? InitialStateConfig.fromJson(
                      _json['shieldedInstanceInitialState']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          source: _json.containsKey('source')
              ? _json['source'] as core.String
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoDelete != null) 'autoDelete': autoDelete!,
        if (boot != null) 'boot': boot!,
        if (deviceName != null) 'deviceName': deviceName!,
        if (diskEncryptionKey != null)
          'diskEncryptionKey': diskEncryptionKey!.toJson(),
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (guestOsFeatures != null)
          'guestOsFeatures':
              guestOsFeatures!.map((value) => value.toJson()).toList(),
        if (index != null) 'index': index!,
        if (initializeParams != null)
          'initializeParams': initializeParams!.toJson(),
        if (interface != null) 'interface': interface!,
        if (kind != null) 'kind': kind!,
        if (licenses != null) 'licenses': licenses!,
        if (mode != null) 'mode': mode!,
        if (shieldedInstanceInitialState != null)
          'shieldedInstanceInitialState':
              shieldedInstanceInitialState!.toJson(),
        if (source != null) 'source': source!,
        if (type != null) 'type': type!,
      };
}

/// \[Input Only\] Specifies the parameters for a new disk that will be created
/// alongside the new instance.
///
/// Use initialization parameters to create boot disks or local SSDs attached to
/// the new instance. This property is mutually exclusive with the source
/// property; you can only define one or the other, but not both.
class AttachedDiskInitializeParams {
  /// An optional description.
  ///
  /// Provide this property when creating the disk.
  core.String? description;

  /// Specifies the disk name.
  ///
  /// If not specified, the default is to use the name of the instance. If a
  /// disk with the same name already exists in the given region, the existing
  /// disk is attached to the new instance and the new disk is not created.
  core.String? diskName;

  /// Specifies the size of the disk in base-2 GB.
  ///
  /// The size must be at least 10 GB. If you specify a sourceImage, which is
  /// required for boot disks, the default size is the size of the sourceImage.
  /// If you do not specify a sourceImage, the default disk size is 500 GB.
  core.String? diskSizeGb;

  /// Specifies the disk type to use to create the instance.
  ///
  /// If not specified, the default is pd-standard, specified using the full
  /// URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /diskTypes/pd-standard For a full list of acceptable values, see
  /// Persistent disk types. If you define this field, you can provide either
  /// the full or partial URL. For example, the following are valid values: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /diskTypes/diskType - projects/project/zones/zone/diskTypes/diskType -
  /// zones/zone/diskTypes/diskType Note that for InstanceTemplate, this is the
  /// name of the disk type, not URL.
  core.String? diskType;

  /// Labels to apply to this disk.
  ///
  /// These can be later modified by the disks.setLabels method. This field is
  /// only applicable for persistent disks.
  core.Map<core.String, core.String>? labels;

  /// Specifies which action to take on instance update with this disk.
  ///
  /// Default is to use the existing disk.
  /// Possible string values are:
  /// - "RECREATE_DISK" : Always recreate the disk.
  /// - "RECREATE_DISK_IF_SOURCE_CHANGED" : Recreate the disk if source (image,
  /// snapshot) of this disk is different from source of existing disk.
  /// - "USE_EXISTING_DISK" : Use the existing disk, this is the default
  /// behaviour.
  core.String? onUpdateAction;

  /// Indicates how many IOPS to provision for the disk.
  ///
  /// This sets the number of I/O operations per second that the disk can
  /// handle. Values must be between 10,000 and 120,000. For more details, see
  /// the Extreme persistent disk documentation.
  core.String? provisionedIops;

  /// Resource policies applied to this disk for automatic snapshot creations.
  ///
  /// Specified using the full or partial URL. For instance template, specify
  /// only the resource policy name.
  core.List<core.String>? resourcePolicies;

  /// The source image to create this disk.
  ///
  /// When creating a new instance, one of initializeParams.sourceImage or
  /// initializeParams.sourceSnapshot or disks.source is required except for
  /// local SSD. To create a disk with one of the public operating system
  /// images, specify the image by its family name. For example, specify
  /// family/debian-9 to use the latest Debian 9 image:
  /// projects/debian-cloud/global/images/family/debian-9 Alternatively, use a
  /// specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD To create a
  /// disk with a custom image that you created, specify the image name in the
  /// following format: global/images/my-custom-image You can also specify a
  /// custom image by its image family, which returns the latest version of the
  /// image in that family. Replace the image name with family/family-name:
  /// global/images/family/my-image-family If the source image is deleted later,
  /// this field will not be set.
  core.String? sourceImage;

  /// The customer-supplied encryption key of the source image.
  ///
  /// Required if the source image is protected by a customer-supplied
  /// encryption key. Instance templates do not store customer-supplied
  /// encryption keys, so you cannot create disks for instances in a managed
  /// instance group if the source images are encrypted with your own keys.
  CustomerEncryptionKey? sourceImageEncryptionKey;

  /// The source snapshot to create this disk.
  ///
  /// When creating a new instance, one of initializeParams.sourceSnapshot or
  /// initializeParams.sourceImage or disks.source is required except for local
  /// SSD. To create a disk with a snapshot that you created, specify the
  /// snapshot name in the following format: global/snapshots/my-backup If the
  /// source snapshot is deleted later, this field will not be set.
  core.String? sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot.
  CustomerEncryptionKey? sourceSnapshotEncryptionKey;

  AttachedDiskInitializeParams({
    this.description,
    this.diskName,
    this.diskSizeGb,
    this.diskType,
    this.labels,
    this.onUpdateAction,
    this.provisionedIops,
    this.resourcePolicies,
    this.sourceImage,
    this.sourceImageEncryptionKey,
    this.sourceSnapshot,
    this.sourceSnapshotEncryptionKey,
  });

  AttachedDiskInitializeParams.fromJson(core.Map _json)
      : this(
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          diskName: _json.containsKey('diskName')
              ? _json['diskName'] as core.String
              : null,
          diskSizeGb: _json.containsKey('diskSizeGb')
              ? _json['diskSizeGb'] as core.String
              : null,
          diskType: _json.containsKey('diskType')
              ? _json['diskType'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          onUpdateAction: _json.containsKey('onUpdateAction')
              ? _json['onUpdateAction'] as core.String
              : null,
          provisionedIops: _json.containsKey('provisionedIops')
              ? _json['provisionedIops'] as core.String
              : null,
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          sourceImage: _json.containsKey('sourceImage')
              ? _json['sourceImage'] as core.String
              : null,
          sourceImageEncryptionKey: _json
                  .containsKey('sourceImageEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['sourceImageEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          sourceSnapshot: _json.containsKey('sourceSnapshot')
              ? _json['sourceSnapshot'] as core.String
              : null,
          sourceSnapshotEncryptionKey:
              _json.containsKey('sourceSnapshotEncryptionKey')
                  ? CustomerEncryptionKey.fromJson(
                      _json['sourceSnapshotEncryptionKey']
                          as core.Map<core.String, core.dynamic>)
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (diskName != null) 'diskName': diskName!,
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (diskType != null) 'diskType': diskType!,
        if (labels != null) 'labels': labels!,
        if (onUpdateAction != null) 'onUpdateAction': onUpdateAction!,
        if (provisionedIops != null) 'provisionedIops': provisionedIops!,
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
        if (sourceImage != null) 'sourceImage': sourceImage!,
        if (sourceImageEncryptionKey != null)
          'sourceImageEncryptionKey': sourceImageEncryptionKey!.toJson(),
        if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
        if (sourceSnapshotEncryptionKey != null)
          'sourceSnapshotEncryptionKey': sourceSnapshotEncryptionKey!.toJson(),
      };
}

/// Specifies the audit configuration for a service.
///
/// The configuration determines which permission types are logged, and what
/// identities, if any, are exempted from logging. An AuditConfig must have one
/// or more AuditLogConfigs. If there are AuditConfigs for both `allServices`
/// and a specific service, the union of the two AuditConfigs is used for that
/// service: the log_types specified in each AuditConfig are enabled, and the
/// exempted_members in each AuditLogConfig are exempted. Example Policy with
/// multiple AuditConfigs: { "audit_configs": \[ { "service": "allServices",
/// "audit_log_configs": \[ { "log_type": "DATA_READ", "exempted_members": \[
/// "user:jose@example.com" \] }, { "log_type": "DATA_WRITE" }, { "log_type":
/// "ADMIN_READ" } \] }, { "service": "sampleservice.googleapis.com",
/// "audit_log_configs": \[ { "log_type": "DATA_READ" }, { "log_type":
/// "DATA_WRITE", "exempted_members": \[ "user:aliya@example.com" \] } \] } \] }
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts jose@example.com from DATA_READ logging, and
/// aliya@example.com from DATA_WRITE logging.
class AuditConfig {
  /// The configuration for logging of each type of permission.
  core.List<AuditLogConfig>? auditLogConfigs;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<core.String>? exemptedMembers;

  /// Specifies a service that will be enabled for audit logging.
  ///
  /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
  /// `allServices` is a special value that covers all services.
  core.String? service;

  AuditConfig({
    this.auditLogConfigs,
    this.exemptedMembers,
    this.service,
  });

  AuditConfig.fromJson(core.Map _json)
      : this(
          auditLogConfigs: _json.containsKey('auditLogConfigs')
              ? (_json['auditLogConfigs'] as core.List)
                  .map<AuditLogConfig>((value) => AuditLogConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          exemptedMembers: _json.containsKey('exemptedMembers')
              ? (_json['exemptedMembers'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (auditLogConfigs != null)
          'auditLogConfigs':
              auditLogConfigs!.map((value) => value.toJson()).toList(),
        if (exemptedMembers != null) 'exemptedMembers': exemptedMembers!,
        if (service != null) 'service': service!,
      };
}

/// Provides the configuration for logging a type of permissions.
///
/// Example: { "audit_log_configs": \[ { "log_type": "DATA_READ",
/// "exempted_members": \[ "user:jose@example.com" \] }, { "log_type":
/// "DATA_WRITE" } \] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while
/// exempting jose@example.com from DATA_READ logging.
class AuditLogConfig {
  /// Specifies the identities that do not cause logging for this type of
  /// permission.
  ///
  /// Follows the same format of Binding.members.
  core.List<core.String>? exemptedMembers;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.bool? ignoreChildExemptions;

  /// The log type that this config enables.
  /// Possible string values are:
  /// - "ADMIN_READ" : Admin reads. Example: CloudIAM getIamPolicy
  /// - "DATA_READ" : Data reads. Example: CloudSQL Users list
  /// - "DATA_WRITE" : Data writes. Example: CloudSQL Users create
  /// - "LOG_TYPE_UNSPECIFIED" : Default case. Should never be this.
  core.String? logType;

  AuditLogConfig({
    this.exemptedMembers,
    this.ignoreChildExemptions,
    this.logType,
  });

  AuditLogConfig.fromJson(core.Map _json)
      : this(
          exemptedMembers: _json.containsKey('exemptedMembers')
              ? (_json['exemptedMembers'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          ignoreChildExemptions: _json.containsKey('ignoreChildExemptions')
              ? _json['ignoreChildExemptions'] as core.bool
              : null,
          logType: _json.containsKey('logType')
              ? _json['logType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exemptedMembers != null) 'exemptedMembers': exemptedMembers!,
        if (ignoreChildExemptions != null)
          'ignoreChildExemptions': ignoreChildExemptions!,
        if (logType != null) 'logType': logType!,
      };
}

/// This is deprecated and has no effect.
///
/// Do not use.
class AuthorizationLoggingOptions {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  /// Possible string values are:
  /// - "ADMIN_READ" : This is deprecated and has no effect. Do not use.
  /// - "ADMIN_WRITE" : This is deprecated and has no effect. Do not use.
  /// - "DATA_READ" : This is deprecated and has no effect. Do not use.
  /// - "DATA_WRITE" : This is deprecated and has no effect. Do not use.
  /// - "PERMISSION_TYPE_UNSPECIFIED" : This is deprecated and has no effect. Do
  /// not use.
  core.String? permissionType;

  AuthorizationLoggingOptions({
    this.permissionType,
  });

  AuthorizationLoggingOptions.fromJson(core.Map _json)
      : this(
          permissionType: _json.containsKey('permissionType')
              ? _json['permissionType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (permissionType != null) 'permissionType': permissionType!,
      };
}

/// Represents an Autoscaler resource.
///
/// Google Compute Engine has two Autoscaler resources: *
/// \[Zonal\](/compute/docs/reference/rest/v1/autoscalers) *
/// \[Regional\](/compute/docs/reference/rest/v1/regionAutoscalers) Use
/// autoscalers to automatically add or delete instances from a managed instance
/// group according to your defined autoscaling policy. For more information,
/// read Autoscaling Groups of Instances. For zonal managed instance groups
/// resource, use the autoscaler resource. For regional managed instance groups,
/// use the regionAutoscalers resource.
class Autoscaler {
  /// The configuration parameters for the autoscaling algorithm.
  ///
  /// You can define one or more signals for an autoscaler: cpuUtilization,
  /// customMetricUtilizations, and loadBalancingUtilization. If none of these
  /// are specified, the default will be to autoscale based on cpuUtilization to
  /// 0.6 or 60%.
  AutoscalingPolicy? autoscalingPolicy;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#autoscaler for autoscalers.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Target recommended MIG size (number of instances) computed by autoscaler.
  ///
  /// Autoscaler calculates the recommended MIG size even when the autoscaling
  /// policy mode is different from ON. This field is empty when autoscaler is
  /// not connected to an existing managed instance group or autoscaler did not
  /// generate its prediction.
  ///
  /// Output only.
  core.int? recommendedSize;

  /// URL of the region where the instance group resides (for autoscalers living
  /// in regional scope).
  ///
  /// Output only.
  core.String? region;

  /// Status information of existing scaling schedules.
  ///
  /// Output only.
  core.Map<core.String, ScalingScheduleStatus>? scalingScheduleStatus;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the autoscaler configuration.
  ///
  /// Current set of possible values: - PENDING: Autoscaler backend hasn't read
  /// new/updated configuration. - DELETING: Configuration is being deleted. -
  /// ACTIVE: Configuration is acknowledged to be effective. Some warnings might
  /// be present in the statusDetails field. - ERROR: Configuration has errors.
  /// Actionable for users. Details are present in the statusDetails field. New
  /// values might be added in the future.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE" : Configuration is acknowledged to be effective
  /// - "DELETING" : Configuration is being deleted
  /// - "ERROR" : Configuration has errors. Actionable for users.
  /// - "PENDING" : Autoscaler backend hasn't read new/updated configuration
  core.String? status;

  /// Human-readable details about the current state of the autoscaler.
  ///
  /// Read the documentation for Commonly returned status messages for examples
  /// of status messages you might encounter.
  ///
  /// Output only.
  core.List<AutoscalerStatusDetails>? statusDetails;

  /// URL of the managed instance group that this autoscaler will scale.
  ///
  /// This field is required when creating an autoscaler.
  core.String? target;

  /// URL of the zone where the instance group resides (for autoscalers living
  /// in zonal scope).
  ///
  /// Output only.
  core.String? zone;

  Autoscaler({
    this.autoscalingPolicy,
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.recommendedSize,
    this.region,
    this.scalingScheduleStatus,
    this.selfLink,
    this.status,
    this.statusDetails,
    this.target,
    this.zone,
  });

  Autoscaler.fromJson(core.Map _json)
      : this(
          autoscalingPolicy: _json.containsKey('autoscalingPolicy')
              ? AutoscalingPolicy.fromJson(_json['autoscalingPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          recommendedSize: _json.containsKey('recommendedSize')
              ? _json['recommendedSize'] as core.int
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          scalingScheduleStatus: _json.containsKey('scalingScheduleStatus')
              ? (_json['scalingScheduleStatus']
                      as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    ScalingScheduleStatus.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          statusDetails: _json.containsKey('statusDetails')
              ? (_json['statusDetails'] as core.List)
                  .map<AutoscalerStatusDetails>((value) =>
                      AutoscalerStatusDetails.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          target: _json.containsKey('target')
              ? _json['target'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalingPolicy != null)
          'autoscalingPolicy': autoscalingPolicy!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (recommendedSize != null) 'recommendedSize': recommendedSize!,
        if (region != null) 'region': region!,
        if (scalingScheduleStatus != null)
          'scalingScheduleStatus': scalingScheduleStatus!
              .map((key, item) => core.MapEntry(key, item.toJson())),
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (statusDetails != null)
          'statusDetails':
              statusDetails!.map((value) => value.toJson()).toList(),
        if (target != null) 'target': target!,
        if (zone != null) 'zone': zone!,
      };
}

class AutoscalerAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AutoscalerAggregatedListWarningData({
    this.key,
    this.value,
  });

  AutoscalerAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AutoscalerAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AutoscalerAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AutoscalerAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  AutoscalerAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AutoscalerAggregatedListWarningData>((value) =>
                      AutoscalerAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AutoscalerAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of AutoscalersScopedList resources.
  core.Map<core.String, AutoscalersScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#autoscalerAggregatedList for aggregated lists of
  /// autoscalers.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// end_interface: MixerListResponseWithEtagBuilder
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  AutoscalerAggregatedListWarning? warning;

  AutoscalerAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  AutoscalerAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    AutoscalersScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? AutoscalerAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AutoscalerListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AutoscalerListWarningData({
    this.key,
    this.value,
  });

  AutoscalerListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AutoscalerListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AutoscalerListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AutoscalerListWarning({
    this.code,
    this.data,
    this.message,
  });

  AutoscalerListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AutoscalerListWarningData>((value) =>
                      AutoscalerListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Autoscaler resources.
class AutoscalerList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler>? items;

  /// Type of resource.
  ///
  /// Always compute#autoscalerList for lists of autoscalers.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  AutoscalerListWarning? warning;

  AutoscalerList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  AutoscalerList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Autoscaler>((value) => Autoscaler.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? AutoscalerListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AutoscalerStatusDetails {
  /// The status message.
  core.String? message;

  /// The type of error, warning, or notice returned.
  ///
  /// Current set of possible values: - ALL_INSTANCES_UNHEALTHY (WARNING): All
  /// instances in the instance group are unhealthy (not in RUNNING state). -
  /// BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service
  /// attached to the instance group. - CAPPED_AT_MAX_NUM_REPLICAS (WARNING):
  /// Autoscaler recommends a size greater than maxNumReplicas. -
  /// CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples
  /// are not exported often enough to be a credible base for autoscaling. -
  /// CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does
  /// not exist or does not have the necessary labels. - MIN_EQUALS_MAX
  /// (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the
  /// autoscaler cannot add or remove instances from the instance group. -
  /// MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not
  /// receive any data from the custom metric configured for autoscaling. -
  /// MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured
  /// to scale based on a load balancing signal but the instance group has not
  /// received any requests from the load balancer. - MODE_OFF (WARNING):
  /// Autoscaling is turned off. The number of instances in the group won't
  /// change automatically. The autoscaling configuration is preserved. -
  /// MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode.
  /// The autoscaler can add instances but not remove any. -
  /// MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be
  /// autoscaled because it has more than one backend service attached to it. -
  /// NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the
  /// necessary resources, such as CPU or number of instances. -
  /// REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers:
  /// there is a resource stockout in the chosen region. -
  /// SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not
  /// exist. - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR):
  /// Autoscaling does not work with an HTTP/S load balancer that has been
  /// configured for maxRate. - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal
  /// autoscalers: there is a resource stockout in the chosen zone. For regional
  /// autoscalers: in at least one of the zones you're using there is a resource
  /// stockout. New values might be added in the future. Some of the values
  /// might not be available in all API versions.
  /// Possible string values are:
  /// - "ALL_INSTANCES_UNHEALTHY" : All instances in the instance group are
  /// unhealthy (not in RUNNING state).
  /// - "BACKEND_SERVICE_DOES_NOT_EXIST" : There is no backend service attached
  /// to the instance group.
  /// - "CAPPED_AT_MAX_NUM_REPLICAS" : Autoscaler recommends a size greater than
  /// maxNumReplicas.
  /// - "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE" : The custom metric samples are
  /// not exported often enough to be a credible base for autoscaling.
  /// - "CUSTOM_METRIC_INVALID" : The custom metric that was specified does not
  /// exist or does not have the necessary labels.
  /// - "MIN_EQUALS_MAX" : The minNumReplicas is equal to maxNumReplicas. This
  /// means the autoscaler cannot add or remove instances from the instance
  /// group.
  /// - "MISSING_CUSTOM_METRIC_DATA_POINTS" : The autoscaler did not receive any
  /// data from the custom metric configured for autoscaling.
  /// - "MISSING_LOAD_BALANCING_DATA_POINTS" : The autoscaler is configured to
  /// scale based on a load balancing signal but the instance group has not
  /// received any requests from the load balancer.
  /// - "MODE_OFF" : Autoscaling is turned off. The number of instances in the
  /// group won't change automatically. The autoscaling configuration is
  /// preserved.
  /// - "MODE_ONLY_SCALE_OUT" : Autoscaling is in the "Autoscale only scale out"
  /// mode. Instances in the group will be only added.
  /// - "MODE_ONLY_UP" : Autoscaling is in the "Autoscale only out" mode.
  /// Instances in the group will be only added.
  /// - "MORE_THAN_ONE_BACKEND_SERVICE" : The instance group cannot be
  /// autoscaled because it has more than one backend service attached to it.
  /// - "NOT_ENOUGH_QUOTA_AVAILABLE" : There is insufficient quota for the
  /// necessary resources, such as CPU or number of instances.
  /// - "REGION_RESOURCE_STOCKOUT" : Showed only for regional autoscalers: there
  /// is a resource stockout in the chosen region.
  /// - "SCALING_TARGET_DOES_NOT_EXIST" : The target to be scaled does not
  /// exist.
  /// - "SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX" : For some scaling
  /// schedules minRequiredReplicas is greater than maxNumReplicas. Autoscaler
  /// always recommends at most maxNumReplicas instances.
  /// - "SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN" : For some scaling
  /// schedules minRequiredReplicas is less than minNumReplicas. Autoscaler
  /// always recommends at least minNumReplicas instances.
  /// - "UNKNOWN"
  /// - "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION" : Autoscaling does
  /// not work with an HTTP/S load balancer that has been configured for
  /// maxRate.
  /// - "ZONE_RESOURCE_STOCKOUT" : For zonal autoscalers: there is a resource
  /// stockout in the chosen zone. For regional autoscalers: in at least one of
  /// the zones you're using there is a resource stockout.
  core.String? type;

  AutoscalerStatusDetails({
    this.message,
    this.type,
  });

  AutoscalerStatusDetails.fromJson(core.Map _json)
      : this(
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (message != null) 'message': message!,
        if (type != null) 'type': type!,
      };
}

class AutoscalersScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AutoscalersScopedListWarningData({
    this.key,
    this.value,
  });

  AutoscalersScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of autoscalers when the list
/// is empty.
///
/// Output only.
class AutoscalersScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AutoscalersScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AutoscalersScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  AutoscalersScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<AutoscalersScopedListWarningData>((value) =>
                      AutoscalersScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AutoscalersScopedList {
  /// A list of autoscalers contained in this scope.
  ///
  /// Output only.
  core.List<Autoscaler>? autoscalers;

  /// Informational warning which replaces the list of autoscalers when the list
  /// is empty.
  ///
  /// Output only.
  AutoscalersScopedListWarning? warning;

  AutoscalersScopedList({
    this.autoscalers,
    this.warning,
  });

  AutoscalersScopedList.fromJson(core.Map _json)
      : this(
          autoscalers: _json.containsKey('autoscalers')
              ? (_json['autoscalers'] as core.List)
                  .map<Autoscaler>((value) => Autoscaler.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? AutoscalersScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalers != null)
          'autoscalers': autoscalers!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Cloud Autoscaler policy.
class AutoscalingPolicy {
  /// The number of seconds that the autoscaler waits before it starts
  /// collecting information from a new instance.
  ///
  /// This prevents the autoscaler from collecting information when the instance
  /// is initializing, during which the collected usage would not be reliable.
  /// The default time autoscaler waits is 60 seconds. Virtual machine
  /// initialization times might vary because of numerous factors. We recommend
  /// that you test how long an instance may take to initialize. To do this,
  /// create an instance and time the startup process.
  core.int? coolDownPeriodSec;

  /// Defines the CPU utilization policy that allows the autoscaler to scale
  /// based on the average CPU utilization of a managed instance group.
  AutoscalingPolicyCpuUtilization? cpuUtilization;

  /// Configuration parameters of autoscaling based on a custom metric.
  core.List<AutoscalingPolicyCustomMetricUtilization>? customMetricUtilizations;

  /// Configuration parameters of autoscaling based on load balancer.
  AutoscalingPolicyLoadBalancingUtilization? loadBalancingUtilization;

  /// The maximum number of instances that the autoscaler can scale out to.
  ///
  /// This is required when creating or updating an autoscaler. The maximum
  /// number of replicas must not be lower than minimal number of replicas.
  core.int? maxNumReplicas;

  /// The minimum number of replicas that the autoscaler can scale in to.
  ///
  /// This cannot be less than 0. If not provided, autoscaler chooses a default
  /// value depending on maximum number of instances allowed.
  core.int? minNumReplicas;

  /// Defines operating mode for this policy.
  /// Possible string values are:
  /// - "OFF" : Do not automatically scale the MIG in or out. The
  /// recommended_size field contains the size of MIG that would be set if the
  /// actuation mode was enabled.
  /// - "ON" : Automatically scale the MIG in and out according to the policy.
  /// - "ONLY_SCALE_OUT" : Automatically create VMs according to the policy, but
  /// do not scale the MIG in.
  /// - "ONLY_UP" : Automatically create VMs according to the policy, but do not
  /// scale the MIG in.
  core.String? mode;
  AutoscalingPolicyScaleInControl? scaleInControl;

  /// Scaling schedules defined for an autoscaler.
  ///
  /// Multiple schedules can be set on an autoscaler, and they can overlap.
  /// During overlapping periods the greatest min_required_replicas of all
  /// scaling schedules is applied. Up to 128 scaling schedules are allowed.
  core.Map<core.String, AutoscalingPolicyScalingSchedule>? scalingSchedules;

  AutoscalingPolicy({
    this.coolDownPeriodSec,
    this.cpuUtilization,
    this.customMetricUtilizations,
    this.loadBalancingUtilization,
    this.maxNumReplicas,
    this.minNumReplicas,
    this.mode,
    this.scaleInControl,
    this.scalingSchedules,
  });

  AutoscalingPolicy.fromJson(core.Map _json)
      : this(
          coolDownPeriodSec: _json.containsKey('coolDownPeriodSec')
              ? _json['coolDownPeriodSec'] as core.int
              : null,
          cpuUtilization: _json.containsKey('cpuUtilization')
              ? AutoscalingPolicyCpuUtilization.fromJson(_json['cpuUtilization']
                  as core.Map<core.String, core.dynamic>)
              : null,
          customMetricUtilizations:
              _json.containsKey('customMetricUtilizations')
                  ? (_json['customMetricUtilizations'] as core.List)
                      .map<AutoscalingPolicyCustomMetricUtilization>((value) =>
                          AutoscalingPolicyCustomMetricUtilization.fromJson(
                              value as core.Map<core.String, core.dynamic>))
                      .toList()
                  : null,
          loadBalancingUtilization:
              _json.containsKey('loadBalancingUtilization')
                  ? AutoscalingPolicyLoadBalancingUtilization.fromJson(
                      _json['loadBalancingUtilization']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          maxNumReplicas: _json.containsKey('maxNumReplicas')
              ? _json['maxNumReplicas'] as core.int
              : null,
          minNumReplicas: _json.containsKey('minNumReplicas')
              ? _json['minNumReplicas'] as core.int
              : null,
          mode: _json.containsKey('mode') ? _json['mode'] as core.String : null,
          scaleInControl: _json.containsKey('scaleInControl')
              ? AutoscalingPolicyScaleInControl.fromJson(_json['scaleInControl']
                  as core.Map<core.String, core.dynamic>)
              : null,
          scalingSchedules: _json.containsKey('scalingSchedules')
              ? (_json['scalingSchedules']
                      as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    AutoscalingPolicyScalingSchedule.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (coolDownPeriodSec != null) 'coolDownPeriodSec': coolDownPeriodSec!,
        if (cpuUtilization != null) 'cpuUtilization': cpuUtilization!.toJson(),
        if (customMetricUtilizations != null)
          'customMetricUtilizations':
              customMetricUtilizations!.map((value) => value.toJson()).toList(),
        if (loadBalancingUtilization != null)
          'loadBalancingUtilization': loadBalancingUtilization!.toJson(),
        if (maxNumReplicas != null) 'maxNumReplicas': maxNumReplicas!,
        if (minNumReplicas != null) 'minNumReplicas': minNumReplicas!,
        if (mode != null) 'mode': mode!,
        if (scaleInControl != null) 'scaleInControl': scaleInControl!.toJson(),
        if (scalingSchedules != null)
          'scalingSchedules': scalingSchedules!
              .map((key, item) => core.MapEntry(key, item.toJson())),
      };
}

/// CPU utilization policy.
class AutoscalingPolicyCpuUtilization {
  /// Indicates whether predictive autoscaling based on CPU metric is enabled.
  ///
  /// Valid values are: * NONE (default). No predictive method is used. The
  /// autoscaler scales the group to meet current demand based on real-time
  /// metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves
  /// availability by monitoring daily and weekly load patterns and scaling out
  /// ahead of anticipated demand.
  /// Possible string values are:
  /// - "NONE" : No predictive method is used. The autoscaler scales the group
  /// to meet current demand based on real-time metrics
  /// - "OPTIMIZE_AVAILABILITY" : Predictive autoscaling improves availability
  /// by monitoring daily and weekly load patterns and scaling out ahead of
  /// anticipated demand.
  core.String? predictiveMethod;

  /// The target CPU utilization that the autoscaler maintains.
  ///
  /// Must be a float value in the range (0, 1\]. If not specified, the default
  /// is 0.6. If the CPU level is below the target utilization, the autoscaler
  /// scales in the number of instances until it reaches the minimum number of
  /// instances you specified or until the average CPU of your instances reaches
  /// the target utilization. If the average CPU is above the target
  /// utilization, the autoscaler scales out until it reaches the maximum number
  /// of instances you specified or until the average utilization reaches the
  /// target utilization.
  core.double? utilizationTarget;

  AutoscalingPolicyCpuUtilization({
    this.predictiveMethod,
    this.utilizationTarget,
  });

  AutoscalingPolicyCpuUtilization.fromJson(core.Map _json)
      : this(
          predictiveMethod: _json.containsKey('predictiveMethod')
              ? _json['predictiveMethod'] as core.String
              : null,
          utilizationTarget: _json.containsKey('utilizationTarget')
              ? (_json['utilizationTarget'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (predictiveMethod != null) 'predictiveMethod': predictiveMethod!,
        if (utilizationTarget != null) 'utilizationTarget': utilizationTarget!,
      };
}

/// Custom utilization metric policy.
class AutoscalingPolicyCustomMetricUtilization {
  /// A filter string, compatible with a Stackdriver Monitoring filter string
  /// for TimeSeries.list API call.
  ///
  /// This filter is used to select a specific TimeSeries for the purpose of
  /// autoscaling and to determine whether the metric is exporting per-instance
  /// or per-group data. For the filter to be valid for autoscaling purposes,
  /// the following rules apply: - You can only use the AND operator for joining
  /// selectors. - You can only use direct equality comparison operator (=)
  /// without any functions for each selector. - You can specify the metric in
  /// both the filter string and in the metric field. However, if specified in
  /// both places, the metric must be identical. - The monitored resource type
  /// determines what kind of values are expected for the metric. If it is a
  /// gce_instance, the autoscaler expects the metric to include a separate
  /// TimeSeries for each instance in a group. In such a case, you cannot filter
  /// on resource labels. If the resource type is any other value, the
  /// autoscaler expects this metric to contain values that apply to the entire
  /// autoscaled instance group and resource label filtering can be performed to
  /// point autoscaler at the correct TimeSeries to scale upon. This is called a
  /// *per-group metric* for the purpose of autoscaling. If not specified, the
  /// type defaults to gce_instance. Try to provide a filter that is selective
  /// enough to pick just one TimeSeries for the autoscaled group or for each of
  /// the instances (if you are using gce_instance resource type). If multiple
  /// TimeSeries are returned upon the query execution, the autoscaler will sum
  /// their respective values to obtain its scaling value.
  core.String? filter;

  /// The identifier (type) of the Stackdriver Monitoring metric.
  ///
  /// The metric cannot have negative values. The metric must have a value type
  /// of INT64 or DOUBLE.
  core.String? metric;

  /// If scaling is based on a per-group metric value that represents the total
  /// amount of work to be done or resource usage, set this value to an amount
  /// assigned for a single instance of the scaled group.
  ///
  /// Autoscaler keeps the number of instances proportional to the value of this
  /// metric. The metric itself does not change value due to group resizing. A
  /// good metric to use with the target is for example
  /// pubsub.googleapis.com/subscription/num_undelivered_messages or a custom
  /// metric exporting the total number of requests coming to your instances. A
  /// bad example would be a metric exporting an average or median latency,
  /// since this value can't include a chunk assignable to a single instance, it
  /// could be better used with utilization_target instead.
  core.double? singleInstanceAssignment;

  /// The target value of the metric that autoscaler maintains.
  ///
  /// This must be a positive value. A utilization metric scales number of
  /// virtual machines handling requests to increase or decrease proportionally
  /// to the metric. For example, a good metric to use as a utilization_target
  /// is
  /// https://www.googleapis.com/compute/v1/instance/network/received_bytes_count.
  /// The autoscaler works to keep this value constant for each of the
  /// instances.
  core.double? utilizationTarget;

  /// Defines how target utilization value is expressed for a Stackdriver
  /// Monitoring metric.
  ///
  /// Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
  /// Possible string values are:
  /// - "DELTA_PER_MINUTE" : Sets the utilization target value for a cumulative
  /// or delta metric, expressed as the rate of growth per minute.
  /// - "DELTA_PER_SECOND" : Sets the utilization target value for a cumulative
  /// or delta metric, expressed as the rate of growth per second.
  /// - "GAUGE" : Sets the utilization target value for a gauge metric. The
  /// autoscaler will collect the average utilization of the virtual machines
  /// from the last couple of minutes, and compare the value to the utilization
  /// target value to perform autoscaling.
  core.String? utilizationTargetType;

  AutoscalingPolicyCustomMetricUtilization({
    this.filter,
    this.metric,
    this.singleInstanceAssignment,
    this.utilizationTarget,
    this.utilizationTargetType,
  });

  AutoscalingPolicyCustomMetricUtilization.fromJson(core.Map _json)
      : this(
          filter: _json.containsKey('filter')
              ? _json['filter'] as core.String
              : null,
          metric: _json.containsKey('metric')
              ? _json['metric'] as core.String
              : null,
          singleInstanceAssignment:
              _json.containsKey('singleInstanceAssignment')
                  ? (_json['singleInstanceAssignment'] as core.num).toDouble()
                  : null,
          utilizationTarget: _json.containsKey('utilizationTarget')
              ? (_json['utilizationTarget'] as core.num).toDouble()
              : null,
          utilizationTargetType: _json.containsKey('utilizationTargetType')
              ? _json['utilizationTargetType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (metric != null) 'metric': metric!,
        if (singleInstanceAssignment != null)
          'singleInstanceAssignment': singleInstanceAssignment!,
        if (utilizationTarget != null) 'utilizationTarget': utilizationTarget!,
        if (utilizationTargetType != null)
          'utilizationTargetType': utilizationTargetType!,
      };
}

/// Configuration parameters of autoscaling based on load balancing.
class AutoscalingPolicyLoadBalancingUtilization {
  /// Fraction of backend capacity utilization (set in HTTP(S) load balancing
  /// configuration) that the autoscaler maintains.
  ///
  /// Must be a positive float value. If not defined, the default is 0.8.
  core.double? utilizationTarget;

  AutoscalingPolicyLoadBalancingUtilization({
    this.utilizationTarget,
  });

  AutoscalingPolicyLoadBalancingUtilization.fromJson(core.Map _json)
      : this(
          utilizationTarget: _json.containsKey('utilizationTarget')
              ? (_json['utilizationTarget'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (utilizationTarget != null) 'utilizationTarget': utilizationTarget!,
      };
}

/// Configuration that allows for slower scale in so that even if Autoscaler
/// recommends an abrupt scale in of a MIG, it will be throttled as specified by
/// the parameters below.
class AutoscalingPolicyScaleInControl {
  /// Maximum allowed number (or %) of VMs that can be deducted from the peak
  /// recommendation during the window autoscaler looks at when computing
  /// recommendations.
  ///
  /// Possibly all these VMs can be deleted at once so user service needs to be
  /// prepared to lose that many VMs in one step.
  FixedOrPercent? maxScaledInReplicas;

  /// How far back autoscaling looks when computing recommendations to include
  /// directives regarding slower scale in, as described above.
  core.int? timeWindowSec;

  AutoscalingPolicyScaleInControl({
    this.maxScaledInReplicas,
    this.timeWindowSec,
  });

  AutoscalingPolicyScaleInControl.fromJson(core.Map _json)
      : this(
          maxScaledInReplicas: _json.containsKey('maxScaledInReplicas')
              ? FixedOrPercent.fromJson(_json['maxScaledInReplicas']
                  as core.Map<core.String, core.dynamic>)
              : null,
          timeWindowSec: _json.containsKey('timeWindowSec')
              ? _json['timeWindowSec'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxScaledInReplicas != null)
          'maxScaledInReplicas': maxScaledInReplicas!.toJson(),
        if (timeWindowSec != null) 'timeWindowSec': timeWindowSec!,
      };
}

/// Scaling based on user-defined schedule.
///
/// The message describes a single scaling schedule. A scaling schedule changes
/// the minimum number of VM instances an autoscaler can recommend, which can
/// trigger scaling out.
class AutoscalingPolicyScalingSchedule {
  /// A description of a scaling schedule.
  core.String? description;

  /// A boolean value that specifies whether a scaling schedule can influence
  /// autoscaler recommendations.
  ///
  /// If set to true, then a scaling schedule has no effect. This field is
  /// optional, and its value is false by default.
  core.bool? disabled;

  /// The duration of time intervals, in seconds, for which this scaling
  /// schedule is to run.
  ///
  /// The minimum allowed value is 300. This field is required.
  core.int? durationSec;

  /// The minimum number of VM instances that the autoscaler will recommend in
  /// time intervals starting according to schedule.
  ///
  /// This field is required.
  core.int? minRequiredReplicas;

  /// The start timestamps of time intervals when this scaling schedule is to
  /// provide a scaling signal.
  ///
  /// This field uses the extended cron format (with an optional year field).
  /// The expression can describe a single timestamp if the optional year is
  /// set, in which case the scaling schedule runs once. The schedule is
  /// interpreted with respect to time_zone. This field is required. Note: These
  /// timestamps only describe when autoscaler starts providing the scaling
  /// signal. The VMs need additional time to become serving.
  core.String? schedule;

  /// The time zone to use when interpreting the schedule.
  ///
  /// The value of this field must be a time zone name from the tz database:
  /// http://en.wikipedia.org/wiki/Tz_database. This field is assigned a default
  /// value of “UTC” if left empty.
  core.String? timeZone;

  AutoscalingPolicyScalingSchedule({
    this.description,
    this.disabled,
    this.durationSec,
    this.minRequiredReplicas,
    this.schedule,
    this.timeZone,
  });

  AutoscalingPolicyScalingSchedule.fromJson(core.Map _json)
      : this(
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          disabled: _json.containsKey('disabled')
              ? _json['disabled'] as core.bool
              : null,
          durationSec: _json.containsKey('durationSec')
              ? _json['durationSec'] as core.int
              : null,
          minRequiredReplicas: _json.containsKey('minRequiredReplicas')
              ? _json['minRequiredReplicas'] as core.int
              : null,
          schedule: _json.containsKey('schedule')
              ? _json['schedule'] as core.String
              : null,
          timeZone: _json.containsKey('timeZone')
              ? _json['timeZone'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (disabled != null) 'disabled': disabled!,
        if (durationSec != null) 'durationSec': durationSec!,
        if (minRequiredReplicas != null)
          'minRequiredReplicas': minRequiredReplicas!,
        if (schedule != null) 'schedule': schedule!,
        if (timeZone != null) 'timeZone': timeZone!,
      };
}

/// Message containing information of one individual backend.
class Backend {
  /// Specifies how to determine whether the backend of a load balancer can
  /// handle additional traffic or is fully loaded.
  ///
  /// For usage guidelines, see Connection balancing mode. Backends must use
  /// compatible balancing modes. For more information, see Supported balancing
  /// modes and target capacity settings and Restrictions and guidance for
  /// instance groups. Note: Currently, if you use the API to configure
  /// incompatible balancing modes, the configuration might be accepted even
  /// though it has no impact and is ignored. Specifically,
  /// Backend.maxUtilization is ignored when Backend.balancingMode is RATE. In
  /// the future, this incompatible combination will be rejected.
  /// Possible string values are:
  /// - "CONNECTION" : Balance based on the number of simultaneous connections.
  /// - "RATE" : Balance based on requests per second (RPS).
  /// - "UTILIZATION" : Balance based on the backend utilization.
  core.String? balancingMode;

  /// A multiplier applied to the backend's target capacity of its balancing
  /// mode.
  ///
  /// The default value is 1, which means the group serves up to 100% of its
  /// configured capacity (depending on balancingMode). A setting of 0 means the
  /// group is completely drained, offering 0% of its available capacity. The
  /// valid ranges are 0.0 and \[0.1,1.0\]. You cannot configure a setting
  /// larger than 0 and smaller than 0.1. You cannot configure a setting of 0
  /// when there is only one backend attached to the backend service.
  core.double? capacityScaler;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// This field designates whether this is a failover backend.
  ///
  /// More than one failover backend can be configured for a given
  /// BackendService.
  core.bool? failover;

  /// The fully-qualified URL of an instance group or network endpoint group
  /// (NEG) resource.
  ///
  /// To determine what types of backends a load balancer supports, see the
  /// [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service#backends).
  /// You must use the *fully-qualified* URL (starting with
  /// https://www.googleapis.com/) to specify the instance group or NEG. Partial
  /// URLs are not supported.
  core.String? group;

  /// Defines a target maximum number of simultaneous connections.
  ///
  /// For usage guidelines, see Connection balancing mode and Utilization
  /// balancing mode. Not available if the backend's balancingMode is RATE.
  core.int? maxConnections;

  /// Defines a target maximum number of simultaneous connections.
  ///
  /// For usage guidelines, see Connection balancing mode and Utilization
  /// balancing mode. Not available if the backend's balancingMode is RATE.
  core.int? maxConnectionsPerEndpoint;

  /// Defines a target maximum number of simultaneous connections.
  ///
  /// For usage guidelines, see Connection balancing mode and Utilization
  /// balancing mode. Not available if the backend's balancingMode is RATE.
  core.int? maxConnectionsPerInstance;

  /// Defines a maximum number of HTTP requests per second (RPS).
  ///
  /// For usage guidelines, see Rate balancing mode and Utilization balancing
  /// mode. Not available if the backend's balancingMode is CONNECTION.
  core.int? maxRate;

  /// Defines a maximum target for requests per second (RPS).
  ///
  /// For usage guidelines, see Rate balancing mode and Utilization balancing
  /// mode. Not available if the backend's balancingMode is CONNECTION.
  core.double? maxRatePerEndpoint;

  /// Defines a maximum target for requests per second (RPS).
  ///
  /// For usage guidelines, see Rate balancing mode and Utilization balancing
  /// mode. Not available if the backend's balancingMode is CONNECTION.
  core.double? maxRatePerInstance;

  /// Optional parameter to define a target capacity for the
  /// UTILIZATIONbalancing mode.
  ///
  /// The valid range is \[0.0, 1.0\]. For usage guidelines, see Utilization
  /// balancing mode.
  core.double? maxUtilization;

  Backend({
    this.balancingMode,
    this.capacityScaler,
    this.description,
    this.failover,
    this.group,
    this.maxConnections,
    this.maxConnectionsPerEndpoint,
    this.maxConnectionsPerInstance,
    this.maxRate,
    this.maxRatePerEndpoint,
    this.maxRatePerInstance,
    this.maxUtilization,
  });

  Backend.fromJson(core.Map _json)
      : this(
          balancingMode: _json.containsKey('balancingMode')
              ? _json['balancingMode'] as core.String
              : null,
          capacityScaler: _json.containsKey('capacityScaler')
              ? (_json['capacityScaler'] as core.num).toDouble()
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          failover: _json.containsKey('failover')
              ? _json['failover'] as core.bool
              : null,
          group:
              _json.containsKey('group') ? _json['group'] as core.String : null,
          maxConnections: _json.containsKey('maxConnections')
              ? _json['maxConnections'] as core.int
              : null,
          maxConnectionsPerEndpoint:
              _json.containsKey('maxConnectionsPerEndpoint')
                  ? _json['maxConnectionsPerEndpoint'] as core.int
                  : null,
          maxConnectionsPerInstance:
              _json.containsKey('maxConnectionsPerInstance')
                  ? _json['maxConnectionsPerInstance'] as core.int
                  : null,
          maxRate: _json.containsKey('maxRate')
              ? _json['maxRate'] as core.int
              : null,
          maxRatePerEndpoint: _json.containsKey('maxRatePerEndpoint')
              ? (_json['maxRatePerEndpoint'] as core.num).toDouble()
              : null,
          maxRatePerInstance: _json.containsKey('maxRatePerInstance')
              ? (_json['maxRatePerInstance'] as core.num).toDouble()
              : null,
          maxUtilization: _json.containsKey('maxUtilization')
              ? (_json['maxUtilization'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (balancingMode != null) 'balancingMode': balancingMode!,
        if (capacityScaler != null) 'capacityScaler': capacityScaler!,
        if (description != null) 'description': description!,
        if (failover != null) 'failover': failover!,
        if (group != null) 'group': group!,
        if (maxConnections != null) 'maxConnections': maxConnections!,
        if (maxConnectionsPerEndpoint != null)
          'maxConnectionsPerEndpoint': maxConnectionsPerEndpoint!,
        if (maxConnectionsPerInstance != null)
          'maxConnectionsPerInstance': maxConnectionsPerInstance!,
        if (maxRate != null) 'maxRate': maxRate!,
        if (maxRatePerEndpoint != null)
          'maxRatePerEndpoint': maxRatePerEndpoint!,
        if (maxRatePerInstance != null)
          'maxRatePerInstance': maxRatePerInstance!,
        if (maxUtilization != null) 'maxUtilization': maxUtilization!,
      };
}

/// Represents a Cloud Storage Bucket resource.
///
/// This Cloud Storage bucket resource is referenced by a URL map of a load
/// balancer. For more information, read Backend Buckets.
class BackendBucket {
  /// Cloud Storage bucket name.
  core.String? bucketName;

  /// Cloud CDN configuration for this BackendBucket.
  BackendBucketCdnPolicy? cdnPolicy;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Headers that the HTTP/S load balancer should add to proxied responses.
  core.List<core.String>? customResponseHeaders;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String? description;

  /// If true, enable Cloud CDN for this BackendBucket.
  core.bool? enableCdn;

  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  BackendBucket({
    this.bucketName,
    this.cdnPolicy,
    this.creationTimestamp,
    this.customResponseHeaders,
    this.description,
    this.enableCdn,
    this.id,
    this.kind,
    this.name,
    this.selfLink,
  });

  BackendBucket.fromJson(core.Map _json)
      : this(
          bucketName: _json.containsKey('bucketName')
              ? _json['bucketName'] as core.String
              : null,
          cdnPolicy: _json.containsKey('cdnPolicy')
              ? BackendBucketCdnPolicy.fromJson(
                  _json['cdnPolicy'] as core.Map<core.String, core.dynamic>)
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          customResponseHeaders: _json.containsKey('customResponseHeaders')
              ? (_json['customResponseHeaders'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          enableCdn: _json.containsKey('enableCdn')
              ? _json['enableCdn'] as core.bool
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bucketName != null) 'bucketName': bucketName!,
        if (cdnPolicy != null) 'cdnPolicy': cdnPolicy!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customResponseHeaders != null)
          'customResponseHeaders': customResponseHeaders!,
        if (description != null) 'description': description!,
        if (enableCdn != null) 'enableCdn': enableCdn!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Message containing Cloud CDN configuration for a backend bucket.
class BackendBucketCdnPolicy {
  /// Bypass the cache when the specified request headers are matched - e.g.
  /// Pragma or Authorization headers.
  ///
  /// Up to 5 headers can be specified. The cache is bypassed for all
  /// cdnPolicy.cacheMode settings.
  core.List<BackendBucketCdnPolicyBypassCacheOnRequestHeader>?
      bypassCacheOnRequestHeaders;

  /// Specifies the cache setting for all responses from this backend.
  ///
  /// The possible values are: USE_ORIGIN_HEADERS Requires the origin to set
  /// valid caching headers to cache content. Responses without these headers
  /// will not be cached at Google's edge, and will require a full trip to the
  /// origin on every request, potentially impacting performance and increasing
  /// load on the origin server. FORCE_CACHE_ALL Cache all content, ignoring any
  /// "private", "no-store" or "no-cache" directives in Cache-Control response
  /// headers. Warning: this may result in Cloud CDN caching private, per-user
  /// (user identifiable) content. CACHE_ALL_STATIC Automatically cache static
  /// content, including common image formats, media (video and audio), and web
  /// assets (JavaScript and CSS). Requests and responses that are marked as
  /// uncacheable, as well as dynamic content (including HTML), will not be
  /// cached.
  /// Possible string values are:
  /// - "CACHE_ALL_STATIC" : Automatically cache static content, including
  /// common image formats, media (video and audio), and web assets (JavaScript
  /// and CSS). Requests and responses that are marked as uncacheable, as well
  /// as dynamic content (including HTML), will not be cached.
  /// - "FORCE_CACHE_ALL" : Cache all content, ignoring any "private",
  /// "no-store" or "no-cache" directives in Cache-Control response headers.
  /// Warning: this may result in Cloud CDN caching private, per-user (user
  /// identifiable) content.
  /// - "INVALID_CACHE_MODE"
  /// - "USE_ORIGIN_HEADERS" : Requires the origin to set valid caching headers
  /// to cache content. Responses without these headers will not be cached at
  /// Google's edge, and will require a full trip to the origin on every
  /// request, potentially impacting performance and increasing load on the
  /// origin server.
  core.String? cacheMode;

  /// Specifies a separate client (e.g. browser client) maximum TTL.
  ///
  /// This is used to clamp the max-age (or Expires) value sent to the client.
  /// With FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for
  /// the response max-age directive, along with a "public" directive. For
  /// cacheable content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age
  /// from the origin (if specified), or else sets the response max-age
  /// directive to the lesser of the client_ttl and default_ttl, and also
  /// ensures a "public" cache-control directive is present. If a client TTL is
  /// not specified, a default value (1 hour) will be used. The maximum allowed
  /// value is 86400s (1 day).
  core.int? clientTtl;

  /// Specifies the default TTL for cached content served by this origin for
  /// responses that do not have an existing valid TTL (max-age or s-max-age).
  ///
  /// Setting a TTL of "0" means "always revalidate". The value of defaultTTL
  /// cannot be set to a value greater than that of maxTTL, but can be equal.
  /// When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will
  /// overwrite the TTL set in all responses. The maximum allowed value is
  /// 31,622,400s (1 year), noting that infrequently accessed objects may be
  /// evicted from the cache before the defined TTL.
  core.int? defaultTtl;

  /// Specifies the maximum allowed TTL for cached content served by this
  /// origin.
  ///
  /// Cache directives that attempt to set a max-age or s-maxage higher than
  /// this, or an Expires header more than maxTTL seconds in the future will be
  /// capped at the value of maxTTL, as if it were the value of an s-maxage
  /// Cache-Control directive. Headers sent to the client will not be modified.
  /// Setting a TTL of "0" means "always revalidate". The maximum allowed value
  /// is 31,622,400s (1 year), noting that infrequently accessed objects may be
  /// evicted from the cache before the defined TTL.
  core.int? maxTtl;

  /// Negative caching allows per-status code TTLs to be set, in order to apply
  /// fine-grained caching for common errors or redirects.
  ///
  /// This can reduce the load on your origin and improve end-user experience by
  /// reducing response latency. When the cache mode is set to CACHE_ALL_STATIC
  /// or USE_ORIGIN_HEADERS, negative caching applies to responses with the
  /// specified response code that lack any Cache-Control, Expires, or Pragma:
  /// no-cache directives. When the cache mode is set to FORCE_CACHE_ALL,
  /// negative caching applies to all responses with the specified response
  /// code, and override any caching headers. By default, Cloud CDN will apply
  /// the following default TTLs to these status codes: HTTP 300 (Multiple
  /// Choice), 301, 308 (Permanent Redirects): 10m HTTP 404 (Not Found), 410
  /// (Gone), 451 (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not
  /// Found), 421 (Misdirected Request), 501 (Not Implemented): 60s. These
  /// defaults can be overridden in negative_caching_policy.
  core.bool? negativeCaching;

  /// Sets a cache TTL for the specified HTTP status code.
  ///
  /// negative_caching must be enabled to configure negative_caching_policy.
  /// Omitting the policy and leaving negative_caching enabled will use Cloud
  /// CDN's default cache TTLs. Note that when specifying an explicit
  /// negative_caching_policy, you should take care to specify a cache TTL for
  /// all response codes that you wish to cache. Cloud CDN will not apply any
  /// default negative caching when a policy exists.
  core.List<BackendBucketCdnPolicyNegativeCachingPolicy>? negativeCachingPolicy;

  /// If true then Cloud CDN will combine multiple concurrent cache fill
  /// requests into a small number of requests to the origin.
  core.bool? requestCoalescing;

  /// Serve existing content from the cache (if available) when revalidating
  /// content with the origin, or when an error is encountered when refreshing
  /// the cache.
  ///
  /// This setting defines the default "max-stale" duration for any cached
  /// responses that do not specify a max-stale directive. Stale responses that
  /// exceed the TTL configured here will not be served. The default limit
  /// (max-stale) is 86400s (1 day), which will allow stale content to be served
  /// up to this limit beyond the max-age (or s-max-age) of a cached response.
  /// The maximum allowed value is 604800 (1 week). Set this to zero (0) to
  /// disable serve-while-stale.
  core.int? serveWhileStale;

  /// Maximum number of seconds the response to a signed URL request will be
  /// considered fresh.
  ///
  /// After this time period, the response will be revalidated before being
  /// served. Defaults to 1hr (3600s). When serving responses to signed URL
  /// requests, Cloud CDN will internally behave as though all responses from
  /// this backend had a "Cache-Control: public, max-age=\[TTL\]" header,
  /// regardless of any existing Cache-Control header. The actual headers served
  /// in responses will not be altered.
  core.String? signedUrlCacheMaxAgeSec;

  /// Names of the keys for signing request URLs.
  ///
  /// Output only.
  core.List<core.String>? signedUrlKeyNames;

  BackendBucketCdnPolicy({
    this.bypassCacheOnRequestHeaders,
    this.cacheMode,
    this.clientTtl,
    this.defaultTtl,
    this.maxTtl,
    this.negativeCaching,
    this.negativeCachingPolicy,
    this.requestCoalescing,
    this.serveWhileStale,
    this.signedUrlCacheMaxAgeSec,
    this.signedUrlKeyNames,
  });

  BackendBucketCdnPolicy.fromJson(core.Map _json)
      : this(
          bypassCacheOnRequestHeaders: _json
                  .containsKey('bypassCacheOnRequestHeaders')
              ? (_json['bypassCacheOnRequestHeaders'] as core.List)
                  .map<BackendBucketCdnPolicyBypassCacheOnRequestHeader>(
                      (value) =>
                          BackendBucketCdnPolicyBypassCacheOnRequestHeader
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          cacheMode: _json.containsKey('cacheMode')
              ? _json['cacheMode'] as core.String
              : null,
          clientTtl: _json.containsKey('clientTtl')
              ? _json['clientTtl'] as core.int
              : null,
          defaultTtl: _json.containsKey('defaultTtl')
              ? _json['defaultTtl'] as core.int
              : null,
          maxTtl:
              _json.containsKey('maxTtl') ? _json['maxTtl'] as core.int : null,
          negativeCaching: _json.containsKey('negativeCaching')
              ? _json['negativeCaching'] as core.bool
              : null,
          negativeCachingPolicy: _json.containsKey('negativeCachingPolicy')
              ? (_json['negativeCachingPolicy'] as core.List)
                  .map<BackendBucketCdnPolicyNegativeCachingPolicy>((value) =>
                      BackendBucketCdnPolicyNegativeCachingPolicy.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          requestCoalescing: _json.containsKey('requestCoalescing')
              ? _json['requestCoalescing'] as core.bool
              : null,
          serveWhileStale: _json.containsKey('serveWhileStale')
              ? _json['serveWhileStale'] as core.int
              : null,
          signedUrlCacheMaxAgeSec: _json.containsKey('signedUrlCacheMaxAgeSec')
              ? _json['signedUrlCacheMaxAgeSec'] as core.String
              : null,
          signedUrlKeyNames: _json.containsKey('signedUrlKeyNames')
              ? (_json['signedUrlKeyNames'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bypassCacheOnRequestHeaders != null)
          'bypassCacheOnRequestHeaders': bypassCacheOnRequestHeaders!
              .map((value) => value.toJson())
              .toList(),
        if (cacheMode != null) 'cacheMode': cacheMode!,
        if (clientTtl != null) 'clientTtl': clientTtl!,
        if (defaultTtl != null) 'defaultTtl': defaultTtl!,
        if (maxTtl != null) 'maxTtl': maxTtl!,
        if (negativeCaching != null) 'negativeCaching': negativeCaching!,
        if (negativeCachingPolicy != null)
          'negativeCachingPolicy':
              negativeCachingPolicy!.map((value) => value.toJson()).toList(),
        if (requestCoalescing != null) 'requestCoalescing': requestCoalescing!,
        if (serveWhileStale != null) 'serveWhileStale': serveWhileStale!,
        if (signedUrlCacheMaxAgeSec != null)
          'signedUrlCacheMaxAgeSec': signedUrlCacheMaxAgeSec!,
        if (signedUrlKeyNames != null) 'signedUrlKeyNames': signedUrlKeyNames!,
      };
}

/// Bypass the cache when the specified request headers are present, e.g. Pragma
/// or Authorization headers.
///
/// Values are case insensitive. The presence of such a header overrides the
/// cache_mode setting.
class BackendBucketCdnPolicyBypassCacheOnRequestHeader {
  /// The header field name to match on when bypassing cache.
  ///
  /// Values are case-insensitive.
  core.String? headerName;

  BackendBucketCdnPolicyBypassCacheOnRequestHeader({
    this.headerName,
  });

  BackendBucketCdnPolicyBypassCacheOnRequestHeader.fromJson(core.Map _json)
      : this(
          headerName: _json.containsKey('headerName')
              ? _json['headerName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (headerName != null) 'headerName': headerName!,
      };
}

/// Specify CDN TTLs for response error codes.
class BackendBucketCdnPolicyNegativeCachingPolicy {
  /// The HTTP status code to define a TTL against.
  ///
  /// Only HTTP status codes 300, 301, 302, 307, 308, 404, 405, 410, 421, 451
  /// and 501 are can be specified as values, and you cannot specify a status
  /// code more than once.
  core.int? code;

  /// The TTL (in seconds) for which to cache responses with the corresponding
  /// status code.
  ///
  /// The maximum allowed value is 1800s (30 minutes), noting that infrequently
  /// accessed objects may be evicted from the cache before the defined TTL.
  core.int? ttl;

  BackendBucketCdnPolicyNegativeCachingPolicy({
    this.code,
    this.ttl,
  });

  BackendBucketCdnPolicyNegativeCachingPolicy.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.int : null,
          ttl: _json.containsKey('ttl') ? _json['ttl'] as core.int : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (ttl != null) 'ttl': ttl!,
      };
}

class BackendBucketListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  BackendBucketListWarningData({
    this.key,
    this.value,
  });

  BackendBucketListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class BackendBucketListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<BackendBucketListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  BackendBucketListWarning({
    this.code,
    this.data,
    this.message,
  });

  BackendBucketListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<BackendBucketListWarningData>((value) =>
                      BackendBucketListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of BackendBucket resources.
class BackendBucketList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of BackendBucket resources.
  core.List<BackendBucket>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  BackendBucketListWarning? warning;

  BackendBucketList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  BackendBucketList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<BackendBucket>((value) => BackendBucket.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? BackendBucketListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Backend Service resource.
///
/// A backend service defines how Google Cloud load balancers distribute
/// traffic. The backend service configuration contains a set of values, such as
/// the protocol used to connect to backends, various distribution and session
/// settings, health checks, and timeouts. These settings provide fine-grained
/// control over how your load balancer behaves. Most of the settings have
/// default values that allow for easy configuration if you need to get started
/// quickly. Backend services in Google Compute Engine can be either regionally
/// or globally scoped. *
/// [Global](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices)
/// *
/// [Regional](https://cloud.google.com/compute/docs/reference/rest/v1/regionBackendServices)
/// For more information, see Backend Services.
class BackendService {
  /// Lifetime of cookies in seconds.
  ///
  /// This setting is applicable to external and internal HTTP(S) load balancers
  /// and Traffic Director and requires GENERATED_COOKIE or HTTP_COOKIE session
  /// affinity. If set to 0, the cookie is non-persistent and lasts only until
  /// the end of the browser session (or equivalent). The maximum allowed value
  /// is one day (86,400). Not supported when the backend service is referenced
  /// by a URL map that is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  core.int? affinityCookieTtlSec;

  /// The list of backends that serve this BackendService.
  core.List<Backend>? backends;

  /// Cloud CDN configuration for this BackendService.
  ///
  /// Only available for specified load balancer types.
  BackendServiceCdnPolicy? cdnPolicy;
  CircuitBreakers? circuitBreakers;
  ConnectionDraining? connectionDraining;

  /// Consistent Hash-based load balancing can be used to provide soft session
  /// affinity based on HTTP headers, cookies or other properties.
  ///
  /// This load balancing policy is applicable only for HTTP connections. The
  /// affinity to a particular destination host will be lost when one or more
  /// hosts are added/removed from the destination service. This field specifies
  /// parameters that control consistent hashing. This field is only applicable
  /// when localityLbPolicy is set to MAGLEV or RING_HASH. This field is
  /// applicable to either: - A regional backend service with the
  /// service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme
  /// set to INTERNAL_MANAGED. - A global backend service with the
  /// load_balancing_scheme set to INTERNAL_SELF_MANAGED. Not supported when the
  /// backend service is referenced by a URL map that is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  ConsistentHashLoadBalancerSettings? consistentHash;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Headers that the load balancer adds to proxied requests.
  ///
  /// See
  /// [Creating custom headers](https://cloud.google.com/load-balancing/docs/custom-headers).
  core.List<core.String>? customRequestHeaders;

  /// Headers that the load balancer adds to proxied responses.
  ///
  /// See
  /// [Creating custom headers](https://cloud.google.com/load-balancing/docs/custom-headers).
  core.List<core.String>? customResponseHeaders;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// If true, enables Cloud CDN for the backend service of an external HTTP(S)
  /// load balancer.
  core.bool? enableCDN;

  /// Requires at least one backend instance group to be defined as a backup
  /// (failover) backend.
  ///
  /// For load balancers that have configurable failover:
  /// [Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
  /// and \[external TCP/UDP Load
  /// Balancing\](/network/networklb-failover-overview).
  BackendServiceFailoverPolicy? failoverPolicy;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// BackendService. An up-to-date fingerprint must be provided in order to
  /// update the BackendService, otherwise the request will fail with error 412
  /// conditionNotMet. To see the latest fingerprint, make a get() request to
  /// retrieve a BackendService.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of URLs to the healthChecks, httpHealthChecks (legacy), or
  /// httpsHealthChecks (legacy) resource for health checking this backend
  /// service.
  ///
  /// Not all backend services support legacy health checks. See Load balancer
  /// guide. Currently, at most one health check can be specified for each
  /// backend service. Backend services with instance group or zonal NEG
  /// backends must have a health check. Backend services with internet or
  /// serverless NEG backends must not have a health check.
  core.List<core.String>? healthChecks;

  /// The configurations for Identity-Aware Proxy on this resource.
  ///
  /// Not available for Internal TCP/UDP Load Balancing and Network Load
  /// Balancing.
  BackendServiceIAP? iap;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#backendService for backend services.
  ///
  /// Output only.
  core.String? kind;

  /// Specifies the load balancer type.
  ///
  /// A backend service created for one type of load balancer cannot be used
  /// with another. For more information, refer to Choosing a load balancer.
  /// Possible string values are:
  /// - "EXTERNAL" : Signifies that this will be used for external HTTP(S), SSL
  /// Proxy, TCP Proxy, or Network Load Balancing
  /// - "INTERNAL" : Signifies that this will be used for Internal TCP/UDP Load
  /// Balancing.
  /// - "INTERNAL_MANAGED" : Signifies that this will be used for Internal
  /// HTTP(S) Load Balancing.
  /// - "INTERNAL_SELF_MANAGED" : Signifies that this will be used by Traffic
  /// Director.
  /// - "INVALID_LOAD_BALANCING_SCHEME"
  core.String? loadBalancingScheme;

  /// The load balancing algorithm used within the scope of the locality.
  ///
  /// The possible values are: - ROUND_ROBIN: This is a simple policy in which
  /// each healthy backend is selected in round robin order. This is the
  /// default. - LEAST_REQUEST: An O(1) algorithm which selects two random
  /// healthy hosts and picks the host which has fewer active requests. -
  /// RING_HASH: The ring/modulo hash load balancer implements consistent
  /// hashing to backends. The algorithm has the property that the
  /// addition/removal of a host from a set of N hosts only affects 1/N of the
  /// requests. - RANDOM: The load balancer selects a random healthy host. -
  /// ORIGINAL_DESTINATION: Backend host is selected based on the client
  /// connection metadata, i.e., connections are opened to the same address as
  /// the destination address of the incoming connection before the connection
  /// was redirected to the load balancer. - MAGLEV: used as a drop in
  /// replacement for the ring hash load balancer. Maglev is not as stable as
  /// ring hash but has faster table lookup build times and host selection
  /// times. For more information about Maglev, see
  /// https://ai.google/research/pubs/pub44824 This field is applicable to
  /// either: - A regional backend service with the service_protocol set to
  /// HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED. If sessionAffinity is not NONE, and this field is
  /// not set to MAGLEV or RING_HASH, session affinity settings will not take
  /// effect. Only the default ROUND_ROBIN policy is supported when the backend
  /// service is referenced by a URL map that is bound to target gRPC proxy that
  /// has validateForProxyless field set to true.
  /// Possible string values are:
  /// - "INVALID_LB_POLICY"
  /// - "LEAST_REQUEST" : An O(1) algorithm which selects two random healthy
  /// hosts and picks the host which has fewer active requests.
  /// - "MAGLEV" : This algorithm implements consistent hashing to backends.
  /// Maglev can be used as a drop in replacement for the ring hash load
  /// balancer. Maglev is not as stable as ring hash but has faster table lookup
  /// build times and host selection times. For more information about Maglev,
  /// see https://ai.google/research/pubs/pub44824
  /// - "ORIGINAL_DESTINATION" : Backend host is selected based on the client
  /// connection metadata, i.e., connections are opened to the same address as
  /// the destination address of the incoming connection before the connection
  /// was redirected to the load balancer.
  /// - "RANDOM" : The load balancer selects a random healthy host.
  /// - "RING_HASH" : The ring/modulo hash load balancer implements consistent
  /// hashing to backends. The algorithm has the property that the
  /// addition/removal of a host from a set of N hosts only affects 1/N of the
  /// requests.
  /// - "ROUND_ROBIN" : This is a simple policy in which each healthy backend is
  /// selected in round robin order. This is the default.
  core.String? localityLbPolicy;

  /// This field denotes the logging options for the load balancer traffic
  /// served by this backend service.
  ///
  /// If logging is enabled, logs will be exported to Stackdriver.
  BackendServiceLogConfig? logConfig;

  /// Specifies the default maximum duration (timeout) for streams to this
  /// service.
  ///
  /// Duration is computed from the beginning of the stream until the response
  /// has been completely processed, including all retries. A stream that does
  /// not complete in this duration is closed. If not specified, there will be
  /// no timeout limit, i.e. the maximum duration is infinite. This value can be
  /// overridden in the PathMatcher configuration of the UrlMap that references
  /// this backend service. This field is only allowed when the
  /// loadBalancingScheme of the backend service is INTERNAL_SELF_MANAGED.
  Duration? maxStreamDuration;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The URL of the network to which this backend service belongs.
  ///
  /// This field can only be specified when the load balancing scheme is set to
  /// INTERNAL.
  core.String? network;

  /// Settings controlling the eviction of unhealthy hosts from the load
  /// balancing pool for the backend service.
  ///
  /// If not set, this feature is considered disabled. This field is applicable
  /// to either: - A regional backend service with the service_protocol set to
  /// HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED. Not supported when the backend service is
  /// referenced by a URL map that is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  OutlierDetection? outlierDetection;

  /// Deprecated in favor of portName.
  ///
  /// The TCP port to connect on the backend. The default value is 80. For
  /// Internal TCP/UDP Load Balancing and Network Load Balancing, omit port.
  core.int? port;

  /// A named port on a backend instance group representing the port for
  /// communication to the backend VMs in that group.
  ///
  /// The named port must be
  /// [defined on each backend instance group](https://cloud.google.com/load-balancing/docs/backend-service#named_ports).
  /// This parameter has no meaning if the backends are NEGs. For Internal
  /// TCP/UDP Load Balancing and Network Load Balancing, omit port_name.
  core.String? portName;

  /// The protocol this BackendService uses to communicate with backends.
  ///
  /// Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending
  /// on the chosen load balancer or Traffic Director configuration. Refer to
  /// the documentation for the load balancers or for Traffic Director for more
  /// information. Must be set to GRPC when the backend service is referenced by
  /// a URL map that is bound to target gRPC proxy.
  /// Possible string values are:
  /// - "GRPC" : gRPC (available for Traffic Director).
  /// - "HTTP"
  /// - "HTTP2" : HTTP/2 with SSL.
  /// - "HTTPS"
  /// - "SSL" : TCP proxying with SSL.
  /// - "TCP" : TCP proxying or TCP pass-through.
  /// - "UDP" : UDP.
  core.String? protocol;

  /// URL of the region where the regional backend service resides.
  ///
  /// This field is not applicable to global backend services. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  ///
  /// Output only.
  core.String? region;

  /// The resource URL for the security policy associated with this backend
  /// service.
  ///
  /// Output only.
  core.String? securityPolicy;

  /// This field specifies the security policy that applies to this backend
  /// service.
  ///
  /// This field is applicable to either: - A regional backend service with the
  /// service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme
  /// set to INTERNAL_MANAGED. - A global backend service with the
  /// load_balancing_scheme set to INTERNAL_SELF_MANAGED.
  SecuritySettings? securitySettings;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Type of session affinity to use.
  ///
  /// The default is NONE. For a detailed description of session affinity
  /// options, see:
  /// [Session affinity](https://cloud.google.com/load-balancing/docs/backend-service#session_affinity).
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  /// Possible string values are:
  /// - "CLIENT_IP" : 2-tuple hash on packet's source and destination IP
  /// addresses. Connections from the same source IP address to the same
  /// destination IP address will be served by the same backend VM while that VM
  /// remains healthy.
  /// - "CLIENT_IP_NO_DESTINATION" : 1-tuple hash only on packet's source IP
  /// address. Connections from the same source IP address will be served by the
  /// same backend VM while that VM remains healthy. This option can only be
  /// used for Internal TCP/UDP Load Balancing.
  /// - "CLIENT_IP_PORT_PROTO" : 5-tuple hash on packet's source and destination
  /// IP addresses, IP protocol, and source and destination ports. Connections
  /// for the same IP protocol from the same source IP address and port to the
  /// same destination IP address and port will be served by the same backend VM
  /// while that VM remains healthy. This option cannot be used for HTTP(S) load
  /// balancing.
  /// - "CLIENT_IP_PROTO" : 3-tuple hash on packet's source and destination IP
  /// addresses, and IP protocol. Connections for the same IP protocol from the
  /// same source IP address to the same destination IP address will be served
  /// by the same backend VM while that VM remains healthy. This option cannot
  /// be used for HTTP(S) load balancing.
  /// - "GENERATED_COOKIE" : Hash based on a cookie generated by the L7
  /// loadbalancer. Only valid for HTTP(S) load balancing.
  /// - "HEADER_FIELD" : The hash is based on a user specified header field.
  /// - "HTTP_COOKIE" : The hash is based on a user provided cookie.
  /// - "NONE" : No session affinity. Connections from the same client IP may go
  /// to any instance in the pool.
  core.String? sessionAffinity;

  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  ///
  /// Instead, use maxStreamDuration.
  core.int? timeoutSec;

  BackendService({
    this.affinityCookieTtlSec,
    this.backends,
    this.cdnPolicy,
    this.circuitBreakers,
    this.connectionDraining,
    this.consistentHash,
    this.creationTimestamp,
    this.customRequestHeaders,
    this.customResponseHeaders,
    this.description,
    this.enableCDN,
    this.failoverPolicy,
    this.fingerprint,
    this.healthChecks,
    this.iap,
    this.id,
    this.kind,
    this.loadBalancingScheme,
    this.localityLbPolicy,
    this.logConfig,
    this.maxStreamDuration,
    this.name,
    this.network,
    this.outlierDetection,
    this.port,
    this.portName,
    this.protocol,
    this.region,
    this.securityPolicy,
    this.securitySettings,
    this.selfLink,
    this.sessionAffinity,
    this.timeoutSec,
  });

  BackendService.fromJson(core.Map _json)
      : this(
          affinityCookieTtlSec: _json.containsKey('affinityCookieTtlSec')
              ? _json['affinityCookieTtlSec'] as core.int
              : null,
          backends: _json.containsKey('backends')
              ? (_json['backends'] as core.List)
                  .map<Backend>((value) => Backend.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          cdnPolicy: _json.containsKey('cdnPolicy')
              ? BackendServiceCdnPolicy.fromJson(
                  _json['cdnPolicy'] as core.Map<core.String, core.dynamic>)
              : null,
          circuitBreakers: _json.containsKey('circuitBreakers')
              ? CircuitBreakers.fromJson(_json['circuitBreakers']
                  as core.Map<core.String, core.dynamic>)
              : null,
          connectionDraining: _json.containsKey('connectionDraining')
              ? ConnectionDraining.fromJson(_json['connectionDraining']
                  as core.Map<core.String, core.dynamic>)
              : null,
          consistentHash: _json.containsKey('consistentHash')
              ? ConsistentHashLoadBalancerSettings.fromJson(
                  _json['consistentHash']
                      as core.Map<core.String, core.dynamic>)
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          customRequestHeaders: _json.containsKey('customRequestHeaders')
              ? (_json['customRequestHeaders'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          customResponseHeaders: _json.containsKey('customResponseHeaders')
              ? (_json['customResponseHeaders'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          enableCDN: _json.containsKey('enableCDN')
              ? _json['enableCDN'] as core.bool
              : null,
          failoverPolicy: _json.containsKey('failoverPolicy')
              ? BackendServiceFailoverPolicy.fromJson(_json['failoverPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          healthChecks: _json.containsKey('healthChecks')
              ? (_json['healthChecks'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          iap: _json.containsKey('iap')
              ? BackendServiceIAP.fromJson(
                  _json['iap'] as core.Map<core.String, core.dynamic>)
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          loadBalancingScheme: _json.containsKey('loadBalancingScheme')
              ? _json['loadBalancingScheme'] as core.String
              : null,
          localityLbPolicy: _json.containsKey('localityLbPolicy')
              ? _json['localityLbPolicy'] as core.String
              : null,
          logConfig: _json.containsKey('logConfig')
              ? BackendServiceLogConfig.fromJson(
                  _json['logConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          maxStreamDuration: _json.containsKey('maxStreamDuration')
              ? Duration.fromJson(_json['maxStreamDuration']
                  as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          outlierDetection: _json.containsKey('outlierDetection')
              ? OutlierDetection.fromJson(_json['outlierDetection']
                  as core.Map<core.String, core.dynamic>)
              : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          portName: _json.containsKey('portName')
              ? _json['portName'] as core.String
              : null,
          protocol: _json.containsKey('protocol')
              ? _json['protocol'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          securityPolicy: _json.containsKey('securityPolicy')
              ? _json['securityPolicy'] as core.String
              : null,
          securitySettings: _json.containsKey('securitySettings')
              ? SecuritySettings.fromJson(_json['securitySettings']
                  as core.Map<core.String, core.dynamic>)
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          sessionAffinity: _json.containsKey('sessionAffinity')
              ? _json['sessionAffinity'] as core.String
              : null,
          timeoutSec: _json.containsKey('timeoutSec')
              ? _json['timeoutSec'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (affinityCookieTtlSec != null)
          'affinityCookieTtlSec': affinityCookieTtlSec!,
        if (backends != null)
          'backends': backends!.map((value) => value.toJson()).toList(),
        if (cdnPolicy != null) 'cdnPolicy': cdnPolicy!.toJson(),
        if (circuitBreakers != null)
          'circuitBreakers': circuitBreakers!.toJson(),
        if (connectionDraining != null)
          'connectionDraining': connectionDraining!.toJson(),
        if (consistentHash != null) 'consistentHash': consistentHash!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customRequestHeaders != null)
          'customRequestHeaders': customRequestHeaders!,
        if (customResponseHeaders != null)
          'customResponseHeaders': customResponseHeaders!,
        if (description != null) 'description': description!,
        if (enableCDN != null) 'enableCDN': enableCDN!,
        if (failoverPolicy != null) 'failoverPolicy': failoverPolicy!.toJson(),
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (healthChecks != null) 'healthChecks': healthChecks!,
        if (iap != null) 'iap': iap!.toJson(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (loadBalancingScheme != null)
          'loadBalancingScheme': loadBalancingScheme!,
        if (localityLbPolicy != null) 'localityLbPolicy': localityLbPolicy!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (maxStreamDuration != null)
          'maxStreamDuration': maxStreamDuration!.toJson(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (outlierDetection != null)
          'outlierDetection': outlierDetection!.toJson(),
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (protocol != null) 'protocol': protocol!,
        if (region != null) 'region': region!,
        if (securityPolicy != null) 'securityPolicy': securityPolicy!,
        if (securitySettings != null)
          'securitySettings': securitySettings!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (sessionAffinity != null) 'sessionAffinity': sessionAffinity!,
        if (timeoutSec != null) 'timeoutSec': timeoutSec!,
      };
}

class BackendServiceAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  BackendServiceAggregatedListWarningData({
    this.key,
    this.value,
  });

  BackendServiceAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class BackendServiceAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<BackendServiceAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  BackendServiceAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  BackendServiceAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<BackendServiceAggregatedListWarningData>((value) =>
                      BackendServiceAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of BackendServicesScopedList.
class BackendServiceAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of BackendServicesScopedList resources.
  core.Map<core.String, BackendServicesScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  BackendServiceAggregatedListWarning? warning;

  BackendServiceAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  BackendServiceAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    BackendServicesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? BackendServiceAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Message containing Cloud CDN configuration for a backend service.
class BackendServiceCdnPolicy {
  /// Bypass the cache when the specified request headers are matched - e.g.
  /// Pragma or Authorization headers.
  ///
  /// Up to 5 headers can be specified. The cache is bypassed for all
  /// cdnPolicy.cacheMode settings.
  core.List<BackendServiceCdnPolicyBypassCacheOnRequestHeader>?
      bypassCacheOnRequestHeaders;

  /// The CacheKeyPolicy for this CdnPolicy.
  CacheKeyPolicy? cacheKeyPolicy;

  /// Specifies the cache setting for all responses from this backend.
  ///
  /// The possible values are: USE_ORIGIN_HEADERS Requires the origin to set
  /// valid caching headers to cache content. Responses without these headers
  /// will not be cached at Google's edge, and will require a full trip to the
  /// origin on every request, potentially impacting performance and increasing
  /// load on the origin server. FORCE_CACHE_ALL Cache all content, ignoring any
  /// "private", "no-store" or "no-cache" directives in Cache-Control response
  /// headers. Warning: this may result in Cloud CDN caching private, per-user
  /// (user identifiable) content. CACHE_ALL_STATIC Automatically cache static
  /// content, including common image formats, media (video and audio), and web
  /// assets (JavaScript and CSS). Requests and responses that are marked as
  /// uncacheable, as well as dynamic content (including HTML), will not be
  /// cached.
  /// Possible string values are:
  /// - "CACHE_ALL_STATIC" : Automatically cache static content, including
  /// common image formats, media (video and audio), and web assets (JavaScript
  /// and CSS). Requests and responses that are marked as uncacheable, as well
  /// as dynamic content (including HTML), will not be cached.
  /// - "FORCE_CACHE_ALL" : Cache all content, ignoring any "private",
  /// "no-store" or "no-cache" directives in Cache-Control response headers.
  /// Warning: this may result in Cloud CDN caching private, per-user (user
  /// identifiable) content.
  /// - "INVALID_CACHE_MODE"
  /// - "USE_ORIGIN_HEADERS" : Requires the origin to set valid caching headers
  /// to cache content. Responses without these headers will not be cached at
  /// Google's edge, and will require a full trip to the origin on every
  /// request, potentially impacting performance and increasing load on the
  /// origin server.
  core.String? cacheMode;

  /// Specifies a separate client (e.g. browser client) maximum TTL.
  ///
  /// This is used to clamp the max-age (or Expires) value sent to the client.
  /// With FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for
  /// the response max-age directive, along with a "public" directive. For
  /// cacheable content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age
  /// from the origin (if specified), or else sets the response max-age
  /// directive to the lesser of the client_ttl and default_ttl, and also
  /// ensures a "public" cache-control directive is present. If a client TTL is
  /// not specified, a default value (1 hour) will be used. The maximum allowed
  /// value is 86400s (1 day).
  core.int? clientTtl;

  /// Specifies the default TTL for cached content served by this origin for
  /// responses that do not have an existing valid TTL (max-age or s-max-age).
  ///
  /// Setting a TTL of "0" means "always revalidate". The value of defaultTTL
  /// cannot be set to a value greater than that of maxTTL, but can be equal.
  /// When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will
  /// overwrite the TTL set in all responses. The maximum allowed value is
  /// 31,622,400s (1 year), noting that infrequently accessed objects may be
  /// evicted from the cache before the defined TTL.
  core.int? defaultTtl;

  /// Specifies the maximum allowed TTL for cached content served by this
  /// origin.
  ///
  /// Cache directives that attempt to set a max-age or s-maxage higher than
  /// this, or an Expires header more than maxTTL seconds in the future will be
  /// capped at the value of maxTTL, as if it were the value of an s-maxage
  /// Cache-Control directive. Headers sent to the client will not be modified.
  /// Setting a TTL of "0" means "always revalidate". The maximum allowed value
  /// is 31,622,400s (1 year), noting that infrequently accessed objects may be
  /// evicted from the cache before the defined TTL.
  core.int? maxTtl;

  /// Negative caching allows per-status code TTLs to be set, in order to apply
  /// fine-grained caching for common errors or redirects.
  ///
  /// This can reduce the load on your origin and improve end-user experience by
  /// reducing response latency. When the cache mode is set to CACHE_ALL_STATIC
  /// or USE_ORIGIN_HEADERS, negative caching applies to responses with the
  /// specified response code that lack any Cache-Control, Expires, or Pragma:
  /// no-cache directives. When the cache mode is set to FORCE_CACHE_ALL,
  /// negative caching applies to all responses with the specified response
  /// code, and override any caching headers. By default, Cloud CDN will apply
  /// the following default TTLs to these status codes: HTTP 300 (Multiple
  /// Choice), 301, 308 (Permanent Redirects): 10m HTTP 404 (Not Found), 410
  /// (Gone), 451 (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not
  /// Found), 421 (Misdirected Request), 501 (Not Implemented): 60s. These
  /// defaults can be overridden in negative_caching_policy.
  core.bool? negativeCaching;

  /// Sets a cache TTL for the specified HTTP status code.
  ///
  /// negative_caching must be enabled to configure negative_caching_policy.
  /// Omitting the policy and leaving negative_caching enabled will use Cloud
  /// CDN's default cache TTLs. Note that when specifying an explicit
  /// negative_caching_policy, you should take care to specify a cache TTL for
  /// all response codes that you wish to cache. Cloud CDN will not apply any
  /// default negative caching when a policy exists.
  core.List<BackendServiceCdnPolicyNegativeCachingPolicy>?
      negativeCachingPolicy;

  /// If true then Cloud CDN will combine multiple concurrent cache fill
  /// requests into a small number of requests to the origin.
  core.bool? requestCoalescing;

  /// Serve existing content from the cache (if available) when revalidating
  /// content with the origin, or when an error is encountered when refreshing
  /// the cache.
  ///
  /// This setting defines the default "max-stale" duration for any cached
  /// responses that do not specify a max-stale directive. Stale responses that
  /// exceed the TTL configured here will not be served. The default limit
  /// (max-stale) is 86400s (1 day), which will allow stale content to be served
  /// up to this limit beyond the max-age (or s-max-age) of a cached response.
  /// The maximum allowed value is 604800 (1 week). Set this to zero (0) to
  /// disable serve-while-stale.
  core.int? serveWhileStale;

  /// Maximum number of seconds the response to a signed URL request will be
  /// considered fresh.
  ///
  /// After this time period, the response will be revalidated before being
  /// served. Defaults to 1hr (3600s). When serving responses to signed URL
  /// requests, Cloud CDN will internally behave as though all responses from
  /// this backend had a "Cache-Control: public, max-age=\[TTL\]" header,
  /// regardless of any existing Cache-Control header. The actual headers served
  /// in responses will not be altered.
  core.String? signedUrlCacheMaxAgeSec;

  /// Names of the keys for signing request URLs.
  ///
  /// Output only.
  core.List<core.String>? signedUrlKeyNames;

  BackendServiceCdnPolicy({
    this.bypassCacheOnRequestHeaders,
    this.cacheKeyPolicy,
    this.cacheMode,
    this.clientTtl,
    this.defaultTtl,
    this.maxTtl,
    this.negativeCaching,
    this.negativeCachingPolicy,
    this.requestCoalescing,
    this.serveWhileStale,
    this.signedUrlCacheMaxAgeSec,
    this.signedUrlKeyNames,
  });

  BackendServiceCdnPolicy.fromJson(core.Map _json)
      : this(
          bypassCacheOnRequestHeaders: _json.containsKey(
                  'bypassCacheOnRequestHeaders')
              ? (_json['bypassCacheOnRequestHeaders'] as core.List)
                  .map<BackendServiceCdnPolicyBypassCacheOnRequestHeader>(
                      (value) =>
                          BackendServiceCdnPolicyBypassCacheOnRequestHeader
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          cacheKeyPolicy: _json.containsKey('cacheKeyPolicy')
              ? CacheKeyPolicy.fromJson(_json['cacheKeyPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          cacheMode: _json.containsKey('cacheMode')
              ? _json['cacheMode'] as core.String
              : null,
          clientTtl: _json.containsKey('clientTtl')
              ? _json['clientTtl'] as core.int
              : null,
          defaultTtl: _json.containsKey('defaultTtl')
              ? _json['defaultTtl'] as core.int
              : null,
          maxTtl:
              _json.containsKey('maxTtl') ? _json['maxTtl'] as core.int : null,
          negativeCaching: _json.containsKey('negativeCaching')
              ? _json['negativeCaching'] as core.bool
              : null,
          negativeCachingPolicy: _json.containsKey('negativeCachingPolicy')
              ? (_json['negativeCachingPolicy'] as core.List)
                  .map<BackendServiceCdnPolicyNegativeCachingPolicy>((value) =>
                      BackendServiceCdnPolicyNegativeCachingPolicy.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          requestCoalescing: _json.containsKey('requestCoalescing')
              ? _json['requestCoalescing'] as core.bool
              : null,
          serveWhileStale: _json.containsKey('serveWhileStale')
              ? _json['serveWhileStale'] as core.int
              : null,
          signedUrlCacheMaxAgeSec: _json.containsKey('signedUrlCacheMaxAgeSec')
              ? _json['signedUrlCacheMaxAgeSec'] as core.String
              : null,
          signedUrlKeyNames: _json.containsKey('signedUrlKeyNames')
              ? (_json['signedUrlKeyNames'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bypassCacheOnRequestHeaders != null)
          'bypassCacheOnRequestHeaders': bypassCacheOnRequestHeaders!
              .map((value) => value.toJson())
              .toList(),
        if (cacheKeyPolicy != null) 'cacheKeyPolicy': cacheKeyPolicy!.toJson(),
        if (cacheMode != null) 'cacheMode': cacheMode!,
        if (clientTtl != null) 'clientTtl': clientTtl!,
        if (defaultTtl != null) 'defaultTtl': defaultTtl!,
        if (maxTtl != null) 'maxTtl': maxTtl!,
        if (negativeCaching != null) 'negativeCaching': negativeCaching!,
        if (negativeCachingPolicy != null)
          'negativeCachingPolicy':
              negativeCachingPolicy!.map((value) => value.toJson()).toList(),
        if (requestCoalescing != null) 'requestCoalescing': requestCoalescing!,
        if (serveWhileStale != null) 'serveWhileStale': serveWhileStale!,
        if (signedUrlCacheMaxAgeSec != null)
          'signedUrlCacheMaxAgeSec': signedUrlCacheMaxAgeSec!,
        if (signedUrlKeyNames != null) 'signedUrlKeyNames': signedUrlKeyNames!,
      };
}

/// Bypass the cache when the specified request headers are present, e.g. Pragma
/// or Authorization headers.
///
/// Values are case insensitive. The presence of such a header overrides the
/// cache_mode setting.
class BackendServiceCdnPolicyBypassCacheOnRequestHeader {
  /// The header field name to match on when bypassing cache.
  ///
  /// Values are case-insensitive.
  core.String? headerName;

  BackendServiceCdnPolicyBypassCacheOnRequestHeader({
    this.headerName,
  });

  BackendServiceCdnPolicyBypassCacheOnRequestHeader.fromJson(core.Map _json)
      : this(
          headerName: _json.containsKey('headerName')
              ? _json['headerName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (headerName != null) 'headerName': headerName!,
      };
}

/// Specify CDN TTLs for response error codes.
class BackendServiceCdnPolicyNegativeCachingPolicy {
  /// The HTTP status code to define a TTL against.
  ///
  /// Only HTTP status codes 300, 301, 302, 307, 308, 404, 405, 410, 421, 451
  /// and 501 are can be specified as values, and you cannot specify a status
  /// code more than once.
  core.int? code;

  /// The TTL (in seconds) for which to cache responses with the corresponding
  /// status code.
  ///
  /// The maximum allowed value is 1800s (30 minutes), noting that infrequently
  /// accessed objects may be evicted from the cache before the defined TTL.
  core.int? ttl;

  BackendServiceCdnPolicyNegativeCachingPolicy({
    this.code,
    this.ttl,
  });

  BackendServiceCdnPolicyNegativeCachingPolicy.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.int : null,
          ttl: _json.containsKey('ttl') ? _json['ttl'] as core.int : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (ttl != null) 'ttl': ttl!,
      };
}

/// For load balancers that have configurable failover:
/// [Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
/// and \[external TCP/UDP Load
/// Balancing\](/network/networklb-failover-overview).
///
/// On failover or failback, this field indicates whether connection draining
/// will be honored. Google Cloud has a fixed connection draining timeout of 10
/// minutes. A setting of true terminates existing TCP connections to the active
/// pool during failover and failback, immediately draining traffic. A setting
/// of false allows existing TCP connections to persist, even on VMs no longer
/// in the active pool, for up to the duration of the connection draining
/// timeout (10 minutes).
class BackendServiceFailoverPolicy {
  /// This can be set to true only if the protocol is TCP.
  ///
  /// The default is false.
  core.bool? disableConnectionDrainOnFailover;

  /// If set to true, connections to the load balancer are dropped when all
  /// primary and all backup backend VMs are unhealthy.If set to false,
  /// connections are distributed among all primary VMs when all primary and all
  /// backup backend VMs are unhealthy.
  ///
  /// For load balancers that have configurable failover:
  /// [Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
  /// and \[external TCP/UDP Load
  /// Balancing\](/network/networklb-failover-overview). The default is false.
  core.bool? dropTrafficIfUnhealthy;

  /// The value of the field must be in the range \[0, 1\].
  ///
  /// If the value is 0, the load balancer performs a failover when the number
  /// of healthy primary VMs equals zero. For all other values, the load
  /// balancer performs a failover when the total number of healthy primary VMs
  /// is less than this ratio. For load balancers that have configurable
  /// failover:
  /// [Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
  /// and \[external TCP/UDP Load
  /// Balancing\](/network/networklb-failover-overview).
  core.double? failoverRatio;

  BackendServiceFailoverPolicy({
    this.disableConnectionDrainOnFailover,
    this.dropTrafficIfUnhealthy,
    this.failoverRatio,
  });

  BackendServiceFailoverPolicy.fromJson(core.Map _json)
      : this(
          disableConnectionDrainOnFailover:
              _json.containsKey('disableConnectionDrainOnFailover')
                  ? _json['disableConnectionDrainOnFailover'] as core.bool
                  : null,
          dropTrafficIfUnhealthy: _json.containsKey('dropTrafficIfUnhealthy')
              ? _json['dropTrafficIfUnhealthy'] as core.bool
              : null,
          failoverRatio: _json.containsKey('failoverRatio')
              ? (_json['failoverRatio'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disableConnectionDrainOnFailover != null)
          'disableConnectionDrainOnFailover': disableConnectionDrainOnFailover!,
        if (dropTrafficIfUnhealthy != null)
          'dropTrafficIfUnhealthy': dropTrafficIfUnhealthy!,
        if (failoverRatio != null) 'failoverRatio': failoverRatio!,
      };
}

class BackendServiceGroupHealth {
  /// Metadata defined as annotations on the network endpoint group.
  core.Map<core.String, core.String>? annotations;

  /// Health state of the backend instances or endpoints in requested instance
  /// or network endpoint group, determined based on configured health checks.
  core.List<HealthStatus>? healthStatus;

  /// Type of resource.
  ///
  /// Always compute#backendServiceGroupHealth for the health of backend
  /// services.
  ///
  /// Output only.
  core.String? kind;

  BackendServiceGroupHealth({
    this.annotations,
    this.healthStatus,
    this.kind,
  });

  BackendServiceGroupHealth.fromJson(core.Map _json)
      : this(
          annotations: _json.containsKey('annotations')
              ? (_json['annotations'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          healthStatus: _json.containsKey('healthStatus')
              ? (_json['healthStatus'] as core.List)
                  .map<HealthStatus>((value) => HealthStatus.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (healthStatus != null)
          'healthStatus': healthStatus!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
      };
}

/// Identity-Aware Proxy
class BackendServiceIAP {
  /// Whether the serving infrastructure will authenticate and authorize all
  /// incoming requests.
  ///
  /// If true, the oauth2ClientId and oauth2ClientSecret fields must be
  /// non-empty.
  core.bool? enabled;

  /// OAuth2 client ID to use for the authentication flow.
  core.String? oauth2ClientId;

  /// OAuth2 client secret to use for the authentication flow.
  ///
  /// For security reasons, this value cannot be retrieved via the API. Instead,
  /// the SHA-256 hash of the value is returned in the oauth2ClientSecretSha256
  /// field. @InputOnly
  core.String? oauth2ClientSecret;

  /// SHA256 hash value for the field oauth2_client_secret above.
  ///
  /// Output only.
  core.String? oauth2ClientSecretSha256;

  BackendServiceIAP({
    this.enabled,
    this.oauth2ClientId,
    this.oauth2ClientSecret,
    this.oauth2ClientSecretSha256,
  });

  BackendServiceIAP.fromJson(core.Map _json)
      : this(
          enabled: _json.containsKey('enabled')
              ? _json['enabled'] as core.bool
              : null,
          oauth2ClientId: _json.containsKey('oauth2ClientId')
              ? _json['oauth2ClientId'] as core.String
              : null,
          oauth2ClientSecret: _json.containsKey('oauth2ClientSecret')
              ? _json['oauth2ClientSecret'] as core.String
              : null,
          oauth2ClientSecretSha256:
              _json.containsKey('oauth2ClientSecretSha256')
                  ? _json['oauth2ClientSecretSha256'] as core.String
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enabled != null) 'enabled': enabled!,
        if (oauth2ClientId != null) 'oauth2ClientId': oauth2ClientId!,
        if (oauth2ClientSecret != null)
          'oauth2ClientSecret': oauth2ClientSecret!,
        if (oauth2ClientSecretSha256 != null)
          'oauth2ClientSecretSha256': oauth2ClientSecretSha256!,
      };
}

class BackendServiceListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  BackendServiceListWarningData({
    this.key,
    this.value,
  });

  BackendServiceListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class BackendServiceListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<BackendServiceListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  BackendServiceListWarning({
    this.code,
    this.data,
    this.message,
  });

  BackendServiceListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<BackendServiceListWarningData>((value) =>
                      BackendServiceListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of BackendService resources.
class BackendServiceList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of BackendService resources.
  core.List<BackendService>? items;

  /// Type of resource.
  ///
  /// Always compute#backendServiceList for lists of backend services.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  BackendServiceListWarning? warning;

  BackendServiceList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  BackendServiceList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<BackendService>((value) => BackendService.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? BackendServiceListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The available logging options for the load balancer traffic served by this
/// backend service.
class BackendServiceLogConfig {
  /// This field denotes whether to enable logging for the load balancer traffic
  /// served by this backend service.
  core.bool? enable;

  /// This field can only be specified if logging is enabled for this backend
  /// service.
  ///
  /// The value of the field must be in \[0, 1\]. This configures the sampling
  /// rate of requests to the load balancer where 1.0 means all logged requests
  /// are reported and 0.0 means no logged requests are reported. The default
  /// value is 1.0.
  core.double? sampleRate;

  BackendServiceLogConfig({
    this.enable,
    this.sampleRate,
  });

  BackendServiceLogConfig.fromJson(core.Map _json)
      : this(
          enable:
              _json.containsKey('enable') ? _json['enable'] as core.bool : null,
          sampleRate: _json.containsKey('sampleRate')
              ? (_json['sampleRate'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
        if (sampleRate != null) 'sampleRate': sampleRate!,
      };
}

class BackendServiceReference {
  core.String? backendService;

  BackendServiceReference({
    this.backendService,
  });

  BackendServiceReference.fromJson(core.Map _json)
      : this(
          backendService: _json.containsKey('backendService')
              ? _json['backendService'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendService != null) 'backendService': backendService!,
      };
}

class BackendServicesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  BackendServicesScopedListWarningData({
    this.key,
    this.value,
  });

  BackendServicesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class BackendServicesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<BackendServicesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  BackendServicesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  BackendServicesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<BackendServicesScopedListWarningData>((value) =>
                      BackendServicesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class BackendServicesScopedList {
  /// A list of BackendServices contained in this scope.
  core.List<BackendService>? backendServices;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  BackendServicesScopedListWarning? warning;

  BackendServicesScopedList({
    this.backendServices,
    this.warning,
  });

  BackendServicesScopedList.fromJson(core.Map _json)
      : this(
          backendServices: _json.containsKey('backendServices')
              ? (_json['backendServices'] as core.List)
                  .map<BackendService>((value) => BackendService.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? BackendServicesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendServices != null)
          'backendServices':
              backendServices!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Associates `members` with a `role`.
class Binding {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.String? bindingId;

  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request. If the condition evaluates to `false`, then this binding
  /// does not apply to the current request. However, a different role binding
  /// might grant the same role to one or more of the members in this binding.
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  Expr? condition;

  /// Specifies the identities requesting access for a Cloud Platform resource.
  ///
  /// `members` can have the following values: * `allUsers`: A special
  /// identifier that represents anyone who is on the internet; with or without
  /// a Google account. * `allAuthenticatedUsers`: A special identifier that
  /// represents anyone who is authenticated with a Google account or a service
  /// account. * `user:{emailid}`: An email address that represents a specific
  /// Google account. For example, `alice@example.com` . *
  /// `serviceAccount:{emailid}`: An email address that represents a service
  /// account. For example, `my-other-app@appspot.gserviceaccount.com`. *
  /// `group:{emailid}`: An email address that represents a Google group. For
  /// example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`:
  /// An email address (plus unique identifier) representing a user that has
  /// been recently deleted. For example,
  /// `alice@example.com?uid=123456789012345678901`. If the user is recovered,
  /// this value reverts to `user:{emailid}` and the recovered user retains the
  /// role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`:
  /// An email address (plus unique identifier) representing a service account
  /// that has been recently deleted. For example,
  /// `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If
  /// the service account is undeleted, this value reverts to
  /// `serviceAccount:{emailid}` and the undeleted service account retains the
  /// role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
  /// address (plus unique identifier) representing a Google group that has been
  /// recently deleted. For example,
  /// `admins@example.com?uid=123456789012345678901`. If the group is recovered,
  /// this value reverts to `group:{emailid}` and the recovered group retains
  /// the role in the binding. * `domain:{domain}`: The G Suite domain (primary)
  /// that represents all the users of that domain. For example, `google.com` or
  /// `example.com`.
  core.List<core.String>? members;

  /// Role that is assigned to `members`.
  ///
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  core.String? role;

  Binding({
    this.bindingId,
    this.condition,
    this.members,
    this.role,
  });

  Binding.fromJson(core.Map _json)
      : this(
          bindingId: _json.containsKey('bindingId')
              ? _json['bindingId'] as core.String
              : null,
          condition: _json.containsKey('condition')
              ? Expr.fromJson(
                  _json['condition'] as core.Map<core.String, core.dynamic>)
              : null,
          members: _json.containsKey('members')
              ? (_json['members'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          role: _json.containsKey('role') ? _json['role'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindingId != null) 'bindingId': bindingId!,
        if (condition != null) 'condition': condition!.toJson(),
        if (members != null) 'members': members!,
        if (role != null) 'role': role!,
      };
}

/// A transient resource used in compute.instances.bulkInsert and
/// compute.regionInstances.bulkInsert .
///
/// This resource is not persisted anywhere, it is used only for processing the
/// requests.
class BulkInsertInstanceResource {
  /// The maximum number of instances to create.
  core.String? count;

  /// The instance properties defining the VM instances to be created.
  ///
  /// Required if sourceInstanceTemplate is not provided.
  InstanceProperties? instanceProperties;

  /// Policy for chosing target zone.
  LocationPolicy? locationPolicy;

  /// The minimum number of instances to create.
  ///
  /// If no min_count is specified then count is used as the default value. If
  /// min_count instances cannot be created, then no instances will be created
  /// and instances already created will be deleted.
  core.String? minCount;

  /// The string pattern used for the names of the VMs.
  ///
  /// Either name_pattern or per_instance_properties must be set. The pattern
  /// must contain one continuous sequence of placeholder hash characters (#)
  /// with each character corresponding to one digit of the generated instance
  /// name. Example: a name_pattern of inst-#### generates instance names such
  /// as inst-0001 and inst-0002. If existing instances in the same project and
  /// zone have names that match the name pattern then the generated instance
  /// numbers start after the biggest existing number. For example, if there
  /// exists an instance with name inst-0050, then instance names generated
  /// using the pattern inst-#### begin with inst-0051. The name pattern
  /// placeholder #...# can contain up to 18 characters.
  core.String? namePattern;

  /// Per-instance properties to be set on individual instances.
  ///
  /// Keys of this map specify requested instance names. Can be empty if
  /// name_pattern is used.
  core.Map<core.String, BulkInsertInstanceResourcePerInstanceProperties>?
      perInstanceProperties;

  /// Specifies the instance template from which to create instances.
  ///
  /// You may combine sourceInstanceTemplate with instanceProperties to override
  /// specific values from an existing instance template. Bulk API follows the
  /// semantics of JSON Merge Patch described by RFC 7396. It can be a full or
  /// partial URL. For example, the following are all valid URLs to an instance
  /// template: - https://www.googleapis.com/compute/v1/projects/project
  /// /global/instanceTemplates/instanceTemplate -
  /// projects/project/global/instanceTemplates/instanceTemplate -
  /// global/instanceTemplates/instanceTemplate This field is optional.
  core.String? sourceInstanceTemplate;

  BulkInsertInstanceResource({
    this.count,
    this.instanceProperties,
    this.locationPolicy,
    this.minCount,
    this.namePattern,
    this.perInstanceProperties,
    this.sourceInstanceTemplate,
  });

  BulkInsertInstanceResource.fromJson(core.Map _json)
      : this(
          count:
              _json.containsKey('count') ? _json['count'] as core.String : null,
          instanceProperties: _json.containsKey('instanceProperties')
              ? InstanceProperties.fromJson(_json['instanceProperties']
                  as core.Map<core.String, core.dynamic>)
              : null,
          locationPolicy: _json.containsKey('locationPolicy')
              ? LocationPolicy.fromJson(_json['locationPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          minCount: _json.containsKey('minCount')
              ? _json['minCount'] as core.String
              : null,
          namePattern: _json.containsKey('namePattern')
              ? _json['namePattern'] as core.String
              : null,
          perInstanceProperties: _json.containsKey('perInstanceProperties')
              ? (_json['perInstanceProperties']
                      as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    BulkInsertInstanceResourcePerInstanceProperties.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          sourceInstanceTemplate: _json.containsKey('sourceInstanceTemplate')
              ? _json['sourceInstanceTemplate'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (count != null) 'count': count!,
        if (instanceProperties != null)
          'instanceProperties': instanceProperties!.toJson(),
        if (locationPolicy != null) 'locationPolicy': locationPolicy!.toJson(),
        if (minCount != null) 'minCount': minCount!,
        if (namePattern != null) 'namePattern': namePattern!,
        if (perInstanceProperties != null)
          'perInstanceProperties': perInstanceProperties!
              .map((key, item) => core.MapEntry(key, item.toJson())),
        if (sourceInstanceTemplate != null)
          'sourceInstanceTemplate': sourceInstanceTemplate!,
      };
}

/// Per-instance properties to be set on individual instances.
///
/// To be extended in the future.
class BulkInsertInstanceResourcePerInstanceProperties {
  /// This field is only temporary.
  ///
  /// It will be removed. Do not use it.
  core.String? name;

  BulkInsertInstanceResourcePerInstanceProperties({
    this.name,
  });

  BulkInsertInstanceResourcePerInstanceProperties.fromJson(core.Map _json)
      : this(
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
      };
}

class CacheInvalidationRule {
  /// If set, this invalidation rule will only apply to requests with a Host
  /// header matching host.
  core.String? host;
  core.String? path;

  CacheInvalidationRule({
    this.host,
    this.path,
  });

  CacheInvalidationRule.fromJson(core.Map _json)
      : this(
          host: _json.containsKey('host') ? _json['host'] as core.String : null,
          path: _json.containsKey('path') ? _json['path'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (path != null) 'path': path!,
      };
}

/// Message containing what to include in the cache key for a request for Cloud
/// CDN.
class CacheKeyPolicy {
  /// If true, requests to different hosts will be cached separately.
  core.bool? includeHost;

  /// If true, http and https requests will be cached separately.
  core.bool? includeProtocol;

  /// If true, include query string parameters in the cache key according to
  /// query_string_whitelist and query_string_blacklist.
  ///
  /// If neither is set, the entire query string will be included. If false, the
  /// query string will be excluded from the cache key entirely.
  core.bool? includeQueryString;

  /// Names of query string parameters to exclude in cache keys.
  ///
  /// All other parameters will be included. Either specify
  /// query_string_whitelist or query_string_blacklist, not both. '&' and '='
  /// will be percent encoded and not treated as delimiters.
  core.List<core.String>? queryStringBlacklist;

  /// Names of query string parameters to include in cache keys.
  ///
  /// All other parameters will be excluded. Either specify
  /// query_string_whitelist or query_string_blacklist, not both. '&' and '='
  /// will be percent encoded and not treated as delimiters.
  core.List<core.String>? queryStringWhitelist;

  CacheKeyPolicy({
    this.includeHost,
    this.includeProtocol,
    this.includeQueryString,
    this.queryStringBlacklist,
    this.queryStringWhitelist,
  });

  CacheKeyPolicy.fromJson(core.Map _json)
      : this(
          includeHost: _json.containsKey('includeHost')
              ? _json['includeHost'] as core.bool
              : null,
          includeProtocol: _json.containsKey('includeProtocol')
              ? _json['includeProtocol'] as core.bool
              : null,
          includeQueryString: _json.containsKey('includeQueryString')
              ? _json['includeQueryString'] as core.bool
              : null,
          queryStringBlacklist: _json.containsKey('queryStringBlacklist')
              ? (_json['queryStringBlacklist'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          queryStringWhitelist: _json.containsKey('queryStringWhitelist')
              ? (_json['queryStringWhitelist'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (includeHost != null) 'includeHost': includeHost!,
        if (includeProtocol != null) 'includeProtocol': includeProtocol!,
        if (includeQueryString != null)
          'includeQueryString': includeQueryString!,
        if (queryStringBlacklist != null)
          'queryStringBlacklist': queryStringBlacklist!,
        if (queryStringWhitelist != null)
          'queryStringWhitelist': queryStringWhitelist!,
      };
}

/// Settings controlling the volume of requests, connections and retries to this
/// backend service.
class CircuitBreakers {
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  core.int? maxConnections;

  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  core.int? maxPendingRequests;

  /// The maximum number of parallel requests that allowed to the backend
  /// service.
  ///
  /// If not specified, there is no limit.
  core.int? maxRequests;

  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  core.int? maxRequestsPerConnection;

  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  core.int? maxRetries;

  CircuitBreakers({
    this.maxConnections,
    this.maxPendingRequests,
    this.maxRequests,
    this.maxRequestsPerConnection,
    this.maxRetries,
  });

  CircuitBreakers.fromJson(core.Map _json)
      : this(
          maxConnections: _json.containsKey('maxConnections')
              ? _json['maxConnections'] as core.int
              : null,
          maxPendingRequests: _json.containsKey('maxPendingRequests')
              ? _json['maxPendingRequests'] as core.int
              : null,
          maxRequests: _json.containsKey('maxRequests')
              ? _json['maxRequests'] as core.int
              : null,
          maxRequestsPerConnection:
              _json.containsKey('maxRequestsPerConnection')
                  ? _json['maxRequestsPerConnection'] as core.int
                  : null,
          maxRetries: _json.containsKey('maxRetries')
              ? _json['maxRetries'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxConnections != null) 'maxConnections': maxConnections!,
        if (maxPendingRequests != null)
          'maxPendingRequests': maxPendingRequests!,
        if (maxRequests != null) 'maxRequests': maxRequests!,
        if (maxRequestsPerConnection != null)
          'maxRequestsPerConnection': maxRequestsPerConnection!,
        if (maxRetries != null) 'maxRetries': maxRetries!,
      };
}

/// Represents a regional Commitment resource.
///
/// Creating a commitment resource means that you are purchasing a committed use
/// contract with an explicit start and end time. You can create commitments
/// based on vCPUs and memory usage and receive discounted rates. For full
/// details, read Signing Up for Committed Use Discounts.
class Commitment {
  /// The category of the commitment.
  ///
  /// Category MACHINE specifies commitments composed of machine resources such
  /// as VCPU or MEMORY, listed in resources. Category LICENSE specifies
  /// commitments composed of software licenses, listed in licenseResources.
  /// Note that only MACHINE commitments should have a Type specified.
  /// Possible string values are:
  /// - "CATEGORY_UNSPECIFIED"
  /// - "LICENSE"
  /// - "MACHINE"
  core.String? category;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Commitment end time in RFC3339 text format.
  ///
  /// Output only.
  core.String? endTimestamp;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#commitment for commitments.
  ///
  /// Output only.
  core.String? kind;

  /// The license specification required as part of a license commitment.
  LicenseResourceCommitment? licenseResource;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The plan for this commitment, which determines duration and discount rate.
  ///
  /// The currently supported plans are TWELVE_MONTH (1 year), and
  /// THIRTY_SIX_MONTH (3 years).
  /// Possible string values are:
  /// - "INVALID"
  /// - "THIRTY_SIX_MONTH"
  /// - "TWELVE_MONTH"
  core.String? plan;

  /// URL of the region where this commitment may be used.
  ///
  /// Output only.
  core.String? region;

  /// List of reservations in this commitment.
  core.List<Reservation>? reservations;

  /// A list of commitment amounts for particular resources.
  ///
  /// Note that VCPU and MEMORY resource commitments must occur together.
  core.List<ResourceCommitment>? resources;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Commitment start time in RFC3339 text format.
  ///
  /// Output only.
  core.String? startTimestamp;

  /// Status of the commitment with regards to eventual expiration (each
  /// commitment has an end date defined).
  ///
  /// One of the following values: NOT_YET_ACTIVE, ACTIVE, EXPIRED.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CREATING"
  /// - "EXPIRED"
  /// - "NOT_YET_ACTIVE"
  core.String? status;

  /// An optional, human-readable explanation of the status.
  ///
  /// Output only.
  core.String? statusMessage;

  /// The type of commitment, which affects the discount rate and the eligible
  /// resources.
  ///
  /// Type MEMORY_OPTIMIZED specifies a commitment that will only apply to
  /// memory optimized machines. Type ACCELERATOR_OPTIMIZED specifies a
  /// commitment that will only apply to accelerator optimized machines.
  /// Possible string values are:
  /// - "ACCELERATOR_OPTIMIZED"
  /// - "COMPUTE_OPTIMIZED"
  /// - "GENERAL_PURPOSE"
  /// - "GENERAL_PURPOSE_E2"
  /// - "GENERAL_PURPOSE_N2"
  /// - "GENERAL_PURPOSE_N2D"
  /// - "MEMORY_OPTIMIZED"
  /// - "TYPE_UNSPECIFIED"
  core.String? type;

  Commitment({
    this.category,
    this.creationTimestamp,
    this.description,
    this.endTimestamp,
    this.id,
    this.kind,
    this.licenseResource,
    this.name,
    this.plan,
    this.region,
    this.reservations,
    this.resources,
    this.selfLink,
    this.startTimestamp,
    this.status,
    this.statusMessage,
    this.type,
  });

  Commitment.fromJson(core.Map _json)
      : this(
          category: _json.containsKey('category')
              ? _json['category'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          endTimestamp: _json.containsKey('endTimestamp')
              ? _json['endTimestamp'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          licenseResource: _json.containsKey('licenseResource')
              ? LicenseResourceCommitment.fromJson(_json['licenseResource']
                  as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          plan: _json.containsKey('plan') ? _json['plan'] as core.String : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          reservations: _json.containsKey('reservations')
              ? (_json['reservations'] as core.List)
                  .map<Reservation>((value) => Reservation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          resources: _json.containsKey('resources')
              ? (_json['resources'] as core.List)
                  .map<ResourceCommitment>((value) =>
                      ResourceCommitment.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          startTimestamp: _json.containsKey('startTimestamp')
              ? _json['startTimestamp'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          statusMessage: _json.containsKey('statusMessage')
              ? _json['statusMessage'] as core.String
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (category != null) 'category': category!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (endTimestamp != null) 'endTimestamp': endTimestamp!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (licenseResource != null)
          'licenseResource': licenseResource!.toJson(),
        if (name != null) 'name': name!,
        if (plan != null) 'plan': plan!,
        if (region != null) 'region': region!,
        if (reservations != null)
          'reservations': reservations!.map((value) => value.toJson()).toList(),
        if (resources != null)
          'resources': resources!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (startTimestamp != null) 'startTimestamp': startTimestamp!,
        if (status != null) 'status': status!,
        if (statusMessage != null) 'statusMessage': statusMessage!,
        if (type != null) 'type': type!,
      };
}

class CommitmentAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  CommitmentAggregatedListWarningData({
    this.key,
    this.value,
  });

  CommitmentAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class CommitmentAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<CommitmentAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  CommitmentAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  CommitmentAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<CommitmentAggregatedListWarningData>((value) =>
                      CommitmentAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class CommitmentAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of CommitmentsScopedList resources.
  core.Map<core.String, CommitmentsScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#commitmentAggregatedList for aggregated lists of
  /// commitments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  CommitmentAggregatedListWarning? warning;

  CommitmentAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  CommitmentAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    CommitmentsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? CommitmentAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class CommitmentListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  CommitmentListWarningData({
    this.key,
    this.value,
  });

  CommitmentListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class CommitmentListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<CommitmentListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  CommitmentListWarning({
    this.code,
    this.data,
    this.message,
  });

  CommitmentListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<CommitmentListWarningData>((value) =>
                      CommitmentListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Commitment resources.
class CommitmentList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Commitment resources.
  core.List<Commitment>? items;

  /// Type of resource.
  ///
  /// Always compute#commitmentList for lists of commitments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  CommitmentListWarning? warning;

  CommitmentList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  CommitmentList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Commitment>((value) => Commitment.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? CommitmentListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class CommitmentsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  CommitmentsScopedListWarningData({
    this.key,
    this.value,
  });

  CommitmentsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of commitments when the list
/// is empty.
///
/// Output only.
class CommitmentsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<CommitmentsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  CommitmentsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  CommitmentsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<CommitmentsScopedListWarningData>((value) =>
                      CommitmentsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class CommitmentsScopedList {
  /// A list of commitments contained in this scope.
  ///
  /// Output only.
  core.List<Commitment>? commitments;

  /// Informational warning which replaces the list of commitments when the list
  /// is empty.
  ///
  /// Output only.
  CommitmentsScopedListWarning? warning;

  CommitmentsScopedList({
    this.commitments,
    this.warning,
  });

  CommitmentsScopedList.fromJson(core.Map _json)
      : this(
          commitments: _json.containsKey('commitments')
              ? (_json['commitments'] as core.List)
                  .map<Commitment>((value) => Commitment.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? CommitmentsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (commitments != null)
          'commitments': commitments!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// This is deprecated and has no effect.
///
/// Do not use.
class Condition {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  /// Possible string values are:
  /// - "APPROVER" : This is deprecated and has no effect. Do not use.
  /// - "ATTRIBUTION" : This is deprecated and has no effect. Do not use.
  /// - "AUTHORITY" : This is deprecated and has no effect. Do not use.
  /// - "CREDENTIALS_TYPE" : This is deprecated and has no effect. Do not use.
  /// - "CREDS_ASSERTION" : This is deprecated and has no effect. Do not use.
  /// - "JUSTIFICATION_TYPE" : This is deprecated and has no effect. Do not use.
  /// - "NO_ATTR" : This is deprecated and has no effect. Do not use.
  /// - "SECURITY_REALM" : This is deprecated and has no effect. Do not use.
  core.String? iam;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  /// Possible string values are:
  /// - "DISCHARGED" : This is deprecated and has no effect. Do not use.
  /// - "EQUALS" : This is deprecated and has no effect. Do not use.
  /// - "IN" : This is deprecated and has no effect. Do not use.
  /// - "NOT_EQUALS" : This is deprecated and has no effect. Do not use.
  /// - "NOT_IN" : This is deprecated and has no effect. Do not use.
  /// - "NO_OP" : This is deprecated and has no effect. Do not use.
  core.String? op;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.String? svc;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  /// Possible string values are:
  /// - "IP" : This is deprecated and has no effect. Do not use.
  /// - "NAME" : This is deprecated and has no effect. Do not use.
  /// - "NO_ATTR" : This is deprecated and has no effect. Do not use.
  /// - "REGION" : This is deprecated and has no effect. Do not use.
  /// - "SERVICE" : This is deprecated and has no effect. Do not use.
  core.String? sys;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<core.String>? values;

  Condition({
    this.iam,
    this.op,
    this.svc,
    this.sys,
    this.values,
  });

  Condition.fromJson(core.Map _json)
      : this(
          iam: _json.containsKey('iam') ? _json['iam'] as core.String : null,
          op: _json.containsKey('op') ? _json['op'] as core.String : null,
          svc: _json.containsKey('svc') ? _json['svc'] as core.String : null,
          sys: _json.containsKey('sys') ? _json['sys'] as core.String : null,
          values: _json.containsKey('values')
              ? (_json['values'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (iam != null) 'iam': iam!,
        if (op != null) 'op': op!,
        if (svc != null) 'svc': svc!,
        if (sys != null) 'sys': sys!,
        if (values != null) 'values': values!,
      };
}

/// A set of Confidential Instance options.
class ConfidentialInstanceConfig {
  /// Defines whether the instance should have confidential compute enabled.
  core.bool? enableConfidentialCompute;

  ConfidentialInstanceConfig({
    this.enableConfidentialCompute,
  });

  ConfidentialInstanceConfig.fromJson(core.Map _json)
      : this(
          enableConfidentialCompute:
              _json.containsKey('enableConfidentialCompute')
                  ? _json['enableConfidentialCompute'] as core.bool
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableConfidentialCompute != null)
          'enableConfidentialCompute': enableConfidentialCompute!,
      };
}

/// Message containing connection draining configuration.
class ConnectionDraining {
  /// Configures a duration timeout for existing requests on a removed backend
  /// instance.
  ///
  /// For supported load balancers and protocols, as described in Enabling
  /// connection draining.
  core.int? drainingTimeoutSec;

  ConnectionDraining({
    this.drainingTimeoutSec,
  });

  ConnectionDraining.fromJson(core.Map _json)
      : this(
          drainingTimeoutSec: _json.containsKey('drainingTimeoutSec')
              ? _json['drainingTimeoutSec'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (drainingTimeoutSec != null)
          'drainingTimeoutSec': drainingTimeoutSec!,
      };
}

/// This message defines settings for a consistent hash style load balancer.
class ConsistentHashLoadBalancerSettings {
  /// Hash is based on HTTP Cookie.
  ///
  /// This field describes a HTTP cookie that will be used as the hash key for
  /// the consistent hash load balancer. If the cookie is not present, it will
  /// be generated. This field is applicable if the sessionAffinity is set to
  /// HTTP_COOKIE.
  ConsistentHashLoadBalancerSettingsHttpCookie? httpCookie;

  /// The hash based on the value of the specified header field.
  ///
  /// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
  core.String? httpHeaderName;

  /// The minimum number of virtual nodes to use for the hash ring.
  ///
  /// Defaults to 1024. Larger ring sizes result in more granular load
  /// distributions. If the number of hosts in the load balancing pool is larger
  /// than the ring size, each host will be assigned a single virtual node.
  core.String? minimumRingSize;

  ConsistentHashLoadBalancerSettings({
    this.httpCookie,
    this.httpHeaderName,
    this.minimumRingSize,
  });

  ConsistentHashLoadBalancerSettings.fromJson(core.Map _json)
      : this(
          httpCookie: _json.containsKey('httpCookie')
              ? ConsistentHashLoadBalancerSettingsHttpCookie.fromJson(
                  _json['httpCookie'] as core.Map<core.String, core.dynamic>)
              : null,
          httpHeaderName: _json.containsKey('httpHeaderName')
              ? _json['httpHeaderName'] as core.String
              : null,
          minimumRingSize: _json.containsKey('minimumRingSize')
              ? _json['minimumRingSize'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (httpCookie != null) 'httpCookie': httpCookie!.toJson(),
        if (httpHeaderName != null) 'httpHeaderName': httpHeaderName!,
        if (minimumRingSize != null) 'minimumRingSize': minimumRingSize!,
      };
}

/// The information about the HTTP Cookie on which the hash function is based
/// for load balancing policies that use a consistent hash.
class ConsistentHashLoadBalancerSettingsHttpCookie {
  /// Name of the cookie.
  core.String? name;

  /// Path to set for the cookie.
  core.String? path;

  /// Lifetime of the cookie.
  Duration? ttl;

  ConsistentHashLoadBalancerSettingsHttpCookie({
    this.name,
    this.path,
    this.ttl,
  });

  ConsistentHashLoadBalancerSettingsHttpCookie.fromJson(core.Map _json)
      : this(
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          path: _json.containsKey('path') ? _json['path'] as core.String : null,
          ttl: _json.containsKey('ttl')
              ? Duration.fromJson(
                  _json['ttl'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (path != null) 'path': path!,
        if (ttl != null) 'ttl': ttl!.toJson(),
      };
}

/// The specification for allowing client side cross-origin requests.
///
/// Please see W3C Recommendation for Cross Origin Resource Sharing
class CorsPolicy {
  /// In response to a preflight request, setting this to true indicates that
  /// the actual request can include user credentials.
  ///
  /// This translates to the Access-Control-Allow-Credentials header. Default is
  /// false.
  core.bool? allowCredentials;

  /// Specifies the content for the Access-Control-Allow-Headers header.
  core.List<core.String>? allowHeaders;

  /// Specifies the content for the Access-Control-Allow-Methods header.
  core.List<core.String>? allowMethods;

  /// Specifies the regualar expression patterns that match allowed origins.
  ///
  /// For regular expression grammar please see
  /// github.com/google/re2/wiki/Syntax An origin is allowed if it matches
  /// either an item in allowOrigins or an item in allowOriginRegexes.
  core.List<core.String>? allowOriginRegexes;

  /// Specifies the list of origins that will be allowed to do CORS requests.
  ///
  /// An origin is allowed if it matches either an item in allowOrigins or an
  /// item in allowOriginRegexes.
  core.List<core.String>? allowOrigins;

  /// If true, specifies the CORS policy is disabled.
  ///
  /// The default value of false, which indicates that the CORS policy is in
  /// effect.
  core.bool? disabled;

  /// Specifies the content for the Access-Control-Expose-Headers header.
  core.List<core.String>? exposeHeaders;

  /// Specifies how long results of a preflight request can be cached in
  /// seconds.
  ///
  /// This translates to the Access-Control-Max-Age header.
  core.int? maxAge;

  CorsPolicy({
    this.allowCredentials,
    this.allowHeaders,
    this.allowMethods,
    this.allowOriginRegexes,
    this.allowOrigins,
    this.disabled,
    this.exposeHeaders,
    this.maxAge,
  });

  CorsPolicy.fromJson(core.Map _json)
      : this(
          allowCredentials: _json.containsKey('allowCredentials')
              ? _json['allowCredentials'] as core.bool
              : null,
          allowHeaders: _json.containsKey('allowHeaders')
              ? (_json['allowHeaders'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          allowMethods: _json.containsKey('allowMethods')
              ? (_json['allowMethods'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          allowOriginRegexes: _json.containsKey('allowOriginRegexes')
              ? (_json['allowOriginRegexes'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          allowOrigins: _json.containsKey('allowOrigins')
              ? (_json['allowOrigins'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          disabled: _json.containsKey('disabled')
              ? _json['disabled'] as core.bool
              : null,
          exposeHeaders: _json.containsKey('exposeHeaders')
              ? (_json['exposeHeaders'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          maxAge:
              _json.containsKey('maxAge') ? _json['maxAge'] as core.int : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowCredentials != null) 'allowCredentials': allowCredentials!,
        if (allowHeaders != null) 'allowHeaders': allowHeaders!,
        if (allowMethods != null) 'allowMethods': allowMethods!,
        if (allowOriginRegexes != null)
          'allowOriginRegexes': allowOriginRegexes!,
        if (allowOrigins != null) 'allowOrigins': allowOrigins!,
        if (disabled != null) 'disabled': disabled!,
        if (exposeHeaders != null) 'exposeHeaders': exposeHeaders!,
        if (maxAge != null) 'maxAge': maxAge!,
      };
}

class CustomerEncryptionKey {
  /// The name of the encryption key that is stored in Google Cloud KMS.
  core.String? kmsKeyName;

  /// The service account being used for the encryption request for the given
  /// KMS key.
  ///
  /// If absent, the Compute Engine default service account is used.
  core.String? kmsKeyServiceAccount;

  /// Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648
  /// base64 to either encrypt or decrypt this resource.
  core.String? rawKey;

  /// Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
  /// customer-supplied encryption key to either encrypt or decrypt this
  /// resource.
  ///
  /// The key must meet the following requirements before you can provide it to
  /// Compute Engine: 1. The key is wrapped using a RSA public key certificate
  /// provided by Google. 2. After being wrapped, the key must be encoded in RFC
  /// 4648 base64 encoding. Gets the RSA public key certificate provided by
  /// Google at:
  /// https://cloud-certs.storage.googleapis.com/google-cloud-csek-ingress.pem
  core.String? rsaEncryptedKey;

  /// The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
  /// encryption key that protects this resource.
  ///
  /// Output only.
  core.String? sha256;

  CustomerEncryptionKey({
    this.kmsKeyName,
    this.kmsKeyServiceAccount,
    this.rawKey,
    this.rsaEncryptedKey,
    this.sha256,
  });

  CustomerEncryptionKey.fromJson(core.Map _json)
      : this(
          kmsKeyName: _json.containsKey('kmsKeyName')
              ? _json['kmsKeyName'] as core.String
              : null,
          kmsKeyServiceAccount: _json.containsKey('kmsKeyServiceAccount')
              ? _json['kmsKeyServiceAccount'] as core.String
              : null,
          rawKey: _json.containsKey('rawKey')
              ? _json['rawKey'] as core.String
              : null,
          rsaEncryptedKey: _json.containsKey('rsaEncryptedKey')
              ? _json['rsaEncryptedKey'] as core.String
              : null,
          sha256: _json.containsKey('sha256')
              ? _json['sha256'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
        if (kmsKeyServiceAccount != null)
          'kmsKeyServiceAccount': kmsKeyServiceAccount!,
        if (rawKey != null) 'rawKey': rawKey!,
        if (rsaEncryptedKey != null) 'rsaEncryptedKey': rsaEncryptedKey!,
        if (sha256 != null) 'sha256': sha256!,
      };
}

class CustomerEncryptionKeyProtectedDisk {
  /// Decrypts data associated with the disk with a customer-supplied encryption
  /// key.
  CustomerEncryptionKey? diskEncryptionKey;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource.
  ///
  /// This field is only applicable for persistent disks.
  core.String? source;

  CustomerEncryptionKeyProtectedDisk({
    this.diskEncryptionKey,
    this.source,
  });

  CustomerEncryptionKeyProtectedDisk.fromJson(core.Map _json)
      : this(
          diskEncryptionKey: _json.containsKey('diskEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['diskEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          source: _json.containsKey('source')
              ? _json['source'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskEncryptionKey != null)
          'diskEncryptionKey': diskEncryptionKey!.toJson(),
        if (source != null) 'source': source!,
      };
}

/// Deprecation status for a public resource.
class DeprecationStatus {
  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DELETED.
  ///
  /// This is only informational and the status will not change unless the
  /// client explicitly changes it.
  core.String? deleted;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DEPRECATED.
  ///
  /// This is only informational and the status will not change unless the
  /// client explicitly changes it.
  core.String? deprecated;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to OBSOLETE.
  ///
  /// This is only informational and the status will not change unless the
  /// client explicitly changes it.
  core.String? obsolete;

  /// The URL of the suggested replacement for a deprecated resource.
  ///
  /// The suggested replacement resource must be the same kind of resource as
  /// the deprecated resource.
  core.String? replacement;

  /// The deprecation state of this resource.
  ///
  /// This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED. Operations which
  /// communicate the end of life date for an image, can use ACTIVE. Operations
  /// which create a new resource using a DEPRECATED resource will return
  /// successfully, but with a warning indicating the deprecated resource and
  /// recommending its replacement. Operations which use OBSOLETE or DELETED
  /// resources will be rejected and result in an error.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DELETED"
  /// - "DEPRECATED"
  /// - "OBSOLETE"
  core.String? state;

  DeprecationStatus({
    this.deleted,
    this.deprecated,
    this.obsolete,
    this.replacement,
    this.state,
  });

  DeprecationStatus.fromJson(core.Map _json)
      : this(
          deleted: _json.containsKey('deleted')
              ? _json['deleted'] as core.String
              : null,
          deprecated: _json.containsKey('deprecated')
              ? _json['deprecated'] as core.String
              : null,
          obsolete: _json.containsKey('obsolete')
              ? _json['obsolete'] as core.String
              : null,
          replacement: _json.containsKey('replacement')
              ? _json['replacement'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deleted != null) 'deleted': deleted!,
        if (deprecated != null) 'deprecated': deprecated!,
        if (obsolete != null) 'obsolete': obsolete!,
        if (replacement != null) 'replacement': replacement!,
        if (state != null) 'state': state!,
      };
}

/// Represents a Persistent Disk resource.
///
/// Google Compute Engine has two Disk resources: *
/// \[Zonal\](/compute/docs/reference/rest/v1/disks) *
/// \[Regional\](/compute/docs/reference/rest/v1/regionDisks) Persistent disks
/// are required for running your VM instances. Create both boot and non-boot
/// (data) persistent disks. For more information, read Persistent Disks. For
/// more storage options, read Storage options. The disks resource represents a
/// zonal persistent disk. For more information, read Zonal persistent disks.
/// The regionDisks resource represents a regional persistent disk. For more
/// information, read Regional resources.
class Disk {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Encrypts the disk using a customer-supplied encryption key or a
  /// customer-managed encryption key.
  ///
  /// Encryption keys do not protect access to metadata of the disk. After you
  /// encrypt a disk with a customer-supplied key, you must provide the same key
  /// if you use the disk later. For example, to create a disk snapshot, to
  /// create a disk image, to create a machine image, or to attach the disk to a
  /// virtual machine. After you encrypt a disk with a customer-managed key, the
  /// diskEncryptionKey.kmsKeyName is set to a key *version* name once the disk
  /// is created. The disk is encrypted with this version of the key. In the
  /// response, diskEncryptionKey.kmsKeyName appears in the following format:
  /// "diskEncryptionKey.kmsKeyName":
  /// "projects/kms_project_id/locations/region/keyRings/
  /// key_region/cryptoKeys/key /cryptoKeysVersions/version If you do not
  /// provide an encryption key when creating the disk, then the disk is
  /// encrypted using an automatically generated key and you don't need to
  /// provide a key to use the disk later.
  CustomerEncryptionKey? diskEncryptionKey;

  /// A list of features to enable on the guest operating system.
  ///
  /// Applicable only for bootable images. Read Enabling guest operating system
  /// features to see a list of available options.
  core.List<GuestOsFeature>? guestOsFeatures;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#disk for disks.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this disk, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve a disk.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this disk.
  ///
  /// These can be later modified by the setLabels method.
  core.Map<core.String, core.String>? labels;

  /// Last attach timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastAttachTimestamp;

  /// Last detach timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastDetachTimestamp;

  /// Integer license codes indicating which licenses are attached to this disk.
  core.List<core.String>? licenseCodes;

  /// A list of publicly visible licenses.
  ///
  /// Reserved for Google's use.
  core.List<core.String>? licenses;

  /// An opaque location hint used to place the disk close to other resources.
  ///
  /// This field is for use by internal tools that use the public API.
  core.String? locationHint;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Internal use only.
  core.String? options;

  /// Physical block size of the persistent disk, in bytes.
  ///
  /// If not present in a request, a default value is used. The currently
  /// supported size is 4096, other sizes may be added in the future. If an
  /// unsupported value is requested, the error message will list the supported
  /// values for the caller's project.
  core.String? physicalBlockSizeBytes;

  /// Indicates how many IOPS to provision for the disk.
  ///
  /// This sets the number of I/O operations per second that the disk can
  /// handle. Values must be between 10,000 and 120,000. For more details, see
  /// the Extreme persistent disk documentation.
  core.String? provisionedIops;

  /// URL of the region where the disk resides.
  ///
  /// Only applicable for regional resources. You must specify this field as
  /// part of the HTTP request URL. It is not settable as a field in the request
  /// body.
  ///
  /// Output only.
  core.String? region;

  /// URLs of the zones where the disk should be replicated to.
  ///
  /// Only applicable for regional resources.
  core.List<core.String>? replicaZones;

  /// Resource policies applied to this disk for automatic snapshot creations.
  core.List<core.String>? resourcePolicies;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Size, in GB, of the persistent disk.
  ///
  /// You can specify this field when creating a persistent disk using the
  /// sourceImage, sourceSnapshot, or sourceDisk parameter, or specify it alone
  /// to create an empty persistent disk. If you specify this field along with a
  /// source, the value of sizeGb must not be less than the size of the source.
  /// Acceptable values are 1 to 65536, inclusive.
  core.String? sizeGb;

  /// The source disk used to create this disk.
  ///
  /// You can provide this as a partial or full URL to the resource. For
  /// example, the following are valid values: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /disks/disk -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /disks/disk - projects/project/zones/zone/disks/disk -
  /// projects/project/regions/region/disks/disk - zones/zone/disks/disk -
  /// regions/region/disks/disk
  core.String? sourceDisk;

  /// The unique ID of the disk used to create this disk.
  ///
  /// This value identifies the exact disk that was used to create this
  /// persistent disk. For example, if you created the persistent disk from a
  /// disk that was later deleted and recreated under the same name, the source
  /// disk ID would identify the exact version of the disk that was used.
  ///
  /// Output only.
  core.String? sourceDiskId;

  /// The source image used to create this disk.
  ///
  /// If the source image is deleted, this field will not be set. To create a
  /// disk with one of the public operating system images, specify the image by
  /// its family name. For example, specify family/debian-9 to use the latest
  /// Debian 9 image: projects/debian-cloud/global/images/family/debian-9
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD To create a
  /// disk with a custom image that you created, specify the image name in the
  /// following format: global/images/my-custom-image You can also specify a
  /// custom image by its image family, which returns the latest version of the
  /// image in that family. Replace the image name with family/family-name:
  /// global/images/family/my-image-family
  core.String? sourceImage;

  /// The customer-supplied encryption key of the source image.
  ///
  /// Required if the source image is protected by a customer-supplied
  /// encryption key.
  CustomerEncryptionKey? sourceImageEncryptionKey;

  /// The ID value of the image used to create this disk.
  ///
  /// This value identifies the exact image that was used to create this
  /// persistent disk. For example, if you created the persistent disk from an
  /// image that was later deleted and recreated under the same name, the source
  /// image ID would identify the exact version of the image that was used.
  ///
  /// Output only.
  core.String? sourceImageId;

  /// The source snapshot used to create this disk.
  ///
  /// You can provide this as a partial or full URL to the resource. For
  /// example, the following are valid values: -
  /// https://www.googleapis.com/compute/v1/projects/project
  /// /global/snapshots/snapshot - projects/project/global/snapshots/snapshot -
  /// global/snapshots/snapshot
  core.String? sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot.
  ///
  /// Required if the source snapshot is protected by a customer-supplied
  /// encryption key.
  CustomerEncryptionKey? sourceSnapshotEncryptionKey;

  /// The unique ID of the snapshot used to create this disk.
  ///
  /// This value identifies the exact snapshot that was used to create this
  /// persistent disk. For example, if you created the persistent disk from a
  /// snapshot that was later deleted and recreated under the same name, the
  /// source snapshot ID would identify the exact version of the snapshot that
  /// was used.
  ///
  /// Output only.
  core.String? sourceSnapshotId;

  /// The full Google Cloud Storage URI where the disk image is stored.
  ///
  /// This file must be a gzip-compressed tarball whose name ends in .tar.gz or
  /// virtual machine disk whose name ends in vmdk. Valid URIs may start with
  /// gs:// or https://storage.googleapis.com/. This flag is not optimized for
  /// creating multiple disks from a source storage object. To create many disks
  /// from a source storage object, use gcloud compute images import instead.
  core.String? sourceStorageObject;

  /// The status of disk creation.
  ///
  /// - CREATING: Disk is provisioning. - RESTORING: Source data is being copied
  /// into the disk. - FAILED: Disk creation failed. - READY: Disk is ready for
  /// use. - DELETING: Disk is deleting.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING" : Disk is provisioning
  /// - "DELETING" : Disk is deleting.
  /// - "FAILED" : Disk creation failed.
  /// - "READY" : Disk is ready for use.
  /// - "RESTORING" : Source data is being copied into the disk.
  core.String? status;

  /// URL of the disk type resource describing which disk type to use to create
  /// the disk.
  ///
  /// Provide this when creating the disk. For example: projects/project
  /// /zones/zone/diskTypes/pd-ssd . See Persistent disk types.
  core.String? type;

  /// Links to the users of the disk (attached instances) in form:
  /// projects/project/zones/zone/instances/instance
  ///
  /// Output only.
  core.List<core.String>? users;

  /// URL of the zone where the disk resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  Disk({
    this.creationTimestamp,
    this.description,
    this.diskEncryptionKey,
    this.guestOsFeatures,
    this.id,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.lastAttachTimestamp,
    this.lastDetachTimestamp,
    this.licenseCodes,
    this.licenses,
    this.locationHint,
    this.name,
    this.options,
    this.physicalBlockSizeBytes,
    this.provisionedIops,
    this.region,
    this.replicaZones,
    this.resourcePolicies,
    this.satisfiesPzs,
    this.selfLink,
    this.sizeGb,
    this.sourceDisk,
    this.sourceDiskId,
    this.sourceImage,
    this.sourceImageEncryptionKey,
    this.sourceImageId,
    this.sourceSnapshot,
    this.sourceSnapshotEncryptionKey,
    this.sourceSnapshotId,
    this.sourceStorageObject,
    this.status,
    this.type,
    this.users,
    this.zone,
  });

  Disk.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          diskEncryptionKey: _json.containsKey('diskEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['diskEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          guestOsFeatures: _json.containsKey('guestOsFeatures')
              ? (_json['guestOsFeatures'] as core.List)
                  .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          lastAttachTimestamp: _json.containsKey('lastAttachTimestamp')
              ? _json['lastAttachTimestamp'] as core.String
              : null,
          lastDetachTimestamp: _json.containsKey('lastDetachTimestamp')
              ? _json['lastDetachTimestamp'] as core.String
              : null,
          licenseCodes: _json.containsKey('licenseCodes')
              ? (_json['licenseCodes'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          licenses: _json.containsKey('licenses')
              ? (_json['licenses'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          locationHint: _json.containsKey('locationHint')
              ? _json['locationHint'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          options: _json.containsKey('options')
              ? _json['options'] as core.String
              : null,
          physicalBlockSizeBytes: _json.containsKey('physicalBlockSizeBytes')
              ? _json['physicalBlockSizeBytes'] as core.String
              : null,
          provisionedIops: _json.containsKey('provisionedIops')
              ? _json['provisionedIops'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          replicaZones: _json.containsKey('replicaZones')
              ? (_json['replicaZones'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          satisfiesPzs: _json.containsKey('satisfiesPzs')
              ? _json['satisfiesPzs'] as core.bool
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          sizeGb: _json.containsKey('sizeGb')
              ? _json['sizeGb'] as core.String
              : null,
          sourceDisk: _json.containsKey('sourceDisk')
              ? _json['sourceDisk'] as core.String
              : null,
          sourceDiskId: _json.containsKey('sourceDiskId')
              ? _json['sourceDiskId'] as core.String
              : null,
          sourceImage: _json.containsKey('sourceImage')
              ? _json['sourceImage'] as core.String
              : null,
          sourceImageEncryptionKey: _json
                  .containsKey('sourceImageEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['sourceImageEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          sourceImageId: _json.containsKey('sourceImageId')
              ? _json['sourceImageId'] as core.String
              : null,
          sourceSnapshot: _json.containsKey('sourceSnapshot')
              ? _json['sourceSnapshot'] as core.String
              : null,
          sourceSnapshotEncryptionKey:
              _json.containsKey('sourceSnapshotEncryptionKey')
                  ? CustomerEncryptionKey.fromJson(
                      _json['sourceSnapshotEncryptionKey']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          sourceSnapshotId: _json.containsKey('sourceSnapshotId')
              ? _json['sourceSnapshotId'] as core.String
              : null,
          sourceStorageObject: _json.containsKey('sourceStorageObject')
              ? _json['sourceStorageObject'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
          users: _json.containsKey('users')
              ? (_json['users'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (diskEncryptionKey != null)
          'diskEncryptionKey': diskEncryptionKey!.toJson(),
        if (guestOsFeatures != null)
          'guestOsFeatures':
              guestOsFeatures!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (lastAttachTimestamp != null)
          'lastAttachTimestamp': lastAttachTimestamp!,
        if (lastDetachTimestamp != null)
          'lastDetachTimestamp': lastDetachTimestamp!,
        if (licenseCodes != null) 'licenseCodes': licenseCodes!,
        if (licenses != null) 'licenses': licenses!,
        if (locationHint != null) 'locationHint': locationHint!,
        if (name != null) 'name': name!,
        if (options != null) 'options': options!,
        if (physicalBlockSizeBytes != null)
          'physicalBlockSizeBytes': physicalBlockSizeBytes!,
        if (provisionedIops != null) 'provisionedIops': provisionedIops!,
        if (region != null) 'region': region!,
        if (replicaZones != null) 'replicaZones': replicaZones!,
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sizeGb != null) 'sizeGb': sizeGb!,
        if (sourceDisk != null) 'sourceDisk': sourceDisk!,
        if (sourceDiskId != null) 'sourceDiskId': sourceDiskId!,
        if (sourceImage != null) 'sourceImage': sourceImage!,
        if (sourceImageEncryptionKey != null)
          'sourceImageEncryptionKey': sourceImageEncryptionKey!.toJson(),
        if (sourceImageId != null) 'sourceImageId': sourceImageId!,
        if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
        if (sourceSnapshotEncryptionKey != null)
          'sourceSnapshotEncryptionKey': sourceSnapshotEncryptionKey!.toJson(),
        if (sourceSnapshotId != null) 'sourceSnapshotId': sourceSnapshotId!,
        if (sourceStorageObject != null)
          'sourceStorageObject': sourceStorageObject!,
        if (status != null) 'status': status!,
        if (type != null) 'type': type!,
        if (users != null) 'users': users!,
        if (zone != null) 'zone': zone!,
      };
}

class DiskAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskAggregatedListWarningData({
    this.key,
    this.value,
  });

  DiskAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class DiskAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  DiskAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<DiskAggregatedListWarningData>((value) =>
                      DiskAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class DiskAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of DisksScopedList resources.
  core.Map<core.String, DisksScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#diskAggregatedList for aggregated lists of persistent
  /// disks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  DiskAggregatedListWarning? warning;

  DiskAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  DiskAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    DisksScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? DiskAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A specification of the desired way to instantiate a disk in the instance
/// template when its created from a source instance.
class DiskInstantiationConfig {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool? autoDelete;

  /// The custom source image to be used to restore this disk when instantiating
  /// this instance template.
  core.String? customImage;

  /// Specifies the device name of the disk to which the configurations apply
  /// to.
  core.String? deviceName;

  /// Specifies whether to include the disk and what image to use.
  ///
  /// Possible values are: - source-image: to use the same image that was used
  /// to create the source instance's corresponding disk. Applicable to the boot
  /// disk and additional read-write disks. - source-image-family: to use the
  /// same image family that was used to create the source instance's
  /// corresponding disk. Applicable to the boot disk and additional read-write
  /// disks. - custom-image: to use a user-provided image url for disk creation.
  /// Applicable to the boot disk and additional read-write disks. -
  /// attach-read-only: to attach a read-only disk. Applicable to read-only
  /// disks. - do-not-include: to exclude a disk from the template. Applicable
  /// to additional read-write disks, local SSDs, and read-only disks.
  /// Possible string values are:
  /// - "ATTACH_READ_ONLY" : Attach the existing disk in read-only mode. The
  /// request will fail if the disk was attached in read-write mode on the
  /// source instance. Applicable to: read-only disks.
  /// - "BLANK" : Create a blank disk. The disk will be created unformatted.
  /// Applicable to: additional read-write disks, local SSDs.
  /// - "CUSTOM_IMAGE" : Use the custom image specified in the custom_image
  /// field. Applicable to: boot disk, additional read-write disks.
  /// - "DEFAULT" : Use the default instantiation option for the corresponding
  /// type of disk. For boot disk and any other R/W disks, new custom images
  /// will be created from each disk. For read-only disks, they will be attached
  /// in read-only mode. Local SSD disks will be created as blank volumes.
  /// - "DO_NOT_INCLUDE" : Do not include the disk in the instance template.
  /// Applicable to: additional read-write disks, local SSDs, read-only disks.
  /// - "SOURCE_IMAGE" : Use the same source image used for creation of the
  /// source instance's corresponding disk. The request will fail if the source
  /// VM's disk was created from a snapshot. Applicable to: boot disk,
  /// additional read-write disks.
  /// - "SOURCE_IMAGE_FAMILY" : Use the same source image family used for
  /// creation of the source instance's corresponding disk. The request will
  /// fail if the source image of the source disk does not belong to any image
  /// family. Applicable to: boot disk, additional read-write disks.
  core.String? instantiateFrom;

  DiskInstantiationConfig({
    this.autoDelete,
    this.customImage,
    this.deviceName,
    this.instantiateFrom,
  });

  DiskInstantiationConfig.fromJson(core.Map _json)
      : this(
          autoDelete: _json.containsKey('autoDelete')
              ? _json['autoDelete'] as core.bool
              : null,
          customImage: _json.containsKey('customImage')
              ? _json['customImage'] as core.String
              : null,
          deviceName: _json.containsKey('deviceName')
              ? _json['deviceName'] as core.String
              : null,
          instantiateFrom: _json.containsKey('instantiateFrom')
              ? _json['instantiateFrom'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoDelete != null) 'autoDelete': autoDelete!,
        if (customImage != null) 'customImage': customImage!,
        if (deviceName != null) 'deviceName': deviceName!,
        if (instantiateFrom != null) 'instantiateFrom': instantiateFrom!,
      };
}

class DiskListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskListWarningData({
    this.key,
    this.value,
  });

  DiskListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class DiskListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskListWarning({
    this.code,
    this.data,
    this.message,
  });

  DiskListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<DiskListWarningData>((value) =>
                      DiskListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of Disk resources.
class DiskList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Disk resources.
  core.List<Disk>? items;

  /// Type of resource.
  ///
  /// Always compute#diskList for lists of disks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  DiskListWarning? warning;

  DiskList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  DiskList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Disk>((value) => Disk.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? DiskListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class DiskMoveRequest {
  /// The URL of the destination zone to move the disk.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a zone: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone -
  /// projects/project/zones/zone - zones/zone
  core.String? destinationZone;

  /// The URL of the target disk to move.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a disk: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /disks/disk - projects/project/zones/zone/disks/disk -
  /// zones/zone/disks/disk
  core.String? targetDisk;

  DiskMoveRequest({
    this.destinationZone,
    this.targetDisk,
  });

  DiskMoveRequest.fromJson(core.Map _json)
      : this(
          destinationZone: _json.containsKey('destinationZone')
              ? _json['destinationZone'] as core.String
              : null,
          targetDisk: _json.containsKey('targetDisk')
              ? _json['targetDisk'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (destinationZone != null) 'destinationZone': destinationZone!,
        if (targetDisk != null) 'targetDisk': targetDisk!,
      };
}

/// Represents a Disk Type resource.
///
/// Google Compute Engine has two Disk Type resources: *
/// \[Regional\](/compute/docs/reference/rest/v1/regionDiskTypes) *
/// \[Zonal\](/compute/docs/reference/rest/v1/diskTypes) You can choose from a
/// variety of disk types based on your needs. For more information, read
/// Storage options. The diskTypes resource represents disk types for a zonal
/// persistent disk. For more information, read Zonal persistent disks. The
/// regionDiskTypes resource represents disk types for a regional persistent
/// disk. For more information, read Regional persistent disks.
class DiskType {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Server-defined default disk size in GB.
  ///
  /// Output only.
  core.String? defaultDiskSizeGb;

  /// The deprecation status associated with this disk type.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// An optional description of this resource.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#diskType for disk types.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// URL of the region where the disk type resides.
  ///
  /// Only applicable for regional resources. You must specify this field as
  /// part of the HTTP request URL. It is not settable as a field in the request
  /// body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// An optional textual description of the valid disk size, such as
  /// "10GB-10TB".
  ///
  /// Output only.
  core.String? validDiskSize;

  /// URL of the zone where the disk type resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  DiskType({
    this.creationTimestamp,
    this.defaultDiskSizeGb,
    this.deprecated,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.region,
    this.selfLink,
    this.validDiskSize,
    this.zone,
  });

  DiskType.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          defaultDiskSizeGb: _json.containsKey('defaultDiskSizeGb')
              ? _json['defaultDiskSizeGb'] as core.String
              : null,
          deprecated: _json.containsKey('deprecated')
              ? DeprecationStatus.fromJson(
                  _json['deprecated'] as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          validDiskSize: _json.containsKey('validDiskSize')
              ? _json['validDiskSize'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (defaultDiskSizeGb != null) 'defaultDiskSizeGb': defaultDiskSizeGb!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (validDiskSize != null) 'validDiskSize': validDiskSize!,
        if (zone != null) 'zone': zone!,
      };
}

class DiskTypeAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskTypeAggregatedListWarningData({
    this.key,
    this.value,
  });

  DiskTypeAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class DiskTypeAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskTypeAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskTypeAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  DiskTypeAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<DiskTypeAggregatedListWarningData>((value) =>
                      DiskTypeAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class DiskTypeAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of DiskTypesScopedList resources.
  core.Map<core.String, DiskTypesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#diskTypeAggregatedList.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  DiskTypeAggregatedListWarning? warning;

  DiskTypeAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  DiskTypeAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    DiskTypesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? DiskTypeAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class DiskTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskTypeListWarningData({
    this.key,
    this.value,
  });

  DiskTypeListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class DiskTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskTypeListWarning({
    this.code,
    this.data,
    this.message,
  });

  DiskTypeListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<DiskTypeListWarningData>((value) =>
                      DiskTypeListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of disk types.
class DiskTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of DiskType resources.
  core.List<DiskType>? items;

  /// Type of resource.
  ///
  /// Always compute#diskTypeList for disk types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  DiskTypeListWarning? warning;

  DiskTypeList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  DiskTypeList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<DiskType>((value) => DiskType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? DiskTypeListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class DiskTypesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskTypesScopedListWarningData({
    this.key,
    this.value,
  });

  DiskTypesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of disk types when the list is
/// empty.
///
/// Output only.
class DiskTypesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskTypesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskTypesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  DiskTypesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<DiskTypesScopedListWarningData>((value) =>
                      DiskTypesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class DiskTypesScopedList {
  /// A list of disk types contained in this scope.
  ///
  /// Output only.
  core.List<DiskType>? diskTypes;

  /// Informational warning which replaces the list of disk types when the list
  /// is empty.
  ///
  /// Output only.
  DiskTypesScopedListWarning? warning;

  DiskTypesScopedList({
    this.diskTypes,
    this.warning,
  });

  DiskTypesScopedList.fromJson(core.Map _json)
      : this(
          diskTypes: _json.containsKey('diskTypes')
              ? (_json['diskTypes'] as core.List)
                  .map<DiskType>((value) => DiskType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? DiskTypesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskTypes != null)
          'diskTypes': diskTypes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class DisksAddResourcePoliciesRequest {
  /// Full or relative path to the resource policy to be added to this disk.
  ///
  /// You can only specify one resource policy.
  core.List<core.String>? resourcePolicies;

  DisksAddResourcePoliciesRequest({
    this.resourcePolicies,
  });

  DisksAddResourcePoliciesRequest.fromJson(core.Map _json)
      : this(
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class DisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String>? resourcePolicies;

  DisksRemoveResourcePoliciesRequest({
    this.resourcePolicies,
  });

  DisksRemoveResourcePoliciesRequest.fromJson(core.Map _json)
      : this(
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class DisksResizeRequest {
  /// The new size of the persistent disk, which is specified in GB.
  core.String? sizeGb;

  DisksResizeRequest({
    this.sizeGb,
  });

  DisksResizeRequest.fromJson(core.Map _json)
      : this(
          sizeGb: _json.containsKey('sizeGb')
              ? _json['sizeGb'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sizeGb != null) 'sizeGb': sizeGb!,
      };
}

class DisksScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DisksScopedListWarningData({
    this.key,
    this.value,
  });

  DisksScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of disks when the list is
/// empty.
///
/// Output only.
class DisksScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DisksScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DisksScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  DisksScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<DisksScopedListWarningData>((value) =>
                      DisksScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class DisksScopedList {
  /// A list of disks contained in this scope.
  ///
  /// Output only.
  core.List<Disk>? disks;

  /// Informational warning which replaces the list of disks when the list is
  /// empty.
  ///
  /// Output only.
  DisksScopedListWarning? warning;

  DisksScopedList({
    this.disks,
    this.warning,
  });

  DisksScopedList.fromJson(core.Map _json)
      : this(
          disks: _json.containsKey('disks')
              ? (_json['disks'] as core.List)
                  .map<Disk>((value) => Disk.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? DisksScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A set of Display Device options
class DisplayDevice {
  /// Defines whether the instance has Display enabled.
  core.bool? enableDisplay;

  DisplayDevice({
    this.enableDisplay,
  });

  DisplayDevice.fromJson(core.Map _json)
      : this(
          enableDisplay: _json.containsKey('enableDisplay')
              ? _json['enableDisplay'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableDisplay != null) 'enableDisplay': enableDisplay!,
      };
}

class DistributionPolicy {
  /// The distribution shape to which the group converges either proactively or
  /// on resize events (depending on the value set in
  /// updatePolicy.instanceRedistributionType).
  /// Possible string values are:
  /// - "ANY" : The group picks zones for creating VM instances to fulfill the
  /// requested number of VMs within present resource constraints and to
  /// maximize utilization of unused zonal reservations. Recommended for batch
  /// workloads that do not require high availability.
  /// - "BALANCED" : The group prioritizes acquisition of resources, scheduling
  /// VMs in zones where resources are available while distributing VMs as
  /// evenly as possible across selected zones to minimize the impact of zonal
  /// failure. Recommended for highly available serving workloads.
  /// - "EVEN" : The group schedules VM instance creation and deletion to
  /// achieve and maintain an even number of managed instances across the
  /// selected zones. The distribution is even when the number of managed
  /// instances does not differ by more than 1 between any two zones.
  /// Recommended for highly available serving workloads.
  core.String? targetShape;

  /// Zones where the regional managed instance group will create and manage its
  /// instances.
  core.List<DistributionPolicyZoneConfiguration>? zones;

  DistributionPolicy({
    this.targetShape,
    this.zones,
  });

  DistributionPolicy.fromJson(core.Map _json)
      : this(
          targetShape: _json.containsKey('targetShape')
              ? _json['targetShape'] as core.String
              : null,
          zones: _json.containsKey('zones')
              ? (_json['zones'] as core.List)
                  .map<DistributionPolicyZoneConfiguration>((value) =>
                      DistributionPolicyZoneConfiguration.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetShape != null) 'targetShape': targetShape!,
        if (zones != null)
          'zones': zones!.map((value) => value.toJson()).toList(),
      };
}

class DistributionPolicyZoneConfiguration {
  /// The URL of the zone.
  ///
  /// The zone must exist in the region where the managed instance group is
  /// located.
  core.String? zone;

  DistributionPolicyZoneConfiguration({
    this.zone,
  });

  DistributionPolicyZoneConfiguration.fromJson(core.Map _json)
      : this(
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (zone != null) 'zone': zone!,
      };
}

/// A Duration represents a fixed-length span of time represented as a count of
/// seconds and fractions of seconds at nanosecond resolution.
///
/// It is independent of any calendar and concepts like "day" or "month". Range
/// is approximately 10,000 years.
class Duration {
  /// Span of time that's a fraction of a second at nanosecond resolution.
  ///
  /// Durations less than one second are represented with a 0 `seconds` field
  /// and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
  core.int? nanos;

  /// Span of time at a resolution of a second.
  ///
  /// Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are
  /// computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year *
  /// 10000 years
  core.String? seconds;

  Duration({
    this.nanos,
    this.seconds,
  });

  Duration.fromJson(core.Map _json)
      : this(
          nanos: _json.containsKey('nanos') ? _json['nanos'] as core.int : null,
          seconds: _json.containsKey('seconds')
              ? _json['seconds'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nanos != null) 'nanos': nanos!,
        if (seconds != null) 'seconds': seconds!,
      };
}

class ExchangedPeeringRoute {
  /// The destination range of the route.
  core.String? destRange;

  /// True if the peering route has been imported from a peer.
  ///
  /// The actual import happens if the field networkPeering.importCustomRoutes
  /// is true for this network, and networkPeering.exportCustomRoutes is true
  /// for the peer network, and the import does not result in a route conflict.
  core.bool? imported;

  /// The region of peering route next hop, only applies to dynamic routes.
  core.String? nextHopRegion;

  /// The priority of the peering route.
  core.int? priority;

  /// The type of the peering route.
  /// Possible string values are:
  /// - "DYNAMIC_PEERING_ROUTE" : For routes exported from local network.
  /// - "STATIC_PEERING_ROUTE" : The peering route.
  /// - "SUBNET_PEERING_ROUTE" : The peering route corresponding to subnetwork
  /// range.
  core.String? type;

  ExchangedPeeringRoute({
    this.destRange,
    this.imported,
    this.nextHopRegion,
    this.priority,
    this.type,
  });

  ExchangedPeeringRoute.fromJson(core.Map _json)
      : this(
          destRange: _json.containsKey('destRange')
              ? _json['destRange'] as core.String
              : null,
          imported: _json.containsKey('imported')
              ? _json['imported'] as core.bool
              : null,
          nextHopRegion: _json.containsKey('nextHopRegion')
              ? _json['nextHopRegion'] as core.String
              : null,
          priority: _json.containsKey('priority')
              ? _json['priority'] as core.int
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (destRange != null) 'destRange': destRange!,
        if (imported != null) 'imported': imported!,
        if (nextHopRegion != null) 'nextHopRegion': nextHopRegion!,
        if (priority != null) 'priority': priority!,
        if (type != null) 'type': type!,
      };
}

class ExchangedPeeringRoutesListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ExchangedPeeringRoutesListWarningData({
    this.key,
    this.value,
  });

  ExchangedPeeringRoutesListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ExchangedPeeringRoutesListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ExchangedPeeringRoutesListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ExchangedPeeringRoutesListWarning({
    this.code,
    this.data,
    this.message,
  });

  ExchangedPeeringRoutesListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ExchangedPeeringRoutesListWarningData>((value) =>
                      ExchangedPeeringRoutesListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ExchangedPeeringRoutesList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ExchangedPeeringRoute resources.
  core.List<ExchangedPeeringRoute>? items;

  /// Type of resource.
  ///
  /// Always compute#exchangedPeeringRoutesList for exchanged peering routes
  /// lists.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ExchangedPeeringRoutesListWarning? warning;

  ExchangedPeeringRoutesList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  ExchangedPeeringRoutesList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<ExchangedPeeringRoute>((value) =>
                      ExchangedPeeringRoute.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? ExchangedPeeringRoutesListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax.
///
/// CEL is a C-like expression language. The syntax and semantics of CEL are
/// documented at https://github.com/google/cel-spec. Example (Comparison):
/// title: "Summary size limit" description: "Determines if a summary is less
/// than 100 chars" expression: "document.summary.size() < 100" Example
/// (Equality): title: "Requestor is owner" description: "Determines if
/// requestor is the document owner" expression: "document.owner ==
/// request.auth.claims.email" Example (Logic): title: "Public documents"
/// description: "Determine whether the document should be publicly visible"
/// expression: "document.type != 'private' && document.type != 'internal'"
/// Example (Data Manipulation): title: "Notification string" description:
/// "Create a notification string with a timestamp." expression: "'New message
/// received at ' + string(document.create_time)" The exact variables and
/// functions that may be referenced within an expression are determined by the
/// service that evaluates it. See the service documentation for additional
/// information.
class Expr {
  /// Description of the expression.
  ///
  /// This is a longer text which describes the expression, e.g. when hovered
  /// over it in a UI.
  ///
  /// Optional.
  core.String? description;

  /// Textual representation of an expression in Common Expression Language
  /// syntax.
  core.String? expression;

  /// String indicating the location of the expression for error reporting, e.g.
  /// a file name and a position in the file.
  ///
  /// Optional.
  core.String? location;

  /// Title for the expression, i.e. a short string describing its purpose.
  ///
  /// This can be used e.g. in UIs which allow to enter the expression.
  ///
  /// Optional.
  core.String? title;

  Expr({
    this.description,
    this.expression,
    this.location,
    this.title,
  });

  Expr.fromJson(core.Map _json)
      : this(
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          expression: _json.containsKey('expression')
              ? _json['expression'] as core.String
              : null,
          location: _json.containsKey('location')
              ? _json['location'] as core.String
              : null,
          title:
              _json.containsKey('title') ? _json['title'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (expression != null) 'expression': expression!,
        if (location != null) 'location': location!,
        if (title != null) 'title': title!,
      };
}

/// Represents an external VPN gateway.
///
/// External VPN gateway is the on-premises VPN gateway(s) or another cloud
/// provider's VPN gateway that connects to your Google Cloud VPN gateway. To
/// create a highly available VPN from Google Cloud Platform to your VPN gateway
/// or another cloud provider's VPN gateway, you must create a external VPN
/// gateway resource with information about the other gateway. For more
/// information about using external VPN gateways, see Creating an HA VPN
/// gateway and tunnel pair to a peer VPN.
class ExternalVpnGateway {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of interfaces for this external VPN gateway.
  ///
  /// If your peer-side gateway is an on-premises gateway and non-AWS cloud
  /// providers' gateway, at most two interfaces can be provided for an external
  /// VPN gateway. If your peer side is an AWS virtual private gateway, four
  /// interfaces should be provided for an external VPN gateway.
  core.List<ExternalVpnGatewayInterface>? interfaces;

  /// Type of the resource.
  ///
  /// Always compute#externalVpnGateway for externalVpnGateways.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this ExternalVpnGateway,
  /// which is essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve an ExternalVpnGateway.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels for this resource.
  ///
  /// These can only be added or modified by the setLabels method. Each label
  /// key/value pair must comply with RFC1035. Label values may be empty.
  core.Map<core.String, core.String>? labels;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Indicates the user-supplied redundancy type of this external VPN gateway.
  /// Possible string values are:
  /// - "FOUR_IPS_REDUNDANCY" : The external VPN gateway has four public IP
  /// addresses; at the time of writing this API, the AWS virtual private
  /// gateway is an example which has four public IP addresses for high
  /// availability connections; there should be two VPN connections in the AWS
  /// virtual private gateway , each AWS VPN connection has two public IP
  /// addresses; please make sure to put two public IP addresses from one AWS
  /// VPN connection into interfaces 0 and 1 of this external VPN gateway, and
  /// put the other two public IP addresses from another AWS VPN connection into
  /// interfaces 2 and 3 of this external VPN gateway. When displaying highly
  /// available configuration status for the VPN tunnels connected to
  /// FOUR_IPS_REDUNDANCY external VPN gateway, Google will always detect
  /// whether interfaces 0 and 1 are connected on one interface of HA Cloud VPN
  /// gateway, and detect whether interfaces 2 and 3 are connected to another
  /// interface of the HA Cloud VPN gateway.
  /// - "SINGLE_IP_INTERNALLY_REDUNDANT" : The external VPN gateway has only one
  /// public IP address which internally provide redundancy or failover.
  /// - "TWO_IPS_REDUNDANCY" : The external VPN gateway has two public IP
  /// addresses which are redundant with each other, the following two types of
  /// setup on your on-premises side would have this type of redundancy: (1) Two
  /// separate on-premises gateways, each with one public IP address, the two
  /// on-premises gateways are redundant with each other. (2) A single
  /// on-premise gateway with two public IP addresses that are redundant with
  /// eatch other.
  core.String? redundancyType;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  ExternalVpnGateway({
    this.creationTimestamp,
    this.description,
    this.id,
    this.interfaces,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.name,
    this.redundancyType,
    this.selfLink,
  });

  ExternalVpnGateway.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          interfaces: _json.containsKey('interfaces')
              ? (_json['interfaces'] as core.List)
                  .map<ExternalVpnGatewayInterface>((value) =>
                      ExternalVpnGatewayInterface.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          redundancyType: _json.containsKey('redundancyType')
              ? _json['redundancyType'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (interfaces != null)
          'interfaces': interfaces!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (redundancyType != null) 'redundancyType': redundancyType!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// The interface for the external VPN gateway.
class ExternalVpnGatewayInterface {
  /// The numeric ID of this interface.
  ///
  /// The allowed input values for this id for different redundancy types of
  /// external VPN gateway: - SINGLE_IP_INTERNALLY_REDUNDANT - 0 -
  /// TWO_IPS_REDUNDANCY - 0, 1 - FOUR_IPS_REDUNDANCY - 0, 1, 2, 3
  core.int? id;

  /// IP address of the interface in the external VPN gateway.
  ///
  /// Only IPv4 is supported. This IP address can be either from your on-premise
  /// gateway or another Cloud provider's VPN gateway, it cannot be an IP
  /// address from Google Compute Engine.
  core.String? ipAddress;

  ExternalVpnGatewayInterface({
    this.id,
    this.ipAddress,
  });

  ExternalVpnGatewayInterface.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.int : null,
          ipAddress: _json.containsKey('ipAddress')
              ? _json['ipAddress'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
      };
}

class ExternalVpnGatewayListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ExternalVpnGatewayListWarningData({
    this.key,
    this.value,
  });

  ExternalVpnGatewayListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ExternalVpnGatewayListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ExternalVpnGatewayListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ExternalVpnGatewayListWarning({
    this.code,
    this.data,
    this.message,
  });

  ExternalVpnGatewayListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ExternalVpnGatewayListWarningData>((value) =>
                      ExternalVpnGatewayListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Response to the list request, and contains a list of externalVpnGateways.
class ExternalVpnGatewayList {
  core.String? etag;

  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ExternalVpnGateway resources.
  core.List<ExternalVpnGateway>? items;

  /// Type of resource.
  ///
  /// Always compute#externalVpnGatewayList for lists of externalVpnGateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ExternalVpnGatewayListWarning? warning;

  ExternalVpnGatewayList({
    this.etag,
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  ExternalVpnGatewayList.fromJson(core.Map _json)
      : this(
          etag: _json.containsKey('etag') ? _json['etag'] as core.String : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<ExternalVpnGateway>((value) =>
                      ExternalVpnGateway.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? ExternalVpnGatewayListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (etag != null) 'etag': etag!,
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class FileContentBuffer {
  /// The raw content in the secure keys file.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> _bytes) {
    content =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The file type of source file.
  /// Possible string values are:
  /// - "BIN"
  /// - "UNDEFINED"
  /// - "X509"
  core.String? fileType;

  FileContentBuffer({
    this.content,
    this.fileType,
  });

  FileContentBuffer.fromJson(core.Map _json)
      : this(
          content: _json.containsKey('content')
              ? _json['content'] as core.String
              : null,
          fileType: _json.containsKey('fileType')
              ? _json['fileType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (content != null) 'content': content!,
        if (fileType != null) 'fileType': fileType!,
      };
}

class FirewallAllowed {
  /// The IP protocol to which this rule applies.
  ///
  /// The protocol type is required when creating a firewall rule. This value
  /// can either be one of the following well known protocol strings (tcp, udp,
  /// icmp, esp, ah, ipip, sctp) or the IP protocol number.
  core.String? IPProtocol;

  /// An optional list of ports to which this rule applies.
  ///
  /// This field is only applicable for the UDP or TCP protocol. Each entry must
  /// be either an integer or a range. If not specified, this rule applies to
  /// connections through any port. Example inputs include: \["22"\],
  /// \["80","443"\], and \["12345-12349"\].
  core.List<core.String>? ports;

  FirewallAllowed({
    this.IPProtocol,
    this.ports,
  });

  FirewallAllowed.fromJson(core.Map _json)
      : this(
          IPProtocol: _json.containsKey('IPProtocol')
              ? _json['IPProtocol'] as core.String
              : null,
          ports: _json.containsKey('ports')
              ? (_json['ports'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPProtocol != null) 'IPProtocol': IPProtocol!,
        if (ports != null) 'ports': ports!,
      };
}

class FirewallDenied {
  /// The IP protocol to which this rule applies.
  ///
  /// The protocol type is required when creating a firewall rule. This value
  /// can either be one of the following well known protocol strings (tcp, udp,
  /// icmp, esp, ah, ipip, sctp) or the IP protocol number.
  core.String? IPProtocol;

  /// An optional list of ports to which this rule applies.
  ///
  /// This field is only applicable for the UDP or TCP protocol. Each entry must
  /// be either an integer or a range. If not specified, this rule applies to
  /// connections through any port. Example inputs include: \["22"\],
  /// \["80","443"\], and \["12345-12349"\].
  core.List<core.String>? ports;

  FirewallDenied({
    this.IPProtocol,
    this.ports,
  });

  FirewallDenied.fromJson(core.Map _json)
      : this(
          IPProtocol: _json.containsKey('IPProtocol')
              ? _json['IPProtocol'] as core.String
              : null,
          ports: _json.containsKey('ports')
              ? (_json['ports'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPProtocol != null) 'IPProtocol': IPProtocol!,
        if (ports != null) 'ports': ports!,
      };
}

/// Represents a Firewall Rule resource.
///
/// Firewall rules allow or deny ingress traffic to, and egress traffic from
/// your instances. For more information, read Firewall rules.
class Firewall {
  /// The list of ALLOW rules specified by this firewall.
  ///
  /// Each rule specifies a protocol and port-range tuple that describes a
  /// permitted connection.
  core.List<FirewallAllowed>? allowed;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The list of DENY rules specified by this firewall.
  ///
  /// Each rule specifies a protocol and port-range tuple that describes a
  /// denied connection.
  core.List<FirewallDenied>? denied;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// If destination ranges are specified, the firewall rule applies only to
  /// traffic that has destination IP address in these ranges.
  ///
  /// These ranges must be expressed in CIDR format. Both IPv4 and IPv6 are
  /// supported.
  core.List<core.String>? destinationRanges;

  /// Direction of traffic to which this firewall applies, either `INGRESS` or
  /// `EGRESS`.
  ///
  /// The default is `INGRESS`. For `INGRESS` traffic, you cannot specify the
  /// destinationRanges field, and for `EGRESS` traffic, you cannot specify the
  /// sourceRanges or sourceTags fields.
  /// Possible string values are:
  /// - "EGRESS" : Indicates that firewall should apply to outgoing traffic.
  /// - "INGRESS" : Indicates that firewall should apply to incoming traffic.
  core.String? direction;

  /// Denotes whether the firewall rule is disabled.
  ///
  /// When set to true, the firewall rule is not enforced and the network
  /// behaves as if it did not exist. If this is unspecified, the firewall rule
  /// will be enabled.
  core.bool? disabled;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#firewall for firewall rules.
  ///
  /// Output only.
  core.String? kind;

  /// This field denotes the logging options for a particular firewall rule.
  ///
  /// If logging is enabled, logs will be exported to Cloud Logging.
  FirewallLogConfig? logConfig;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression \`\[a-z\](\[-a-z0-9\]*\[a-z0-9\])?. The first character must be
  /// a lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String? name;

  /// URL of the network resource for this firewall rule.
  ///
  /// If not specified when creating a firewall rule, the default network is
  /// used: global/networks/default If you choose to specify this field, you can
  /// specify the network as a full or partial URL. For example, the following
  /// are all valid URLs: -
  /// https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network
  /// - projects/myproject/global/networks/my-network - global/networks/default
  core.String? network;

  /// Priority for this rule.
  ///
  /// This is an integer between `0` and `65535`, both inclusive. The default
  /// value is `1000`. Relative priorities determine which rule takes effect if
  /// multiple rules apply. Lower values indicate higher priority. For example,
  /// a rule with priority `0` has higher precedence than a rule with priority
  /// `1`. DENY rules take precedence over ALLOW rules if they have equal
  /// priority. Note that VPC networks have implied rules with a priority of
  /// `65535`. To avoid conflicts with the implied rules, use a priority number
  /// less than `65535`.
  core.int? priority;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// If source ranges are specified, the firewall rule applies only to traffic
  /// that has a source IP address in these ranges.
  ///
  /// These ranges must be expressed in CIDR format. One or both of sourceRanges
  /// and sourceTags may be set. If both fields are set, the rule applies to
  /// traffic that has a source IP address within sourceRanges OR a source IP
  /// from a resource with a matching tag listed in the sourceTags field. The
  /// connection does not need to match both fields for the rule to apply. Both
  /// IPv4 and IPv6 are supported.
  core.List<core.String>? sourceRanges;

  /// If source service accounts are specified, the firewall rules apply only to
  /// traffic originating from an instance with a service account in this list.
  ///
  /// Source service accounts cannot be used to control traffic to an instance's
  /// external IP address because service accounts are associated with an
  /// instance, not an IP address. sourceRanges can be set at the same time as
  /// sourceServiceAccounts. If both are set, the firewall applies to traffic
  /// that has a source IP address within the sourceRanges OR a source IP that
  /// belongs to an instance with service account listed in
  /// sourceServiceAccount. The connection does not need to match both fields
  /// for the firewall to apply. sourceServiceAccounts cannot be used at the
  /// same time as sourceTags or targetTags.
  core.List<core.String>? sourceServiceAccounts;

  /// If source tags are specified, the firewall rule applies only to traffic
  /// with source IPs that match the primary network interfaces of VM instances
  /// that have the tag and are in the same VPC network.
  ///
  /// Source tags cannot be used to control traffic to an instance's external IP
  /// address, it only applies to traffic between instances in the same virtual
  /// network. Because tags are associated with instances, not IP addresses. One
  /// or both of sourceRanges and sourceTags may be set. If both fields are set,
  /// the firewall applies to traffic that has a source IP address within
  /// sourceRanges OR a source IP from a resource with a matching tag listed in
  /// the sourceTags field. The connection does not need to match both fields
  /// for the firewall to apply.
  core.List<core.String>? sourceTags;

  /// A list of service accounts indicating sets of instances located in the
  /// network that may make network connections as specified in allowed\[\].
  ///
  /// targetServiceAccounts cannot be used at the same time as targetTags or
  /// sourceTags. If neither targetServiceAccounts nor targetTags are specified,
  /// the firewall rule applies to all instances on the specified network.
  core.List<core.String>? targetServiceAccounts;

  /// A list of tags that controls which instances the firewall rule applies to.
  ///
  /// If targetTags are specified, then the firewall rule applies only to
  /// instances in the VPC network that have one of those tags. If no targetTags
  /// are specified, the firewall rule applies to all instances on the specified
  /// network.
  core.List<core.String>? targetTags;

  Firewall({
    this.allowed,
    this.creationTimestamp,
    this.denied,
    this.description,
    this.destinationRanges,
    this.direction,
    this.disabled,
    this.id,
    this.kind,
    this.logConfig,
    this.name,
    this.network,
    this.priority,
    this.selfLink,
    this.sourceRanges,
    this.sourceServiceAccounts,
    this.sourceTags,
    this.targetServiceAccounts,
    this.targetTags,
  });

  Firewall.fromJson(core.Map _json)
      : this(
          allowed: _json.containsKey('allowed')
              ? (_json['allowed'] as core.List)
                  .map<FirewallAllowed>((value) => FirewallAllowed.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          denied: _json.containsKey('denied')
              ? (_json['denied'] as core.List)
                  .map<FirewallDenied>((value) => FirewallDenied.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          destinationRanges: _json.containsKey('destinationRanges')
              ? (_json['destinationRanges'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          direction: _json.containsKey('direction')
              ? _json['direction'] as core.String
              : null,
          disabled: _json.containsKey('disabled')
              ? _json['disabled'] as core.bool
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          logConfig: _json.containsKey('logConfig')
              ? FirewallLogConfig.fromJson(
                  _json['logConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          priority: _json.containsKey('priority')
              ? _json['priority'] as core.int
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          sourceRanges: _json.containsKey('sourceRanges')
              ? (_json['sourceRanges'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          sourceServiceAccounts: _json.containsKey('sourceServiceAccounts')
              ? (_json['sourceServiceAccounts'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          sourceTags: _json.containsKey('sourceTags')
              ? (_json['sourceTags'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          targetServiceAccounts: _json.containsKey('targetServiceAccounts')
              ? (_json['targetServiceAccounts'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          targetTags: _json.containsKey('targetTags')
              ? (_json['targetTags'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowed != null)
          'allowed': allowed!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (denied != null)
          'denied': denied!.map((value) => value.toJson()).toList(),
        if (description != null) 'description': description!,
        if (destinationRanges != null) 'destinationRanges': destinationRanges!,
        if (direction != null) 'direction': direction!,
        if (disabled != null) 'disabled': disabled!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (priority != null) 'priority': priority!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sourceRanges != null) 'sourceRanges': sourceRanges!,
        if (sourceServiceAccounts != null)
          'sourceServiceAccounts': sourceServiceAccounts!,
        if (sourceTags != null) 'sourceTags': sourceTags!,
        if (targetServiceAccounts != null)
          'targetServiceAccounts': targetServiceAccounts!,
        if (targetTags != null) 'targetTags': targetTags!,
      };
}

class FirewallListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  FirewallListWarningData({
    this.key,
    this.value,
  });

  FirewallListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class FirewallListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<FirewallListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  FirewallListWarning({
    this.code,
    this.data,
    this.message,
  });

  FirewallListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<FirewallListWarningData>((value) =>
                      FirewallListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of firewalls.
class FirewallList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Firewall resources.
  core.List<Firewall>? items;

  /// Type of resource.
  ///
  /// Always compute#firewallList for lists of firewalls.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  FirewallListWarning? warning;

  FirewallList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  FirewallList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Firewall>((value) => Firewall.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? FirewallListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The available logging options for a firewall rule.
class FirewallLogConfig {
  /// This field denotes whether to enable logging for a particular firewall
  /// rule.
  core.bool? enable;

  /// This field can only be specified for a particular firewall rule if logging
  /// is enabled for that rule.
  ///
  /// This field denotes whether to include or exclude metadata for firewall
  /// logs.
  /// Possible string values are:
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String? metadata;

  FirewallLogConfig({
    this.enable,
    this.metadata,
  });

  FirewallLogConfig.fromJson(core.Map _json)
      : this(
          enable:
              _json.containsKey('enable') ? _json['enable'] as core.bool : null,
          metadata: _json.containsKey('metadata')
              ? _json['metadata'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
        if (metadata != null) 'metadata': metadata!,
      };
}

class FirewallPoliciesListAssociationsResponse {
  /// A list of associations.
  core.List<FirewallPolicyAssociation>? associations;

  /// Type of firewallPolicy associations.
  ///
  /// Always compute#FirewallPoliciesListAssociations for lists of
  /// firewallPolicy associations.
  ///
  /// Output only.
  core.String? kind;

  FirewallPoliciesListAssociationsResponse({
    this.associations,
    this.kind,
  });

  FirewallPoliciesListAssociationsResponse.fromJson(core.Map _json)
      : this(
          associations: _json.containsKey('associations')
              ? (_json['associations'] as core.List)
                  .map<FirewallPolicyAssociation>((value) =>
                      FirewallPolicyAssociation.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (associations != null)
          'associations': associations!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
      };
}

/// Represents a Firewall Policy resource.
class FirewallPolicy {
  /// A list of associations that belong to this firewall policy.
  core.List<FirewallPolicyAssociation>? associations;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Deprecated, please use short name instead.
  ///
  /// User-provided name of the Organization firewall plicy. The name should be
  /// unique in the organization in which the firewall policy is created. This
  /// name must be set on creation and cannot be changed. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? displayName;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update metadata. You must always provide an
  /// up-to-date fingerprint hash in order to update or change metadata,
  /// otherwise the request will fail with error 412 conditionNotMet. To see the
  /// latest fingerprint, make get() request to the firewall policy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#firewallPolicyfor firewall policies
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// It is a numeric ID allocated by GCP which uniquely identifies the Firewall
  /// Policy.
  ///
  /// Output only.
  core.String? name;

  /// The parent of the firewall policy.
  ///
  /// Output only.
  core.String? parent;

  /// Total count of all firewall policy rule tuples.
  ///
  /// A firewall policy can not exceed a set number of tuples.
  ///
  /// Output only.
  core.int? ruleTupleCount;

  /// A list of rules that belong to this policy.
  ///
  /// There must always be a default rule (rule with priority 2147483647 and
  /// match "*"). If no rules are provided when creating a firewall policy, a
  /// default rule with action "allow" will be added.
  core.List<FirewallPolicyRule>? rules;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Server-defined URL for this resource with the resource id.
  ///
  /// Output only.
  core.String? selfLinkWithId;

  /// User-provided name of the Organization firewall plicy.
  ///
  /// The name should be unique in the organization in which the firewall policy
  /// is created. This name must be set on creation and cannot be changed. The
  /// name must be 1-63 characters long, and comply with RFC1035. Specifically,
  /// the name must be 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? shortName;

  FirewallPolicy({
    this.associations,
    this.creationTimestamp,
    this.description,
    this.displayName,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.parent,
    this.ruleTupleCount,
    this.rules,
    this.selfLink,
    this.selfLinkWithId,
    this.shortName,
  });

  FirewallPolicy.fromJson(core.Map _json)
      : this(
          associations: _json.containsKey('associations')
              ? (_json['associations'] as core.List)
                  .map<FirewallPolicyAssociation>((value) =>
                      FirewallPolicyAssociation.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          displayName: _json.containsKey('displayName')
              ? _json['displayName'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          parent: _json.containsKey('parent')
              ? _json['parent'] as core.String
              : null,
          ruleTupleCount: _json.containsKey('ruleTupleCount')
              ? _json['ruleTupleCount'] as core.int
              : null,
          rules: _json.containsKey('rules')
              ? (_json['rules'] as core.List)
                  .map<FirewallPolicyRule>((value) =>
                      FirewallPolicyRule.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          selfLinkWithId: _json.containsKey('selfLinkWithId')
              ? _json['selfLinkWithId'] as core.String
              : null,
          shortName: _json.containsKey('shortName')
              ? _json['shortName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (associations != null)
          'associations': associations!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (parent != null) 'parent': parent!,
        if (ruleTupleCount != null) 'ruleTupleCount': ruleTupleCount!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (selfLinkWithId != null) 'selfLinkWithId': selfLinkWithId!,
        if (shortName != null) 'shortName': shortName!,
      };
}

class FirewallPolicyAssociation {
  /// The target that the firewall policy is attached to.
  core.String? attachmentTarget;

  /// Deprecated, please use short name instead.
  ///
  /// The display name of the firewall policy of the association.
  ///
  /// Output only.
  core.String? displayName;

  /// The firewall policy ID of the association.
  ///
  /// Output only.
  core.String? firewallPolicyId;

  /// The name for an association.
  core.String? name;

  /// The short name of the firewall policy of the association.
  ///
  /// Output only.
  core.String? shortName;

  FirewallPolicyAssociation({
    this.attachmentTarget,
    this.displayName,
    this.firewallPolicyId,
    this.name,
    this.shortName,
  });

  FirewallPolicyAssociation.fromJson(core.Map _json)
      : this(
          attachmentTarget: _json.containsKey('attachmentTarget')
              ? _json['attachmentTarget'] as core.String
              : null,
          displayName: _json.containsKey('displayName')
              ? _json['displayName'] as core.String
              : null,
          firewallPolicyId: _json.containsKey('firewallPolicyId')
              ? _json['firewallPolicyId'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          shortName: _json.containsKey('shortName')
              ? _json['shortName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attachmentTarget != null) 'attachmentTarget': attachmentTarget!,
        if (displayName != null) 'displayName': displayName!,
        if (firewallPolicyId != null) 'firewallPolicyId': firewallPolicyId!,
        if (name != null) 'name': name!,
        if (shortName != null) 'shortName': shortName!,
      };
}

class FirewallPolicyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  FirewallPolicyListWarningData({
    this.key,
    this.value,
  });

  FirewallPolicyListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class FirewallPolicyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<FirewallPolicyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  FirewallPolicyListWarning({
    this.code,
    this.data,
    this.message,
  });

  FirewallPolicyListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<FirewallPolicyListWarningData>((value) =>
                      FirewallPolicyListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class FirewallPolicyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of FirewallPolicy resources.
  core.List<FirewallPolicy>? items;

  /// Type of resource.
  ///
  /// Always compute#firewallPolicyList for listsof FirewallPolicies
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  FirewallPolicyListWarning? warning;

  FirewallPolicyList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.warning,
  });

  FirewallPolicyList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<FirewallPolicy>((value) => FirewallPolicy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? FirewallPolicyListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a rule that describes one or more match conditions along with the
/// action to be taken when traffic matches this condition (allow or deny).
class FirewallPolicyRule {
  /// The Action to perform when the client connection triggers the rule.
  ///
  /// Can currently be either "allow" or "deny()" where valid values for status
  /// are 403, 404, and 502.
  core.String? action;

  /// An optional description for this resource.
  core.String? description;

  /// The direction in which this rule applies.
  /// Possible string values are:
  /// - "EGRESS"
  /// - "INGRESS"
  core.String? direction;

  /// Denotes whether the firewall policy rule is disabled.
  ///
  /// When set to true, the firewall policy rule is not enforced and traffic
  /// behaves as if it did not exist. If this is unspecified, the firewall
  /// policy rule will be enabled.
  core.bool? disabled;

  /// Denotes whether to enable logging for a particular rule.
  ///
  /// If logging is enabled, logs will be exported to the configured export
  /// destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub.
  /// Note: you cannot enable logging on "goto_next" rules.
  core.bool? enableLogging;

  /// Type of the resource.
  ///
  /// Always compute#firewallPolicyRule for firewall policy rules
  ///
  /// Output only.
  core.String? kind;

  /// A match condition that incoming traffic is evaluated against.
  ///
  /// If it evaluates to true, the corresponding 'action' is enforced.
  FirewallPolicyRuleMatcher? match;

  /// An integer indicating the priority of a rule in the list.
  ///
  /// The priority must be a positive value between 0 and 2147483647. Rules are
  /// evaluated from highest to lowest priority where 0 is the highest priority
  /// and 2147483647 is the lowest prority.
  core.int? priority;

  /// Calculation of the complexity of a single firewall policy rule.
  ///
  /// Output only.
  core.int? ruleTupleCount;

  /// A list of network resource URLs to which this rule applies.
  ///
  /// This field allows you to control which network's VMs get this rule. If
  /// this field is left blank, all VMs within the organization will receive the
  /// rule.
  core.List<core.String>? targetResources;

  /// A list of service accounts indicating the sets of instances that are
  /// applied with this rule.
  core.List<core.String>? targetServiceAccounts;

  FirewallPolicyRule({
    this.action,
    this.description,
    this.direction,
    this.disabled,
    this.enableLogging,
    this.kind,
    this.match,
    this.priority,
    this.ruleTupleCount,
    this.targetResources,
    this.targetServiceAccounts,
  });

  FirewallPolicyRule.fromJson(core.Map _json)
      : this(
          action: _json.containsKey('action')
              ? _json['action'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          direction: _json.containsKey('direction')
              ? _json['direction'] as core.String
              : null,
          disabled: _json.containsKey('disabled')
              ? _json['disabled'] as core.bool
              : null,
          enableLogging: _json.containsKey('enableLogging')
              ? _json['enableLogging'] as core.bool
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          match: _json.containsKey('match')
              ? FirewallPolicyRuleMatcher.fromJson(
                  _json['match'] as core.Map<core.String, core.dynamic>)
              : null,
          priority: _json.containsKey('priority')
              ? _json['priority'] as core.int
              : null,
          ruleTupleCount: _json.containsKey('ruleTupleCount')
              ? _json['ruleTupleCount'] as core.int
              : null,
          targetResources: _json.containsKey('targetResources')
              ? (_json['targetResources'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          targetServiceAccounts: _json.containsKey('targetServiceAccounts')
              ? (_json['targetServiceAccounts'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (action != null) 'action': action!,
        if (description != null) 'description': description!,
        if (direction != null) 'direction': direction!,
        if (disabled != null) 'disabled': disabled!,
        if (enableLogging != null) 'enableLogging': enableLogging!,
        if (kind != null) 'kind': kind!,
        if (match != null) 'match': match!.toJson(),
        if (priority != null) 'priority': priority!,
        if (ruleTupleCount != null) 'ruleTupleCount': ruleTupleCount!,
        if (targetResources != null) 'targetResources': targetResources!,
        if (targetServiceAccounts != null)
          'targetServiceAccounts': targetServiceAccounts!,
      };
}

/// Represents a match condition that incoming traffic is evaluated against.
///
/// Exactly one field must be specified.
class FirewallPolicyRuleMatcher {
  /// CIDR IP address range.
  ///
  /// Maximum number of destination CIDR IP ranges allowed is 5000.
  core.List<core.String>? destIpRanges;

  /// Pairs of IP protocols and ports that the rule should match.
  core.List<FirewallPolicyRuleMatcherLayer4Config>? layer4Configs;

  /// CIDR IP address range.
  ///
  /// Maximum number of source CIDR IP ranges allowed is 5000.
  core.List<core.String>? srcIpRanges;

  FirewallPolicyRuleMatcher({
    this.destIpRanges,
    this.layer4Configs,
    this.srcIpRanges,
  });

  FirewallPolicyRuleMatcher.fromJson(core.Map _json)
      : this(
          destIpRanges: _json.containsKey('destIpRanges')
              ? (_json['destIpRanges'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          layer4Configs: _json.containsKey('layer4Configs')
              ? (_json['layer4Configs'] as core.List)
                  .map<FirewallPolicyRuleMatcherLayer4Config>((value) =>
                      FirewallPolicyRuleMatcherLayer4Config.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          srcIpRanges: _json.containsKey('srcIpRanges')
              ? (_json['srcIpRanges'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (destIpRanges != null) 'destIpRanges': destIpRanges!,
        if (layer4Configs != null)
          'layer4Configs':
              layer4Configs!.map((value) => value.toJson()).toList(),
        if (srcIpRanges != null) 'srcIpRanges': srcIpRanges!,
      };
}

class FirewallPolicyRuleMatcherLayer4Config {
  /// The IP protocol to which this rule applies.
  ///
  /// The protocol type is required when creating a firewall rule. This value
  /// can either be one of the following well known protocol strings (tcp, udp,
  /// icmp, esp, ah, ipip, sctp), or the IP protocol number.
  core.String? ipProtocol;

  /// An optional list of ports to which this rule applies.
  ///
  /// This field is only applicable for UDP or TCP protocol. Each entry must be
  /// either an integer or a range. If not specified, this rule applies to
  /// connections through any port. Example inputs include: \["22"\],
  /// \["80","443"\], and \["12345-12349"\].
  core.List<core.String>? ports;

  FirewallPolicyRuleMatcherLayer4Config({
    this.ipProtocol,
    this.ports,
  });

  FirewallPolicyRuleMatcherLayer4Config.fromJson(core.Map _json)
      : this(
          ipProtocol: _json.containsKey('ipProtocol')
              ? _json['ipProtocol'] as core.String
              : null,
          ports: _json.containsKey('ports')
              ? (_json['ports'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipProtocol != null) 'ipProtocol': ipProtocol!,
        if (ports != null) 'ports': ports!,
      };
}

/// Encapsulates numeric value that can be either absolute or relative.
class FixedOrPercent {
  /// Absolute value of VM instances calculated based on the specific mode.
  ///
  /// - If the value is fixed, then the calculated value is equal to the fixed
  /// value. - If the value is a percent, then the calculated value is
  /// percent/100 * targetSize. For example, the calculated value of a 80% of a
  /// managed instance group with 150 instances would be (80/100 * 150) = 120 VM
  /// instances. If there is a remainder, the number is rounded.
  ///
  /// Output only.
  core.int? calculated;

  /// Specifies a fixed number of VM instances.
  ///
  /// This must be a positive integer.
  core.int? fixed;

  /// Specifies a percentage of instances between 0 to 100%, inclusive.
  ///
  /// For example, specify 80 for 80%.
  core.int? percent;

  FixedOrPercent({
    this.calculated,
    this.fixed,
    this.percent,
  });

  FixedOrPercent.fromJson(core.Map _json)
      : this(
          calculated: _json.containsKey('calculated')
              ? _json['calculated'] as core.int
              : null,
          fixed: _json.containsKey('fixed') ? _json['fixed'] as core.int : null,
          percent: _json.containsKey('percent')
              ? _json['percent'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (calculated != null) 'calculated': calculated!,
        if (fixed != null) 'fixed': fixed!,
        if (percent != null) 'percent': percent!,
      };
}

/// Represents a Forwarding Rule resource.
///
/// Forwarding rule resources in Google Cloud can be either regional or global
/// in scope: *
/// [Global](https://cloud.google.com/compute/docs/reference/rest/v1/globalForwardingRules)
/// *
/// [Regional](https://cloud.google.com/compute/docs/reference/rest/v1/forwardingRules)
/// A forwarding rule and its corresponding IP address represent the frontend
/// configuration of a Google Cloud Platform load balancer. Forwarding rules can
/// also reference target instances and Cloud VPN Classic gateways
/// (targetVpnGateway). For more information, read Forwarding rule concepts and
/// Using protocol forwarding.
class ForwardingRule {
  /// IP address that this forwarding rule serves.
  ///
  /// When a client sends traffic to this IP address, the forwarding rule
  /// directs the traffic to the target that you specify in the forwarding rule.
  /// If you don't specify a reserved IP address, an ephemeral IP address is
  /// assigned. Methods for specifying an IP address: * IPv4 dotted decimal, as
  /// in `100.1.2.3` * Full URL, as in
  /// https://www.googleapis.com/compute/v1/projects/project_id/regions/region
  /// /addresses/address-name * Partial URL or by name, as in: -
  /// projects/project_id/regions/region/addresses/address-name -
  /// regions/region/addresses/address-name - global/addresses/address-name -
  /// address-name The loadBalancingScheme and the forwarding rule's target
  /// determine the type of IP address that you can use. For detailed
  /// information, see
  /// [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
  /// Must be set to `0.0.0.0` when the target is targetGrpcProxy that has
  /// validateForProxyless field set to true. For Private Service Connect
  /// forwarding rules that forward traffic to Google APIs, IP address must be
  /// provided.
  core.String? IPAddress;

  /// The IP protocol to which this rule applies.
  ///
  /// For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP, ICMP
  /// and L3_DEFAULT. The valid IP protocols are different for different load
  /// balancing products as described in
  /// [Load balancing features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends).
  /// Possible string values are:
  /// - "AH"
  /// - "ESP"
  /// - "ICMP"
  /// - "SCTP"
  /// - "TCP"
  /// - "UDP"
  core.String? IPProtocol;

  /// This field is used along with the backend_service field for Internal
  /// TCP/UDP Load Balancing or Network Load Balancing, or with the target field
  /// for internal and external TargetInstance.
  ///
  /// You can only use one of ports and port_range, or allPorts. The three are
  /// mutually exclusive. For TCP, UDP and SCTP traffic, packets addressed to
  /// any ports will be forwarded to the target or backendService.
  core.bool? allPorts;

  /// This field is used along with the backend_service field for internal load
  /// balancing or with the target field for internal TargetInstance.
  ///
  /// If the field is set to TRUE, clients can access ILB from all regions.
  /// Otherwise only allows access from clients in the same region as the
  /// internal load balancer.
  core.bool? allowGlobalAccess;

  /// Identifies the backend service to which the forwarding rule sends traffic.
  ///
  /// Required for Internal TCP/UDP Load Balancing and Network Load Balancing;
  /// must be omitted for all other load balancer types.
  core.String? backendService;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// ForwardingRule. Include the fingerprint in patch request to ensure that
  /// you do not overwrite changes that were applied from another concurrent
  /// request. To see the latest fingerprint, make a get() request to retrieve a
  /// ForwardingRule.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The IP Version that will be used by this forwarding rule.
  ///
  /// Valid options are IPV4 or IPV6. This can only be specified for an external
  /// global forwarding rule.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String? ipVersion;

  /// Indicates whether or not this load balancer can be used as a collector for
  /// packet mirroring.
  ///
  /// To prevent mirroring loops, instances behind this load balancer will not
  /// have their traffic mirrored even if a PacketMirroring rule applies to
  /// them. This can only be set to true for load balancers that have their
  /// loadBalancingScheme set to INTERNAL.
  core.bool? isMirroringCollector;

  /// Type of the resource.
  ///
  /// Always compute#forwardingRule for Forwarding Rule resources.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this resource, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve a ForwardingRule.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels for this resource.
  ///
  /// These can only be added or modified by the setLabels method. Each label
  /// key/value pair must comply with RFC1035. Label values may be empty.
  core.Map<core.String, core.String>? labels;

  /// Specifies the forwarding rule type.
  ///
  /// For more information about forwarding rules, refer to Forwarding rule
  /// concepts.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INTERNAL_MANAGED"
  /// - "INTERNAL_SELF_MANAGED"
  /// - "INVALID"
  core.String? loadBalancingScheme;

  /// Opaque filter criteria used by load balancer to restrict routing
  /// configuration to a limited set of xDS compliant clients.
  ///
  /// In their xDS requests to load balancer, xDS clients present node metadata.
  /// When there is a match, the relevant configuration is made available to
  /// those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap)
  /// referenced by the ForwardingRule are not visible to those proxies. For
  /// each metadataFilter in this list, if its filterMatchCriteria is set to
  /// MATCH_ANY, at least one of the filterLabels must match the corresponding
  /// label provided in the metadata. If its filterMatchCriteria is set to
  /// MATCH_ALL, then all of its filterLabels must match with corresponding
  /// labels provided in the metadata. If multiple metadataFilters are
  /// specified, all of them need to be satisfied in order to be considered a
  /// match. metadataFilters specified here will be applifed before those
  /// specified in the UrlMap that this ForwardingRule references.
  /// metadataFilters only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.List<MetadataFilter>? metadataFilters;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash. For Private Service Connect forwarding rules that forward traffic to
  /// Google APIs, the forwarding rule name must be a 1-20 characters string
  /// with lowercase letters and numbers and must start with a letter.
  core.String? name;

  /// This field is not used for external load balancing.
  ///
  /// For Internal TCP/UDP Load Balancing, this field identifies the network
  /// that the load balanced IP should belong to for this Forwarding Rule. If
  /// this field is not specified, the default network will be used. For Private
  /// Service Connect forwarding rules that forward traffic to Google APIs, a
  /// network must be provided.
  core.String? network;

  /// This signifies the networking tier used for configuring this load balancer
  /// and can only take the following values: PREMIUM, STANDARD.
  ///
  /// For regional ForwardingRule, the valid values are PREMIUM and STANDARD.
  /// For GlobalForwardingRule, the valid value is PREMIUM. If this field is not
  /// specified, it is assumed to be PREMIUM. If IPAddress is specified, this
  /// value must be equal to the networkTier of the Address.
  /// Possible string values are:
  /// - "PREMIUM" : High quality, Google-grade network tier, support for all
  /// networking products.
  /// - "STANDARD" : Public internet quality, only limited support for other
  /// networking products.
  core.String? networkTier;

  /// This field can be used only if: - Load balancing scheme is one of
  /// EXTERNAL, INTERNAL_SELF_MANAGED or INTERNAL_MANAGED - IPProtocol is one of
  /// TCP, UDP, or SCTP.
  ///
  /// Packets addressed to ports in the specified range will be forwarded to
  /// target or backend_service. You can only use one of ports, port_range, or
  /// allPorts. The three are mutually exclusive. Forwarding rules with the same
  /// \[IPAddress, IPProtocol\] pair must have disjoint ports. Some types of
  /// forwarding target have constraints on the acceptable ports. For more
  /// information, see
  /// [Port specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#port_specifications).
  /// @pattern: \\d+(?:-\\d+)?
  core.String? portRange;

  /// The ports field is only supported when the forwarding rule references a
  /// backend_service directly.
  ///
  /// Only packets addressed to the \[specified list of
  /// ports\]((https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#port_specifications))
  /// are forwarded to backends. You can only use one of ports and port_range,
  /// or allPorts. The three are mutually exclusive. You can specify a list of
  /// up to five ports, which can be non-contiguous. Forwarding rules with the
  /// same \[IPAddress, IPProtocol\] pair must have disjoint ports. @pattern:
  /// \\d+(?:-\\d+)?
  core.List<core.String>? ports;

  /// The PSC connection id of the PSC Forwarding Rule.
  ///
  /// Output only.
  core.String? pscConnectionId;

  ///
  /// Possible string values are:
  /// - "ACCEPTED" : The connection has been accepted by the producer.
  /// - "CLOSED" : The connection has been closed by the producer and will not
  /// serve traffic going forward.
  /// - "PENDING" : The connection is pending acceptance by the producer.
  /// - "REJECTED" : The connection has been rejected by the producer.
  /// - "STATUS_UNSPECIFIED"
  core.String? pscConnectionStatus;

  /// URL of the region where the regional forwarding rule resides.
  ///
  /// This field is not applicable to global forwarding rules. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Service Directory resources to register this forwarding rule with.
  ///
  /// Currently, only supports a single Service Directory resource. It is only
  /// supported for internal load balancing.
  core.List<ForwardingRuleServiceDirectoryRegistration>?
      serviceDirectoryRegistrations;

  /// An optional prefix to the service name for this Forwarding Rule.
  ///
  /// If specified, the prefix is the first label of the fully qualified service
  /// name. The label must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the label must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash. This field is only used for internal load balancing.
  core.String? serviceLabel;

  /// The internal fully qualified service name for this Forwarding Rule.
  ///
  /// This field is only used for internal load balancing.
  ///
  /// Output only.
  core.String? serviceName;

  /// This field identifies the subnetwork that the load balanced IP should
  /// belong to for this Forwarding Rule, used in internal load balancing and
  /// network load balancing with IPv6.
  ///
  /// If the network specified is in auto subnet mode, this field is optional.
  /// However, a subnetwork must be specified if the network is in custom subnet
  /// mode or when creating external forwarding rule with IPv6.
  core.String? subnetwork;
  core.String? target;

  ForwardingRule({
    this.IPAddress,
    this.IPProtocol,
    this.allPorts,
    this.allowGlobalAccess,
    this.backendService,
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.ipVersion,
    this.isMirroringCollector,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.loadBalancingScheme,
    this.metadataFilters,
    this.name,
    this.network,
    this.networkTier,
    this.portRange,
    this.ports,
    this.pscConnectionId,
    this.pscConnectionStatus,
    this.region,
    this.selfLink,
    this.serviceDirectoryRegistrations,
    this.serviceLabel,
    this.serviceName,
    this.subnetwork,
    this.target,
  });

  ForwardingRule.fromJson(core.Map _json)
      : this(
          IPAddress: _json.containsKey('IPAddress')
              ? _json['IPAddress'] as core.String
              : null,
          IPProtocol: _json.containsKey('IPProtocol')
              ? _json['IPProtocol'] as core.String
              : null,
          allPorts: _json.containsKey('allPorts')
              ? _json['allPorts'] as core.bool
              : null,
          allowGlobalAccess: _json.containsKey('allowGlobalAccess')
              ? _json['allowGlobalAccess'] as core.bool
              : null,
          backendService: _json.containsKey('backendService')
              ? _json['backendService'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          ipVersion: _json.containsKey('ipVersion')
              ? _json['ipVersion'] as core.String
              : null,
          isMirroringCollector: _json.containsKey('isMirroringCollector')
              ? _json['isMirroringCollector'] as core.bool
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          loadBalancingScheme: _json.containsKey('loadBalancingScheme')
              ? _json['loadBalancingScheme'] as core.String
              : null,
          metadataFilters: _json.containsKey('metadataFilters')
              ? (_json['metadataFilters'] as core.List)
                  .map<MetadataFilter>((value) => MetadataFilter.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          networkTier: _json.containsKey('networkTier')
              ? _json['networkTier'] as core.String
              : null,
          portRange: _json.containsKey('portRange')
              ? _json['portRange'] as core.String
              : null,
          ports: _json.containsKey('ports')
              ? (_json['ports'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          pscConnectionId: _json.containsKey('pscConnectionId')
              ? _json['pscConnectionId'] as core.String
              : null,
          pscConnectionStatus: _json.containsKey('pscConnectionStatus')
              ? _json['pscConnectionStatus'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          serviceDirectoryRegistrations: _json
                  .containsKey('serviceDirectoryRegistrations')
              ? (_json['serviceDirectoryRegistrations'] as core.List)
                  .map<ForwardingRuleServiceDirectoryRegistration>((value) =>
                      ForwardingRuleServiceDirectoryRegistration.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          serviceLabel: _json.containsKey('serviceLabel')
              ? _json['serviceLabel'] as core.String
              : null,
          serviceName: _json.containsKey('serviceName')
              ? _json['serviceName'] as core.String
              : null,
          subnetwork: _json.containsKey('subnetwork')
              ? _json['subnetwork'] as core.String
              : null,
          target: _json.containsKey('target')
              ? _json['target'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPAddress != null) 'IPAddress': IPAddress!,
        if (IPProtocol != null) 'IPProtocol': IPProtocol!,
        if (allPorts != null) 'allPorts': allPorts!,
        if (allowGlobalAccess != null) 'allowGlobalAccess': allowGlobalAccess!,
        if (backendService != null) 'backendService': backendService!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (ipVersion != null) 'ipVersion': ipVersion!,
        if (isMirroringCollector != null)
          'isMirroringCollector': isMirroringCollector!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (loadBalancingScheme != null)
          'loadBalancingScheme': loadBalancingScheme!,
        if (metadataFilters != null)
          'metadataFilters':
              metadataFilters!.map((value) => value.toJson()).toList(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (networkTier != null) 'networkTier': networkTier!,
        if (portRange != null) 'portRange': portRange!,
        if (ports != null) 'ports': ports!,
        if (pscConnectionId != null) 'pscConnectionId': pscConnectionId!,
        if (pscConnectionStatus != null)
          'pscConnectionStatus': pscConnectionStatus!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (serviceDirectoryRegistrations != null)
          'serviceDirectoryRegistrations': serviceDirectoryRegistrations!
              .map((value) => value.toJson())
              .toList(),
        if (serviceLabel != null) 'serviceLabel': serviceLabel!,
        if (serviceName != null) 'serviceName': serviceName!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
        if (target != null) 'target': target!,
      };
}

class ForwardingRuleAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ForwardingRuleAggregatedListWarningData({
    this.key,
    this.value,
  });

  ForwardingRuleAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ForwardingRuleAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ForwardingRuleAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ForwardingRuleAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  ForwardingRuleAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ForwardingRuleAggregatedListWarningData>((value) =>
                      ForwardingRuleAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ForwardingRuleAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ForwardingRulesScopedList resources.
  core.Map<core.String, ForwardingRulesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#forwardingRuleAggregatedList for lists of forwarding rules.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  ForwardingRuleAggregatedListWarning? warning;

  ForwardingRuleAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  ForwardingRuleAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    ForwardingRulesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? ForwardingRuleAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ForwardingRuleListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ForwardingRuleListWarningData({
    this.key,
    this.value,
  });

  ForwardingRuleListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ForwardingRuleListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ForwardingRuleListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ForwardingRuleListWarning({
    this.code,
    this.data,
    this.message,
  });

  ForwardingRuleListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ForwardingRuleListWarningData>((value) =>
                      ForwardingRuleListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of ForwardingRule resources.
class ForwardingRuleList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ForwardingRule resources.
  core.List<ForwardingRule>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ForwardingRuleListWarning? warning;

  ForwardingRuleList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  ForwardingRuleList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<ForwardingRule>((value) => ForwardingRule.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? ForwardingRuleListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ForwardingRuleReference {
  core.String? forwardingRule;

  ForwardingRuleReference({
    this.forwardingRule,
  });

  ForwardingRuleReference.fromJson(core.Map _json)
      : this(
          forwardingRule: _json.containsKey('forwardingRule')
              ? _json['forwardingRule'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (forwardingRule != null) 'forwardingRule': forwardingRule!,
      };
}

/// Describes the auto-registration of the Forwarding Rule to Service Directory.
///
/// The region and project of the Service Directory resource generated from this
/// registration will be the same as this Forwarding Rule.
class ForwardingRuleServiceDirectoryRegistration {
  /// Service Directory namespace to register the forwarding rule under.
  core.String? namespace;

  /// Service Directory service to register the forwarding rule under.
  core.String? service;

  /// Service Directory region to register this global forwarding rule under.
  ///
  /// Default to "us-central1". Only used for PSC for Google APIs. All PSC for
  /// Google APIs Forwarding Rules on the same network should use the same
  /// Service Directory region.
  ///
  /// Optional.
  core.String? serviceDirectoryRegion;

  ForwardingRuleServiceDirectoryRegistration({
    this.namespace,
    this.service,
    this.serviceDirectoryRegion,
  });

  ForwardingRuleServiceDirectoryRegistration.fromJson(core.Map _json)
      : this(
          namespace: _json.containsKey('namespace')
              ? _json['namespace'] as core.String
              : null,
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
          serviceDirectoryRegion: _json.containsKey('serviceDirectoryRegion')
              ? _json['serviceDirectoryRegion'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (namespace != null) 'namespace': namespace!,
        if (service != null) 'service': service!,
        if (serviceDirectoryRegion != null)
          'serviceDirectoryRegion': serviceDirectoryRegion!,
      };
}

class ForwardingRulesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ForwardingRulesScopedListWarningData({
    this.key,
    this.value,
  });

  ForwardingRulesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of forwarding rules when the
/// list is empty.
class ForwardingRulesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ForwardingRulesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ForwardingRulesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  ForwardingRulesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ForwardingRulesScopedListWarningData>((value) =>
                      ForwardingRulesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ForwardingRulesScopedList {
  /// A list of forwarding rules contained in this scope.
  core.List<ForwardingRule>? forwardingRules;

  /// Informational warning which replaces the list of forwarding rules when the
  /// list is empty.
  ForwardingRulesScopedListWarning? warning;

  ForwardingRulesScopedList({
    this.forwardingRules,
    this.warning,
  });

  ForwardingRulesScopedList.fromJson(core.Map _json)
      : this(
          forwardingRules: _json.containsKey('forwardingRules')
              ? (_json['forwardingRules'] as core.List)
                  .map<ForwardingRule>((value) => ForwardingRule.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? ForwardingRulesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (forwardingRules != null)
          'forwardingRules':
              forwardingRules!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class GRPCHealthCheck {
  /// The gRPC service name for the health check.
  ///
  /// This field is optional. The value of grpc_service_name has the following
  /// meanings by convention: - Empty service_name means the overall status of
  /// all services at the backend. - Non-empty service_name means the health of
  /// that gRPC service, as defined by the owner of the service. The
  /// grpc_service_name can only be ASCII.
  core.String? grpcServiceName;

  /// The port number for the health check request.
  ///
  /// Must be specified if port_name and port_specification are not set or if
  /// port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence. The
  /// port_name should conform to RFC1035.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values: USE_FIXED_PORT: The port number in port is used for
  /// health checking.
  ///
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking. If not specified, gRPC health check follows behavior specified
  /// in port and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in port is used for health checking.
  /// - "USE_NAMED_PORT" : The portName is used for health checking.
  /// - "USE_SERVING_PORT" : For NetworkEndpointGroup, the port specified for
  /// each network endpoint is used for health checking. For other backends, the
  /// port or named port specified in the Backend Service is used for health
  /// checking.
  core.String? portSpecification;

  GRPCHealthCheck({
    this.grpcServiceName,
    this.port,
    this.portName,
    this.portSpecification,
  });

  GRPCHealthCheck.fromJson(core.Map _json)
      : this(
          grpcServiceName: _json.containsKey('grpcServiceName')
              ? _json['grpcServiceName'] as core.String
              : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          portName: _json.containsKey('portName')
              ? _json['portName'] as core.String
              : null,
          portSpecification: _json.containsKey('portSpecification')
              ? _json['portSpecification'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (grpcServiceName != null) 'grpcServiceName': grpcServiceName!,
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
      };
}

class GlobalNetworkEndpointGroupsAttachEndpointsRequest {
  /// The list of network endpoints to be attached.
  core.List<NetworkEndpoint>? networkEndpoints;

  GlobalNetworkEndpointGroupsAttachEndpointsRequest({
    this.networkEndpoints,
  });

  GlobalNetworkEndpointGroupsAttachEndpointsRequest.fromJson(core.Map _json)
      : this(
          networkEndpoints: _json.containsKey('networkEndpoints')
              ? (_json['networkEndpoints'] as core.List)
                  .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpoints != null)
          'networkEndpoints':
              networkEndpoints!.map((value) => value.toJson()).toList(),
      };
}

class GlobalNetworkEndpointGroupsDetachEndpointsRequest {
  /// The list of network endpoints to be detached.
  core.List<NetworkEndpoint>? networkEndpoints;

  GlobalNetworkEndpointGroupsDetachEndpointsRequest({
    this.networkEndpoints,
  });

  GlobalNetworkEndpointGroupsDetachEndpointsRequest.fromJson(core.Map _json)
      : this(
          networkEndpoints: _json.containsKey('networkEndpoints')
              ? (_json['networkEndpoints'] as core.List)
                  .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpoints != null)
          'networkEndpoints':
              networkEndpoints!.map((value) => value.toJson()).toList(),
      };
}

class GlobalOrganizationSetPolicyRequest {
  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify bindings.
  core.List<Binding>? bindings;

  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify the etag.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is
  /// in general a valid policy but certain services (like Projects) might
  /// reject them.
  Policy? policy;

  GlobalOrganizationSetPolicyRequest({
    this.bindings,
    this.etag,
    this.policy,
  });

  GlobalOrganizationSetPolicyRequest.fromJson(core.Map _json)
      : this(
          bindings: _json.containsKey('bindings')
              ? (_json['bindings'] as core.List)
                  .map<Binding>((value) => Binding.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          etag: _json.containsKey('etag') ? _json['etag'] as core.String : null,
          policy: _json.containsKey('policy')
              ? Policy.fromJson(
                  _json['policy'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (policy != null) 'policy': policy!.toJson(),
      };
}

class GlobalSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash when updating or changing labels, otherwise
  /// the request will fail with error 412 conditionNotMet. Make a get() request
  /// to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of labels to apply for this resource.
  ///
  /// Each label key & value must comply with RFC1035. Specifically, the name
  /// must be 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash. For
  /// example, "webserver-frontend": "images". A label value can also be empty
  /// (e.g. "my-label": "").
  core.Map<core.String, core.String>? labels;

  GlobalSetLabelsRequest({
    this.labelFingerprint,
    this.labels,
  });

  GlobalSetLabelsRequest.fromJson(core.Map _json)
      : this(
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
      };
}

class GlobalSetPolicyRequest {
  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify bindings.
  core.List<Binding>? bindings;

  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify the etag.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is
  /// in general a valid policy but certain services (like Projects) might
  /// reject them.
  Policy? policy;

  GlobalSetPolicyRequest({
    this.bindings,
    this.etag,
    this.policy,
  });

  GlobalSetPolicyRequest.fromJson(core.Map _json)
      : this(
          bindings: _json.containsKey('bindings')
              ? (_json['bindings'] as core.List)
                  .map<Binding>((value) => Binding.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          etag: _json.containsKey('etag') ? _json['etag'] as core.String : null,
          policy: _json.containsKey('policy')
              ? Policy.fromJson(
                  _json['policy'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (policy != null) 'policy': policy!.toJson(),
      };
}

/// A guest attributes entry.
class GuestAttributes {
  /// Type of the resource.
  ///
  /// Always compute#guestAttributes for guest attributes entry.
  ///
  /// Output only.
  core.String? kind;

  /// The path to be queried.
  ///
  /// This can be the default namespace ('') or a nested namespace ('\/') or a
  /// specified key ('\/\').
  core.String? queryPath;

  /// The value of the requested queried path.
  ///
  /// Output only.
  GuestAttributesValue? queryValue;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The key to search for.
  core.String? variableKey;

  /// The value found for the requested key.
  ///
  /// Output only.
  core.String? variableValue;

  GuestAttributes({
    this.kind,
    this.queryPath,
    this.queryValue,
    this.selfLink,
    this.variableKey,
    this.variableValue,
  });

  GuestAttributes.fromJson(core.Map _json)
      : this(
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          queryPath: _json.containsKey('queryPath')
              ? _json['queryPath'] as core.String
              : null,
          queryValue: _json.containsKey('queryValue')
              ? GuestAttributesValue.fromJson(
                  _json['queryValue'] as core.Map<core.String, core.dynamic>)
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          variableKey: _json.containsKey('variableKey')
              ? _json['variableKey'] as core.String
              : null,
          variableValue: _json.containsKey('variableValue')
              ? _json['variableValue'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (queryPath != null) 'queryPath': queryPath!,
        if (queryValue != null) 'queryValue': queryValue!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (variableKey != null) 'variableKey': variableKey!,
        if (variableValue != null) 'variableValue': variableValue!,
      };
}

/// A guest attributes namespace/key/value entry.
class GuestAttributesEntry {
  /// Key for the guest attribute entry.
  core.String? key;

  /// Namespace for the guest attribute entry.
  core.String? namespace;

  /// Value for the guest attribute entry.
  core.String? value;

  GuestAttributesEntry({
    this.key,
    this.namespace,
    this.value,
  });

  GuestAttributesEntry.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          namespace: _json.containsKey('namespace')
              ? _json['namespace'] as core.String
              : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (namespace != null) 'namespace': namespace!,
        if (value != null) 'value': value!,
      };
}

/// Array of guest attribute namespace/key/value tuples.
class GuestAttributesValue {
  core.List<GuestAttributesEntry>? items;

  GuestAttributesValue({
    this.items,
  });

  GuestAttributesValue.fromJson(core.Map _json)
      : this(
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<GuestAttributesEntry>((value) =>
                      GuestAttributesEntry.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
      };
}

/// Guest OS features.
class GuestOsFeature {
  /// The ID of a supported feature.
  ///
  /// Read Enabling guest operating system features to see a list of available
  /// options.
  /// Possible string values are:
  /// - "FEATURE_TYPE_UNSPECIFIED"
  /// - "GVNIC"
  /// - "MULTI_IP_SUBNET"
  /// - "SECURE_BOOT"
  /// - "SEV_CAPABLE"
  /// - "UEFI_COMPATIBLE"
  /// - "VIRTIO_SCSI_MULTIQUEUE"
  /// - "WINDOWS"
  core.String? type;

  GuestOsFeature({
    this.type,
  });

  GuestOsFeature.fromJson(core.Map _json)
      : this(
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (type != null) 'type': type!,
      };
}

class HTTP2HealthCheck {
  /// The value of the host header in the HTTP/2 health check request.
  ///
  /// If left empty (default value), the IP on behalf of which this health check
  /// is performed will be used.
  core.String? host;

  /// The TCP port number for the health check request.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values: USE_FIXED_PORT: The port number in port is used for
  /// health checking.
  ///
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking. If not specified, HTTP2 health check follows behavior specified
  /// in port and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in port is used for health checking.
  /// - "USE_NAMED_PORT" : The portName is used for health checking.
  /// - "USE_SERVING_PORT" : For NetworkEndpointGroup, the port specified for
  /// each network endpoint is used for health checking. For other backends, the
  /// port or named port specified in the Backend Service is used for health
  /// checking.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTP/2 health check request.
  ///
  /// The default value is /.
  core.String? requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  ///
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String? response;

  HTTP2HealthCheck({
    this.host,
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.requestPath,
    this.response,
  });

  HTTP2HealthCheck.fromJson(core.Map _json)
      : this(
          host: _json.containsKey('host') ? _json['host'] as core.String : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          portName: _json.containsKey('portName')
              ? _json['portName'] as core.String
              : null,
          portSpecification: _json.containsKey('portSpecification')
              ? _json['portSpecification'] as core.String
              : null,
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
          requestPath: _json.containsKey('requestPath')
              ? _json['requestPath'] as core.String
              : null,
          response: _json.containsKey('response')
              ? _json['response'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (response != null) 'response': response!,
      };
}

class HTTPHealthCheck {
  /// The value of the host header in the HTTP health check request.
  ///
  /// If left empty (default value), the IP on behalf of which this health check
  /// is performed will be used.
  core.String? host;

  /// The TCP port number for the health check request.
  ///
  /// The default value is 80. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values: USE_FIXED_PORT: The port number in port is used for
  /// health checking.
  ///
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking. If not specified, HTTP health check follows behavior specified
  /// in port and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in port is used for health checking.
  /// - "USE_NAMED_PORT" : The portName is used for health checking.
  /// - "USE_SERVING_PORT" : For NetworkEndpointGroup, the port specified for
  /// each network endpoint is used for health checking. For other backends, the
  /// port or named port specified in the Backend Service is used for health
  /// checking.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTP health check request.
  ///
  /// The default value is /.
  core.String? requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  ///
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String? response;

  HTTPHealthCheck({
    this.host,
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.requestPath,
    this.response,
  });

  HTTPHealthCheck.fromJson(core.Map _json)
      : this(
          host: _json.containsKey('host') ? _json['host'] as core.String : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          portName: _json.containsKey('portName')
              ? _json['portName'] as core.String
              : null,
          portSpecification: _json.containsKey('portSpecification')
              ? _json['portSpecification'] as core.String
              : null,
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
          requestPath: _json.containsKey('requestPath')
              ? _json['requestPath'] as core.String
              : null,
          response: _json.containsKey('response')
              ? _json['response'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (response != null) 'response': response!,
      };
}

class HTTPSHealthCheck {
  /// The value of the host header in the HTTPS health check request.
  ///
  /// If left empty (default value), the IP on behalf of which this health check
  /// is performed will be used.
  core.String? host;

  /// The TCP port number for the health check request.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values: USE_FIXED_PORT: The port number in port is used for
  /// health checking.
  ///
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking. If not specified, HTTPS health check follows behavior specified
  /// in port and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in port is used for health checking.
  /// - "USE_NAMED_PORT" : The portName is used for health checking.
  /// - "USE_SERVING_PORT" : For NetworkEndpointGroup, the port specified for
  /// each network endpoint is used for health checking. For other backends, the
  /// port or named port specified in the Backend Service is used for health
  /// checking.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTPS health check request.
  ///
  /// The default value is /.
  core.String? requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  ///
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String? response;

  HTTPSHealthCheck({
    this.host,
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.requestPath,
    this.response,
  });

  HTTPSHealthCheck.fromJson(core.Map _json)
      : this(
          host: _json.containsKey('host') ? _json['host'] as core.String : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          portName: _json.containsKey('portName')
              ? _json['portName'] as core.String
              : null,
          portSpecification: _json.containsKey('portSpecification')
              ? _json['portSpecification'] as core.String
              : null,
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
          requestPath: _json.containsKey('requestPath')
              ? _json['requestPath'] as core.String
              : null,
          response: _json.containsKey('response')
              ? _json['response'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (response != null) 'response': response!,
      };
}

/// Represents a Health Check resource.
///
/// Google Compute Engine has two Health Check resources: *
/// \[Global\](/compute/docs/reference/rest/v1/healthChecks) *
/// \[Regional\](/compute/docs/reference/rest/v1/regionHealthChecks) Internal
/// HTTP(S) load balancers must use regional health checks
/// (`compute.v1.regionHealthChecks`). Traffic Director must use global health
/// checks (`compute.v1.HealthChecks`). Internal TCP/UDP load balancers can use
/// either regional or global health checks (`compute.v1.regionHealthChecks` or
/// `compute.v1.HealthChecks`). External HTTP(S), TCP proxy, and SSL proxy load
/// balancers as well as managed instance group auto-healing must use global
/// health checks (`compute.v1.HealthChecks`). Backend service-based network
/// load balancers must use regional health checks
/// (`compute.v1.regionHealthChecks`). Target pool-based network load balancers
/// must use legacy HTTP health checks (`compute.v1.httpHealthChecks`). For more
/// information, see Health checks overview.
class HealthCheck {
  /// How often (in seconds) to send a health check.
  ///
  /// The default value is 5 seconds.
  core.int? checkIntervalSec;

  /// Creation timestamp in 3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;
  GRPCHealthCheck? grpcHealthCheck;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes.
  ///
  /// The default value is 2.
  core.int? healthyThreshold;
  HTTP2HealthCheck? http2HealthCheck;
  HTTPHealthCheck? httpHealthCheck;
  HTTPSHealthCheck? httpsHealthCheck;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  core.String? kind;

  /// Configure logging on this health check.
  HealthCheckLogConfig? logConfig;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. For example, a name that is 1-63
  /// characters long, matches the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`, and otherwise complies with RFC1035. This
  /// regular expression describes a name where the first character is a
  /// lowercase letter, and all following characters are a dash, lowercase
  /// letter, or digit, except the last character, which isn't a dash.
  core.String? name;

  /// Region where the health check resides.
  ///
  /// Not applicable to global health checks.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;
  SSLHealthCheck? sslHealthCheck;
  TCPHealthCheck? tcpHealthCheck;

  /// How long (in seconds) to wait before claiming failure.
  ///
  /// The default value is 5 seconds. It is invalid for timeoutSec to have
  /// greater value than checkIntervalSec.
  core.int? timeoutSec;

  /// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or
  /// HTTP2.
  ///
  /// If not specified, the default is TCP. Exactly one of the protocol-specific
  /// health check field must be specified, which must match type field.
  /// Possible string values are:
  /// - "GRPC"
  /// - "HTTP"
  /// - "HTTP2"
  /// - "HTTPS"
  /// - "INVALID"
  /// - "SSL"
  /// - "TCP"
  core.String? type;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures.
  ///
  /// The default value is 2.
  core.int? unhealthyThreshold;

  HealthCheck({
    this.checkIntervalSec,
    this.creationTimestamp,
    this.description,
    this.grpcHealthCheck,
    this.healthyThreshold,
    this.http2HealthCheck,
    this.httpHealthCheck,
    this.httpsHealthCheck,
    this.id,
    this.kind,
    this.logConfig,
    this.name,
    this.region,
    this.selfLink,
    this.sslHealthCheck,
    this.tcpHealthCheck,
    this.timeoutSec,
    this.type,
    this.unhealthyThreshold,
  });

  HealthCheck.fromJson(core.Map _json)
      : this(
          checkIntervalSec: _json.containsKey('checkIntervalSec')
              ? _json['checkIntervalSec'] as core.int
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          grpcHealthCheck: _json.containsKey('grpcHealthCheck')
              ? GRPCHealthCheck.fromJson(_json['grpcHealthCheck']
                  as core.Map<core.String, core.dynamic>)
              : null,
          healthyThreshold: _json.containsKey('healthyThreshold')
              ? _json['healthyThreshold'] as core.int
              : null,
          http2HealthCheck: _json.containsKey('http2HealthCheck')
              ? HTTP2HealthCheck.fromJson(_json['http2HealthCheck']
                  as core.Map<core.String, core.dynamic>)
              : null,
          httpHealthCheck: _json.containsKey('httpHealthCheck')
              ? HTTPHealthCheck.fromJson(_json['httpHealthCheck']
                  as core.Map<core.String, core.dynamic>)
              : null,
          httpsHealthCheck: _json.containsKey('httpsHealthCheck')
              ? HTTPSHealthCheck.fromJson(_json['httpsHealthCheck']
                  as core.Map<core.String, core.dynamic>)
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          logConfig: _json.containsKey('logConfig')
              ? HealthCheckLogConfig.fromJson(
                  _json['logConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          sslHealthCheck: _json.containsKey('sslHealthCheck')
              ? SSLHealthCheck.fromJson(_json['sslHealthCheck']
                  as core.Map<core.String, core.dynamic>)
              : null,
          tcpHealthCheck: _json.containsKey('tcpHealthCheck')
              ? TCPHealthCheck.fromJson(_json['tcpHealthCheck']
                  as core.Map<core.String, core.dynamic>)
              : null,
          timeoutSec: _json.containsKey('timeoutSec')
              ? _json['timeoutSec'] as core.int
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
          unhealthyThreshold: _json.containsKey('unhealthyThreshold')
              ? _json['unhealthyThreshold'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (checkIntervalSec != null) 'checkIntervalSec': checkIntervalSec!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (grpcHealthCheck != null)
          'grpcHealthCheck': grpcHealthCheck!.toJson(),
        if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
        if (http2HealthCheck != null)
          'http2HealthCheck': http2HealthCheck!.toJson(),
        if (httpHealthCheck != null)
          'httpHealthCheck': httpHealthCheck!.toJson(),
        if (httpsHealthCheck != null)
          'httpsHealthCheck': httpsHealthCheck!.toJson(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sslHealthCheck != null) 'sslHealthCheck': sslHealthCheck!.toJson(),
        if (tcpHealthCheck != null) 'tcpHealthCheck': tcpHealthCheck!.toJson(),
        if (timeoutSec != null) 'timeoutSec': timeoutSec!,
        if (type != null) 'type': type!,
        if (unhealthyThreshold != null)
          'unhealthyThreshold': unhealthyThreshold!,
      };
}

class HealthCheckListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HealthCheckListWarningData({
    this.key,
    this.value,
  });

  HealthCheckListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HealthCheckListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HealthCheckListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HealthCheckListWarning({
    this.code,
    this.data,
    this.message,
  });

  HealthCheckListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<HealthCheckListWarningData>((value) =>
                      HealthCheckListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of HealthCheck resources.
class HealthCheckList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HealthCheck resources.
  core.List<HealthCheck>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  HealthCheckListWarning? warning;

  HealthCheckList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  HealthCheckList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<HealthCheck>((value) => HealthCheck.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? HealthCheckListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Configuration of logging on a health check.
///
/// If logging is enabled, logs will be exported to Stackdriver.
class HealthCheckLogConfig {
  /// Indicates whether or not to export logs.
  ///
  /// This is false by default, which means no health check logging will be
  /// done.
  core.bool? enable;

  HealthCheckLogConfig({
    this.enable,
  });

  HealthCheckLogConfig.fromJson(core.Map _json)
      : this(
          enable:
              _json.containsKey('enable') ? _json['enable'] as core.bool : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
      };
}

/// A full or valid partial URL to a health check.
///
/// For example, the following are valid URLs: -
/// https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check
/// - projects/project-id/global/httpHealthChecks/health-check -
/// global/httpHealthChecks/health-check
class HealthCheckReference {
  core.String? healthCheck;

  HealthCheckReference({
    this.healthCheck,
  });

  HealthCheckReference.fromJson(core.Map _json)
      : this(
          healthCheck: _json.containsKey('healthCheck')
              ? _json['healthCheck'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthCheck != null) 'healthCheck': healthCheck!,
      };
}

/// Represents a Health-Check as a Service resource.
class HealthCheckService {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// HealthCheckService. An up-to-date fingerprint must be provided in order to
  /// patch/update the HealthCheckService; Otherwise, the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve the HealthCheckService.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of URLs to the HealthCheck resources.
  ///
  /// Must have at least one HealthCheck, and not more than 10. HealthCheck
  /// resources must have portSpecification=USE_SERVING_PORT or
  /// portSpecification=USE_FIXED_PORT. For regional HealthCheckService, the
  /// HealthCheck must be regional and in the same region. For global
  /// HealthCheckService, HealthCheck must be global. Mix of regional and global
  /// HealthChecks is not supported. Multiple regional HealthChecks must belong
  /// to the same region. Regional HealthChecks must belong to the same region
  /// as zones of NEGs.
  core.List<core.String>? healthChecks;

  /// Policy for how the results from multiple health checks for the same
  /// endpoint are aggregated.
  ///
  /// Defaults to NO_AGGREGATION if unspecified. - NO_AGGREGATION. An
  /// EndpointHealth message is returned for each pair in the health check
  /// service. - AND. If any health check of an endpoint reports UNHEALTHY, then
  /// UNHEALTHY is the HealthState of the endpoint. If all health checks report
  /// HEALTHY, the HealthState of the endpoint is HEALTHY. .
  ///
  /// Optional.
  /// Possible string values are:
  /// - "AND" : If any backend's health check reports UNHEALTHY, then UNHEALTHY
  /// is the HealthState of the entire health check service. If all backend's
  /// are healthy, the HealthState of the health check service is HEALTHY.
  /// - "NO_AGGREGATION" : An EndpointHealth message is returned for each
  /// backend in the health check service.
  core.String? healthStatusAggregationPolicy;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#healthCheckServicefor health check services.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// A list of URLs to the NetworkEndpointGroup resources.
  ///
  /// Must not have more than 100. For regional HealthCheckService, NEGs must be
  /// in zones in the region of the HealthCheckService.
  core.List<core.String>? networkEndpointGroups;

  /// A list of URLs to the NotificationEndpoint resources.
  ///
  /// Must not have more than 10. A list of endpoints for receiving
  /// notifications of change in health status. For regional HealthCheckService,
  /// NotificationEndpoint must be regional and in the same region. For global
  /// HealthCheckService, NotificationEndpoint must be global.
  core.List<core.String>? notificationEndpoints;

  /// URL of the region where the health check service resides.
  ///
  /// This field is not applicable to global health check services. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  HealthCheckService({
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.healthChecks,
    this.healthStatusAggregationPolicy,
    this.id,
    this.kind,
    this.name,
    this.networkEndpointGroups,
    this.notificationEndpoints,
    this.region,
    this.selfLink,
  });

  HealthCheckService.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          healthChecks: _json.containsKey('healthChecks')
              ? (_json['healthChecks'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          healthStatusAggregationPolicy:
              _json.containsKey('healthStatusAggregationPolicy')
                  ? _json['healthStatusAggregationPolicy'] as core.String
                  : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          networkEndpointGroups: _json.containsKey('networkEndpointGroups')
              ? (_json['networkEndpointGroups'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          notificationEndpoints: _json.containsKey('notificationEndpoints')
              ? (_json['notificationEndpoints'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (healthChecks != null) 'healthChecks': healthChecks!,
        if (healthStatusAggregationPolicy != null)
          'healthStatusAggregationPolicy': healthStatusAggregationPolicy!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (networkEndpointGroups != null)
          'networkEndpointGroups': networkEndpointGroups!,
        if (notificationEndpoints != null)
          'notificationEndpoints': notificationEndpoints!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// A full or valid partial URL to a health check service.
///
/// For example, the following are valid URLs: -
/// https://www.googleapis.com/compute/beta/projects/project-id/regions/us-west1/healthCheckServices/health-check-service
/// -
/// projects/project-id/regions/us-west1/healthCheckServices/health-check-service
/// - regions/us-west1/healthCheckServices/health-check-service
class HealthCheckServiceReference {
  core.String? healthCheckService;

  HealthCheckServiceReference({
    this.healthCheckService,
  });

  HealthCheckServiceReference.fromJson(core.Map _json)
      : this(
          healthCheckService: _json.containsKey('healthCheckService')
              ? _json['healthCheckService'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthCheckService != null)
          'healthCheckService': healthCheckService!,
      };
}

class HealthCheckServicesListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HealthCheckServicesListWarningData({
    this.key,
    this.value,
  });

  HealthCheckServicesListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HealthCheckServicesListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HealthCheckServicesListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HealthCheckServicesListWarning({
    this.code,
    this.data,
    this.message,
  });

  HealthCheckServicesListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<HealthCheckServicesListWarningData>((value) =>
                      HealthCheckServicesListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class HealthCheckServicesList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HealthCheckService resources.
  core.List<HealthCheckService>? items;

  /// Type of the resource.
  ///
  /// Always compute#healthCheckServicesList for lists of HealthCheckServices.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  HealthCheckServicesListWarning? warning;

  HealthCheckServicesList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  HealthCheckServicesList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<HealthCheckService>((value) =>
                      HealthCheckService.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? HealthCheckServicesListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class HealthChecksAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HealthChecksAggregatedListWarningData({
    this.key,
    this.value,
  });

  HealthChecksAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HealthChecksAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HealthChecksAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HealthChecksAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  HealthChecksAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<HealthChecksAggregatedListWarningData>((value) =>
                      HealthChecksAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class HealthChecksAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HealthChecksScopedList resources.
  core.Map<core.String, HealthChecksScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  HealthChecksAggregatedListWarning? warning;

  HealthChecksAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  HealthChecksAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    HealthChecksScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? HealthChecksAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class HealthChecksScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HealthChecksScopedListWarningData({
    this.key,
    this.value,
  });

  HealthChecksScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class HealthChecksScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HealthChecksScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HealthChecksScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  HealthChecksScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<HealthChecksScopedListWarningData>((value) =>
                      HealthChecksScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class HealthChecksScopedList {
  /// A list of HealthChecks contained in this scope.
  core.List<HealthCheck>? healthChecks;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  HealthChecksScopedListWarning? warning;

  HealthChecksScopedList({
    this.healthChecks,
    this.warning,
  });

  HealthChecksScopedList.fromJson(core.Map _json)
      : this(
          healthChecks: _json.containsKey('healthChecks')
              ? (_json['healthChecks'] as core.List)
                  .map<HealthCheck>((value) => HealthCheck.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? HealthChecksScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthChecks != null)
          'healthChecks': healthChecks!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class HealthStatus {
  /// Metadata defined as annotations for network endpoint.
  core.Map<core.String, core.String>? annotations;

  /// URL of the forwarding rule associated with the health status of the
  /// instance.
  core.String? forwardingRule;

  /// A forwarding rule IP address assigned to this instance.
  core.String? forwardingRuleIp;

  /// Health state of the instance.
  /// Possible string values are:
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  core.String? healthState;

  /// URL of the instance resource.
  core.String? instance;

  /// For target pool based Network Load Balancing, it indicates the forwarding
  /// rule's IP address assigned to this instance.
  ///
  /// For other types of load balancing, the field indicates VM internal ip.
  core.String? ipAddress;

  /// The named port of the instance group, not necessarily the port that is
  /// health-checked.
  core.int? port;
  core.String? weight;

  ///
  /// Possible string values are:
  /// - "INVALID_WEIGHT" : The response to a Health Check probe had the HTTP
  /// response header field X-Load-Balancing-Endpoint-Weight, but its content
  /// was invalid (i.e., not a non-negative single-precision floating-point
  /// number in decimal string representation).
  /// - "MISSING_WEIGHT" : The response to a Health Check probe did not have the
  /// HTTP response header field X-Load-Balancing-Endpoint-Weight.
  /// - "UNAVAILABLE_WEIGHT" : This is the value when the accompanied health
  /// status is either TIMEOUT (i.e.,the Health Check probe was not able to get
  /// a response in time) or UNKNOWN. For the latter, it should be typically
  /// because there has not been sufficient time to parse and report the weight
  /// for a new backend (which is with 0.0.0.0 ip address). However, it can be
  /// also due to an outage case for which the health status is explicitly reset
  /// to UNKNOWN.
  /// - "WEIGHT_NONE" : This is the default value when WeightReportMode is
  /// DISABLE, and is also the initial value when WeightReportMode has just
  /// updated to ENABLE or DRY_RUN and there has not been sufficient time to
  /// parse and report the backend weight.
  core.String? weightError;

  HealthStatus({
    this.annotations,
    this.forwardingRule,
    this.forwardingRuleIp,
    this.healthState,
    this.instance,
    this.ipAddress,
    this.port,
    this.weight,
    this.weightError,
  });

  HealthStatus.fromJson(core.Map _json)
      : this(
          annotations: _json.containsKey('annotations')
              ? (_json['annotations'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          forwardingRule: _json.containsKey('forwardingRule')
              ? _json['forwardingRule'] as core.String
              : null,
          forwardingRuleIp: _json.containsKey('forwardingRuleIp')
              ? _json['forwardingRuleIp'] as core.String
              : null,
          healthState: _json.containsKey('healthState')
              ? _json['healthState'] as core.String
              : null,
          instance: _json.containsKey('instance')
              ? _json['instance'] as core.String
              : null,
          ipAddress: _json.containsKey('ipAddress')
              ? _json['ipAddress'] as core.String
              : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          weight: _json.containsKey('weight')
              ? _json['weight'] as core.String
              : null,
          weightError: _json.containsKey('weightError')
              ? _json['weightError'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (forwardingRule != null) 'forwardingRule': forwardingRule!,
        if (forwardingRuleIp != null) 'forwardingRuleIp': forwardingRuleIp!,
        if (healthState != null) 'healthState': healthState!,
        if (instance != null) 'instance': instance!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (port != null) 'port': port!,
        if (weight != null) 'weight': weight!,
        if (weightError != null) 'weightError': weightError!,
      };
}

class HealthStatusForNetworkEndpoint {
  /// URL of the backend service associated with the health state of the network
  /// endpoint.
  BackendServiceReference? backendService;

  /// URL of the forwarding rule associated with the health state of the network
  /// endpoint.
  ForwardingRuleReference? forwardingRule;

  /// URL of the health check associated with the health state of the network
  /// endpoint.
  HealthCheckReference? healthCheck;

  /// URL of the health check service associated with the health state of the
  /// network endpoint.
  HealthCheckServiceReference? healthCheckService;

  /// Health state of the network endpoint determined based on the health checks
  /// configured.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  /// - "UNKNOWN"
  core.String? healthState;

  HealthStatusForNetworkEndpoint({
    this.backendService,
    this.forwardingRule,
    this.healthCheck,
    this.healthCheckService,
    this.healthState,
  });

  HealthStatusForNetworkEndpoint.fromJson(core.Map _json)
      : this(
          backendService: _json.containsKey('backendService')
              ? BackendServiceReference.fromJson(_json['backendService']
                  as core.Map<core.String, core.dynamic>)
              : null,
          forwardingRule: _json.containsKey('forwardingRule')
              ? ForwardingRuleReference.fromJson(_json['forwardingRule']
                  as core.Map<core.String, core.dynamic>)
              : null,
          healthCheck: _json.containsKey('healthCheck')
              ? HealthCheckReference.fromJson(
                  _json['healthCheck'] as core.Map<core.String, core.dynamic>)
              : null,
          healthCheckService: _json.containsKey('healthCheckService')
              ? HealthCheckServiceReference.fromJson(_json['healthCheckService']
                  as core.Map<core.String, core.dynamic>)
              : null,
          healthState: _json.containsKey('healthState')
              ? _json['healthState'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendService != null) 'backendService': backendService!.toJson(),
        if (forwardingRule != null) 'forwardingRule': forwardingRule!.toJson(),
        if (healthCheck != null) 'healthCheck': healthCheck!.toJson(),
        if (healthCheckService != null)
          'healthCheckService': healthCheckService!.toJson(),
        if (healthState != null) 'healthState': healthState!,
      };
}

/// UrlMaps A host-matching rule for a URL.
///
/// If matched, will use the named PathMatcher to select the BackendService.
class HostRule {
  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The list of host patterns to match.
  ///
  /// They must be valid hostnames with optional port numbers in the format
  /// host:port. * matches any string of (\[a-z0-9-.\]*). In that case, * must
  /// be the first character and must be followed in the pattern by either - or
  /// .. * based matching is not supported when the URL map is bound to target
  /// gRPC proxy that has validateForProxyless field set to true.
  core.List<core.String>? hosts;

  /// The name of the PathMatcher to use to match the path portion of the URL if
  /// the hostRule matches the URL's host portion.
  core.String? pathMatcher;

  HostRule({
    this.description,
    this.hosts,
    this.pathMatcher,
  });

  HostRule.fromJson(core.Map _json)
      : this(
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          hosts: _json.containsKey('hosts')
              ? (_json['hosts'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          pathMatcher: _json.containsKey('pathMatcher')
              ? _json['pathMatcher'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (hosts != null) 'hosts': hosts!,
        if (pathMatcher != null) 'pathMatcher': pathMatcher!,
      };
}

/// Specification for how requests are aborted as part of fault injection.
class HttpFaultAbort {
  /// The HTTP status code used to abort the request.
  ///
  /// The value must be between 200 and 599 inclusive. For gRPC protocol, the
  /// gRPC status code is mapped to HTTP status code according to this mapping
  /// table. HTTP status 200 is mapped to gRPC status UNKNOWN. Injecting an OK
  /// status is currently not supported by Traffic Director.
  core.int? httpStatus;

  /// The percentage of traffic (connections/operations/requests) which will be
  /// aborted as part of fault injection.
  ///
  /// The value must be between 0.0 and 100.0 inclusive.
  core.double? percentage;

  HttpFaultAbort({
    this.httpStatus,
    this.percentage,
  });

  HttpFaultAbort.fromJson(core.Map _json)
      : this(
          httpStatus: _json.containsKey('httpStatus')
              ? _json['httpStatus'] as core.int
              : null,
          percentage: _json.containsKey('percentage')
              ? (_json['percentage'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (httpStatus != null) 'httpStatus': httpStatus!,
        if (percentage != null) 'percentage': percentage!,
      };
}

/// Specifies the delay introduced by Loadbalancer before forwarding the request
/// to the backend service as part of fault injection.
class HttpFaultDelay {
  /// Specifies the value of the fixed delay interval.
  Duration? fixedDelay;

  /// The percentage of traffic (connections/operations/requests) on which delay
  /// will be introduced as part of fault injection.
  ///
  /// The value must be between 0.0 and 100.0 inclusive.
  core.double? percentage;

  HttpFaultDelay({
    this.fixedDelay,
    this.percentage,
  });

  HttpFaultDelay.fromJson(core.Map _json)
      : this(
          fixedDelay: _json.containsKey('fixedDelay')
              ? Duration.fromJson(
                  _json['fixedDelay'] as core.Map<core.String, core.dynamic>)
              : null,
          percentage: _json.containsKey('percentage')
              ? (_json['percentage'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fixedDelay != null) 'fixedDelay': fixedDelay!.toJson(),
        if (percentage != null) 'percentage': percentage!,
      };
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure.
///
/// As part of fault injection, when clients send requests to a backend service,
/// delays can be introduced by Loadbalancer on a percentage of requests before
/// sending those request to the backend service. Similarly requests from
/// clients can be aborted by the Loadbalancer for a percentage of requests.
class HttpFaultInjection {
  /// The specification for how client requests are aborted as part of fault
  /// injection.
  HttpFaultAbort? abort;

  /// The specification for how client requests are delayed as part of fault
  /// injection, before being sent to a backend service.
  HttpFaultDelay? delay;

  HttpFaultInjection({
    this.abort,
    this.delay,
  });

  HttpFaultInjection.fromJson(core.Map _json)
      : this(
          abort: _json.containsKey('abort')
              ? HttpFaultAbort.fromJson(
                  _json['abort'] as core.Map<core.String, core.dynamic>)
              : null,
          delay: _json.containsKey('delay')
              ? HttpFaultDelay.fromJson(
                  _json['delay'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (abort != null) 'abort': abort!.toJson(),
        if (delay != null) 'delay': delay!.toJson(),
      };
}

/// The request and response header transformations that take effect before the
/// request is passed along to the selected backendService.
class HttpHeaderAction {
  /// Headers to add to a matching request prior to forwarding the request to
  /// the backendService.
  core.List<HttpHeaderOption>? requestHeadersToAdd;

  /// A list of header names for headers that need to be removed from the
  /// request prior to forwarding the request to the backendService.
  core.List<core.String>? requestHeadersToRemove;

  /// Headers to add the response prior to sending the response back to the
  /// client.
  core.List<HttpHeaderOption>? responseHeadersToAdd;

  /// A list of header names for headers that need to be removed from the
  /// response prior to sending the response back to the client.
  core.List<core.String>? responseHeadersToRemove;

  HttpHeaderAction({
    this.requestHeadersToAdd,
    this.requestHeadersToRemove,
    this.responseHeadersToAdd,
    this.responseHeadersToRemove,
  });

  HttpHeaderAction.fromJson(core.Map _json)
      : this(
          requestHeadersToAdd: _json.containsKey('requestHeadersToAdd')
              ? (_json['requestHeadersToAdd'] as core.List)
                  .map<HttpHeaderOption>((value) => HttpHeaderOption.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          requestHeadersToRemove: _json.containsKey('requestHeadersToRemove')
              ? (_json['requestHeadersToRemove'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          responseHeadersToAdd: _json.containsKey('responseHeadersToAdd')
              ? (_json['responseHeadersToAdd'] as core.List)
                  .map<HttpHeaderOption>((value) => HttpHeaderOption.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          responseHeadersToRemove: _json.containsKey('responseHeadersToRemove')
              ? (_json['responseHeadersToRemove'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (requestHeadersToAdd != null)
          'requestHeadersToAdd':
              requestHeadersToAdd!.map((value) => value.toJson()).toList(),
        if (requestHeadersToRemove != null)
          'requestHeadersToRemove': requestHeadersToRemove!,
        if (responseHeadersToAdd != null)
          'responseHeadersToAdd':
              responseHeadersToAdd!.map((value) => value.toJson()).toList(),
        if (responseHeadersToRemove != null)
          'responseHeadersToRemove': responseHeadersToRemove!,
      };
}

/// matchRule criteria for request header matches.
class HttpHeaderMatch {
  /// The value should exactly match contents of exactMatch.
  ///
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String? exactMatch;

  /// The name of the HTTP header to match.
  ///
  /// For matching against the HTTP request's authority, use a headerMatch with
  /// the header name ":authority". For matching a request's method, use the
  /// headerName ":method". When the URL map is bound to target gRPC proxy that
  /// has validateForProxyless field set to true, only non-binary user-specified
  /// custom metadata and the \`content-type\` header are supported. The
  /// following transport-level headers cannot be used in header matching rules:
  /// \`:authority\`, \`:method\`, \`:path\`, \`:scheme\`, \`user-agent\`,
  /// \`accept-encoding\`, \`content-encoding\`, \`grpc-accept-encoding\`,
  /// \`grpc-encoding\`, \`grpc-previous-rpc-attempts\`, \`grpc-tags-bin\`,
  /// \`grpc-timeout\` and \`grpc-trace-bin.
  core.String? headerName;

  /// If set to false, the headerMatch is considered a match if the match
  /// criteria above are met.
  ///
  /// If set to true, the headerMatch is considered a match if the match
  /// criteria above are NOT met. The default setting is false.
  core.bool? invertMatch;

  /// The value of the header must start with the contents of prefixMatch.
  ///
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String? prefixMatch;

  /// A header with the contents of headerName must exist.
  ///
  /// The match takes place whether or not the request's header has a value.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.bool? presentMatch;

  /// The header value must be an integer and its value must be in the range
  /// specified in rangeMatch.
  ///
  /// If the header does not contain an integer, number or is empty, the match
  /// fails. For example for a range \[-5, 0\] - -3 will match. - 0 will not
  /// match. - 0.25 will not match. - -3someString will not match. Only one of
  /// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
  /// rangeMatch must be set. Note that rangeMatch is not supported for
  /// Loadbalancers that have their loadBalancingScheme set to EXTERNAL.
  Int64RangeMatch? rangeMatch;

  /// The value of the header must match the regular expression specified in
  /// regexMatch.
  ///
  /// For regular expression grammar, please see:
  /// github.com/google/re2/wiki/Syntax For matching against a port specified in
  /// the HTTP request, use a headerMatch with headerName set to PORT and a
  /// regular expression that satisfies the RFC2616 Host header's port
  /// specifier. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
  /// presentMatch or rangeMatch must be set. Note that regexMatch only applies
  /// to Loadbalancers that have their loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED.
  core.String? regexMatch;

  /// The value of the header must end with the contents of suffixMatch.
  ///
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String? suffixMatch;

  HttpHeaderMatch({
    this.exactMatch,
    this.headerName,
    this.invertMatch,
    this.prefixMatch,
    this.presentMatch,
    this.rangeMatch,
    this.regexMatch,
    this.suffixMatch,
  });

  HttpHeaderMatch.fromJson(core.Map _json)
      : this(
          exactMatch: _json.containsKey('exactMatch')
              ? _json['exactMatch'] as core.String
              : null,
          headerName: _json.containsKey('headerName')
              ? _json['headerName'] as core.String
              : null,
          invertMatch: _json.containsKey('invertMatch')
              ? _json['invertMatch'] as core.bool
              : null,
          prefixMatch: _json.containsKey('prefixMatch')
              ? _json['prefixMatch'] as core.String
              : null,
          presentMatch: _json.containsKey('presentMatch')
              ? _json['presentMatch'] as core.bool
              : null,
          rangeMatch: _json.containsKey('rangeMatch')
              ? Int64RangeMatch.fromJson(
                  _json['rangeMatch'] as core.Map<core.String, core.dynamic>)
              : null,
          regexMatch: _json.containsKey('regexMatch')
              ? _json['regexMatch'] as core.String
              : null,
          suffixMatch: _json.containsKey('suffixMatch')
              ? _json['suffixMatch'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exactMatch != null) 'exactMatch': exactMatch!,
        if (headerName != null) 'headerName': headerName!,
        if (invertMatch != null) 'invertMatch': invertMatch!,
        if (prefixMatch != null) 'prefixMatch': prefixMatch!,
        if (presentMatch != null) 'presentMatch': presentMatch!,
        if (rangeMatch != null) 'rangeMatch': rangeMatch!.toJson(),
        if (regexMatch != null) 'regexMatch': regexMatch!,
        if (suffixMatch != null) 'suffixMatch': suffixMatch!,
      };
}

/// Specification determining how headers are added to requests or responses.
class HttpHeaderOption {
  /// The name of the header.
  core.String? headerName;

  /// The value of the header to add.
  core.String? headerValue;

  /// If false, headerValue is appended to any values that already exist for the
  /// header.
  ///
  /// If true, headerValue is set for the header, discarding any values that
  /// were set for that header. The default value is false.
  core.bool? replace;

  HttpHeaderOption({
    this.headerName,
    this.headerValue,
    this.replace,
  });

  HttpHeaderOption.fromJson(core.Map _json)
      : this(
          headerName: _json.containsKey('headerName')
              ? _json['headerName'] as core.String
              : null,
          headerValue: _json.containsKey('headerValue')
              ? _json['headerValue'] as core.String
              : null,
          replace: _json.containsKey('replace')
              ? _json['replace'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (headerName != null) 'headerName': headerName!,
        if (headerValue != null) 'headerValue': headerValue!,
        if (replace != null) 'replace': replace!,
      };
}

/// Represents a legacy HTTP Health Check resource.
///
/// Legacy HTTP health checks are now only required by target pool-based network
/// load balancers. For all other load balancers, including backend
/// service-based network load balancers, and for managed instance group
/// auto-healing, you must use modern (non-legacy) health checks. For more
/// information, see Health checks overview .
class HttpHealthCheck {
  /// How often (in seconds) to send a health check.
  ///
  /// The default value is 5 seconds.
  core.int? checkIntervalSec;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes.
  ///
  /// The default value is 2.
  core.int? healthyThreshold;

  /// The value of the host header in the HTTP health check request.
  ///
  /// If left empty (default value), the public IP on behalf of which this
  /// health check is performed will be used.
  core.String? host;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#httpHealthCheck for HTTP health checks.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The TCP port number for the HTTP health check request.
  ///
  /// The default value is 80.
  core.int? port;

  /// The request path of the HTTP health check request.
  ///
  /// The default value is /. This field does not support query parameters.
  core.String? requestPath;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// How long (in seconds) to wait before claiming failure.
  ///
  /// The default value is 5 seconds. It is invalid for timeoutSec to have
  /// greater value than checkIntervalSec.
  core.int? timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures.
  ///
  /// The default value is 2.
  core.int? unhealthyThreshold;

  HttpHealthCheck({
    this.checkIntervalSec,
    this.creationTimestamp,
    this.description,
    this.healthyThreshold,
    this.host,
    this.id,
    this.kind,
    this.name,
    this.port,
    this.requestPath,
    this.selfLink,
    this.timeoutSec,
    this.unhealthyThreshold,
  });

  HttpHealthCheck.fromJson(core.Map _json)
      : this(
          checkIntervalSec: _json.containsKey('checkIntervalSec')
              ? _json['checkIntervalSec'] as core.int
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          healthyThreshold: _json.containsKey('healthyThreshold')
              ? _json['healthyThreshold'] as core.int
              : null,
          host: _json.containsKey('host') ? _json['host'] as core.String : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          requestPath: _json.containsKey('requestPath')
              ? _json['requestPath'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          timeoutSec: _json.containsKey('timeoutSec')
              ? _json['timeoutSec'] as core.int
              : null,
          unhealthyThreshold: _json.containsKey('unhealthyThreshold')
              ? _json['unhealthyThreshold'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (checkIntervalSec != null) 'checkIntervalSec': checkIntervalSec!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
        if (host != null) 'host': host!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (port != null) 'port': port!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (timeoutSec != null) 'timeoutSec': timeoutSec!,
        if (unhealthyThreshold != null)
          'unhealthyThreshold': unhealthyThreshold!,
      };
}

class HttpHealthCheckListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HttpHealthCheckListWarningData({
    this.key,
    this.value,
  });

  HttpHealthCheckListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HttpHealthCheckListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HttpHealthCheckListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HttpHealthCheckListWarning({
    this.code,
    this.data,
    this.message,
  });

  HttpHealthCheckListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<HttpHealthCheckListWarningData>((value) =>
                      HttpHealthCheckListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of HttpHealthCheck resources.
class HttpHealthCheckList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HttpHealthCheck resources.
  core.List<HttpHealthCheck>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  HttpHealthCheckListWarning? warning;

  HttpHealthCheckList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  HttpHealthCheckList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<HttpHealthCheck>((value) => HttpHealthCheck.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? HttpHealthCheckListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// HttpRouteRuleMatch criteria for a request's query parameter.
class HttpQueryParameterMatch {
  /// The queryParameterMatch matches if the value of the parameter exactly
  /// matches the contents of exactMatch.
  ///
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  core.String? exactMatch;

  /// The name of the query parameter to match.
  ///
  /// The query parameter must exist in the request, in the absence of which the
  /// request match fails.
  core.String? name;

  /// Specifies that the queryParameterMatch matches if the request contains the
  /// query parameter, irrespective of whether the parameter has a value or not.
  ///
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  core.bool? presentMatch;

  /// The queryParameterMatch matches if the value of the parameter matches the
  /// regular expression specified by regexMatch.
  ///
  /// For the regular expression grammar, please see
  /// github.com/google/re2/wiki/Syntax Only one of presentMatch, exactMatch or
  /// regexMatch must be set. Note that regexMatch only applies when the
  /// loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
  core.String? regexMatch;

  HttpQueryParameterMatch({
    this.exactMatch,
    this.name,
    this.presentMatch,
    this.regexMatch,
  });

  HttpQueryParameterMatch.fromJson(core.Map _json)
      : this(
          exactMatch: _json.containsKey('exactMatch')
              ? _json['exactMatch'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          presentMatch: _json.containsKey('presentMatch')
              ? _json['presentMatch'] as core.bool
              : null,
          regexMatch: _json.containsKey('regexMatch')
              ? _json['regexMatch'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exactMatch != null) 'exactMatch': exactMatch!,
        if (name != null) 'name': name!,
        if (presentMatch != null) 'presentMatch': presentMatch!,
        if (regexMatch != null) 'regexMatch': regexMatch!,
      };
}

/// Specifies settings for an HTTP redirect.
class HttpRedirectAction {
  /// The host that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  ///
  /// The value must be between 1 and 255 characters.
  core.String? hostRedirect;

  /// If set to true, the URL scheme in the redirected request is set to https.
  ///
  /// If set to false, the URL scheme of the redirected request will remain the
  /// same as that of the request. This must only be set for UrlMaps used in
  /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not permitted.
  /// The default is set to false.
  core.bool? httpsRedirect;

  /// The path that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  ///
  /// pathRedirect cannot be supplied together with prefixRedirect. Supply one
  /// alone or neither. If neither is supplied, the path of the original request
  /// will be used for the redirect. The value must be between 1 and 1024
  /// characters.
  core.String? pathRedirect;

  /// The prefix that replaces the prefixMatch specified in the
  /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
  /// redirecting the request.
  ///
  /// prefixRedirect cannot be supplied together with pathRedirect. Supply one
  /// alone or neither. If neither is supplied, the path of the original request
  /// will be used for the redirect. The value must be between 1 and 1024
  /// characters.
  core.String? prefixRedirect;

  /// The HTTP Status code to use for this RedirectAction.
  ///
  /// Supported values are: - MOVED_PERMANENTLY_DEFAULT, which is the default
  /// value and corresponds to 301. - FOUND, which corresponds to 302. -
  /// SEE_OTHER which corresponds to 303. - TEMPORARY_REDIRECT, which
  /// corresponds to 307. In this case, the request method will be retained. -
  /// PERMANENT_REDIRECT, which corresponds to 308. In this case, the request
  /// method will be retained.
  /// Possible string values are:
  /// - "FOUND" : Http Status Code 302 - Found.
  /// - "MOVED_PERMANENTLY_DEFAULT" : Http Status Code 301 - Moved Permanently.
  /// - "PERMANENT_REDIRECT" : Http Status Code 308 - Permanent Redirect
  /// maintaining HTTP method.
  /// - "SEE_OTHER" : Http Status Code 303 - See Other.
  /// - "TEMPORARY_REDIRECT" : Http Status Code 307 - Temporary Redirect
  /// maintaining HTTP method.
  core.String? redirectResponseCode;

  /// If set to true, any accompanying query portion of the original URL is
  /// removed prior to redirecting the request.
  ///
  /// If set to false, the query portion of the original URL is retained. The
  /// default is set to false.
  core.bool? stripQuery;

  HttpRedirectAction({
    this.hostRedirect,
    this.httpsRedirect,
    this.pathRedirect,
    this.prefixRedirect,
    this.redirectResponseCode,
    this.stripQuery,
  });

  HttpRedirectAction.fromJson(core.Map _json)
      : this(
          hostRedirect: _json.containsKey('hostRedirect')
              ? _json['hostRedirect'] as core.String
              : null,
          httpsRedirect: _json.containsKey('httpsRedirect')
              ? _json['httpsRedirect'] as core.bool
              : null,
          pathRedirect: _json.containsKey('pathRedirect')
              ? _json['pathRedirect'] as core.String
              : null,
          prefixRedirect: _json.containsKey('prefixRedirect')
              ? _json['prefixRedirect'] as core.String
              : null,
          redirectResponseCode: _json.containsKey('redirectResponseCode')
              ? _json['redirectResponseCode'] as core.String
              : null,
          stripQuery: _json.containsKey('stripQuery')
              ? _json['stripQuery'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (hostRedirect != null) 'hostRedirect': hostRedirect!,
        if (httpsRedirect != null) 'httpsRedirect': httpsRedirect!,
        if (pathRedirect != null) 'pathRedirect': pathRedirect!,
        if (prefixRedirect != null) 'prefixRedirect': prefixRedirect!,
        if (redirectResponseCode != null)
          'redirectResponseCode': redirectResponseCode!,
        if (stripQuery != null) 'stripQuery': stripQuery!,
      };
}

/// The retry policy associates with HttpRouteRule
class HttpRetryPolicy {
  /// Specifies the allowed number retries.
  ///
  /// This number must be > 0. If not specified, defaults to 1.
  core.int? numRetries;

  /// Specifies a non-zero timeout per retry attempt.
  ///
  /// If not specified, will use the timeout set in HttpRouteAction. If timeout
  /// in HttpRouteAction is not set, will use the largest timeout among all
  /// backend services associated with the route.
  Duration? perTryTimeout;

  /// Specifies one or more conditions when this retry policy applies.
  ///
  /// Valid values are: - 5xx: Retry will be attempted if the instance or
  /// endpoint responds with any 5xx response code, or if the instance or
  /// endpoint does not respond at all, example: disconnects, reset, read
  /// timeout, connection failure, and refused streams. - gateway-error: Similar
  /// to 5xx, but only applies to response codes 502, 503 or 504. - -
  /// connect-failure: A retry will be attempted on failures connecting to the
  /// instance or endpoint, for example due to connection timeouts. -
  /// retriable-4xx: A retry will be attempted if the instance or endpoint
  /// responds with a retriable 4xx response code. Currently the only retriable
  /// error supported is 409. - refused-stream: A retry will be attempted if the
  /// instance or endpoint resets the stream with a REFUSED_STREAM error code.
  /// This reset type indicates that it is safe to retry. - cancelled: A retry
  /// will be attempted if the gRPC status code in the response header is set to
  /// cancelled. - deadline-exceeded: A retry will be attempted if the gRPC
  /// status code in the response header is set to deadline-exceeded. -
  /// internal: A retry will be attempted if the gRPC status code in the
  /// response header is set to internal. - resource-exhausted: A retry will be
  /// attempted if the gRPC status code in the response header is set to
  /// resource-exhausted. - unavailable: A retry will be attempted if the gRPC
  /// status code in the response header is set to unavailable.
  core.List<core.String>? retryConditions;

  HttpRetryPolicy({
    this.numRetries,
    this.perTryTimeout,
    this.retryConditions,
  });

  HttpRetryPolicy.fromJson(core.Map _json)
      : this(
          numRetries: _json.containsKey('numRetries')
              ? _json['numRetries'] as core.int
              : null,
          perTryTimeout: _json.containsKey('perTryTimeout')
              ? Duration.fromJson(
                  _json['perTryTimeout'] as core.Map<core.String, core.dynamic>)
              : null,
          retryConditions: _json.containsKey('retryConditions')
              ? (_json['retryConditions'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (numRetries != null) 'numRetries': numRetries!,
        if (perTryTimeout != null) 'perTryTimeout': perTryTimeout!.toJson(),
        if (retryConditions != null) 'retryConditions': retryConditions!,
      };
}

class HttpRouteAction {
  /// The specification for allowing client side cross-origin requests.
  ///
  /// Please see W3C Recommendation for Cross Origin Resource Sharing Not
  /// supported when the URL map is bound to target gRPC proxy.
  CorsPolicy? corsPolicy;

  /// The specification for fault injection introduced into traffic to test the
  /// resiliency of clients to backend service failure.
  ///
  /// As part of fault injection, when clients send requests to a backend
  /// service, delays can be introduced by Loadbalancer on a percentage of
  /// requests before sending those request to the backend service. Similarly
  /// requests from clients can be aborted by the Loadbalancer for a percentage
  /// of requests. For the requests impacted by fault injection, timeout and
  /// retry_policy will be ignored by clients that are configured with a
  /// fault_injection_policy.
  HttpFaultInjection? faultInjectionPolicy;

  /// Specifies the maximum duration (timeout) for streams on the selected
  /// route.
  ///
  /// Unlike the timeout field where the timeout duration starts from the time
  /// the request has been fully processed (i.e. end-of-stream), the duration in
  /// this field is computed from the beginning of the stream until the response
  /// has been completely processed, including all retries. A stream that does
  /// not complete in this duration is closed. If not specified, will use the
  /// largest maxStreamDuration among all backend services associated with the
  /// route. This field is only allowed if the Url map is used with backend
  /// services with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  Duration? maxStreamDuration;

  /// Specifies the policy on how requests intended for the route's backends are
  /// shadowed to a separate mirrored backend service.
  ///
  /// Loadbalancer does not wait for responses from the shadow service. Prior to
  /// sending traffic to the shadow service, the host / authority header is
  /// suffixed with -shadow. Not supported when the URL map is bound to target
  /// gRPC proxy that has validateForProxyless field set to true.
  RequestMirrorPolicy? requestMirrorPolicy;

  /// Specifies the retry policy associated with this route.
  ///
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpRetryPolicy? retryPolicy;

  /// Specifies the timeout for the selected route.
  ///
  /// Timeout is computed from the time the request has been fully processed
  /// (i.e. end-of-stream) up until the response has been completely processed.
  /// Timeout includes all retries. If not specified, will use the largest
  /// timeout among all backend services associated with the route. Not
  /// supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  Duration? timeout;

  /// The spec to modify the URL of the request, prior to forwarding the request
  /// to the matched service.
  ///
  /// urlRewrite is the only action supported in UrlMaps for external HTTP(S)
  /// load balancers. Not supported when the URL map is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  UrlRewrite? urlRewrite;

  /// A list of weighted backend services to send traffic to when a route match
  /// occurs.
  ///
  /// The weights determine the fraction of traffic that flows to their
  /// corresponding backend service. If all traffic needs to go to a single
  /// backend service, there must be one weightedBackendService with weight set
  /// to a non-zero number. Once a backendService is identified and before
  /// forwarding the request to the backend service, advanced routing actions
  /// such as URL rewrites and header transformations are applied depending on
  /// additional settings specified in this HttpRouteAction.
  core.List<WeightedBackendService>? weightedBackendServices;

  HttpRouteAction({
    this.corsPolicy,
    this.faultInjectionPolicy,
    this.maxStreamDuration,
    this.requestMirrorPolicy,
    this.retryPolicy,
    this.timeout,
    this.urlRewrite,
    this.weightedBackendServices,
  });

  HttpRouteAction.fromJson(core.Map _json)
      : this(
          corsPolicy: _json.containsKey('corsPolicy')
              ? CorsPolicy.fromJson(
                  _json['corsPolicy'] as core.Map<core.String, core.dynamic>)
              : null,
          faultInjectionPolicy: _json.containsKey('faultInjectionPolicy')
              ? HttpFaultInjection.fromJson(_json['faultInjectionPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          maxStreamDuration: _json.containsKey('maxStreamDuration')
              ? Duration.fromJson(_json['maxStreamDuration']
                  as core.Map<core.String, core.dynamic>)
              : null,
          requestMirrorPolicy: _json.containsKey('requestMirrorPolicy')
              ? RequestMirrorPolicy.fromJson(_json['requestMirrorPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          retryPolicy: _json.containsKey('retryPolicy')
              ? HttpRetryPolicy.fromJson(
                  _json['retryPolicy'] as core.Map<core.String, core.dynamic>)
              : null,
          timeout: _json.containsKey('timeout')
              ? Duration.fromJson(
                  _json['timeout'] as core.Map<core.String, core.dynamic>)
              : null,
          urlRewrite: _json.containsKey('urlRewrite')
              ? UrlRewrite.fromJson(
                  _json['urlRewrite'] as core.Map<core.String, core.dynamic>)
              : null,
          weightedBackendServices: _json.containsKey('weightedBackendServices')
              ? (_json['weightedBackendServices'] as core.List)
                  .map<WeightedBackendService>((value) =>
                      WeightedBackendService.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (corsPolicy != null) 'corsPolicy': corsPolicy!.toJson(),
        if (faultInjectionPolicy != null)
          'faultInjectionPolicy': faultInjectionPolicy!.toJson(),
        if (maxStreamDuration != null)
          'maxStreamDuration': maxStreamDuration!.toJson(),
        if (requestMirrorPolicy != null)
          'requestMirrorPolicy': requestMirrorPolicy!.toJson(),
        if (retryPolicy != null) 'retryPolicy': retryPolicy!.toJson(),
        if (timeout != null) 'timeout': timeout!.toJson(),
        if (urlRewrite != null) 'urlRewrite': urlRewrite!.toJson(),
        if (weightedBackendServices != null)
          'weightedBackendServices':
              weightedBackendServices!.map((value) => value.toJson()).toList(),
      };
}

/// An HttpRouteRule specifies how to match an HTTP request and the
/// corresponding routing action that load balancing proxies will perform.
class HttpRouteRule {
  /// The short description conveying the intent of this routeRule.
  ///
  /// The description can have a maximum length of 1024 characters.
  core.String? description;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  ///
  /// The headerAction specified here are applied before the matching
  /// pathMatchers\[\].headerAction and after
  /// pathMatchers\[\].routeRules\[\].routeAction.weightedBackendService.backendServiceWeightAction\[\].headerAction
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL. Not supported when the URL map is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  HttpHeaderAction? headerAction;

  /// The list of criteria for matching attributes of a request to this
  /// routeRule.
  ///
  /// This list has OR semantics: the request matches this routeRule when any of
  /// the matchRules are satisfied. However predicates within a given matchRule
  /// have AND semantics. All predicates within a matchRule must match for the
  /// request to match the rule.
  core.List<HttpRouteRuleMatch>? matchRules;

  /// For routeRules within a given pathMatcher, priority determines the order
  /// in which load balancer will interpret routeRules.
  ///
  /// RouteRules are evaluated in order of priority, from the lowest to highest
  /// number. The priority of a rule decreases as its number increases (1, 2, 3,
  /// N+1). The first rule that matches the request is applied. You cannot
  /// configure two or more routeRules with the same priority. Priority for each
  /// rule must be set to a number between 0 and 2147483647 inclusive. Priority
  /// numbers can have gaps, which enable you to add or remove rules in the
  /// future without affecting the rest of the rules. For example, 1, 2, 3, 4,
  /// 5, 9, 12, 16 is a valid series of priority numbers to which you could add
  /// rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the future without
  /// any impact on existing rules.
  core.int? priority;

  /// In response to a matching matchRule, the load balancer performs advanced
  /// routing actions like URL rewrites, header transformations, etc.
  ///
  /// prior to forwarding the request to the selected backend. If routeAction
  /// specifies any weightedBackendServices, service must not be set. Conversely
  /// if service is set, routeAction cannot contain any weightedBackendServices.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set. UrlMaps for external HTTP(S) load balancers support only the
  /// urlRewrite action within a routeRule's routeAction.
  HttpRouteAction? routeAction;

  /// The full or partial URL of the backend service resource to which traffic
  /// is directed if this rule is matched.
  ///
  /// If routeAction is additionally specified, advanced routing actions like
  /// URL Rewrites, etc. take effect prior to sending the request to the
  /// backend. However, if service is specified, routeAction cannot contain any
  /// weightedBackendService s. Conversely, if routeAction specifies any
  /// weightedBackendServices, service must not be specified. Only one of
  /// urlRedirect, service or routeAction.weightedBackendService must be set.
  core.String? service;

  /// When this rule is matched, the request is redirected to a URL specified by
  /// urlRedirect.
  ///
  /// If urlRedirect is specified, service or routeAction must not be set. Not
  /// supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction? urlRedirect;

  HttpRouteRule({
    this.description,
    this.headerAction,
    this.matchRules,
    this.priority,
    this.routeAction,
    this.service,
    this.urlRedirect,
  });

  HttpRouteRule.fromJson(core.Map _json)
      : this(
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          headerAction: _json.containsKey('headerAction')
              ? HttpHeaderAction.fromJson(
                  _json['headerAction'] as core.Map<core.String, core.dynamic>)
              : null,
          matchRules: _json.containsKey('matchRules')
              ? (_json['matchRules'] as core.List)
                  .map<HttpRouteRuleMatch>((value) =>
                      HttpRouteRuleMatch.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          priority: _json.containsKey('priority')
              ? _json['priority'] as core.int
              : null,
          routeAction: _json.containsKey('routeAction')
              ? HttpRouteAction.fromJson(
                  _json['routeAction'] as core.Map<core.String, core.dynamic>)
              : null,
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
          urlRedirect: _json.containsKey('urlRedirect')
              ? HttpRedirectAction.fromJson(
                  _json['urlRedirect'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (headerAction != null) 'headerAction': headerAction!.toJson(),
        if (matchRules != null)
          'matchRules': matchRules!.map((value) => value.toJson()).toList(),
        if (priority != null) 'priority': priority!,
        if (routeAction != null) 'routeAction': routeAction!.toJson(),
        if (service != null) 'service': service!,
        if (urlRedirect != null) 'urlRedirect': urlRedirect!.toJson(),
      };
}

/// HttpRouteRuleMatch specifies a set of criteria for matching requests to an
/// HttpRouteRule.
///
/// All specified criteria must be satisfied for a match to occur.
class HttpRouteRuleMatch {
  /// For satisfying the matchRule condition, the path of the request must
  /// exactly match the value specified in fullPathMatch after removing any
  /// query parameters and anchor that may be part of the original URL.
  ///
  /// fullPathMatch must be between 1 and 1024 characters. Only one of
  /// prefixMatch, fullPathMatch or regexMatch must be specified.
  core.String? fullPathMatch;

  /// Specifies a list of header match criteria, all of which must match
  /// corresponding headers in the request.
  core.List<HttpHeaderMatch>? headerMatches;

  /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
  ///
  /// The default value is false. ignoreCase must not be used with regexMatch.
  /// Not supported when the URL map is bound to target gRPC proxy.
  core.bool? ignoreCase;

  /// Opaque filter criteria used by Loadbalancer to restrict routing
  /// configuration to a limited set of xDS compliant clients.
  ///
  /// In their xDS requests to Loadbalancer, xDS clients present node metadata.
  /// When there is a match, the relevant routing configuration is made
  /// available to those proxies. For each metadataFilter in this list, if its
  /// filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels
  /// must match the corresponding label provided in the metadata. If its
  /// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must
  /// match with corresponding labels provided in the metadata. If multiple
  /// metadataFilters are specified, all of them need to be satisfied in order
  /// to be considered a match. metadataFilters specified here will be applied
  /// after those specified in ForwardingRule that refers to the UrlMap this
  /// HttpRouteRuleMatch belongs to. metadataFilters only applies to
  /// Loadbalancers that have their loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED. Not supported when the URL map is bound to target
  /// gRPC proxy that has validateForProxyless field set to true.
  core.List<MetadataFilter>? metadataFilters;

  /// For satisfying the matchRule condition, the request's path must begin with
  /// the specified prefixMatch.
  ///
  /// prefixMatch must begin with a /. The value must be between 1 and 1024
  /// characters. Only one of prefixMatch, fullPathMatch or regexMatch must be
  /// specified.
  core.String? prefixMatch;

  /// Specifies a list of query parameter match criteria, all of which must
  /// match corresponding query parameters in the request.
  ///
  /// Not supported when the URL map is bound to target gRPC proxy.
  core.List<HttpQueryParameterMatch>? queryParameterMatches;

  /// For satisfying the matchRule condition, the path of the request must
  /// satisfy the regular expression specified in regexMatch after removing any
  /// query parameters and anchor supplied with the original URL.
  ///
  /// For regular expression grammar please see
  /// github.com/google/re2/wiki/Syntax Only one of prefixMatch, fullPathMatch
  /// or regexMatch must be specified. Note that regexMatch only applies to
  /// Loadbalancers that have their loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED.
  core.String? regexMatch;

  HttpRouteRuleMatch({
    this.fullPathMatch,
    this.headerMatches,
    this.ignoreCase,
    this.metadataFilters,
    this.prefixMatch,
    this.queryParameterMatches,
    this.regexMatch,
  });

  HttpRouteRuleMatch.fromJson(core.Map _json)
      : this(
          fullPathMatch: _json.containsKey('fullPathMatch')
              ? _json['fullPathMatch'] as core.String
              : null,
          headerMatches: _json.containsKey('headerMatches')
              ? (_json['headerMatches'] as core.List)
                  .map<HttpHeaderMatch>((value) => HttpHeaderMatch.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          ignoreCase: _json.containsKey('ignoreCase')
              ? _json['ignoreCase'] as core.bool
              : null,
          metadataFilters: _json.containsKey('metadataFilters')
              ? (_json['metadataFilters'] as core.List)
                  .map<MetadataFilter>((value) => MetadataFilter.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          prefixMatch: _json.containsKey('prefixMatch')
              ? _json['prefixMatch'] as core.String
              : null,
          queryParameterMatches: _json.containsKey('queryParameterMatches')
              ? (_json['queryParameterMatches'] as core.List)
                  .map<HttpQueryParameterMatch>((value) =>
                      HttpQueryParameterMatch.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          regexMatch: _json.containsKey('regexMatch')
              ? _json['regexMatch'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fullPathMatch != null) 'fullPathMatch': fullPathMatch!,
        if (headerMatches != null)
          'headerMatches':
              headerMatches!.map((value) => value.toJson()).toList(),
        if (ignoreCase != null) 'ignoreCase': ignoreCase!,
        if (metadataFilters != null)
          'metadataFilters':
              metadataFilters!.map((value) => value.toJson()).toList(),
        if (prefixMatch != null) 'prefixMatch': prefixMatch!,
        if (queryParameterMatches != null)
          'queryParameterMatches':
              queryParameterMatches!.map((value) => value.toJson()).toList(),
        if (regexMatch != null) 'regexMatch': regexMatch!,
      };
}

/// Represents a legacy HTTPS Health Check resource.
///
/// Legacy HTTPS health checks have been deprecated. If you are using a target
/// pool-based network load balancer, you must use a legacy HTTP (not HTTPS)
/// health check. For all other load balancers, including backend service-based
/// network load balancers, and for managed instance group auto-healing, you
/// must use modern (non-legacy) health checks. For more information, see Health
/// checks overview .
class HttpsHealthCheck {
  /// How often (in seconds) to send a health check.
  ///
  /// The default value is 5 seconds.
  core.int? checkIntervalSec;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes.
  ///
  /// The default value is 2.
  core.int? healthyThreshold;

  /// The value of the host header in the HTTPS health check request.
  ///
  /// If left empty (default value), the public IP on behalf of which this
  /// health check is performed will be used.
  core.String? host;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The TCP port number for the HTTPS health check request.
  ///
  /// The default value is 443.
  core.int? port;

  /// The request path of the HTTPS health check request.
  ///
  /// The default value is "/".
  core.String? requestPath;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// How long (in seconds) to wait before claiming failure.
  ///
  /// The default value is 5 seconds. It is invalid for timeoutSec to have a
  /// greater value than checkIntervalSec.
  core.int? timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures.
  ///
  /// The default value is 2.
  core.int? unhealthyThreshold;

  HttpsHealthCheck({
    this.checkIntervalSec,
    this.creationTimestamp,
    this.description,
    this.healthyThreshold,
    this.host,
    this.id,
    this.kind,
    this.name,
    this.port,
    this.requestPath,
    this.selfLink,
    this.timeoutSec,
    this.unhealthyThreshold,
  });

  HttpsHealthCheck.fromJson(core.Map _json)
      : this(
          checkIntervalSec: _json.containsKey('checkIntervalSec')
              ? _json['checkIntervalSec'] as core.int
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          healthyThreshold: _json.containsKey('healthyThreshold')
              ? _json['healthyThreshold'] as core.int
              : null,
          host: _json.containsKey('host') ? _json['host'] as core.String : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          requestPath: _json.containsKey('requestPath')
              ? _json['requestPath'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          timeoutSec: _json.containsKey('timeoutSec')
              ? _json['timeoutSec'] as core.int
              : null,
          unhealthyThreshold: _json.containsKey('unhealthyThreshold')
              ? _json['unhealthyThreshold'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (checkIntervalSec != null) 'checkIntervalSec': checkIntervalSec!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
        if (host != null) 'host': host!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (port != null) 'port': port!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (timeoutSec != null) 'timeoutSec': timeoutSec!,
        if (unhealthyThreshold != null)
          'unhealthyThreshold': unhealthyThreshold!,
      };
}

class HttpsHealthCheckListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HttpsHealthCheckListWarningData({
    this.key,
    this.value,
  });

  HttpsHealthCheckListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HttpsHealthCheckListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HttpsHealthCheckListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HttpsHealthCheckListWarning({
    this.code,
    this.data,
    this.message,
  });

  HttpsHealthCheckListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<HttpsHealthCheckListWarningData>((value) =>
                      HttpsHealthCheckListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of HttpsHealthCheck resources.
class HttpsHealthCheckList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HttpsHealthCheck resources.
  core.List<HttpsHealthCheck>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  HttpsHealthCheckListWarning? warning;

  HttpsHealthCheckList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  HttpsHealthCheckList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<HttpsHealthCheck>((value) => HttpsHealthCheck.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? HttpsHealthCheckListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The parameters of the raw disk image.
class ImageRawDisk {
  /// The format used to encode and transmit the block device, which should be
  /// TAR.
  ///
  /// This is just a container and transmission format and not a runtime format.
  /// Provided by the client when the disk image is created.
  /// Possible string values are:
  /// - "TAR"
  core.String? containerType;

  /// This field is deprecated.
  ///
  /// An optional SHA1 checksum of the disk image before unpackaging provided by
  /// the client when the disk image is created.
  ///
  /// Deprecated.
  core.String? sha1Checksum;

  /// The full Google Cloud Storage URL where the raw disk image archive is
  /// stored.
  ///
  /// The following are valid formats for the URL: -
  /// https://storage.googleapis.com/bucket_name/image_archive_name -
  /// https://storage.googleapis.com/bucket_name/folder_name/ image_archive_name
  /// In order to create an image, you must provide the full or partial URL of
  /// one of the following: - The rawDisk.source URL - The sourceDisk URL - The
  /// sourceImage URL - The sourceSnapshot URL
  core.String? source;

  ImageRawDisk({
    this.containerType,
    this.sha1Checksum,
    this.source,
  });

  ImageRawDisk.fromJson(core.Map _json)
      : this(
          containerType: _json.containsKey('containerType')
              ? _json['containerType'] as core.String
              : null,
          sha1Checksum: _json.containsKey('sha1Checksum')
              ? _json['sha1Checksum'] as core.String
              : null,
          source: _json.containsKey('source')
              ? _json['source'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (containerType != null) 'containerType': containerType!,
        if (sha1Checksum != null) 'sha1Checksum': sha1Checksum!,
        if (source != null) 'source': source!,
      };
}

/// Represents an Image resource.
///
/// You can use images to create boot disks for your VM instances. For more
/// information, read Images.
class Image {
  /// Size of the image tar.gz archive stored in Google Cloud Storage (in
  /// bytes).
  core.String? archiveSizeBytes;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this image.
  DeprecationStatus? deprecated;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Size of the image when restored onto a persistent disk (in GB).
  core.String? diskSizeGb;

  /// The name of the image family to which this image belongs.
  ///
  /// You can create disks by specifying an image family instead of a specific
  /// image name. The image family always returns its latest image that is not
  /// deprecated. The name of the image family must comply with RFC1035.
  core.String? family;

  /// A list of features to enable on the guest operating system.
  ///
  /// Applicable only for bootable images. Read Enabling guest operating system
  /// features to see a list of available options.
  core.List<GuestOsFeature>? guestOsFeatures;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Encrypts the image using a customer-supplied encryption key.
  ///
  /// After you encrypt an image with a customer-supplied key, you must provide
  /// the same key if you use the image later (e.g. to create a disk from the
  /// image). Customer-supplied encryption keys do not protect access to
  /// metadata of the disk. If you do not provide an encryption key when
  /// creating the image, then the disk will be encrypted using an automatically
  /// generated key and you do not need to provide a key to use the image later.
  CustomerEncryptionKey? imageEncryptionKey;

  /// Type of the resource.
  ///
  /// Always compute#image for images.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this image, which is
  /// essentially a hash of the labels used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve an image.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this image.
  ///
  /// These can be later modified by the setLabels method.
  core.Map<core.String, core.String>? labels;

  /// Integer license codes indicating which licenses are attached to this
  /// image.
  core.List<core.String>? licenseCodes;

  /// Any applicable license URI.
  core.List<core.String>? licenses;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The parameters of the raw disk image.
  ImageRawDisk? rawDisk;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Set the secure boot keys of shielded instance.
  InitialStateConfig? shieldedInstanceInitialState;

  /// URL of the source disk used to create this image.
  ///
  /// For example, the following are valid values: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /disks/disk - projects/project/zones/zone/disks/disk -
  /// zones/zone/disks/disk In order to create an image, you must provide the
  /// full or partial URL of one of the following: - The rawDisk.source URL -
  /// The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL
  core.String? sourceDisk;

  /// The customer-supplied encryption key of the source disk.
  ///
  /// Required if the source disk is protected by a customer-supplied encryption
  /// key.
  CustomerEncryptionKey? sourceDiskEncryptionKey;

  /// The ID value of the disk used to create this image.
  ///
  /// This value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given disk name.
  ///
  /// Output only.
  core.String? sourceDiskId;

  /// URL of the source image used to create this image.
  ///
  /// The following are valid formats for the URL: -
  /// https://www.googleapis.com/compute/v1/projects/project_id/global/
  /// images/image_name - projects/project_id/global/images/image_name In order
  /// to create an image, you must provide the full or partial URL of one of the
  /// following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage
  /// URL - The sourceSnapshot URL
  core.String? sourceImage;

  /// The customer-supplied encryption key of the source image.
  ///
  /// Required if the source image is protected by a customer-supplied
  /// encryption key.
  CustomerEncryptionKey? sourceImageEncryptionKey;

  /// The ID value of the image used to create this image.
  ///
  /// This value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given image name.
  ///
  /// Output only.
  core.String? sourceImageId;

  /// URL of the source snapshot used to create this image.
  ///
  /// The following are valid formats for the URL: -
  /// https://www.googleapis.com/compute/v1/projects/project_id/global/
  /// snapshots/snapshot_name -
  /// projects/project_id/global/snapshots/snapshot_name In order to create an
  /// image, you must provide the full or partial URL of one of the following: -
  /// The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The
  /// sourceSnapshot URL
  core.String? sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot.
  ///
  /// Required if the source snapshot is protected by a customer-supplied
  /// encryption key.
  CustomerEncryptionKey? sourceSnapshotEncryptionKey;

  /// The ID value of the snapshot used to create this image.
  ///
  /// This value may be used to determine whether the snapshot was taken from
  /// the current or a previous instance of a given snapshot name.
  ///
  /// Output only.
  core.String? sourceSnapshotId;

  /// The type of the image used to create this disk.
  ///
  /// The default and only value is RAW
  /// Possible string values are:
  /// - "RAW"
  core.String? sourceType;

  /// The status of the image.
  ///
  /// An image can be used to create other resources, such as instances, only
  /// after the image has been successfully created and the status is set to
  /// READY. Possible values are FAILED, PENDING, or READY.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DELETING" : Image is deleting.
  /// - "FAILED" : Image creation failed due to an error.
  /// - "PENDING" : Image hasn't been created as yet.
  /// - "READY" : Image has been successfully created.
  core.String? status;

  /// Cloud Storage bucket storage location of the image (regional or
  /// multi-regional).
  core.List<core.String>? storageLocations;

  Image({
    this.archiveSizeBytes,
    this.creationTimestamp,
    this.deprecated,
    this.description,
    this.diskSizeGb,
    this.family,
    this.guestOsFeatures,
    this.id,
    this.imageEncryptionKey,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.licenseCodes,
    this.licenses,
    this.name,
    this.rawDisk,
    this.satisfiesPzs,
    this.selfLink,
    this.shieldedInstanceInitialState,
    this.sourceDisk,
    this.sourceDiskEncryptionKey,
    this.sourceDiskId,
    this.sourceImage,
    this.sourceImageEncryptionKey,
    this.sourceImageId,
    this.sourceSnapshot,
    this.sourceSnapshotEncryptionKey,
    this.sourceSnapshotId,
    this.sourceType,
    this.status,
    this.storageLocations,
  });

  Image.fromJson(core.Map _json)
      : this(
          archiveSizeBytes: _json.containsKey('archiveSizeBytes')
              ? _json['archiveSizeBytes'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          deprecated: _json.containsKey('deprecated')
              ? DeprecationStatus.fromJson(
                  _json['deprecated'] as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          diskSizeGb: _json.containsKey('diskSizeGb')
              ? _json['diskSizeGb'] as core.String
              : null,
          family: _json.containsKey('family')
              ? _json['family'] as core.String
              : null,
          guestOsFeatures: _json.containsKey('guestOsFeatures')
              ? (_json['guestOsFeatures'] as core.List)
                  .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          imageEncryptionKey: _json.containsKey('imageEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['imageEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          licenseCodes: _json.containsKey('licenseCodes')
              ? (_json['licenseCodes'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          licenses: _json.containsKey('licenses')
              ? (_json['licenses'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          rawDisk: _json.containsKey('rawDisk')
              ? ImageRawDisk.fromJson(
                  _json['rawDisk'] as core.Map<core.String, core.dynamic>)
              : null,
          satisfiesPzs: _json.containsKey('satisfiesPzs')
              ? _json['satisfiesPzs'] as core.bool
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          shieldedInstanceInitialState:
              _json.containsKey('shieldedInstanceInitialState')
                  ? InitialStateConfig.fromJson(
                      _json['shieldedInstanceInitialState']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          sourceDisk: _json.containsKey('sourceDisk')
              ? _json['sourceDisk'] as core.String
              : null,
          sourceDiskEncryptionKey: _json.containsKey('sourceDiskEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['sourceDiskEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          sourceDiskId: _json.containsKey('sourceDiskId')
              ? _json['sourceDiskId'] as core.String
              : null,
          sourceImage: _json.containsKey('sourceImage')
              ? _json['sourceImage'] as core.String
              : null,
          sourceImageEncryptionKey: _json
                  .containsKey('sourceImageEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['sourceImageEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          sourceImageId: _json.containsKey('sourceImageId')
              ? _json['sourceImageId'] as core.String
              : null,
          sourceSnapshot: _json.containsKey('sourceSnapshot')
              ? _json['sourceSnapshot'] as core.String
              : null,
          sourceSnapshotEncryptionKey:
              _json.containsKey('sourceSnapshotEncryptionKey')
                  ? CustomerEncryptionKey.fromJson(
                      _json['sourceSnapshotEncryptionKey']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          sourceSnapshotId: _json.containsKey('sourceSnapshotId')
              ? _json['sourceSnapshotId'] as core.String
              : null,
          sourceType: _json.containsKey('sourceType')
              ? _json['sourceType'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          storageLocations: _json.containsKey('storageLocations')
              ? (_json['storageLocations'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (archiveSizeBytes != null) 'archiveSizeBytes': archiveSizeBytes!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (family != null) 'family': family!,
        if (guestOsFeatures != null)
          'guestOsFeatures':
              guestOsFeatures!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
        if (imageEncryptionKey != null)
          'imageEncryptionKey': imageEncryptionKey!.toJson(),
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (licenseCodes != null) 'licenseCodes': licenseCodes!,
        if (licenses != null) 'licenses': licenses!,
        if (name != null) 'name': name!,
        if (rawDisk != null) 'rawDisk': rawDisk!.toJson(),
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (shieldedInstanceInitialState != null)
          'shieldedInstanceInitialState':
              shieldedInstanceInitialState!.toJson(),
        if (sourceDisk != null) 'sourceDisk': sourceDisk!,
        if (sourceDiskEncryptionKey != null)
          'sourceDiskEncryptionKey': sourceDiskEncryptionKey!.toJson(),
        if (sourceDiskId != null) 'sourceDiskId': sourceDiskId!,
        if (sourceImage != null) 'sourceImage': sourceImage!,
        if (sourceImageEncryptionKey != null)
          'sourceImageEncryptionKey': sourceImageEncryptionKey!.toJson(),
        if (sourceImageId != null) 'sourceImageId': sourceImageId!,
        if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
        if (sourceSnapshotEncryptionKey != null)
          'sourceSnapshotEncryptionKey': sourceSnapshotEncryptionKey!.toJson(),
        if (sourceSnapshotId != null) 'sourceSnapshotId': sourceSnapshotId!,
        if (sourceType != null) 'sourceType': sourceType!,
        if (status != null) 'status': status!,
        if (storageLocations != null) 'storageLocations': storageLocations!,
      };
}

class ImageFamilyView {
  /// The latest image that is part of the specified image family in the
  /// requested location, and that is not deprecated.
  Image? image;

  ImageFamilyView({
    this.image,
  });

  ImageFamilyView.fromJson(core.Map _json)
      : this(
          image: _json.containsKey('image')
              ? Image.fromJson(
                  _json['image'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (image != null) 'image': image!.toJson(),
      };
}

class ImageListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ImageListWarningData({
    this.key,
    this.value,
  });

  ImageListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ImageListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ImageListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ImageListWarning({
    this.code,
    this.data,
    this.message,
  });

  ImageListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ImageListWarningData>((value) =>
                      ImageListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of images.
class ImageList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Image resources.
  core.List<Image>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ImageListWarning? warning;

  ImageList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  ImageList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Image>((value) => Image.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? ImageListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Initial State for shielded instance, these are public keys which are safe to
/// store in public
class InitialStateConfig {
  /// The Key Database (db).
  core.List<FileContentBuffer>? dbs;

  /// The forbidden key database (dbx).
  core.List<FileContentBuffer>? dbxs;

  /// The Key Exchange Key (KEK).
  core.List<FileContentBuffer>? keks;

  /// The Platform Key (PK).
  FileContentBuffer? pk;

  InitialStateConfig({
    this.dbs,
    this.dbxs,
    this.keks,
    this.pk,
  });

  InitialStateConfig.fromJson(core.Map _json)
      : this(
          dbs: _json.containsKey('dbs')
              ? (_json['dbs'] as core.List)
                  .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          dbxs: _json.containsKey('dbxs')
              ? (_json['dbxs'] as core.List)
                  .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          keks: _json.containsKey('keks')
              ? (_json['keks'] as core.List)
                  .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          pk: _json.containsKey('pk')
              ? FileContentBuffer.fromJson(
                  _json['pk'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dbs != null) 'dbs': dbs!.map((value) => value.toJson()).toList(),
        if (dbxs != null) 'dbxs': dbxs!.map((value) => value.toJson()).toList(),
        if (keks != null) 'keks': keks!.map((value) => value.toJson()).toList(),
        if (pk != null) 'pk': pk!.toJson(),
      };
}

/// Represents an Instance resource.
///
/// An instance is a virtual machine that is hosted on Google Cloud Platform.
/// For more information, read Virtual Machine Instances.
class Instance {
  /// Controls for advanced machine-related behavior features.
  AdvancedMachineFeatures? advancedMachineFeatures;

  /// Allows this instance to send and receive packets with non-matching
  /// destination or source IPs.
  ///
  /// This is required if you plan to use this instance to forward routes. For
  /// more information, see Enabling IP Forwarding .
  core.bool? canIpForward;
  ConfidentialInstanceConfig? confidentialInstanceConfig;

  /// The CPU platform used by this instance.
  ///
  /// Output only.
  core.String? cpuPlatform;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Whether the resource should be protected against deletion.
  core.bool? deletionProtection;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Array of disks associated with this instance.
  ///
  /// Persistent disks must be created before you can assign them.
  core.List<AttachedDisk>? disks;

  /// Enables display device for the instance.
  DisplayDevice? displayDevice;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the instance's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update the instance. You must always provide an
  /// up-to-date fingerprint hash in order to update the instance. To see the
  /// latest fingerprint, make get() request to the instance.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of the type and count of accelerator cards attached to the
  /// instance.
  core.List<AcceleratorConfig>? guestAccelerators;

  /// Specifies the hostname of the instance.
  ///
  /// The specified hostname must be RFC1035 compliant. If hostname is not
  /// specified, the default hostname is
  /// \[INSTANCE_NAME\].c.\[PROJECT_ID\].internal when using the global DNS, and
  /// \[INSTANCE_NAME\].\[ZONE\].c.\[PROJECT_ID\].internal when using zonal DNS.
  core.String? hostname;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#instance for instances.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for this request, which is essentially a hash of the label's
  /// contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels. To see
  /// the latest fingerprint, make get() request to the instance.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this instance.
  ///
  /// These can be later modified by the setLabels method.
  core.Map<core.String, core.String>? labels;

  /// Last start timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastStartTimestamp;

  /// Last stop timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastStopTimestamp;

  /// Last suspended timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastSuspendedTimestamp;

  /// Full or partial URL of the machine type resource to use for this instance,
  /// in the format: zones/zone/machineTypes/machine-type.
  ///
  /// This is provided by the client when the instance is created. For example,
  /// the following is a valid partial url to a predefined machine type:
  /// zones/us-central1-f/machineTypes/n1-standard-1 To create a custom machine
  /// type, provide a URL to a machine type in the following format, where CPUS
  /// is 1 or an even number up to 32 (2, 4, 6, ... 24, etc), and MEMORY is the
  /// total memory for this instance. Memory must be a multiple of 256 MB and
  /// must be supplied in MB (e.g. 5 GB of memory is 5120 MB):
  /// zones/zone/machineTypes/custom-CPUS-MEMORY For example:
  /// zones/us-central1-f/machineTypes/custom-4-5120 For a full list of
  /// restrictions, read the Specifications for custom machine types.
  core.String? machineType;

  /// The metadata key/value pairs assigned to this instance.
  ///
  /// This includes custom metadata and predefined keys.
  Metadata? metadata;

  /// Specifies a minimum CPU platform for the VM instance.
  ///
  /// Applicable values are the friendly names of CPU platforms, such as
  /// minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge".
  core.String? minCpuPlatform;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// An array of network configurations for this instance.
  ///
  /// These specify how interfaces are configured to interact with other network
  /// services, such as connecting to the internet. Multiple interfaces are
  /// supported per instance.
  core.List<NetworkInterface>? networkInterfaces;

  /// The private IPv6 google access type for the VM.
  ///
  /// If not specified, use INHERIT_FROM_SUBNETWORK as default.
  /// Possible string values are:
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" : Bidirectional private IPv6
  /// access to/from Google services. If specified, the subnetwork who is
  /// attached to the instance's default network interface will be assigned an
  /// internal IPv6 prefix if it doesn't have before.
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" : Outbound private IPv6 access
  /// from VMs in this subnet to Google services. If specified, the subnetwork
  /// who is attached to the instance's default network interface will be
  /// assigned an internal IPv6 prefix if it doesn't have before.
  /// - "INHERIT_FROM_SUBNETWORK" : Each network interface inherits
  /// PrivateIpv6GoogleAccess from its subnetwork.
  core.String? privateIpv6GoogleAccess;

  /// Specifies the reservations that this instance can consume from.
  ReservationAffinity? reservationAffinity;

  /// Resource policies applied to this instance.
  core.List<core.String>? resourcePolicies;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Sets the scheduling options for this instance.
  Scheduling? scheduling;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// A list of service accounts, with their specified scopes, authorized for
  /// this instance.
  ///
  /// Only one service account per VM instance is supported. Service accounts
  /// generate access tokens that can be accessed through the metadata server
  /// and used to authenticate applications on the instance. See Service
  /// Accounts for more information.
  core.List<ServiceAccount>? serviceAccounts;
  ShieldedInstanceConfig? shieldedInstanceConfig;
  ShieldedInstanceIntegrityPolicy? shieldedInstanceIntegrityPolicy;

  /// Whether a VM has been restricted for start because Compute Engine has
  /// detected suspicious activity.
  ///
  /// Output only.
  core.bool? startRestricted;

  /// The status of the instance.
  ///
  /// One of the following values: PROVISIONING, STAGING, RUNNING, STOPPING,
  /// SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. For more information
  /// about the status of the instance, see Instance life cycle.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DEPROVISIONING" : The Nanny is halted and we are performing tear down
  /// tasks like network deprogramming, releasing quota, IP, tearing down disks
  /// etc.
  /// - "PROVISIONING" : Resources are being allocated for the instance.
  /// - "REPAIRING" : The instance is in repair.
  /// - "RUNNING" : The instance is running.
  /// - "STAGING" : All required resources have been allocated and the instance
  /// is being started.
  /// - "STOPPED" : The instance has stopped successfully.
  /// - "STOPPING" : The instance is currently stopping (either being deleted or
  /// killed).
  /// - "SUSPENDED" : The instance has suspended.
  /// - "SUSPENDING" : The instance is suspending.
  /// - "TERMINATED" : The instance has stopped (either by explicit action or
  /// underlying failure).
  core.String? status;

  /// An optional, human-readable explanation of the status.
  ///
  /// Output only.
  core.String? statusMessage;

  /// Tags to apply to this instance.
  ///
  /// Tags are used to identify valid sources or targets for network firewalls
  /// and are specified by the client during instance creation. The tags can be
  /// later modified by the setTags method. Each tag within the list must comply
  /// with RFC1035. Multiple tags can be specified via the 'tags.items' field.
  Tags? tags;

  /// URL of the zone where the instance resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  Instance({
    this.advancedMachineFeatures,
    this.canIpForward,
    this.confidentialInstanceConfig,
    this.cpuPlatform,
    this.creationTimestamp,
    this.deletionProtection,
    this.description,
    this.disks,
    this.displayDevice,
    this.fingerprint,
    this.guestAccelerators,
    this.hostname,
    this.id,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.lastStartTimestamp,
    this.lastStopTimestamp,
    this.lastSuspendedTimestamp,
    this.machineType,
    this.metadata,
    this.minCpuPlatform,
    this.name,
    this.networkInterfaces,
    this.privateIpv6GoogleAccess,
    this.reservationAffinity,
    this.resourcePolicies,
    this.satisfiesPzs,
    this.scheduling,
    this.selfLink,
    this.serviceAccounts,
    this.shieldedInstanceConfig,
    this.shieldedInstanceIntegrityPolicy,
    this.startRestricted,
    this.status,
    this.statusMessage,
    this.tags,
    this.zone,
  });

  Instance.fromJson(core.Map _json)
      : this(
          advancedMachineFeatures: _json.containsKey('advancedMachineFeatures')
              ? AdvancedMachineFeatures.fromJson(
                  _json['advancedMachineFeatures']
                      as core.Map<core.String, core.dynamic>)
              : null,
          canIpForward: _json.containsKey('canIpForward')
              ? _json['canIpForward'] as core.bool
              : null,
          confidentialInstanceConfig:
              _json.containsKey('confidentialInstanceConfig')
                  ? ConfidentialInstanceConfig.fromJson(
                      _json['confidentialInstanceConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          cpuPlatform: _json.containsKey('cpuPlatform')
              ? _json['cpuPlatform'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          deletionProtection: _json.containsKey('deletionProtection')
              ? _json['deletionProtection'] as core.bool
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          disks: _json.containsKey('disks')
              ? (_json['disks'] as core.List)
                  .map<AttachedDisk>((value) => AttachedDisk.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          displayDevice: _json.containsKey('displayDevice')
              ? DisplayDevice.fromJson(
                  _json['displayDevice'] as core.Map<core.String, core.dynamic>)
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          guestAccelerators: _json.containsKey('guestAccelerators')
              ? (_json['guestAccelerators'] as core.List)
                  .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          hostname: _json.containsKey('hostname')
              ? _json['hostname'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          lastStartTimestamp: _json.containsKey('lastStartTimestamp')
              ? _json['lastStartTimestamp'] as core.String
              : null,
          lastStopTimestamp: _json.containsKey('lastStopTimestamp')
              ? _json['lastStopTimestamp'] as core.String
              : null,
          lastSuspendedTimestamp: _json.containsKey('lastSuspendedTimestamp')
              ? _json['lastSuspendedTimestamp'] as core.String
              : null,
          machineType: _json.containsKey('machineType')
              ? _json['machineType'] as core.String
              : null,
          metadata: _json.containsKey('metadata')
              ? Metadata.fromJson(
                  _json['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          minCpuPlatform: _json.containsKey('minCpuPlatform')
              ? _json['minCpuPlatform'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          networkInterfaces: _json.containsKey('networkInterfaces')
              ? (_json['networkInterfaces'] as core.List)
                  .map<NetworkInterface>((value) => NetworkInterface.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          privateIpv6GoogleAccess: _json.containsKey('privateIpv6GoogleAccess')
              ? _json['privateIpv6GoogleAccess'] as core.String
              : null,
          reservationAffinity: _json.containsKey('reservationAffinity')
              ? ReservationAffinity.fromJson(_json['reservationAffinity']
                  as core.Map<core.String, core.dynamic>)
              : null,
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          satisfiesPzs: _json.containsKey('satisfiesPzs')
              ? _json['satisfiesPzs'] as core.bool
              : null,
          scheduling: _json.containsKey('scheduling')
              ? Scheduling.fromJson(
                  _json['scheduling'] as core.Map<core.String, core.dynamic>)
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          serviceAccounts: _json.containsKey('serviceAccounts')
              ? (_json['serviceAccounts'] as core.List)
                  .map<ServiceAccount>((value) => ServiceAccount.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          shieldedInstanceConfig: _json.containsKey('shieldedInstanceConfig')
              ? ShieldedInstanceConfig.fromJson(_json['shieldedInstanceConfig']
                  as core.Map<core.String, core.dynamic>)
              : null,
          shieldedInstanceIntegrityPolicy:
              _json.containsKey('shieldedInstanceIntegrityPolicy')
                  ? ShieldedInstanceIntegrityPolicy.fromJson(
                      _json['shieldedInstanceIntegrityPolicy']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          startRestricted: _json.containsKey('startRestricted')
              ? _json['startRestricted'] as core.bool
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          statusMessage: _json.containsKey('statusMessage')
              ? _json['statusMessage'] as core.String
              : null,
          tags: _json.containsKey('tags')
              ? Tags.fromJson(
                  _json['tags'] as core.Map<core.String, core.dynamic>)
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (advancedMachineFeatures != null)
          'advancedMachineFeatures': advancedMachineFeatures!.toJson(),
        if (canIpForward != null) 'canIpForward': canIpForward!,
        if (confidentialInstanceConfig != null)
          'confidentialInstanceConfig': confidentialInstanceConfig!.toJson(),
        if (cpuPlatform != null) 'cpuPlatform': cpuPlatform!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deletionProtection != null)
          'deletionProtection': deletionProtection!,
        if (description != null) 'description': description!,
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (displayDevice != null) 'displayDevice': displayDevice!.toJson(),
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (guestAccelerators != null)
          'guestAccelerators':
              guestAccelerators!.map((value) => value.toJson()).toList(),
        if (hostname != null) 'hostname': hostname!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (lastStartTimestamp != null)
          'lastStartTimestamp': lastStartTimestamp!,
        if (lastStopTimestamp != null) 'lastStopTimestamp': lastStopTimestamp!,
        if (lastSuspendedTimestamp != null)
          'lastSuspendedTimestamp': lastSuspendedTimestamp!,
        if (machineType != null) 'machineType': machineType!,
        if (metadata != null) 'metadata': metadata!.toJson(),
        if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
        if (name != null) 'name': name!,
        if (networkInterfaces != null)
          'networkInterfaces':
              networkInterfaces!.map((value) => value.toJson()).toList(),
        if (privateIpv6GoogleAccess != null)
          'privateIpv6GoogleAccess': privateIpv6GoogleAccess!,
        if (reservationAffinity != null)
          'reservationAffinity': reservationAffinity!.toJson(),
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (scheduling != null) 'scheduling': scheduling!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (serviceAccounts != null)
          'serviceAccounts':
              serviceAccounts!.map((value) => value.toJson()).toList(),
        if (shieldedInstanceConfig != null)
          'shieldedInstanceConfig': shieldedInstanceConfig!.toJson(),
        if (shieldedInstanceIntegrityPolicy != null)
          'shieldedInstanceIntegrityPolicy':
              shieldedInstanceIntegrityPolicy!.toJson(),
        if (startRestricted != null) 'startRestricted': startRestricted!,
        if (status != null) 'status': status!,
        if (statusMessage != null) 'statusMessage': statusMessage!,
        if (tags != null) 'tags': tags!.toJson(),
        if (zone != null) 'zone': zone!,
      };
}

class InstanceAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceAggregatedListWarningData({
    this.key,
    this.value,
  });

  InstanceAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceAggregatedListWarningData>((value) =>
                      InstanceAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// An object that contains a list of instances scoped by zone.
  core.Map<core.String, InstancesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#instanceAggregatedList for aggregated lists of Instance
  /// resources.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceAggregatedListWarning? warning;

  InstanceAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  InstanceAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    InstancesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? InstanceAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents an Instance Group resource.
///
/// Instance Groups can be used to configure a target for load balancing.
/// Instance groups can either be managed or unmanaged. To create managed
/// instance groups, use the instanceGroupManager or regionInstanceGroupManager
/// resource instead. Use zonal unmanaged instance groups if you need to apply
/// load balancing to groups of heterogeneous instances or if you need to manage
/// the instances yourself. You cannot create regional unmanaged instance
/// groups. For more information, read Instance groups.
class InstanceGroup {
  /// The creation timestamp for this instance group in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The fingerprint of the named ports.
  ///
  /// The system uses this fingerprint to detect conflicts when multiple users
  /// change the named ports concurrently.
  ///
  /// Output only.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A unique identifier for this instance group, generated by the server.
  ///
  /// Output only.
  core.String? id;

  /// The resource type, which is always compute#instanceGroup for instance
  /// groups.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the instance group.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String? name;

  ///  Assigns a name to a port number.
  ///
  /// For example: {name: "http", port: 80} This allows the system to reference
  /// ports by the assigned name instead of a port number. Named ports can also
  /// contain multiple ports. For example: \[{name: "http", port: 80},{name:
  /// "http", port: 8080}\] Named ports apply to all instances in this instance
  /// group.
  core.List<NamedPort>? namedPorts;

  /// The URL of the network to which all instances in the instance group
  /// belong.
  ///
  /// If your instance has multiple network interfaces, then the network and
  /// subnetwork fields only refer to the network and subnet used by your
  /// primary interface (nic0).
  ///
  /// Output only.
  core.String? network;

  /// The URL of the region where the instance group is located (for regional
  /// resources).
  ///
  /// Output only.
  core.String? region;

  /// The URL for this instance group.
  ///
  /// The server generates this URL.
  ///
  /// Output only.
  core.String? selfLink;

  /// The total number of instances in the instance group.
  ///
  /// Output only.
  core.int? size;

  /// The URL of the subnetwork to which all instances in the instance group
  /// belong.
  ///
  /// If your instance has multiple network interfaces, then the network and
  /// subnetwork fields only refer to the network and subnet used by your
  /// primary interface (nic0).
  ///
  /// Output only.
  core.String? subnetwork;

  /// The URL of the zone where the instance group is located (for zonal
  /// resources).
  ///
  /// Output only.
  core.String? zone;

  InstanceGroup({
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.namedPorts,
    this.network,
    this.region,
    this.selfLink,
    this.size,
    this.subnetwork,
    this.zone,
  });

  InstanceGroup.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          namedPorts: _json.containsKey('namedPorts')
              ? (_json['namedPorts'] as core.List)
                  .map<NamedPort>((value) => NamedPort.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          size: _json.containsKey('size') ? _json['size'] as core.int : null,
          subnetwork: _json.containsKey('subnetwork')
              ? _json['subnetwork'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
        if (network != null) 'network': network!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (size != null) 'size': size!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
        if (zone != null) 'zone': zone!,
      };
}

class InstanceGroupAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupAggregatedListWarningData({
    this.key,
    this.value,
  });

  InstanceGroupAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceGroupAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceGroupAggregatedListWarningData>((value) =>
                      InstanceGroupAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroupsScopedList resources.
  core.Map<core.String, InstanceGroupsScopedList>? items;

  /// The resource type, which is always compute#instanceGroupAggregatedList for
  /// aggregated lists of instance groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupAggregatedListWarning? warning;

  InstanceGroupAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  InstanceGroupAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    InstanceGroupsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? InstanceGroupAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupListWarningData({
    this.key,
    this.value,
  });

  InstanceGroupListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceGroupListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceGroupListWarningData>((value) =>
                      InstanceGroupListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of InstanceGroup resources.
class InstanceGroupList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup>? items;

  /// The resource type, which is always compute#instanceGroupList for instance
  /// group lists.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupListWarning? warning;

  InstanceGroupList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InstanceGroupList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceGroup>((value) => InstanceGroup.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InstanceGroupListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Managed Instance Group resource.
///
/// An instance group is a collection of VM instances that you can manage as a
/// single entity. For more information, read Instance groups. For zonal Managed
/// Instance Group, use the instanceGroupManagers resource. For regional Managed
/// Instance Group, use the regionInstanceGroupManagers resource.
class InstanceGroupManager {
  /// The autohealing policy for this managed instance group.
  ///
  /// You can specify only one value.
  core.List<InstanceGroupManagerAutoHealingPolicy>? autoHealingPolicies;

  /// The base instance name to use for instances in this group.
  ///
  /// The value must be 1-58 characters long. Instances are named by appending a
  /// hyphen and a random four-character string to the base instance name. The
  /// base instance name must comply with RFC1035.
  core.String? baseInstanceName;

  /// The creation timestamp for this managed instance group in RFC3339 text
  /// format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The list of instance actions and the number of instances in this managed
  /// instance group that are scheduled for each of those actions.
  ///
  /// Output only.
  InstanceGroupManagerActionsSummary? currentActions;

  /// An optional description of this resource.
  core.String? description;

  /// Policy specifying the intended distribution of managed instances across
  /// zones in a regional managed instance group.
  DistributionPolicy? distributionPolicy;

  /// Fingerprint of this resource.
  ///
  /// This field may be used in optimistic locking. It will be ignored when
  /// inserting an InstanceGroupManager. An up-to-date fingerprint must be
  /// provided in order to update the InstanceGroupManager, otherwise the
  /// request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve an InstanceGroupManager.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A unique identifier for this resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// The URL of the Instance Group resource.
  ///
  /// Output only.
  core.String? instanceGroup;

  /// The URL of the instance template that is specified for this managed
  /// instance group.
  ///
  /// The group uses this template to create all new instances in the managed
  /// instance group. The templates for existing instances in the group do not
  /// change unless you run recreateInstances, run applyUpdatesToInstances, or
  /// set the group's updatePolicy.type to PROACTIVE.
  core.String? instanceTemplate;

  /// The resource type, which is always compute#instanceGroupManager for
  /// managed instance groups.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the managed instance group.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String? name;

  /// Named ports configured for the Instance Groups complementary to this
  /// Instance Group Manager.
  core.List<NamedPort>? namedPorts;

  /// The URL of the region where the managed instance group resides (for
  /// regional resources).
  ///
  /// Output only.
  core.String? region;

  /// The URL for this managed instance group.
  ///
  /// The server defines this URL.
  ///
  /// Output only.
  core.String? selfLink;

  /// Stateful configuration for this Instanced Group Manager
  StatefulPolicy? statefulPolicy;

  /// The status of this managed instance group.
  ///
  /// Output only.
  InstanceGroupManagerStatus? status;

  /// The URLs for all TargetPool resources to which instances in the
  /// instanceGroup field are added.
  ///
  /// The target pools automatically apply to all of the instances in the
  /// managed instance group.
  core.List<core.String>? targetPools;

  /// The target number of running instances for this managed instance group.
  ///
  /// You can reduce this number by using the instanceGroupManager
  /// deleteInstances or abandonInstances methods. Resizing the group also
  /// changes this number.
  core.int? targetSize;

  /// The update policy for this managed instance group.
  InstanceGroupManagerUpdatePolicy? updatePolicy;

  /// Specifies the instance templates used by this managed instance group to
  /// create instances.
  ///
  /// Each version is defined by an instanceTemplate and a name. Every version
  /// can appear at most once per instance group. This field overrides the
  /// top-level instanceTemplate field. Read more about the relationships
  /// between these fields. Exactly one version must leave the targetSize field
  /// unset. That version will be applied to all remaining instances. For more
  /// information, read about canary updates.
  core.List<InstanceGroupManagerVersion>? versions;

  /// The URL of a zone where the managed instance group is located (for zonal
  /// resources).
  ///
  /// Output only.
  core.String? zone;

  InstanceGroupManager({
    this.autoHealingPolicies,
    this.baseInstanceName,
    this.creationTimestamp,
    this.currentActions,
    this.description,
    this.distributionPolicy,
    this.fingerprint,
    this.id,
    this.instanceGroup,
    this.instanceTemplate,
    this.kind,
    this.name,
    this.namedPorts,
    this.region,
    this.selfLink,
    this.statefulPolicy,
    this.status,
    this.targetPools,
    this.targetSize,
    this.updatePolicy,
    this.versions,
    this.zone,
  });

  InstanceGroupManager.fromJson(core.Map _json)
      : this(
          autoHealingPolicies: _json.containsKey('autoHealingPolicies')
              ? (_json['autoHealingPolicies'] as core.List)
                  .map<InstanceGroupManagerAutoHealingPolicy>((value) =>
                      InstanceGroupManagerAutoHealingPolicy.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          baseInstanceName: _json.containsKey('baseInstanceName')
              ? _json['baseInstanceName'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          currentActions: _json.containsKey('currentActions')
              ? InstanceGroupManagerActionsSummary.fromJson(
                  _json['currentActions']
                      as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          distributionPolicy: _json.containsKey('distributionPolicy')
              ? DistributionPolicy.fromJson(_json['distributionPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          instanceGroup: _json.containsKey('instanceGroup')
              ? _json['instanceGroup'] as core.String
              : null,
          instanceTemplate: _json.containsKey('instanceTemplate')
              ? _json['instanceTemplate'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          namedPorts: _json.containsKey('namedPorts')
              ? (_json['namedPorts'] as core.List)
                  .map<NamedPort>((value) => NamedPort.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          statefulPolicy: _json.containsKey('statefulPolicy')
              ? StatefulPolicy.fromJson(_json['statefulPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          status: _json.containsKey('status')
              ? InstanceGroupManagerStatus.fromJson(
                  _json['status'] as core.Map<core.String, core.dynamic>)
              : null,
          targetPools: _json.containsKey('targetPools')
              ? (_json['targetPools'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          targetSize: _json.containsKey('targetSize')
              ? _json['targetSize'] as core.int
              : null,
          updatePolicy: _json.containsKey('updatePolicy')
              ? InstanceGroupManagerUpdatePolicy.fromJson(
                  _json['updatePolicy'] as core.Map<core.String, core.dynamic>)
              : null,
          versions: _json.containsKey('versions')
              ? (_json['versions'] as core.List)
                  .map<InstanceGroupManagerVersion>((value) =>
                      InstanceGroupManagerVersion.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoHealingPolicies != null)
          'autoHealingPolicies':
              autoHealingPolicies!.map((value) => value.toJson()).toList(),
        if (baseInstanceName != null) 'baseInstanceName': baseInstanceName!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (currentActions != null) 'currentActions': currentActions!.toJson(),
        if (description != null) 'description': description!,
        if (distributionPolicy != null)
          'distributionPolicy': distributionPolicy!.toJson(),
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (instanceGroup != null) 'instanceGroup': instanceGroup!,
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (statefulPolicy != null) 'statefulPolicy': statefulPolicy!.toJson(),
        if (status != null) 'status': status!.toJson(),
        if (targetPools != null) 'targetPools': targetPools!,
        if (targetSize != null) 'targetSize': targetSize!,
        if (updatePolicy != null) 'updatePolicy': updatePolicy!.toJson(),
        if (versions != null)
          'versions': versions!.map((value) => value.toJson()).toList(),
        if (zone != null) 'zone': zone!,
      };
}

class InstanceGroupManagerActionsSummary {
  /// The total number of instances in the managed instance group that are
  /// scheduled to be abandoned.
  ///
  /// Abandoning an instance removes it from the managed instance group without
  /// deleting it.
  ///
  /// Output only.
  core.int? abandoning;

  /// The number of instances in the managed instance group that are scheduled
  /// to be created or are currently being created.
  ///
  /// If the group fails to create any of these instances, it tries again until
  /// it creates the instance successfully. If you have disabled creation
  /// retries, this field will not be populated; instead, the
  /// creatingWithoutRetries field will be populated.
  ///
  /// Output only.
  core.int? creating;

  /// The number of instances that the managed instance group will attempt to
  /// create.
  ///
  /// The group attempts to create each instance only once. If the group fails
  /// to create any of these instances, it decreases the group's targetSize
  /// value accordingly.
  ///
  /// Output only.
  core.int? creatingWithoutRetries;

  /// The number of instances in the managed instance group that are scheduled
  /// to be deleted or are currently being deleted.
  ///
  /// Output only.
  core.int? deleting;

  /// The number of instances in the managed instance group that are running and
  /// have no scheduled actions.
  ///
  /// Output only.
  core.int? none;

  /// The number of instances in the managed instance group that are scheduled
  /// to be recreated or are currently being being recreated.
  ///
  /// Recreating an instance deletes the existing root persistent disk and
  /// creates a new disk from the image that is defined in the instance
  /// template.
  ///
  /// Output only.
  core.int? recreating;

  /// The number of instances in the managed instance group that are being
  /// reconfigured with properties that do not require a restart or a recreate
  /// action.
  ///
  /// For example, setting or removing target pools for the instance.
  ///
  /// Output only.
  core.int? refreshing;

  /// The number of instances in the managed instance group that are scheduled
  /// to be restarted or are currently being restarted.
  ///
  /// Output only.
  core.int? restarting;

  /// The number of instances in the managed instance group that are being
  /// verified.
  ///
  /// See the managedInstances\[\].currentAction property in the
  /// listManagedInstances method documentation.
  ///
  /// Output only.
  core.int? verifying;

  InstanceGroupManagerActionsSummary({
    this.abandoning,
    this.creating,
    this.creatingWithoutRetries,
    this.deleting,
    this.none,
    this.recreating,
    this.refreshing,
    this.restarting,
    this.verifying,
  });

  InstanceGroupManagerActionsSummary.fromJson(core.Map _json)
      : this(
          abandoning: _json.containsKey('abandoning')
              ? _json['abandoning'] as core.int
              : null,
          creating: _json.containsKey('creating')
              ? _json['creating'] as core.int
              : null,
          creatingWithoutRetries: _json.containsKey('creatingWithoutRetries')
              ? _json['creatingWithoutRetries'] as core.int
              : null,
          deleting: _json.containsKey('deleting')
              ? _json['deleting'] as core.int
              : null,
          none: _json.containsKey('none') ? _json['none'] as core.int : null,
          recreating: _json.containsKey('recreating')
              ? _json['recreating'] as core.int
              : null,
          refreshing: _json.containsKey('refreshing')
              ? _json['refreshing'] as core.int
              : null,
          restarting: _json.containsKey('restarting')
              ? _json['restarting'] as core.int
              : null,
          verifying: _json.containsKey('verifying')
              ? _json['verifying'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (abandoning != null) 'abandoning': abandoning!,
        if (creating != null) 'creating': creating!,
        if (creatingWithoutRetries != null)
          'creatingWithoutRetries': creatingWithoutRetries!,
        if (deleting != null) 'deleting': deleting!,
        if (none != null) 'none': none!,
        if (recreating != null) 'recreating': recreating!,
        if (refreshing != null) 'refreshing': refreshing!,
        if (restarting != null) 'restarting': restarting!,
        if (verifying != null) 'verifying': verifying!,
      };
}

class InstanceGroupManagerAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupManagerAggregatedListWarningData({
    this.key,
    this.value,
  });

  InstanceGroupManagerAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupManagerAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupManagerAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupManagerAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceGroupManagerAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceGroupManagerAggregatedListWarningData>((value) =>
                      InstanceGroupManagerAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupManagerAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroupManagersScopedList resources.
  core.Map<core.String, InstanceGroupManagersScopedList>? items;

  /// The resource type, which is always
  /// compute#instanceGroupManagerAggregatedList for an aggregated list of
  /// managed instance groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupManagerAggregatedListWarning? warning;

  InstanceGroupManagerAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  InstanceGroupManagerAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    InstanceGroupManagersScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? InstanceGroupManagerAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupManagerAutoHealingPolicy {
  /// The URL for the health check that signals autohealing.
  core.String? healthCheck;

  /// The number of seconds that the managed instance group waits before it
  /// applies autohealing policies to new instances or recently recreated
  /// instances.
  ///
  /// This initial delay allows instances to initialize and run their startup
  /// scripts before the instance group determines that they are UNHEALTHY. This
  /// prevents the managed instance group from recreating its instances
  /// prematurely. This value must be from range \[0, 3600\].
  core.int? initialDelaySec;

  InstanceGroupManagerAutoHealingPolicy({
    this.healthCheck,
    this.initialDelaySec,
  });

  InstanceGroupManagerAutoHealingPolicy.fromJson(core.Map _json)
      : this(
          healthCheck: _json.containsKey('healthCheck')
              ? _json['healthCheck'] as core.String
              : null,
          initialDelaySec: _json.containsKey('initialDelaySec')
              ? _json['initialDelaySec'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthCheck != null) 'healthCheck': healthCheck!,
        if (initialDelaySec != null) 'initialDelaySec': initialDelaySec!,
      };
}

class InstanceGroupManagerListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupManagerListWarningData({
    this.key,
    this.value,
  });

  InstanceGroupManagerListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupManagerListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupManagerListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupManagerListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceGroupManagerListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceGroupManagerListWarningData>((value) =>
                      InstanceGroupManagerListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of managed instance groups.
///
/// Output only.
class InstanceGroupManagerList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager>? items;

  /// The resource type, which is always compute#instanceGroupManagerList for a
  /// list of managed instance groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupManagerListWarning? warning;

  InstanceGroupManagerList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InstanceGroupManagerList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceGroupManager>((value) =>
                      InstanceGroupManager.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InstanceGroupManagerListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupManagerStatus {
  /// The URL of the Autoscaler that targets this instance group manager.
  ///
  /// Output only.
  core.String? autoscaler;

  /// A bit indicating whether the managed instance group is in a stable state.
  ///
  /// A stable state means that: none of the instances in the managed instance
  /// group is currently undergoing any type of change (for example, creation,
  /// restart, or deletion); no future changes are scheduled for instances in
  /// the managed instance group; and the managed instance group itself is not
  /// being modified.
  ///
  /// Output only.
  core.bool? isStable;

  /// Stateful status of the given Instance Group Manager.
  ///
  /// Output only.
  InstanceGroupManagerStatusStateful? stateful;

  /// A status of consistency of Instances' versions with their target version
  /// specified by version field on Instance Group Manager.
  ///
  /// Output only.
  InstanceGroupManagerStatusVersionTarget? versionTarget;

  InstanceGroupManagerStatus({
    this.autoscaler,
    this.isStable,
    this.stateful,
    this.versionTarget,
  });

  InstanceGroupManagerStatus.fromJson(core.Map _json)
      : this(
          autoscaler: _json.containsKey('autoscaler')
              ? _json['autoscaler'] as core.String
              : null,
          isStable: _json.containsKey('isStable')
              ? _json['isStable'] as core.bool
              : null,
          stateful: _json.containsKey('stateful')
              ? InstanceGroupManagerStatusStateful.fromJson(
                  _json['stateful'] as core.Map<core.String, core.dynamic>)
              : null,
          versionTarget: _json.containsKey('versionTarget')
              ? InstanceGroupManagerStatusVersionTarget.fromJson(
                  _json['versionTarget'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscaler != null) 'autoscaler': autoscaler!,
        if (isStable != null) 'isStable': isStable!,
        if (stateful != null) 'stateful': stateful!.toJson(),
        if (versionTarget != null) 'versionTarget': versionTarget!.toJson(),
      };
}

class InstanceGroupManagerStatusStateful {
  /// A bit indicating whether the managed instance group has stateful
  /// configuration, that is, if you have configured any items in a stateful
  /// policy or in per-instance configs.
  ///
  /// The group might report that it has no stateful config even when there is
  /// still some preserved state on a managed instance, for example, if you have
  /// deleted all PICs but not yet applied those deletions.
  ///
  /// Output only.
  core.bool? hasStatefulConfig;

  /// Status of per-instance configs on the instance.
  ///
  /// Output only.
  InstanceGroupManagerStatusStatefulPerInstanceConfigs? perInstanceConfigs;

  InstanceGroupManagerStatusStateful({
    this.hasStatefulConfig,
    this.perInstanceConfigs,
  });

  InstanceGroupManagerStatusStateful.fromJson(core.Map _json)
      : this(
          hasStatefulConfig: _json.containsKey('hasStatefulConfig')
              ? _json['hasStatefulConfig'] as core.bool
              : null,
          perInstanceConfigs: _json.containsKey('perInstanceConfigs')
              ? InstanceGroupManagerStatusStatefulPerInstanceConfigs.fromJson(
                  _json['perInstanceConfigs']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (hasStatefulConfig != null) 'hasStatefulConfig': hasStatefulConfig!,
        if (perInstanceConfigs != null)
          'perInstanceConfigs': perInstanceConfigs!.toJson(),
      };
}

class InstanceGroupManagerStatusStatefulPerInstanceConfigs {
  /// A bit indicating if all of the group's per-instance configs (listed in the
  /// output of a listPerInstanceConfigs API call) have status EFFECTIVE or
  /// there are no per-instance-configs.
  core.bool? allEffective;

  InstanceGroupManagerStatusStatefulPerInstanceConfigs({
    this.allEffective,
  });

  InstanceGroupManagerStatusStatefulPerInstanceConfigs.fromJson(core.Map _json)
      : this(
          allEffective: _json.containsKey('allEffective')
              ? _json['allEffective'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allEffective != null) 'allEffective': allEffective!,
      };
}

class InstanceGroupManagerStatusVersionTarget {
  /// A bit indicating whether version target has been reached in this managed
  /// instance group, i.e. all instances are in their target version.
  ///
  /// Instances' target version are specified by version field on Instance Group
  /// Manager.
  ///
  /// Output only.
  core.bool? isReached;

  InstanceGroupManagerStatusVersionTarget({
    this.isReached,
  });

  InstanceGroupManagerStatusVersionTarget.fromJson(core.Map _json)
      : this(
          isReached: _json.containsKey('isReached')
              ? _json['isReached'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (isReached != null) 'isReached': isReached!,
      };
}

class InstanceGroupManagerUpdatePolicy {
  /// The instance redistribution policy for regional managed instance groups.
  ///
  /// Valid values are: - PROACTIVE (default): The group attempts to maintain an
  /// even distribution of VM instances across zones in the region. - NONE: For
  /// non-autoscaled groups, proactive redistribution is disabled.
  /// Possible string values are:
  /// - "NONE" : No action is being proactively performed in order to bring this
  /// IGM to its target instance distribution.
  /// - "PROACTIVE" : This IGM will actively converge to its target instance
  /// distribution.
  core.String? instanceRedistributionType;

  /// The maximum number of instances that can be created above the specified
  /// targetSize during the update process.
  ///
  /// This value can be either a fixed number or, if the group has 10 or more
  /// instances, a percentage. If you set a percentage, the number of instances
  /// is rounded if necessary. The default value for maxSurge is a fixed value
  /// equal to the number of zones in which the managed instance group operates.
  /// At least one of either maxSurge or maxUnavailable must be greater than 0.
  /// Learn more about maxSurge.
  FixedOrPercent? maxSurge;

  /// The maximum number of instances that can be unavailable during the update
  /// process.
  ///
  /// An instance is considered available if all of the following conditions are
  /// satisfied: - The instance's status is RUNNING. - If there is a health
  /// check on the instance group, the instance's health check status must be
  /// HEALTHY at least once. If there is no health check on the group, then the
  /// instance only needs to have a status of RUNNING to be considered
  /// available. This value can be either a fixed number or, if the group has 10
  /// or more instances, a percentage. If you set a percentage, the number of
  /// instances is rounded if necessary. The default value for maxUnavailable is
  /// a fixed value equal to the number of zones in which the managed instance
  /// group operates. At least one of either maxSurge or maxUnavailable must be
  /// greater than 0. Learn more about maxUnavailable.
  FixedOrPercent? maxUnavailable;

  /// Minimal action to be taken on an instance.
  ///
  /// You can specify either RESTART to restart existing instances or REPLACE to
  /// delete and create new instances from the target template. If you specify a
  /// RESTART, the Updater will attempt to perform that action only. However, if
  /// the Updater determines that the minimal action you specify is not enough
  /// to perform the update, it might perform a more disruptive action.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Updates applied in runtime, instances will not be disrupted.
  /// - "REPLACE" : Old instances will be deleted. New instances will be created
  /// from the target template.
  /// - "RESTART" : Every instance will be restarted.
  core.String? minimalAction;

  /// What action should be used to replace instances.
  ///
  /// See minimal_action.REPLACE
  /// Possible string values are:
  /// - "RECREATE" : Instances will be recreated (with the same name)
  /// - "SUBSTITUTE" : Default option: instances will be deleted and created
  /// (with a new name)
  core.String? replacementMethod;

  /// The type of update process.
  ///
  /// You can specify either PROACTIVE so that the instance group manager
  /// proactively executes actions in order to bring instances to their target
  /// versions or OPPORTUNISTIC so that no action is proactively executed but
  /// the update will be performed as part of other actions (for example,
  /// resizes or recreateInstances calls).
  /// Possible string values are:
  /// - "OPPORTUNISTIC" : No action is being proactively performed in order to
  /// bring this IGM to its target version distribution (regardless of whether
  /// this distribution is expressed using instanceTemplate or versions field).
  /// - "PROACTIVE" : This IGM will actively converge to its target version
  /// distribution (regardless of whether this distribution is expressed using
  /// instanceTemplate or versions field).
  core.String? type;

  InstanceGroupManagerUpdatePolicy({
    this.instanceRedistributionType,
    this.maxSurge,
    this.maxUnavailable,
    this.minimalAction,
    this.replacementMethod,
    this.type,
  });

  InstanceGroupManagerUpdatePolicy.fromJson(core.Map _json)
      : this(
          instanceRedistributionType:
              _json.containsKey('instanceRedistributionType')
                  ? _json['instanceRedistributionType'] as core.String
                  : null,
          maxSurge: _json.containsKey('maxSurge')
              ? FixedOrPercent.fromJson(
                  _json['maxSurge'] as core.Map<core.String, core.dynamic>)
              : null,
          maxUnavailable: _json.containsKey('maxUnavailable')
              ? FixedOrPercent.fromJson(_json['maxUnavailable']
                  as core.Map<core.String, core.dynamic>)
              : null,
          minimalAction: _json.containsKey('minimalAction')
              ? _json['minimalAction'] as core.String
              : null,
          replacementMethod: _json.containsKey('replacementMethod')
              ? _json['replacementMethod'] as core.String
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceRedistributionType != null)
          'instanceRedistributionType': instanceRedistributionType!,
        if (maxSurge != null) 'maxSurge': maxSurge!.toJson(),
        if (maxUnavailable != null) 'maxUnavailable': maxUnavailable!.toJson(),
        if (minimalAction != null) 'minimalAction': minimalAction!,
        if (replacementMethod != null) 'replacementMethod': replacementMethod!,
        if (type != null) 'type': type!,
      };
}

class InstanceGroupManagerVersion {
  /// The URL of the instance template that is specified for this managed
  /// instance group.
  ///
  /// The group uses this template to create new instances in the managed
  /// instance group until the `targetSize` for this version is reached. The
  /// templates for existing instances in the group do not change unless you run
  /// recreateInstances, run applyUpdatesToInstances, or set the group's
  /// updatePolicy.type to PROACTIVE; in those cases, existing instances are
  /// updated until the `targetSize` for this version is reached.
  core.String? instanceTemplate;

  /// Name of the version.
  ///
  /// Unique among all versions in the scope of this managed instance group.
  core.String? name;

  /// Specifies the intended number of instances to be created from the
  /// instanceTemplate.
  ///
  /// The final number of instances created from the template will be equal to:
  /// - If expressed as a fixed number, the minimum of either targetSize.fixed
  /// or instanceGroupManager.targetSize is used. - if expressed as a percent,
  /// the targetSize would be (targetSize.percent/100 *
  /// InstanceGroupManager.targetSize) If there is a remainder, the number is
  /// rounded. If unset, this version will update any remaining instances not
  /// updated by another version. Read Starting a canary update for more
  /// information.
  FixedOrPercent? targetSize;

  InstanceGroupManagerVersion({
    this.instanceTemplate,
    this.name,
    this.targetSize,
  });

  InstanceGroupManagerVersion.fromJson(core.Map _json)
      : this(
          instanceTemplate: _json.containsKey('instanceTemplate')
              ? _json['instanceTemplate'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          targetSize: _json.containsKey('targetSize')
              ? FixedOrPercent.fromJson(
                  _json['targetSize'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
        if (name != null) 'name': name!,
        if (targetSize != null) 'targetSize': targetSize!.toJson(),
      };
}

class InstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  InstanceGroupManagersAbandonInstancesRequest({
    this.instances,
  });

  InstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

/// InstanceGroupManagers.applyUpdatesToInstances
class InstanceGroupManagersApplyUpdatesRequest {
  /// Flag to update all instances instead of specified list of “instances”.
  ///
  /// If the flag is set to true then the instances may not be specified in the
  /// request.
  core.bool? allInstances;

  /// The list of URLs of one or more instances for which you want to apply
  /// updates.
  ///
  /// Each URL can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// The minimal action that you want to perform on each instance during the
  /// update: - REPLACE: At minimum, delete the instance and create it again.
  ///
  /// - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
  /// the instance. - NONE: Do not disrupt the instance at all. By default, the
  /// minimum action is NONE. If your update requires a more disruptive action
  /// than you set with this flag, the necessary action is performed to execute
  /// the update.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Updates applied in runtime, instances will not be disrupted.
  /// - "REPLACE" : Old instances will be deleted. New instances will be created
  /// from the target template.
  /// - "RESTART" : Every instance will be restarted.
  core.String? minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update: - REPLACE: Delete the instance and create it again.
  ///
  /// - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
  /// the instance. - NONE: Do not disrupt the instance at all. By default, the
  /// most disruptive allowed action is REPLACE. If your update requires a more
  /// disruptive action than you set with this flag, the update request will
  /// fail.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Updates applied in runtime, instances will not be disrupted.
  /// - "REPLACE" : Old instances will be deleted. New instances will be created
  /// from the target template.
  /// - "RESTART" : Every instance will be restarted.
  core.String? mostDisruptiveAllowedAction;

  InstanceGroupManagersApplyUpdatesRequest({
    this.allInstances,
    this.instances,
    this.minimalAction,
    this.mostDisruptiveAllowedAction,
  });

  InstanceGroupManagersApplyUpdatesRequest.fromJson(core.Map _json)
      : this(
          allInstances: _json.containsKey('allInstances')
              ? _json['allInstances'] as core.bool
              : null,
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          minimalAction: _json.containsKey('minimalAction')
              ? _json['minimalAction'] as core.String
              : null,
          mostDisruptiveAllowedAction:
              _json.containsKey('mostDisruptiveAllowedAction')
                  ? _json['mostDisruptiveAllowedAction'] as core.String
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allInstances != null) 'allInstances': allInstances!,
        if (instances != null) 'instances': instances!,
        if (minimalAction != null) 'minimalAction': minimalAction!,
        if (mostDisruptiveAllowedAction != null)
          'mostDisruptiveAllowedAction': mostDisruptiveAllowedAction!,
      };
}

/// InstanceGroupManagers.createInstances
class InstanceGroupManagersCreateInstancesRequest {
  /// List of specifications of per-instance configs.
  ///
  /// Required.
  core.List<PerInstanceConfig>? instances;

  InstanceGroupManagersCreateInstancesRequest({
    this.instances,
  });

  InstanceGroupManagersCreateInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// Specifies whether the request should proceed despite the inclusion of
  /// instances that are not members of the group or that are already in the
  /// process of being deleted or abandoned.
  ///
  /// If this field is set to `false` and such an instance is specified in the
  /// request, the operation fails. The operation always fails if the request
  /// contains a malformed instance URL or a reference to an instance that
  /// exists in a zone or region other than the group's zone or region.
  core.bool? skipInstancesOnValidationError;

  InstanceGroupManagersDeleteInstancesRequest({
    this.instances,
    this.skipInstancesOnValidationError,
  });

  InstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          skipInstancesOnValidationError:
              _json.containsKey('skipInstancesOnValidationError')
                  ? _json['skipInstancesOnValidationError'] as core.bool
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (skipInstancesOnValidationError != null)
          'skipInstancesOnValidationError': skipInstancesOnValidationError!,
      };
}

/// InstanceGroupManagers.deletePerInstanceConfigs
class InstanceGroupManagersDeletePerInstanceConfigsReq {
  /// The list of instance names for which we want to delete per-instance
  /// configs on this managed instance group.
  core.List<core.String>? names;

  InstanceGroupManagersDeletePerInstanceConfigsReq({
    this.names,
  });

  InstanceGroupManagersDeletePerInstanceConfigsReq.fromJson(core.Map _json)
      : this(
          names: _json.containsKey('names')
              ? (_json['names'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (names != null) 'names': names!,
      };
}

class InstanceGroupManagersListErrorsResponse {
  /// The list of errors of the managed instance group.
  ///
  /// Output only.
  core.List<InstanceManagedByIgmError>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  InstanceGroupManagersListErrorsResponse({
    this.items,
    this.nextPageToken,
  });

  InstanceGroupManagersListErrorsResponse.fromJson(core.Map _json)
      : this(
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceManagedByIgmError>((value) =>
                      InstanceManagedByIgmError.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

class InstanceGroupManagersListManagedInstancesResponse {
  /// The list of instances in the managed instance group.
  ///
  /// Output only.
  core.List<ManagedInstance>? managedInstances;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  InstanceGroupManagersListManagedInstancesResponse({
    this.managedInstances,
    this.nextPageToken,
  });

  InstanceGroupManagersListManagedInstancesResponse.fromJson(core.Map _json)
      : this(
          managedInstances: _json.containsKey('managedInstances')
              ? (_json['managedInstances'] as core.List)
                  .map<ManagedInstance>((value) => ManagedInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (managedInstances != null)
          'managedInstances':
              managedInstances!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

class InstanceGroupManagersListPerInstanceConfigsRespWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupManagersListPerInstanceConfigsRespWarningData({
    this.key,
    this.value,
  });

  InstanceGroupManagersListPerInstanceConfigsRespWarningData.fromJson(
      core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupManagersListPerInstanceConfigsRespWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupManagersListPerInstanceConfigsRespWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupManagersListPerInstanceConfigsRespWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceGroupManagersListPerInstanceConfigsRespWarning.fromJson(
      core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceGroupManagersListPerInstanceConfigsRespWarningData>(
                      (value) =>
                          InstanceGroupManagersListPerInstanceConfigsRespWarningData
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupManagersListPerInstanceConfigsResp {
  /// The list of PerInstanceConfig.
  ///
  /// Output only.
  core.List<PerInstanceConfig>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupManagersListPerInstanceConfigsRespWarning? warning;

  InstanceGroupManagersListPerInstanceConfigsResp({
    this.items,
    this.nextPageToken,
    this.warning,
  });

  InstanceGroupManagersListPerInstanceConfigsResp.fromJson(core.Map _json)
      : this(
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InstanceGroupManagersListPerInstanceConfigsRespWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// InstanceGroupManagers.patchPerInstanceConfigs
class InstanceGroupManagersPatchPerInstanceConfigsReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig>? perInstanceConfigs;

  InstanceGroupManagersPatchPerInstanceConfigsReq({
    this.perInstanceConfigs,
  });

  InstanceGroupManagersPatchPerInstanceConfigsReq.fromJson(core.Map _json)
      : this(
          perInstanceConfigs: _json.containsKey('perInstanceConfigs')
              ? (_json['perInstanceConfigs'] as core.List)
                  .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (perInstanceConfigs != null)
          'perInstanceConfigs':
              perInstanceConfigs!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupManagersRecreateInstancesRequest {
  /// The URLs of one or more instances to recreate.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  InstanceGroupManagersRecreateInstancesRequest({
    this.instances,
  });

  InstanceGroupManagersRecreateInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

class InstanceGroupManagersScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupManagersScopedListWarningData({
    this.key,
    this.value,
  });

  InstanceGroupManagersScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// The warning that replaces the list of managed instance groups when the list
/// is empty.
///
/// Output only.
class InstanceGroupManagersScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupManagersScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupManagersScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceGroupManagersScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceGroupManagersScopedListWarningData>((value) =>
                      InstanceGroupManagersScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupManagersScopedList {
  /// The list of managed instance groups that are contained in the specified
  /// project and zone.
  ///
  /// Output only.
  core.List<InstanceGroupManager>? instanceGroupManagers;

  /// The warning that replaces the list of managed instance groups when the
  /// list is empty.
  ///
  /// Output only.
  InstanceGroupManagersScopedListWarning? warning;

  InstanceGroupManagersScopedList({
    this.instanceGroupManagers,
    this.warning,
  });

  InstanceGroupManagersScopedList.fromJson(core.Map _json)
      : this(
          instanceGroupManagers: _json.containsKey('instanceGroupManagers')
              ? (_json['instanceGroupManagers'] as core.List)
                  .map<InstanceGroupManager>((value) =>
                      InstanceGroupManager.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? InstanceGroupManagersScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceGroupManagers != null)
          'instanceGroupManagers':
              instanceGroupManagers!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupManagersSetInstanceTemplateRequest {
  /// The URL of the instance template that is specified for this managed
  /// instance group.
  ///
  /// The group uses this template to create all new instances in the managed
  /// instance group. The templates for existing instances in the group do not
  /// change unless you run recreateInstances, run applyUpdatesToInstances, or
  /// set the group's updatePolicy.type to PROACTIVE.
  core.String? instanceTemplate;

  InstanceGroupManagersSetInstanceTemplateRequest({
    this.instanceTemplate,
  });

  InstanceGroupManagersSetInstanceTemplateRequest.fromJson(core.Map _json)
      : this(
          instanceTemplate: _json.containsKey('instanceTemplate')
              ? _json['instanceTemplate'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
      };
}

class InstanceGroupManagersSetTargetPoolsRequest {
  /// The fingerprint of the target pools information.
  ///
  /// Use this optional property to prevent conflicts when multiple users change
  /// the target pools settings concurrently. Obtain the fingerprint with the
  /// instanceGroupManagers.get method. Then, include the fingerprint in your
  /// request to ensure that you do not overwrite changes that were applied from
  /// another concurrent request.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of target pool URLs that instances in this managed instance group
  /// belong to.
  ///
  /// The managed instance group applies these target pools to all of the
  /// instances in the group. Existing instances and new instances in the group
  /// all receive these target pool settings.
  core.List<core.String>? targetPools;

  InstanceGroupManagersSetTargetPoolsRequest({
    this.fingerprint,
    this.targetPools,
  });

  InstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json)
      : this(
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          targetPools: _json.containsKey('targetPools')
              ? (_json['targetPools'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (targetPools != null) 'targetPools': targetPools!,
      };
}

/// InstanceGroupManagers.updatePerInstanceConfigs
class InstanceGroupManagersUpdatePerInstanceConfigsReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig>? perInstanceConfigs;

  InstanceGroupManagersUpdatePerInstanceConfigsReq({
    this.perInstanceConfigs,
  });

  InstanceGroupManagersUpdatePerInstanceConfigsReq.fromJson(core.Map _json)
      : this(
          perInstanceConfigs: _json.containsKey('perInstanceConfigs')
              ? (_json['perInstanceConfigs'] as core.List)
                  .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (perInstanceConfigs != null)
          'perInstanceConfigs':
              perInstanceConfigs!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupsAddInstancesRequest {
  /// The list of instances to add to the instance group.
  core.List<InstanceReference>? instances;

  InstanceGroupsAddInstancesRequest({
    this.instances,
  });

  InstanceGroupsAddInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<InstanceReference>((value) => InstanceReference.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupsListInstancesWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupsListInstancesWarningData({
    this.key,
    this.value,
  });

  InstanceGroupsListInstancesWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupsListInstancesWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupsListInstancesWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupsListInstancesWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceGroupsListInstancesWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceGroupsListInstancesWarningData>((value) =>
                      InstanceGroupsListInstancesWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupsListInstances {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts>? items;

  /// The resource type, which is always compute#instanceGroupsListInstances for
  /// the list of instances in the specified instance group.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupsListInstancesWarning? warning;

  InstanceGroupsListInstances({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InstanceGroupsListInstances.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceWithNamedPorts>((value) =>
                      InstanceWithNamedPorts.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InstanceGroupsListInstancesWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupsListInstancesRequest {
  /// A filter for the state of the instances in the instance group.
  ///
  /// Valid options are ALL or RUNNING. If you do not specify this parameter the
  /// list includes all instances regardless of their state.
  /// Possible string values are:
  /// - "ALL" : Includes all instances in the generated list regardless of their
  /// state.
  /// - "RUNNING" : Includes instances in the generated list only if they have a
  /// RUNNING state.
  core.String? instanceState;

  InstanceGroupsListInstancesRequest({
    this.instanceState,
  });

  InstanceGroupsListInstancesRequest.fromJson(core.Map _json)
      : this(
          instanceState: _json.containsKey('instanceState')
              ? _json['instanceState'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceState != null) 'instanceState': instanceState!,
      };
}

class InstanceGroupsRemoveInstancesRequest {
  /// The list of instances to remove from the instance group.
  core.List<InstanceReference>? instances;

  InstanceGroupsRemoveInstancesRequest({
    this.instances,
  });

  InstanceGroupsRemoveInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<InstanceReference>((value) => InstanceReference.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupsScopedListWarningData({
    this.key,
    this.value,
  });

  InstanceGroupsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that replaces the list of instance groups when the
/// list is empty.
///
/// Output only.
class InstanceGroupsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceGroupsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceGroupsScopedListWarningData>((value) =>
                      InstanceGroupsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupsScopedList {
  /// The list of instance groups that are contained in this scope.
  ///
  /// Output only.
  core.List<InstanceGroup>? instanceGroups;

  /// An informational warning that replaces the list of instance groups when
  /// the list is empty.
  ///
  /// Output only.
  InstanceGroupsScopedListWarning? warning;

  InstanceGroupsScopedList({
    this.instanceGroups,
    this.warning,
  });

  InstanceGroupsScopedList.fromJson(core.Map _json)
      : this(
          instanceGroups: _json.containsKey('instanceGroups')
              ? (_json['instanceGroups'] as core.List)
                  .map<InstanceGroup>((value) => InstanceGroup.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? InstanceGroupsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceGroups != null)
          'instanceGroups':
              instanceGroups!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  ///
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request. A request with an incorrect fingerprint will fail with
  /// error 412 conditionNotMet.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort>? namedPorts;

  InstanceGroupsSetNamedPortsRequest({
    this.fingerprint,
    this.namedPorts,
  });

  InstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json)
      : this(
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          namedPorts: _json.containsKey('namedPorts')
              ? (_json['namedPorts'] as core.List)
                  .map<NamedPort>((value) => NamedPort.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
      };
}

class InstanceListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceListWarningData({
    this.key,
    this.value,
  });

  InstanceListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceListWarningData>((value) =>
                      InstanceListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of instances.
class InstanceList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Instance resources.
  core.List<Instance>? items;

  /// Type of resource.
  ///
  /// Always compute#instanceList for lists of Instance resources.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceListWarning? warning;

  InstanceList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InstanceList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Instance>((value) => Instance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InstanceListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceListReferrersWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceListReferrersWarningData({
    this.key,
    this.value,
  });

  InstanceListReferrersWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceListReferrersWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceListReferrersWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceListReferrersWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceListReferrersWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceListReferrersWarningData>((value) =>
                      InstanceListReferrersWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of instance referrers.
class InstanceListReferrers {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Reference resources.
  core.List<Reference>? items;

  /// Type of resource.
  ///
  /// Always compute#instanceListReferrers for lists of Instance referrers.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceListReferrersWarning? warning;

  InstanceListReferrers({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InstanceListReferrers.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Reference>((value) => Reference.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InstanceListReferrersWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceManagedByIgmError {
  /// Contents of the error.
  ///
  /// Output only.
  InstanceManagedByIgmErrorManagedInstanceError? error;

  /// Details of the instance action that triggered this error.
  ///
  /// May be null, if the error was not caused by an action on an instance. This
  /// field is optional.
  ///
  /// Output only.
  InstanceManagedByIgmErrorInstanceActionDetails? instanceActionDetails;

  /// The time that this error occurred.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? timestamp;

  InstanceManagedByIgmError({
    this.error,
    this.instanceActionDetails,
    this.timestamp,
  });

  InstanceManagedByIgmError.fromJson(core.Map _json)
      : this(
          error: _json.containsKey('error')
              ? InstanceManagedByIgmErrorManagedInstanceError.fromJson(
                  _json['error'] as core.Map<core.String, core.dynamic>)
              : null,
          instanceActionDetails: _json.containsKey('instanceActionDetails')
              ? InstanceManagedByIgmErrorInstanceActionDetails.fromJson(
                  _json['instanceActionDetails']
                      as core.Map<core.String, core.dynamic>)
              : null,
          timestamp: _json.containsKey('timestamp')
              ? _json['timestamp'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (error != null) 'error': error!.toJson(),
        if (instanceActionDetails != null)
          'instanceActionDetails': instanceActionDetails!.toJson(),
        if (timestamp != null) 'timestamp': timestamp!,
      };
}

class InstanceManagedByIgmErrorInstanceActionDetails {
  /// Action that managed instance group was executing on the instance when the
  /// error occurred.
  ///
  /// Possible values:
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ABANDONING" : The managed instance group is abandoning this instance.
  /// The instance will be removed from the instance group and from any target
  /// pools that are associated with this group.
  /// - "CREATING" : The managed instance group is creating this instance. If
  /// the group fails to create this instance, it will try again until it is
  /// successful.
  /// - "CREATING_WITHOUT_RETRIES" : The managed instance group is attempting to
  /// create this instance only once. If the group fails to create this
  /// instance, it does not try again and the group's targetSize value is
  /// decreased.
  /// - "DELETING" : The managed instance group is permanently deleting this
  /// instance.
  /// - "NONE" : The managed instance group has not scheduled any actions for
  /// this instance.
  /// - "RECREATING" : The managed instance group is recreating this instance.
  /// - "REFRESHING" : The managed instance group is applying configuration
  /// changes to the instance without stopping it. For example, the group can
  /// update the target pool list for an instance without stopping that
  /// instance.
  /// - "RESTARTING" : The managed instance group is restarting this instance.
  /// - "VERIFYING" : The managed instance group is verifying this already
  /// created instance. Verification happens every time the instance is
  /// (re)created or restarted and consists of: 1. Waiting until health check
  /// specified as part of this managed instance group's autohealing policy
  /// reports HEALTHY. Note: Applies only if autohealing policy has a health
  /// check specified 2. Waiting for addition verification steps performed as
  /// post-instance creation (subject to future extensions).
  core.String? action;

  /// The URL of the instance.
  ///
  /// The URL can be set even if the instance has not yet been created.
  ///
  /// Output only.
  core.String? instance;

  /// Version this instance was created from, or was being created from, but the
  /// creation failed.
  ///
  /// Corresponds to one of the versions that were set on the Instance Group
  /// Manager resource at the time this instance was being created.
  ///
  /// Output only.
  ManagedInstanceVersion? version;

  InstanceManagedByIgmErrorInstanceActionDetails({
    this.action,
    this.instance,
    this.version,
  });

  InstanceManagedByIgmErrorInstanceActionDetails.fromJson(core.Map _json)
      : this(
          action: _json.containsKey('action')
              ? _json['action'] as core.String
              : null,
          instance: _json.containsKey('instance')
              ? _json['instance'] as core.String
              : null,
          version: _json.containsKey('version')
              ? ManagedInstanceVersion.fromJson(
                  _json['version'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (action != null) 'action': action!,
        if (instance != null) 'instance': instance!,
        if (version != null) 'version': version!.toJson(),
      };
}

class InstanceManagedByIgmErrorManagedInstanceError {
  /// Error code.
  ///
  /// Output only.
  core.String? code;

  /// Error message.
  ///
  /// Output only.
  core.String? message;

  InstanceManagedByIgmErrorManagedInstanceError({
    this.code,
    this.message,
  });

  InstanceManagedByIgmErrorManagedInstanceError.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (message != null) 'message': message!,
      };
}

class InstanceMoveRequest {
  /// The URL of the destination zone to move the instance.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a zone: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone -
  /// projects/project/zones/zone - zones/zone
  core.String? destinationZone;

  /// The URL of the target instance to move.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to an instance: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /instances/instance - projects/project/zones/zone/instances/instance -
  /// zones/zone/instances/instance
  core.String? targetInstance;

  InstanceMoveRequest({
    this.destinationZone,
    this.targetInstance,
  });

  InstanceMoveRequest.fromJson(core.Map _json)
      : this(
          destinationZone: _json.containsKey('destinationZone')
              ? _json['destinationZone'] as core.String
              : null,
          targetInstance: _json.containsKey('targetInstance')
              ? _json['targetInstance'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (destinationZone != null) 'destinationZone': destinationZone!,
        if (targetInstance != null) 'targetInstance': targetInstance!,
      };
}

class InstanceProperties {
  /// Controls for advanced machine-related behavior features.
  AdvancedMachineFeatures? advancedMachineFeatures;

  /// Enables instances created based on these properties to send packets with
  /// source IP addresses other than their own and receive packets with
  /// destination IP addresses other than their own.
  ///
  /// If these instances will be used as an IP gateway or it will be set as the
  /// next-hop in a Route resource, specify true. If unsure, leave this set to
  /// false. See the Enable IP forwarding documentation for more information.
  core.bool? canIpForward;

  /// Specifies the Confidential Instance options.
  ConfidentialInstanceConfig? confidentialInstanceConfig;

  /// An optional text description for the instances that are created from these
  /// properties.
  core.String? description;

  /// An array of disks that are associated with the instances that are created
  /// from these properties.
  core.List<AttachedDisk>? disks;

  /// A list of guest accelerator cards' type and count to use for instances
  /// created from these properties.
  core.List<AcceleratorConfig>? guestAccelerators;

  /// Labels to apply to instances that are created from these properties.
  core.Map<core.String, core.String>? labels;

  /// The machine type to use for instances that are created from these
  /// properties.
  core.String? machineType;

  /// The metadata key/value pairs to assign to instances that are created from
  /// these properties.
  ///
  /// These pairs can consist of custom metadata or predefined keys. See Project
  /// and instance metadata for more information.
  Metadata? metadata;

  /// Minimum cpu/platform to be used by instances.
  ///
  /// The instance may be scheduled on the specified or newer cpu/platform.
  /// Applicable values are the friendly names of CPU platforms, such as
  /// minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge".
  /// For more information, read Specifying a Minimum CPU Platform.
  core.String? minCpuPlatform;

  /// An array of network access configurations for this interface.
  core.List<NetworkInterface>? networkInterfaces;

  /// The private IPv6 google access type for VMs.
  ///
  /// If not specified, use INHERIT_FROM_SUBNETWORK as default.
  /// Possible string values are:
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" : Bidirectional private IPv6
  /// access to/from Google services. If specified, the subnetwork who is
  /// attached to the instance's default network interface will be assigned an
  /// internal IPv6 prefix if it doesn't have before.
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" : Outbound private IPv6 access
  /// from VMs in this subnet to Google services. If specified, the subnetwork
  /// who is attached to the instance's default network interface will be
  /// assigned an internal IPv6 prefix if it doesn't have before.
  /// - "INHERIT_FROM_SUBNETWORK" : Each network interface inherits
  /// PrivateIpv6GoogleAccess from its subnetwork.
  core.String? privateIpv6GoogleAccess;

  /// Specifies the reservations that instances can consume from.
  ReservationAffinity? reservationAffinity;

  /// Resource policies (names, not ULRs) applied to instances created from
  /// these properties.
  core.List<core.String>? resourcePolicies;

  /// Specifies the scheduling options for the instances that are created from
  /// these properties.
  Scheduling? scheduling;

  /// A list of service accounts with specified scopes.
  ///
  /// Access tokens for these service accounts are available to the instances
  /// that are created from these properties. Use metadata queries to obtain the
  /// access tokens for these instances.
  core.List<ServiceAccount>? serviceAccounts;
  ShieldedInstanceConfig? shieldedInstanceConfig;

  /// A list of tags to apply to the instances that are created from these
  /// properties.
  ///
  /// The tags identify valid sources or targets for network firewalls. The
  /// setTags method can modify this list of tags. Each tag within the list must
  /// comply with RFC1035.
  Tags? tags;

  InstanceProperties({
    this.advancedMachineFeatures,
    this.canIpForward,
    this.confidentialInstanceConfig,
    this.description,
    this.disks,
    this.guestAccelerators,
    this.labels,
    this.machineType,
    this.metadata,
    this.minCpuPlatform,
    this.networkInterfaces,
    this.privateIpv6GoogleAccess,
    this.reservationAffinity,
    this.resourcePolicies,
    this.scheduling,
    this.serviceAccounts,
    this.shieldedInstanceConfig,
    this.tags,
  });

  InstanceProperties.fromJson(core.Map _json)
      : this(
          advancedMachineFeatures: _json.containsKey('advancedMachineFeatures')
              ? AdvancedMachineFeatures.fromJson(
                  _json['advancedMachineFeatures']
                      as core.Map<core.String, core.dynamic>)
              : null,
          canIpForward: _json.containsKey('canIpForward')
              ? _json['canIpForward'] as core.bool
              : null,
          confidentialInstanceConfig:
              _json.containsKey('confidentialInstanceConfig')
                  ? ConfidentialInstanceConfig.fromJson(
                      _json['confidentialInstanceConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          disks: _json.containsKey('disks')
              ? (_json['disks'] as core.List)
                  .map<AttachedDisk>((value) => AttachedDisk.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          guestAccelerators: _json.containsKey('guestAccelerators')
              ? (_json['guestAccelerators'] as core.List)
                  .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          machineType: _json.containsKey('machineType')
              ? _json['machineType'] as core.String
              : null,
          metadata: _json.containsKey('metadata')
              ? Metadata.fromJson(
                  _json['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          minCpuPlatform: _json.containsKey('minCpuPlatform')
              ? _json['minCpuPlatform'] as core.String
              : null,
          networkInterfaces: _json.containsKey('networkInterfaces')
              ? (_json['networkInterfaces'] as core.List)
                  .map<NetworkInterface>((value) => NetworkInterface.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          privateIpv6GoogleAccess: _json.containsKey('privateIpv6GoogleAccess')
              ? _json['privateIpv6GoogleAccess'] as core.String
              : null,
          reservationAffinity: _json.containsKey('reservationAffinity')
              ? ReservationAffinity.fromJson(_json['reservationAffinity']
                  as core.Map<core.String, core.dynamic>)
              : null,
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          scheduling: _json.containsKey('scheduling')
              ? Scheduling.fromJson(
                  _json['scheduling'] as core.Map<core.String, core.dynamic>)
              : null,
          serviceAccounts: _json.containsKey('serviceAccounts')
              ? (_json['serviceAccounts'] as core.List)
                  .map<ServiceAccount>((value) => ServiceAccount.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          shieldedInstanceConfig: _json.containsKey('shieldedInstanceConfig')
              ? ShieldedInstanceConfig.fromJson(_json['shieldedInstanceConfig']
                  as core.Map<core.String, core.dynamic>)
              : null,
          tags: _json.containsKey('tags')
              ? Tags.fromJson(
                  _json['tags'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (advancedMachineFeatures != null)
          'advancedMachineFeatures': advancedMachineFeatures!.toJson(),
        if (canIpForward != null) 'canIpForward': canIpForward!,
        if (confidentialInstanceConfig != null)
          'confidentialInstanceConfig': confidentialInstanceConfig!.toJson(),
        if (description != null) 'description': description!,
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (guestAccelerators != null)
          'guestAccelerators':
              guestAccelerators!.map((value) => value.toJson()).toList(),
        if (labels != null) 'labels': labels!,
        if (machineType != null) 'machineType': machineType!,
        if (metadata != null) 'metadata': metadata!.toJson(),
        if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
        if (networkInterfaces != null)
          'networkInterfaces':
              networkInterfaces!.map((value) => value.toJson()).toList(),
        if (privateIpv6GoogleAccess != null)
          'privateIpv6GoogleAccess': privateIpv6GoogleAccess!,
        if (reservationAffinity != null)
          'reservationAffinity': reservationAffinity!.toJson(),
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
        if (scheduling != null) 'scheduling': scheduling!.toJson(),
        if (serviceAccounts != null)
          'serviceAccounts':
              serviceAccounts!.map((value) => value.toJson()).toList(),
        if (shieldedInstanceConfig != null)
          'shieldedInstanceConfig': shieldedInstanceConfig!.toJson(),
        if (tags != null) 'tags': tags!.toJson(),
      };
}

class InstanceReference {
  /// The URL for a specific instance.
  ///
  /// @required compute.instancegroups.addInstances/removeInstances
  core.String? instance;

  InstanceReference({
    this.instance,
  });

  InstanceReference.fromJson(core.Map _json)
      : this(
          instance: _json.containsKey('instance')
              ? _json['instance'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
      };
}

/// Represents an Instance Template resource.
///
/// You can use instance templates to create VM instances and managed instance
/// groups. For more information, read Instance Templates.
class InstanceTemplate {
  /// The creation timestamp for this instance template in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A unique identifier for this instance template.
  ///
  /// The server defines this identifier.
  ///
  /// Output only.
  core.String? id;

  /// The resource type, which is always compute#instanceTemplate for instance
  /// templates.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The instance properties for this instance template.
  InstanceProperties? properties;

  /// The URL for this instance template.
  ///
  /// The server defines this URL.
  ///
  /// Output only.
  core.String? selfLink;

  /// The source instance used to create the template.
  ///
  /// You can provide this as a partial or full URL to the resource. For
  /// example, the following are valid values: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /instances/instance - projects/project/zones/zone/instances/instance
  core.String? sourceInstance;

  /// The source instance params to use to create this instance template.
  SourceInstanceParams? sourceInstanceParams;

  InstanceTemplate({
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.properties,
    this.selfLink,
    this.sourceInstance,
    this.sourceInstanceParams,
  });

  InstanceTemplate.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          properties: _json.containsKey('properties')
              ? InstanceProperties.fromJson(
                  _json['properties'] as core.Map<core.String, core.dynamic>)
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          sourceInstance: _json.containsKey('sourceInstance')
              ? _json['sourceInstance'] as core.String
              : null,
          sourceInstanceParams: _json.containsKey('sourceInstanceParams')
              ? SourceInstanceParams.fromJson(_json['sourceInstanceParams']
                  as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (properties != null) 'properties': properties!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (sourceInstance != null) 'sourceInstance': sourceInstance!,
        if (sourceInstanceParams != null)
          'sourceInstanceParams': sourceInstanceParams!.toJson(),
      };
}

class InstanceTemplateListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceTemplateListWarningData({
    this.key,
    this.value,
  });

  InstanceTemplateListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceTemplateListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceTemplateListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceTemplateListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstanceTemplateListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstanceTemplateListWarningData>((value) =>
                      InstanceTemplateListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of instance templates.
class InstanceTemplateList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceTemplate resources.
  core.List<InstanceTemplate>? items;

  /// The resource type, which is always compute#instanceTemplatesListResponse
  /// for instance template lists.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceTemplateListWarning? warning;

  InstanceTemplateList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InstanceTemplateList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceTemplate>((value) => InstanceTemplate.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InstanceTemplateListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceWithNamedPorts {
  /// The URL of the instance.
  ///
  /// Output only.
  core.String? instance;

  /// The named ports that belong to this instance group.
  ///
  /// Output only.
  core.List<NamedPort>? namedPorts;

  /// The status of the instance.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DEPROVISIONING" : The Nanny is halted and we are performing tear down
  /// tasks like network deprogramming, releasing quota, IP, tearing down disks
  /// etc.
  /// - "PROVISIONING" : Resources are being allocated for the instance.
  /// - "REPAIRING" : The instance is in repair.
  /// - "RUNNING" : The instance is running.
  /// - "STAGING" : All required resources have been allocated and the instance
  /// is being started.
  /// - "STOPPED" : The instance has stopped successfully.
  /// - "STOPPING" : The instance is currently stopping (either being deleted or
  /// killed).
  /// - "SUSPENDED" : The instance has suspended.
  /// - "SUSPENDING" : The instance is suspending.
  /// - "TERMINATED" : The instance has stopped (either by explicit action or
  /// underlying failure).
  core.String? status;

  InstanceWithNamedPorts({
    this.instance,
    this.namedPorts,
    this.status,
  });

  InstanceWithNamedPorts.fromJson(core.Map _json)
      : this(
          instance: _json.containsKey('instance')
              ? _json['instance'] as core.String
              : null,
          namedPorts: _json.containsKey('namedPorts')
              ? (_json['namedPorts'] as core.List)
                  .map<NamedPort>((value) => NamedPort.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
        if (status != null) 'status': status!,
      };
}

class InstancesAddResourcePoliciesRequest {
  /// Resource policies to be added to this instance.
  core.List<core.String>? resourcePolicies;

  InstancesAddResourcePoliciesRequest({
    this.resourcePolicies,
  });

  InstancesAddResourcePoliciesRequest.fromJson(core.Map _json)
      : this(
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class InstancesGetEffectiveFirewallsResponse {
  /// Effective firewalls from firewall policies.
  core.List<InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy>?
      firewallPolicys;

  /// Effective firewalls on the instance.
  core.List<Firewall>? firewalls;

  InstancesGetEffectiveFirewallsResponse({
    this.firewallPolicys,
    this.firewalls,
  });

  InstancesGetEffectiveFirewallsResponse.fromJson(core.Map _json)
      : this(
          firewallPolicys: _json.containsKey('firewallPolicys')
              ? (_json['firewallPolicys'] as core.List)
                  .map<InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy>(
                      (value) =>
                          InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          firewalls: _json.containsKey('firewalls')
              ? (_json['firewalls'] as core.List)
                  .map<Firewall>((value) => Firewall.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (firewallPolicys != null)
          'firewallPolicys':
              firewallPolicys!.map((value) => value.toJson()).toList(),
        if (firewalls != null)
          'firewalls': firewalls!.map((value) => value.toJson()).toList(),
      };
}

class InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
  /// Deprecated, please use short name instead.
  ///
  /// The display name of the firewall policy.
  ///
  /// Output only.
  core.String? displayName;

  /// The name of the firewall policy.
  ///
  /// Output only.
  core.String? name;

  /// The rules that apply to the network.
  core.List<FirewallPolicyRule>? rules;

  /// The short name of the firewall policy.
  ///
  /// Output only.
  core.String? shortName;

  /// The type of the firewall policy.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HIERARCHY"
  /// - "UNSPECIFIED"
  core.String? type;

  InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy({
    this.displayName,
    this.name,
    this.rules,
    this.shortName,
    this.type,
  });

  InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy.fromJson(
      core.Map _json)
      : this(
          displayName: _json.containsKey('displayName')
              ? _json['displayName'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          rules: _json.containsKey('rules')
              ? (_json['rules'] as core.List)
                  .map<FirewallPolicyRule>((value) =>
                      FirewallPolicyRule.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          shortName: _json.containsKey('shortName')
              ? _json['shortName'] as core.String
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
        if (name != null) 'name': name!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (shortName != null) 'shortName': shortName!,
        if (type != null) 'type': type!,
      };
}

class InstancesRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this instance.
  core.List<core.String>? resourcePolicies;

  InstancesRemoveResourcePoliciesRequest({
    this.resourcePolicies,
  });

  InstancesRemoveResourcePoliciesRequest.fromJson(core.Map _json)
      : this(
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class InstancesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstancesScopedListWarningData({
    this.key,
    this.value,
  });

  InstancesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of instances when the list is
/// empty.
///
/// Output only.
class InstancesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstancesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstancesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  InstancesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InstancesScopedListWarningData>((value) =>
                      InstancesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstancesScopedList {
  /// A list of instances contained in this scope.
  ///
  /// Output only.
  core.List<Instance>? instances;

  /// Informational warning which replaces the list of instances when the list
  /// is empty.
  ///
  /// Output only.
  InstancesScopedListWarning? warning;

  InstancesScopedList({
    this.instances,
    this.warning,
  });

  InstancesScopedList.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<Instance>((value) => Instance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? InstancesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstancesSetLabelsRequest {
  /// Fingerprint of the previous set of labels for this resource, used to
  /// prevent conflicts.
  ///
  /// Provide the latest fingerprint value when making a request to add or
  /// change labels.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  core.Map<core.String, core.String>? labels;

  InstancesSetLabelsRequest({
    this.labelFingerprint,
    this.labels,
  });

  InstancesSetLabelsRequest.fromJson(core.Map _json)
      : this(
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
      };
}

class InstancesSetMachineResourcesRequest {
  /// A list of the type and count of accelerator cards attached to the
  /// instance.
  core.List<AcceleratorConfig>? guestAccelerators;

  InstancesSetMachineResourcesRequest({
    this.guestAccelerators,
  });

  InstancesSetMachineResourcesRequest.fromJson(core.Map _json)
      : this(
          guestAccelerators: _json.containsKey('guestAccelerators')
              ? (_json['guestAccelerators'] as core.List)
                  .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (guestAccelerators != null)
          'guestAccelerators':
              guestAccelerators!.map((value) => value.toJson()).toList(),
      };
}

class InstancesSetMachineTypeRequest {
  /// Full or partial URL of the machine type resource.
  ///
  /// See Machine Types for a full list of machine types. For example:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  core.String? machineType;

  InstancesSetMachineTypeRequest({
    this.machineType,
  });

  InstancesSetMachineTypeRequest.fromJson(core.Map _json)
      : this(
          machineType: _json.containsKey('machineType')
              ? _json['machineType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (machineType != null) 'machineType': machineType!,
      };
}

class InstancesSetMinCpuPlatformRequest {
  /// Minimum cpu/platform this instance should be started at.
  core.String? minCpuPlatform;

  InstancesSetMinCpuPlatformRequest({
    this.minCpuPlatform,
  });

  InstancesSetMinCpuPlatformRequest.fromJson(core.Map _json)
      : this(
          minCpuPlatform: _json.containsKey('minCpuPlatform')
              ? _json['minCpuPlatform'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
      };
}

class InstancesSetServiceAccountRequest {
  /// Email address of the service account.
  core.String? email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String>? scopes;

  InstancesSetServiceAccountRequest({
    this.email,
    this.scopes,
  });

  InstancesSetServiceAccountRequest.fromJson(core.Map _json)
      : this(
          email:
              _json.containsKey('email') ? _json['email'] as core.String : null,
          scopes: _json.containsKey('scopes')
              ? (_json['scopes'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (email != null) 'email': email!,
        if (scopes != null) 'scopes': scopes!,
      };
}

class InstancesStartWithEncryptionKeyRequest {
  /// Array of disks associated with this instance that are protected with a
  /// customer-supplied encryption key.
  ///
  /// In order to start the instance, the disk url and its corresponding key
  /// must be provided. If the disk is not protected with a customer-supplied
  /// encryption key it should not be specified.
  core.List<CustomerEncryptionKeyProtectedDisk>? disks;

  InstancesStartWithEncryptionKeyRequest({
    this.disks,
  });

  InstancesStartWithEncryptionKeyRequest.fromJson(core.Map _json)
      : this(
          disks: _json.containsKey('disks')
              ? (_json['disks'] as core.List)
                  .map<CustomerEncryptionKeyProtectedDisk>((value) =>
                      CustomerEncryptionKeyProtectedDisk.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
      };
}

/// HttpRouteRuleMatch criteria for field values that must stay within the
/// specified integer range.
class Int64RangeMatch {
  /// The end of the range (exclusive) in signed long integer format.
  core.String? rangeEnd;

  /// The start of the range (inclusive) in signed long integer format.
  core.String? rangeStart;

  Int64RangeMatch({
    this.rangeEnd,
    this.rangeStart,
  });

  Int64RangeMatch.fromJson(core.Map _json)
      : this(
          rangeEnd: _json.containsKey('rangeEnd')
              ? _json['rangeEnd'] as core.String
              : null,
          rangeStart: _json.containsKey('rangeStart')
              ? _json['rangeStart'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (rangeEnd != null) 'rangeEnd': rangeEnd!,
        if (rangeStart != null) 'rangeStart': rangeStart!,
      };
}

/// Represents an Interconnect resource.
///
/// An Interconnect resource is a dedicated connection between the GCP network
/// and your on-premises network. For more information, read the Dedicated
/// Interconnect Overview.
class Interconnect {
  /// Administrative status of the interconnect.
  ///
  /// When this is set to true, the Interconnect is functional and can carry
  /// traffic. When set to false, no packets can be carried over the
  /// interconnect and no BGP routes are exchanged over it. By default, the
  /// status is set to true.
  core.bool? adminEnabled;

  /// A list of CircuitInfo objects, that describe the individual circuits in
  /// this LAG.
  ///
  /// Output only.
  core.List<InterconnectCircuitInfo>? circuitInfos;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Customer name, to put in the Letter of Authorization as the party
  /// authorized to request a crossconnect.
  core.String? customerName;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A list of outages expected for this Interconnect.
  ///
  /// Output only.
  core.List<InterconnectOutageNotification>? expectedOutages;

  /// IP address configured on the Google side of the Interconnect link.
  ///
  /// This can be used only for ping tests.
  ///
  /// Output only.
  core.String? googleIpAddress;

  /// Google reference ID to be used when raising support tickets with Google or
  /// otherwise to debug backend connectivity issues.
  ///
  /// Output only.
  core.String? googleReferenceId;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of the URLs of all InterconnectAttachments configured to use this
  /// Interconnect.
  ///
  /// Output only.
  core.List<core.String>? interconnectAttachments;

  /// Type of interconnect, which can take one of the following values: -
  /// PARTNER: A partner-managed interconnection shared between customers though
  /// a partner.
  ///
  /// - DEDICATED: A dedicated physical interconnection with the customer. Note
  /// that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
  /// Possible string values are:
  /// - "DEDICATED" : A dedicated physical interconnection with the customer.
  /// - "IT_PRIVATE" : \[Deprecated\] A private, physical interconnection with
  /// the customer.
  /// - "PARTNER" : A partner-managed interconnection shared between customers
  /// via partner.
  core.String? interconnectType;

  /// Type of the resource.
  ///
  /// Always compute#interconnect for interconnects.
  ///
  /// Output only.
  core.String? kind;

  /// Type of link requested, which can take one of the following values: -
  /// LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics -
  /// LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics.
  ///
  /// Note that this field indicates the speed of each of the links in the
  /// bundle, not the speed of the entire bundle.
  /// Possible string values are:
  /// - "LINK_TYPE_ETHERNET_100G_LR" : 100G Ethernet, LR Optics.
  /// - "LINK_TYPE_ETHERNET_10G_LR" : 10G Ethernet, LR Optics. \[(rate_bps) =
  /// 10000000000\];
  core.String? linkType;

  /// URL of the InterconnectLocation object that represents where this
  /// connection is to be provisioned.
  core.String? location;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Email address to contact the customer NOC for operations and maintenance
  /// notifications regarding this Interconnect.
  ///
  /// If specified, this will be used for notifications in addition to all other
  /// forms described, such as Stackdriver logs alerting and Cloud
  /// Notifications.
  core.String? nocContactEmail;

  /// The current status of this Interconnect's functionality, which can take
  /// one of the following values: - OS_ACTIVE: A valid Interconnect, which is
  /// turned up and is ready to use.
  ///
  /// Attachments may be provisioned on this Interconnect. - OS_UNPROVISIONED:
  /// An Interconnect that has not completed turnup. No attachments may be
  /// provisioned on this Interconnect. - OS_UNDER_MAINTENANCE: An Interconnect
  /// that is undergoing internal maintenance. No attachments may be provisioned
  /// or updated on this Interconnect.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "OS_ACTIVE" : The interconnect is valid, turned up, and ready to use.
  /// Attachments may be provisioned on this interconnect.
  /// - "OS_UNPROVISIONED" : The interconnect has not completed turnup. No
  /// attachments may be provisioned on this interconnect.
  core.String? operationalStatus;

  /// IP address configured on the customer side of the Interconnect link.
  ///
  /// The customer should configure this IP address during turnup when prompted
  /// by Google NOC. This can be used only for ping tests.
  ///
  /// Output only.
  core.String? peerIpAddress;

  /// Number of links actually provisioned in this interconnect.
  ///
  /// Output only.
  core.int? provisionedLinkCount;

  /// Target number of physical links in the link bundle, as requested by the
  /// customer.
  core.int? requestedLinkCount;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The current state of Interconnect functionality, which can take one of the
  /// following values: - ACTIVE: The Interconnect is valid, turned up and ready
  /// to use.
  ///
  /// Attachments may be provisioned on this Interconnect. - UNPROVISIONED: The
  /// Interconnect has not completed turnup. No attachments may be provisioned
  /// on this Interconnect. - UNDER_MAINTENANCE: The Interconnect is undergoing
  /// internal maintenance. No attachments may be provisioned or updated on this
  /// Interconnect.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE" : The interconnect is valid, turned up, and ready to use.
  /// Attachments may be provisioned on this interconnect.
  /// - "UNPROVISIONED" : The interconnect has not completed turnup. No
  /// attachments may be provisioned on this interconnect.
  core.String? state;

  Interconnect({
    this.adminEnabled,
    this.circuitInfos,
    this.creationTimestamp,
    this.customerName,
    this.description,
    this.expectedOutages,
    this.googleIpAddress,
    this.googleReferenceId,
    this.id,
    this.interconnectAttachments,
    this.interconnectType,
    this.kind,
    this.linkType,
    this.location,
    this.name,
    this.nocContactEmail,
    this.operationalStatus,
    this.peerIpAddress,
    this.provisionedLinkCount,
    this.requestedLinkCount,
    this.selfLink,
    this.state,
  });

  Interconnect.fromJson(core.Map _json)
      : this(
          adminEnabled: _json.containsKey('adminEnabled')
              ? _json['adminEnabled'] as core.bool
              : null,
          circuitInfos: _json.containsKey('circuitInfos')
              ? (_json['circuitInfos'] as core.List)
                  .map<InterconnectCircuitInfo>((value) =>
                      InterconnectCircuitInfo.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          customerName: _json.containsKey('customerName')
              ? _json['customerName'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          expectedOutages: _json.containsKey('expectedOutages')
              ? (_json['expectedOutages'] as core.List)
                  .map<InterconnectOutageNotification>((value) =>
                      InterconnectOutageNotification.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          googleIpAddress: _json.containsKey('googleIpAddress')
              ? _json['googleIpAddress'] as core.String
              : null,
          googleReferenceId: _json.containsKey('googleReferenceId')
              ? _json['googleReferenceId'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          interconnectAttachments: _json.containsKey('interconnectAttachments')
              ? (_json['interconnectAttachments'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          interconnectType: _json.containsKey('interconnectType')
              ? _json['interconnectType'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          linkType: _json.containsKey('linkType')
              ? _json['linkType'] as core.String
              : null,
          location: _json.containsKey('location')
              ? _json['location'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          nocContactEmail: _json.containsKey('nocContactEmail')
              ? _json['nocContactEmail'] as core.String
              : null,
          operationalStatus: _json.containsKey('operationalStatus')
              ? _json['operationalStatus'] as core.String
              : null,
          peerIpAddress: _json.containsKey('peerIpAddress')
              ? _json['peerIpAddress'] as core.String
              : null,
          provisionedLinkCount: _json.containsKey('provisionedLinkCount')
              ? _json['provisionedLinkCount'] as core.int
              : null,
          requestedLinkCount: _json.containsKey('requestedLinkCount')
              ? _json['requestedLinkCount'] as core.int
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (adminEnabled != null) 'adminEnabled': adminEnabled!,
        if (circuitInfos != null)
          'circuitInfos': circuitInfos!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customerName != null) 'customerName': customerName!,
        if (description != null) 'description': description!,
        if (expectedOutages != null)
          'expectedOutages':
              expectedOutages!.map((value) => value.toJson()).toList(),
        if (googleIpAddress != null) 'googleIpAddress': googleIpAddress!,
        if (googleReferenceId != null) 'googleReferenceId': googleReferenceId!,
        if (id != null) 'id': id!,
        if (interconnectAttachments != null)
          'interconnectAttachments': interconnectAttachments!,
        if (interconnectType != null) 'interconnectType': interconnectType!,
        if (kind != null) 'kind': kind!,
        if (linkType != null) 'linkType': linkType!,
        if (location != null) 'location': location!,
        if (name != null) 'name': name!,
        if (nocContactEmail != null) 'nocContactEmail': nocContactEmail!,
        if (operationalStatus != null) 'operationalStatus': operationalStatus!,
        if (peerIpAddress != null) 'peerIpAddress': peerIpAddress!,
        if (provisionedLinkCount != null)
          'provisionedLinkCount': provisionedLinkCount!,
        if (requestedLinkCount != null)
          'requestedLinkCount': requestedLinkCount!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (state != null) 'state': state!,
      };
}

/// Represents an Interconnect Attachment (VLAN) resource.
///
/// You can use Interconnect attachments (VLANS) to connect your Virtual Private
/// Cloud networks to your on-premises networks through an Interconnect. For
/// more information, read Creating VLAN Attachments.
class InterconnectAttachment {
  /// Determines whether this Attachment will carry packets.
  ///
  /// Not present for PARTNER_PROVIDER.
  core.bool? adminEnabled;

  /// Provisioned bandwidth capacity for the interconnect attachment.
  ///
  /// For attachments of type DEDICATED, the user can set the bandwidth. For
  /// attachments of type PARTNER, the Google Partner that is operating the
  /// interconnect must set the bandwidth. Output only for PARTNER type, mutable
  /// for PARTNER_PROVIDER and DEDICATED, and can take one of the following
  /// values: - BPS_50M: 50 Mbit/s - BPS_100M: 100 Mbit/s - BPS_200M: 200 Mbit/s
  /// - BPS_300M: 300 Mbit/s - BPS_400M: 400 Mbit/s - BPS_500M: 500 Mbit/s -
  /// BPS_1G: 1 Gbit/s - BPS_2G: 2 Gbit/s - BPS_5G: 5 Gbit/s - BPS_10G: 10
  /// Gbit/s - BPS_20G: 20 Gbit/s - BPS_50G: 50 Gbit/s
  /// Possible string values are:
  /// - "BPS_100M" : 100 Mbit/s
  /// - "BPS_10G" : 10 Gbit/s
  /// - "BPS_1G" : 1 Gbit/s
  /// - "BPS_200M" : 200 Mbit/s
  /// - "BPS_20G" : 20 Gbit/s
  /// - "BPS_2G" : 2 Gbit/s
  /// - "BPS_300M" : 300 Mbit/s
  /// - "BPS_400M" : 400 Mbit/s
  /// - "BPS_500M" : 500 Mbit/s
  /// - "BPS_50G" : 50 Gbit/s
  /// - "BPS_50M" : 50 Mbit/s
  /// - "BPS_5G" : 5 Gbit/s
  core.String? bandwidth;

  /// Up to 16 candidate prefixes that can be used to restrict the allocation of
  /// cloudRouterIpAddress and customerRouterIpAddress for this attachment.
  ///
  /// All prefixes must be within link-local address space (169.254.0.0/16) and
  /// must be /29 or shorter (/28, /27, etc). Google will attempt to select an
  /// unused /29 from the supplied candidate prefix(es). The request will fail
  /// if all possible /29s are in use on Google's edge. If not supplied, Google
  /// will randomly select an unused /29 from all of link-local space.
  core.List<core.String>? candidateSubnets;

  /// IPv4 address + prefix length to be configured on Cloud Router Interface
  /// for this interconnect attachment.
  ///
  /// Output only.
  core.String? cloudRouterIpAddress;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// IPv4 address + prefix length to be configured on the customer router
  /// subinterface for this interconnect attachment.
  ///
  /// Output only.
  core.String? customerRouterIpAddress;

  /// Dataplane version for this InterconnectAttachment.
  ///
  /// Output only.
  core.int? dataplaneVersion;

  /// An optional description of this resource.
  core.String? description;

  /// Desired availability domain for the attachment.
  ///
  /// Only available for type PARTNER, at creation time, and can take one of the
  /// following values: - AVAILABILITY_DOMAIN_ANY - AVAILABILITY_DOMAIN_1 -
  /// AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure
  /// a pair of attachments, one per availability domain. The selected
  /// availability domain will be provided to the Partner via the pairing key,
  /// so that the provisioned circuit will lie in the specified domain. If not
  /// specified, the value will default to AVAILABILITY_DOMAIN_ANY.
  /// Possible string values are:
  /// - "AVAILABILITY_DOMAIN_1"
  /// - "AVAILABILITY_DOMAIN_2"
  /// - "AVAILABILITY_DOMAIN_ANY"
  core.String? edgeAvailabilityDomain;

  /// Indicates the user-supplied encryption option of this VLAN attachment
  /// (interconnectAttachment).
  ///
  /// Can only be specified at attachment creation for PARTNER or DEDICATED
  /// attachments. Possible values are: - NONE - This is the default value,
  /// which means that the VLAN attachment carries unencrypted traffic. VMs are
  /// able to send traffic to, or receive traffic from, such a VLAN attachment.
  /// - IPSEC - The VLAN attachment carries only encrypted traffic that is
  /// encrypted by an IPsec device, such as an HA VPN gateway or third-party
  /// IPsec VPN. VMs cannot directly send traffic to, or receive traffic from,
  /// such a VLAN attachment. To use *IPsec-encrypted Cloud Interconnect*, the
  /// VLAN attachment must be created with this option. Not currently available
  /// publicly.
  /// Possible string values are:
  /// - "IPSEC" : The interconnect attachment will carry only encrypted traffic
  /// that is encrypted by an IPsec device such as HA VPN gateway; VMs cannot
  /// directly send traffic to or receive traffic from such an interconnect
  /// attachment. To use IPsec-encrypted Cloud Interconnect, the interconnect
  /// attachment must be created with this option.
  /// - "NONE" : This is the default value, which means the Interconnect
  /// Attachment will carry unencrypted traffic. VMs will be able to send
  /// traffic to or receive traffic from such interconnect attachment.
  core.String? encryption;

  /// Google reference ID, to be used when raising support tickets with Google
  /// or otherwise to debug backend connectivity issues.
  ///
  /// \[Deprecated\] This field is not used.
  ///
  /// Output only.
  core.String? googleReferenceId;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// URL of the underlying Interconnect object that this attachment's traffic
  /// will traverse through.
  core.String? interconnect;

  /// A list of URLs of addresses that have been reserved for the VLAN
  /// attachment.
  ///
  /// Used only for the VLAN attachment that has the encryption option as IPSEC.
  /// The addresses must be regional internal IP address ranges. When creating
  /// an HA VPN gateway over the VLAN attachment, if the attachment is
  /// configured to use a regional internal IP address, then the VPN gateway's
  /// IP address is allocated from the IP address range specified here. For
  /// example, if the HA VPN gateway's interface 0 is paired to this VLAN
  /// attachment, then a regional internal IP address for the VPN gateway
  /// interface 0 will be allocated from the IP address specified for this VLAN
  /// attachment. If this field is not specified when creating the VLAN
  /// attachment, then later on when creating an HA VPN gateway on this VLAN
  /// attachment, the HA VPN gateway's IP address is allocated from the regional
  /// external IP address pool. Not currently available publicly.
  core.List<core.String>? ipsecInternalAddresses;

  /// Type of the resource.
  ///
  /// Always compute#interconnectAttachment for interconnect attachments.
  ///
  /// Output only.
  core.String? kind;

  /// Maximum Transmission Unit (MTU), in bytes, of packets passing through this
  /// interconnect attachment.
  ///
  /// Only 1440 and 1500 are allowed. If not specified, the value will default
  /// to 1440.
  core.int? mtu;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The current status of whether or not this interconnect attachment is
  /// functional, which can take one of the following values: - OS_ACTIVE: The
  /// attachment has been turned up and is ready to use.
  ///
  /// - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup
  /// is not complete.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "OS_ACTIVE" : Indicates that attachment has been turned up and is ready
  /// to use.
  /// - "OS_UNPROVISIONED" : Indicates that attachment is not ready to use yet,
  /// because turnup is not complete.
  core.String? operationalStatus;

  /// \[Output only for type PARTNER.
  ///
  /// Input only for PARTNER_PROVIDER. Not present for DEDICATED\]. The opaque
  /// identifier of an PARTNER attachment used to initiate provisioning with a
  /// selected partner. Of the form "XXXXX/region/domain"
  core.String? pairingKey;

  /// Optional BGP ASN for the router supplied by a Layer 3 Partner if they
  /// configured BGP on behalf of the customer.
  ///
  /// Output only for PARTNER type, input only for PARTNER_PROVIDER, not
  /// available for DEDICATED.
  core.String? partnerAsn;

  /// Informational metadata about Partner attachments from Partners to display
  /// to customers.
  ///
  /// Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not
  /// available for DEDICATED.
  InterconnectAttachmentPartnerMetadata? partnerMetadata;

  /// Information specific to an InterconnectAttachment.
  ///
  /// This property is populated if the interconnect that this is attached to is
  /// of type DEDICATED.
  ///
  /// Output only.
  InterconnectAttachmentPrivateInfo? privateInterconnectInfo;

  /// URL of the region where the regional interconnect attachment resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// URL of the Cloud Router to be used for dynamic routing.
  ///
  /// This router must be in the same region as this InterconnectAttachment. The
  /// InterconnectAttachment will automatically connect the Interconnect to the
  /// network & region within which the Cloud Router is configured.
  core.String? router;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The current state of this attachment's functionality.
  ///
  /// Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE,
  /// PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values
  /// PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used
  /// for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state
  /// can take one of the following values: - ACTIVE: The attachment has been
  /// turned up and is ready to use. - UNPROVISIONED: The attachment is not
  /// ready to use yet, because turnup is not complete. - PENDING_PARTNER: A
  /// newly-created PARTNER attachment that has not yet been configured on the
  /// Partner side. - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the
  /// process of provisioning after a PARTNER_PROVIDER attachment was created
  /// that references it. - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER
  /// attachment that is waiting for a customer to activate it. - DEFUNCT: The
  /// attachment was deleted externally and is no longer functional. This could
  /// be because the associated Interconnect was removed, or because the other
  /// side of a Partner attachment was deleted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE" : Indicates that attachment has been turned up and is ready to
  /// use.
  /// - "DEFUNCT" : The attachment was deleted externally and is no longer
  /// functional. This could be because the associated Interconnect was wiped
  /// out, or because the other side of a Partner attachment was deleted.
  /// - "PARTNER_REQUEST_RECEIVED" : A PARTNER attachment is in the process of
  /// provisioning after a PARTNER_PROVIDER attachment was created that
  /// references it.
  /// - "PENDING_CUSTOMER" : PARTNER or PARTNER_PROVIDER attachment that is
  /// waiting for the customer to activate.
  /// - "PENDING_PARTNER" : A newly created PARTNER attachment that has not yet
  /// been configured on the Partner side.
  /// - "STATE_UNSPECIFIED"
  /// - "UNPROVISIONED" : Indicates that attachment is not ready to use yet,
  /// because turnup is not complete.
  core.String? state;

  /// The type of interconnect attachment this is, which can take one of the
  /// following values: - DEDICATED: an attachment to a Dedicated Interconnect.
  ///
  /// - PARTNER: an attachment to a Partner Interconnect, created by the
  /// customer. - PARTNER_PROVIDER: an attachment to a Partner Interconnect,
  /// created by the partner.
  /// Possible string values are:
  /// - "DEDICATED" : Attachment to a dedicated interconnect.
  /// - "PARTNER" : Attachment to a partner interconnect, created by the
  /// customer.
  /// - "PARTNER_PROVIDER" : Attachment to a partner interconnect, created by
  /// the partner.
  core.String? type;

  /// The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094.
  ///
  /// Only specified at creation time.
  core.int? vlanTag8021q;

  InterconnectAttachment({
    this.adminEnabled,
    this.bandwidth,
    this.candidateSubnets,
    this.cloudRouterIpAddress,
    this.creationTimestamp,
    this.customerRouterIpAddress,
    this.dataplaneVersion,
    this.description,
    this.edgeAvailabilityDomain,
    this.encryption,
    this.googleReferenceId,
    this.id,
    this.interconnect,
    this.ipsecInternalAddresses,
    this.kind,
    this.mtu,
    this.name,
    this.operationalStatus,
    this.pairingKey,
    this.partnerAsn,
    this.partnerMetadata,
    this.privateInterconnectInfo,
    this.region,
    this.router,
    this.selfLink,
    this.state,
    this.type,
    this.vlanTag8021q,
  });

  InterconnectAttachment.fromJson(core.Map _json)
      : this(
          adminEnabled: _json.containsKey('adminEnabled')
              ? _json['adminEnabled'] as core.bool
              : null,
          bandwidth: _json.containsKey('bandwidth')
              ? _json['bandwidth'] as core.String
              : null,
          candidateSubnets: _json.containsKey('candidateSubnets')
              ? (_json['candidateSubnets'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          cloudRouterIpAddress: _json.containsKey('cloudRouterIpAddress')
              ? _json['cloudRouterIpAddress'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          customerRouterIpAddress: _json.containsKey('customerRouterIpAddress')
              ? _json['customerRouterIpAddress'] as core.String
              : null,
          dataplaneVersion: _json.containsKey('dataplaneVersion')
              ? _json['dataplaneVersion'] as core.int
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          edgeAvailabilityDomain: _json.containsKey('edgeAvailabilityDomain')
              ? _json['edgeAvailabilityDomain'] as core.String
              : null,
          encryption: _json.containsKey('encryption')
              ? _json['encryption'] as core.String
              : null,
          googleReferenceId: _json.containsKey('googleReferenceId')
              ? _json['googleReferenceId'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          interconnect: _json.containsKey('interconnect')
              ? _json['interconnect'] as core.String
              : null,
          ipsecInternalAddresses: _json.containsKey('ipsecInternalAddresses')
              ? (_json['ipsecInternalAddresses'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          mtu: _json.containsKey('mtu') ? _json['mtu'] as core.int : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          operationalStatus: _json.containsKey('operationalStatus')
              ? _json['operationalStatus'] as core.String
              : null,
          pairingKey: _json.containsKey('pairingKey')
              ? _json['pairingKey'] as core.String
              : null,
          partnerAsn: _json.containsKey('partnerAsn')
              ? _json['partnerAsn'] as core.String
              : null,
          partnerMetadata: _json.containsKey('partnerMetadata')
              ? InterconnectAttachmentPartnerMetadata.fromJson(
                  _json['partnerMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          privateInterconnectInfo: _json.containsKey('privateInterconnectInfo')
              ? InterconnectAttachmentPrivateInfo.fromJson(
                  _json['privateInterconnectInfo']
                      as core.Map<core.String, core.dynamic>)
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          router: _json.containsKey('router')
              ? _json['router'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
          vlanTag8021q: _json.containsKey('vlanTag8021q')
              ? _json['vlanTag8021q'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (adminEnabled != null) 'adminEnabled': adminEnabled!,
        if (bandwidth != null) 'bandwidth': bandwidth!,
        if (candidateSubnets != null) 'candidateSubnets': candidateSubnets!,
        if (cloudRouterIpAddress != null)
          'cloudRouterIpAddress': cloudRouterIpAddress!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customerRouterIpAddress != null)
          'customerRouterIpAddress': customerRouterIpAddress!,
        if (dataplaneVersion != null) 'dataplaneVersion': dataplaneVersion!,
        if (description != null) 'description': description!,
        if (edgeAvailabilityDomain != null)
          'edgeAvailabilityDomain': edgeAvailabilityDomain!,
        if (encryption != null) 'encryption': encryption!,
        if (googleReferenceId != null) 'googleReferenceId': googleReferenceId!,
        if (id != null) 'id': id!,
        if (interconnect != null) 'interconnect': interconnect!,
        if (ipsecInternalAddresses != null)
          'ipsecInternalAddresses': ipsecInternalAddresses!,
        if (kind != null) 'kind': kind!,
        if (mtu != null) 'mtu': mtu!,
        if (name != null) 'name': name!,
        if (operationalStatus != null) 'operationalStatus': operationalStatus!,
        if (pairingKey != null) 'pairingKey': pairingKey!,
        if (partnerAsn != null) 'partnerAsn': partnerAsn!,
        if (partnerMetadata != null)
          'partnerMetadata': partnerMetadata!.toJson(),
        if (privateInterconnectInfo != null)
          'privateInterconnectInfo': privateInterconnectInfo!.toJson(),
        if (region != null) 'region': region!,
        if (router != null) 'router': router!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (state != null) 'state': state!,
        if (type != null) 'type': type!,
        if (vlanTag8021q != null) 'vlanTag8021q': vlanTag8021q!,
      };
}

class InterconnectAttachmentAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectAttachmentAggregatedListWarningData({
    this.key,
    this.value,
  });

  InterconnectAttachmentAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InterconnectAttachmentAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectAttachmentAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectAttachmentAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  InterconnectAttachmentAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InterconnectAttachmentAggregatedListWarningData>(
                      (value) => InterconnectAttachmentAggregatedListWarningData
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InterconnectAttachmentAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InterconnectAttachmentsScopedList resources.
  core.Map<core.String, InterconnectAttachmentsScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#interconnectAttachmentAggregatedList for aggregated lists
  /// of interconnect attachments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  InterconnectAttachmentAggregatedListWarning? warning;

  InterconnectAttachmentAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  InterconnectAttachmentAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    InterconnectAttachmentsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? InterconnectAttachmentAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InterconnectAttachmentListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectAttachmentListWarningData({
    this.key,
    this.value,
  });

  InterconnectAttachmentListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InterconnectAttachmentListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectAttachmentListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectAttachmentListWarning({
    this.code,
    this.data,
    this.message,
  });

  InterconnectAttachmentListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InterconnectAttachmentListWarningData>((value) =>
                      InterconnectAttachmentListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Response to the list request, and contains a list of interconnect
/// attachments.
class InterconnectAttachmentList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InterconnectAttachment resources.
  core.List<InterconnectAttachment>? items;

  /// Type of resource.
  ///
  /// Always compute#interconnectAttachmentList for lists of interconnect
  /// attachments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InterconnectAttachmentListWarning? warning;

  InterconnectAttachmentList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InterconnectAttachmentList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InterconnectAttachment>((value) =>
                      InterconnectAttachment.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InterconnectAttachmentListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Informational metadata about Partner attachments from Partners to display to
/// customers.
///
/// These fields are propagated from PARTNER_PROVIDER attachments to their
/// corresponding PARTNER attachments.
class InterconnectAttachmentPartnerMetadata {
  /// Plain text name of the Interconnect this attachment is connected to, as
  /// displayed in the Partner's portal.
  ///
  /// For instance "Chicago 1". This value may be validated to match approved
  /// Partner values.
  core.String? interconnectName;

  /// Plain text name of the Partner providing this attachment.
  ///
  /// This value may be validated to match approved Partner values.
  core.String? partnerName;

  /// URL of the Partner's portal for this Attachment.
  ///
  /// Partners may customise this to be a deep link to the specific resource on
  /// the Partner portal. This value may be validated to match approved Partner
  /// values.
  core.String? portalUrl;

  InterconnectAttachmentPartnerMetadata({
    this.interconnectName,
    this.partnerName,
    this.portalUrl,
  });

  InterconnectAttachmentPartnerMetadata.fromJson(core.Map _json)
      : this(
          interconnectName: _json.containsKey('interconnectName')
              ? _json['interconnectName'] as core.String
              : null,
          partnerName: _json.containsKey('partnerName')
              ? _json['partnerName'] as core.String
              : null,
          portalUrl: _json.containsKey('portalUrl')
              ? _json['portalUrl'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (interconnectName != null) 'interconnectName': interconnectName!,
        if (partnerName != null) 'partnerName': partnerName!,
        if (portalUrl != null) 'portalUrl': portalUrl!,
      };
}

/// Information for an interconnect attachment when this belongs to an
/// interconnect of type DEDICATED.
class InterconnectAttachmentPrivateInfo {
  /// 802.1q encapsulation tag to be used for traffic between Google and the
  /// customer, going to and from this network and region.
  ///
  /// Output only.
  core.int? tag8021q;

  InterconnectAttachmentPrivateInfo({
    this.tag8021q,
  });

  InterconnectAttachmentPrivateInfo.fromJson(core.Map _json)
      : this(
          tag8021q: _json.containsKey('tag8021q')
              ? _json['tag8021q'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tag8021q != null) 'tag8021q': tag8021q!,
      };
}

class InterconnectAttachmentsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectAttachmentsScopedListWarningData({
    this.key,
    this.value,
  });

  InterconnectAttachmentsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class InterconnectAttachmentsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectAttachmentsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectAttachmentsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  InterconnectAttachmentsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InterconnectAttachmentsScopedListWarningData>((value) =>
                      InterconnectAttachmentsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InterconnectAttachmentsScopedList {
  /// A list of interconnect attachments contained in this scope.
  core.List<InterconnectAttachment>? interconnectAttachments;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  InterconnectAttachmentsScopedListWarning? warning;

  InterconnectAttachmentsScopedList({
    this.interconnectAttachments,
    this.warning,
  });

  InterconnectAttachmentsScopedList.fromJson(core.Map _json)
      : this(
          interconnectAttachments: _json.containsKey('interconnectAttachments')
              ? (_json['interconnectAttachments'] as core.List)
                  .map<InterconnectAttachment>((value) =>
                      InterconnectAttachment.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? InterconnectAttachmentsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (interconnectAttachments != null)
          'interconnectAttachments':
              interconnectAttachments!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Describes a single physical circuit between the Customer and Google.
///
/// CircuitInfo objects are created by Google, so all fields are output only.
class InterconnectCircuitInfo {
  /// Customer-side demarc ID for this circuit.
  core.String? customerDemarcId;

  /// Google-assigned unique ID for this circuit.
  ///
  /// Assigned at circuit turn-up.
  core.String? googleCircuitId;

  /// Google-side demarc ID for this circuit.
  ///
  /// Assigned at circuit turn-up and provided by Google to the customer in the
  /// LOA.
  core.String? googleDemarcId;

  InterconnectCircuitInfo({
    this.customerDemarcId,
    this.googleCircuitId,
    this.googleDemarcId,
  });

  InterconnectCircuitInfo.fromJson(core.Map _json)
      : this(
          customerDemarcId: _json.containsKey('customerDemarcId')
              ? _json['customerDemarcId'] as core.String
              : null,
          googleCircuitId: _json.containsKey('googleCircuitId')
              ? _json['googleCircuitId'] as core.String
              : null,
          googleDemarcId: _json.containsKey('googleDemarcId')
              ? _json['googleDemarcId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (customerDemarcId != null) 'customerDemarcId': customerDemarcId!,
        if (googleCircuitId != null) 'googleCircuitId': googleCircuitId!,
        if (googleDemarcId != null) 'googleDemarcId': googleDemarcId!,
      };
}

/// Diagnostics information about interconnect, contains detailed and current
/// technical information about Google's side of the connection.
class InterconnectDiagnostics {
  /// A list of InterconnectDiagnostics.ARPEntry objects, describing individual
  /// neighbors currently seen by the Google router in the ARP cache for the
  /// Interconnect.
  ///
  /// This will be empty when the Interconnect is not bundled.
  core.List<InterconnectDiagnosticsARPEntry>? arpCaches;

  /// A list of InterconnectDiagnostics.LinkStatus objects, describing the
  /// status for each link on the Interconnect.
  core.List<InterconnectDiagnosticsLinkStatus>? links;

  /// The MAC address of the Interconnect's bundle interface.
  core.String? macAddress;

  InterconnectDiagnostics({
    this.arpCaches,
    this.links,
    this.macAddress,
  });

  InterconnectDiagnostics.fromJson(core.Map _json)
      : this(
          arpCaches: _json.containsKey('arpCaches')
              ? (_json['arpCaches'] as core.List)
                  .map<InterconnectDiagnosticsARPEntry>((value) =>
                      InterconnectDiagnosticsARPEntry.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          links: _json.containsKey('links')
              ? (_json['links'] as core.List)
                  .map<InterconnectDiagnosticsLinkStatus>((value) =>
                      InterconnectDiagnosticsLinkStatus.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          macAddress: _json.containsKey('macAddress')
              ? _json['macAddress'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (arpCaches != null)
          'arpCaches': arpCaches!.map((value) => value.toJson()).toList(),
        if (links != null)
          'links': links!.map((value) => value.toJson()).toList(),
        if (macAddress != null) 'macAddress': macAddress!,
      };
}

/// Describing the ARP neighbor entries seen on this link
class InterconnectDiagnosticsARPEntry {
  /// The IP address of this ARP neighbor.
  core.String? ipAddress;

  /// The MAC address of this ARP neighbor.
  core.String? macAddress;

  InterconnectDiagnosticsARPEntry({
    this.ipAddress,
    this.macAddress,
  });

  InterconnectDiagnosticsARPEntry.fromJson(core.Map _json)
      : this(
          ipAddress: _json.containsKey('ipAddress')
              ? _json['ipAddress'] as core.String
              : null,
          macAddress: _json.containsKey('macAddress')
              ? _json['macAddress'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (macAddress != null) 'macAddress': macAddress!,
      };
}

class InterconnectDiagnosticsLinkLACPStatus {
  /// System ID of the port on Google's side of the LACP exchange.
  core.String? googleSystemId;

  /// System ID of the port on the neighbor's side of the LACP exchange.
  core.String? neighborSystemId;

  /// The state of a LACP link, which can take one of the following values: -
  /// ACTIVE: The link is configured and active within the bundle.
  ///
  /// - DETACHED: The link is not configured within the bundle. This means that
  /// the rest of the object should be empty.
  /// Possible string values are:
  /// - "ACTIVE" : The link is configured and active within the bundle.
  /// - "DETACHED" : The link is not configured within the bundle, this means
  /// the rest of the object should be empty.
  core.String? state;

  InterconnectDiagnosticsLinkLACPStatus({
    this.googleSystemId,
    this.neighborSystemId,
    this.state,
  });

  InterconnectDiagnosticsLinkLACPStatus.fromJson(core.Map _json)
      : this(
          googleSystemId: _json.containsKey('googleSystemId')
              ? _json['googleSystemId'] as core.String
              : null,
          neighborSystemId: _json.containsKey('neighborSystemId')
              ? _json['neighborSystemId'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (googleSystemId != null) 'googleSystemId': googleSystemId!,
        if (neighborSystemId != null) 'neighborSystemId': neighborSystemId!,
        if (state != null) 'state': state!,
      };
}

class InterconnectDiagnosticsLinkOpticalPower {
  /// The status of the current value when compared to the warning and alarm
  /// levels for the receiving or transmitting transceiver.
  ///
  /// Possible states include: - OK: The value has not crossed a warning
  /// threshold. - LOW_WARNING: The value has crossed below the low warning
  /// threshold. - HIGH_WARNING: The value has crossed above the high warning
  /// threshold. - LOW_ALARM: The value has crossed below the low alarm
  /// threshold. - HIGH_ALARM: The value has crossed above the high alarm
  /// threshold.
  /// Possible string values are:
  /// - "HIGH_ALARM" : The value has crossed above the high alarm threshold.
  /// - "HIGH_WARNING" : The value of the current optical power has crossed
  /// above the high warning threshold.
  /// - "LOW_ALARM" : The value of the current optical power has crossed below
  /// the low alarm threshold.
  /// - "LOW_WARNING" : The value of the current optical power has crossed below
  /// the low warning threshold.
  /// - "OK" : The value of the current optical power has not crossed a warning
  /// threshold.
  core.String? state;

  /// Value of the current receiving or transmitting optical power, read in dBm.
  ///
  /// Take a known good optical value, give it a 10% margin and trigger warnings
  /// relative to that value. In general, a -7dBm warning and a -11dBm alarm are
  /// good optical value estimates for most links.
  core.double? value;

  InterconnectDiagnosticsLinkOpticalPower({
    this.state,
    this.value,
  });

  InterconnectDiagnosticsLinkOpticalPower.fromJson(core.Map _json)
      : this(
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
          value: _json.containsKey('value')
              ? (_json['value'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (state != null) 'state': state!,
        if (value != null) 'value': value!,
      };
}

class InterconnectDiagnosticsLinkStatus {
  /// A list of InterconnectDiagnostics.ARPEntry objects, describing the ARP
  /// neighbor entries seen on this link.
  ///
  /// This will be empty if the link is bundled
  core.List<InterconnectDiagnosticsARPEntry>? arpCaches;

  /// The unique ID for this link assigned during turn up by Google.
  core.String? circuitId;

  /// The Demarc address assigned by Google and provided in the LoA.
  core.String? googleDemarc;
  InterconnectDiagnosticsLinkLACPStatus? lacpStatus;

  /// An InterconnectDiagnostics.LinkOpticalPower object, describing the current
  /// value and status of the received light level.
  InterconnectDiagnosticsLinkOpticalPower? receivingOpticalPower;

  /// An InterconnectDiagnostics.LinkOpticalPower object, describing the current
  /// value and status of the transmitted light level.
  InterconnectDiagnosticsLinkOpticalPower? transmittingOpticalPower;

  InterconnectDiagnosticsLinkStatus({
    this.arpCaches,
    this.circuitId,
    this.googleDemarc,
    this.lacpStatus,
    this.receivingOpticalPower,
    this.transmittingOpticalPower,
  });

  InterconnectDiagnosticsLinkStatus.fromJson(core.Map _json)
      : this(
          arpCaches: _json.containsKey('arpCaches')
              ? (_json['arpCaches'] as core.List)
                  .map<InterconnectDiagnosticsARPEntry>((value) =>
                      InterconnectDiagnosticsARPEntry.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          circuitId: _json.containsKey('circuitId')
              ? _json['circuitId'] as core.String
              : null,
          googleDemarc: _json.containsKey('googleDemarc')
              ? _json['googleDemarc'] as core.String
              : null,
          lacpStatus: _json.containsKey('lacpStatus')
              ? InterconnectDiagnosticsLinkLACPStatus.fromJson(
                  _json['lacpStatus'] as core.Map<core.String, core.dynamic>)
              : null,
          receivingOpticalPower: _json.containsKey('receivingOpticalPower')
              ? InterconnectDiagnosticsLinkOpticalPower.fromJson(
                  _json['receivingOpticalPower']
                      as core.Map<core.String, core.dynamic>)
              : null,
          transmittingOpticalPower:
              _json.containsKey('transmittingOpticalPower')
                  ? InterconnectDiagnosticsLinkOpticalPower.fromJson(
                      _json['transmittingOpticalPower']
                          as core.Map<core.String, core.dynamic>)
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (arpCaches != null)
          'arpCaches': arpCaches!.map((value) => value.toJson()).toList(),
        if (circuitId != null) 'circuitId': circuitId!,
        if (googleDemarc != null) 'googleDemarc': googleDemarc!,
        if (lacpStatus != null) 'lacpStatus': lacpStatus!.toJson(),
        if (receivingOpticalPower != null)
          'receivingOpticalPower': receivingOpticalPower!.toJson(),
        if (transmittingOpticalPower != null)
          'transmittingOpticalPower': transmittingOpticalPower!.toJson(),
      };
}

class InterconnectListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectListWarningData({
    this.key,
    this.value,
  });

  InterconnectListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InterconnectListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectListWarning({
    this.code,
    this.data,
    this.message,
  });

  InterconnectListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InterconnectListWarningData>((value) =>
                      InterconnectListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Response to the list request, and contains a list of interconnects.
class InterconnectList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Interconnect resources.
  core.List<Interconnect>? items;

  /// Type of resource.
  ///
  /// Always compute#interconnectList for lists of interconnects.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InterconnectListWarning? warning;

  InterconnectList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InterconnectList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Interconnect>((value) => Interconnect.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InterconnectListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents an Interconnect Attachment (VLAN) Location resource.
///
/// You can use this resource to find location details about an Interconnect
/// attachment (VLAN). For more information about interconnect attachments, read
/// Creating VLAN Attachments.
class InterconnectLocation {
  /// The postal address of the Point of Presence, each line in the address is
  /// separated by a newline character.
  ///
  /// Output only.
  core.String? address;

  /// Availability zone for this InterconnectLocation.
  ///
  /// Within a metropolitan area (metro), maintenance will not be simultaneously
  /// scheduled in more than one availability zone. Example: "zone1" or "zone2".
  ///
  /// Output only.
  core.String? availabilityZone;

  /// Metropolitan area designator that indicates which city an interconnect is
  /// located.
  ///
  /// For example: "Chicago, IL", "Amsterdam, Netherlands".
  ///
  /// Output only.
  core.String? city;

  /// Continent for this location, which can take one of the following values: -
  /// AFRICA - ASIA_PAC - EUROPE - NORTH_AMERICA - SOUTH_AMERICA
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AFRICA"
  /// - "ASIA_PAC"
  /// - "C_AFRICA"
  /// - "C_ASIA_PAC"
  /// - "C_EUROPE"
  /// - "C_NORTH_AMERICA"
  /// - "C_SOUTH_AMERICA"
  /// - "EUROPE"
  /// - "NORTH_AMERICA"
  /// - "SOUTH_AMERICA"
  core.String? continent;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The name of the provider for this facility (e.g., EQUINIX).
  ///
  /// Output only.
  core.String? facilityProvider;

  /// A provider-assigned Identifier for this facility (e.g., Ashburn-DC1).
  ///
  /// Output only.
  core.String? facilityProviderFacilityId;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#interconnectLocation for interconnect locations.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// The peeringdb identifier for this facility (corresponding with a netfac
  /// type in peeringdb).
  ///
  /// Output only.
  core.String? peeringdbFacilityId;

  /// A list of InterconnectLocation.RegionInfo objects, that describe
  /// parameters pertaining to the relation between this InterconnectLocation
  /// and various Google Cloud regions.
  ///
  /// Output only.
  core.List<InterconnectLocationRegionInfo>? regionInfos;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of this InterconnectLocation, which can take one of the
  /// following values: - CLOSED: The InterconnectLocation is closed and is
  /// unavailable for provisioning new Interconnects.
  ///
  /// - AVAILABLE: The InterconnectLocation is available for provisioning new
  /// Interconnects.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AVAILABLE" : The InterconnectLocation is available for provisioning new
  /// Interconnects.
  /// - "CLOSED" : The InterconnectLocation is closed for provisioning new
  /// Interconnects.
  core.String? status;

  InterconnectLocation({
    this.address,
    this.availabilityZone,
    this.city,
    this.continent,
    this.creationTimestamp,
    this.description,
    this.facilityProvider,
    this.facilityProviderFacilityId,
    this.id,
    this.kind,
    this.name,
    this.peeringdbFacilityId,
    this.regionInfos,
    this.selfLink,
    this.status,
  });

  InterconnectLocation.fromJson(core.Map _json)
      : this(
          address: _json.containsKey('address')
              ? _json['address'] as core.String
              : null,
          availabilityZone: _json.containsKey('availabilityZone')
              ? _json['availabilityZone'] as core.String
              : null,
          city: _json.containsKey('city') ? _json['city'] as core.String : null,
          continent: _json.containsKey('continent')
              ? _json['continent'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          facilityProvider: _json.containsKey('facilityProvider')
              ? _json['facilityProvider'] as core.String
              : null,
          facilityProviderFacilityId:
              _json.containsKey('facilityProviderFacilityId')
                  ? _json['facilityProviderFacilityId'] as core.String
                  : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          peeringdbFacilityId: _json.containsKey('peeringdbFacilityId')
              ? _json['peeringdbFacilityId'] as core.String
              : null,
          regionInfos: _json.containsKey('regionInfos')
              ? (_json['regionInfos'] as core.List)
                  .map<InterconnectLocationRegionInfo>((value) =>
                      InterconnectLocationRegionInfo.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (address != null) 'address': address!,
        if (availabilityZone != null) 'availabilityZone': availabilityZone!,
        if (city != null) 'city': city!,
        if (continent != null) 'continent': continent!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (facilityProvider != null) 'facilityProvider': facilityProvider!,
        if (facilityProviderFacilityId != null)
          'facilityProviderFacilityId': facilityProviderFacilityId!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (peeringdbFacilityId != null)
          'peeringdbFacilityId': peeringdbFacilityId!,
        if (regionInfos != null)
          'regionInfos': regionInfos!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
      };
}

class InterconnectLocationListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectLocationListWarningData({
    this.key,
    this.value,
  });

  InterconnectLocationListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InterconnectLocationListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectLocationListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectLocationListWarning({
    this.code,
    this.data,
    this.message,
  });

  InterconnectLocationListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<InterconnectLocationListWarningData>((value) =>
                      InterconnectLocationListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Response to the list request, and contains a list of interconnect locations.
class InterconnectLocationList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InterconnectLocation resources.
  core.List<InterconnectLocation>? items;

  /// Type of resource.
  ///
  /// Always compute#interconnectLocationList for lists of interconnect
  /// locations.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InterconnectLocationListWarning? warning;

  InterconnectLocationList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  InterconnectLocationList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InterconnectLocation>((value) =>
                      InterconnectLocation.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? InterconnectLocationListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Information about any potential InterconnectAttachments between an
/// Interconnect at a specific InterconnectLocation, and a specific Cloud
/// Region.
class InterconnectLocationRegionInfo {
  /// Expected round-trip time in milliseconds, from this InterconnectLocation
  /// to a VM in this region.
  core.String? expectedRttMs;

  /// Identifies the network presence of this location.
  /// Possible string values are:
  /// - "GLOBAL" : This region is not in any common network presence with this
  /// InterconnectLocation.
  /// - "LOCAL_REGION" : This region shares the same regional network presence
  /// as this InterconnectLocation.
  /// - "LP_GLOBAL" : \[Deprecated\] This region is not in any common network
  /// presence with this InterconnectLocation.
  /// - "LP_LOCAL_REGION" : \[Deprecated\] This region shares the same regional
  /// network presence as this InterconnectLocation.
  core.String? locationPresence;

  /// URL for the region of this location.
  core.String? region;

  InterconnectLocationRegionInfo({
    this.expectedRttMs,
    this.locationPresence,
    this.region,
  });

  InterconnectLocationRegionInfo.fromJson(core.Map _json)
      : this(
          expectedRttMs: _json.containsKey('expectedRttMs')
              ? _json['expectedRttMs'] as core.String
              : null,
          locationPresence: _json.containsKey('locationPresence')
              ? _json['locationPresence'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (expectedRttMs != null) 'expectedRttMs': expectedRttMs!,
        if (locationPresence != null) 'locationPresence': locationPresence!,
        if (region != null) 'region': region!,
      };
}

/// Description of a planned outage on this Interconnect.
class InterconnectOutageNotification {
  /// If issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs
  /// that will be affected.
  core.List<core.String>? affectedCircuits;

  /// A description about the purpose of the outage.
  core.String? description;

  /// Scheduled end time for the outage (milliseconds since Unix epoch).
  core.String? endTime;

  /// Form this outage is expected to take, which can take one of the following
  /// values: - OUTAGE: The Interconnect may be completely out of service for
  /// some or all of the specified window.
  ///
  /// - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole
  /// should remain up, but with reduced bandwidth. Note that the versions of
  /// this enum prefixed with "IT_" have been deprecated in favor of the
  /// unprefixed values.
  /// Possible string values are:
  /// - "IT_OUTAGE" : \[Deprecated\] The Interconnect may be completely out of
  /// service for some or all of the specified window.
  /// - "IT_PARTIAL_OUTAGE" : \[Deprecated\] Some circuits comprising the
  /// Interconnect will be out of service during the expected window. The
  /// interconnect as a whole should remain up, albeit with reduced bandwidth.
  /// - "OUTAGE" : The Interconnect may be completely out of service for some or
  /// all of the specified window.
  /// - "PARTIAL_OUTAGE" : Some circuits comprising the Interconnect will be out
  /// of service during the expected window. The interconnect as a whole should
  /// remain up, albeit with reduced bandwidth.
  core.String? issueType;

  /// Unique identifier for this outage notification.
  core.String? name;

  /// The party that generated this notification, which can take the following
  /// value: - GOOGLE: this notification as generated by Google.
  ///
  /// Note that the value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
  /// Possible string values are:
  /// - "GOOGLE" : This notification was generated by Google.
  /// - "NSRC_GOOGLE" : \[Deprecated\] This notification was generated by
  /// Google.
  core.String? source;

  /// Scheduled start time for the outage (milliseconds since Unix epoch).
  core.String? startTime;

  /// State of this notification, which can take one of the following values: -
  /// ACTIVE: This outage notification is active.
  ///
  /// The event could be in the past, present, or future. See start_time and
  /// end_time for scheduling. - CANCELLED: The outage associated with this
  /// notification was cancelled before the outage was due to start. -
  /// COMPLETED: The outage associated with this notification is complete. Note
  /// that the versions of this enum prefixed with "NS_" have been deprecated in
  /// favor of the unprefixed values.
  /// Possible string values are:
  /// - "ACTIVE" : This outage notification is active. The event could be in the
  /// future, present, or past. See start_time and end_time for scheduling.
  /// - "CANCELLED" : The outage associated with this notification was cancelled
  /// before the outage was due to start.
  /// - "COMPLETED" : The outage associated with this notification is complete.
  /// - "NS_ACTIVE" : \[Deprecated\] This outage notification is active. The
  /// event could be in the future, present, or past. See start_time and
  /// end_time for scheduling.
  /// - "NS_CANCELED" : \[Deprecated\] The outage associated with this
  /// notification was canceled before the outage was due to start.
  core.String? state;

  InterconnectOutageNotification({
    this.affectedCircuits,
    this.description,
    this.endTime,
    this.issueType,
    this.name,
    this.source,
    this.startTime,
    this.state,
  });

  InterconnectOutageNotification.fromJson(core.Map _json)
      : this(
          affectedCircuits: _json.containsKey('affectedCircuits')
              ? (_json['affectedCircuits'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          endTime: _json.containsKey('endTime')
              ? _json['endTime'] as core.String
              : null,
          issueType: _json.containsKey('issueType')
              ? _json['issueType'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          source: _json.containsKey('source')
              ? _json['source'] as core.String
              : null,
          startTime: _json.containsKey('startTime')
              ? _json['startTime'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (affectedCircuits != null) 'affectedCircuits': affectedCircuits!,
        if (description != null) 'description': description!,
        if (endTime != null) 'endTime': endTime!,
        if (issueType != null) 'issueType': issueType!,
        if (name != null) 'name': name!,
        if (source != null) 'source': source!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
      };
}

/// Response for the InterconnectsGetDiagnosticsRequest.
class InterconnectsGetDiagnosticsResponse {
  InterconnectDiagnostics? result;

  InterconnectsGetDiagnosticsResponse({
    this.result,
  });

  InterconnectsGetDiagnosticsResponse.fromJson(core.Map _json)
      : this(
          result: _json.containsKey('result')
              ? InterconnectDiagnostics.fromJson(
                  _json['result'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (result != null) 'result': result!.toJson(),
      };
}

/// Represents a License resource.
///
/// A License represents billing and aggregate usage data for public and
/// marketplace images. *Caution* This resource is intended for use only by
/// third-party partners who are creating Cloud Marketplace images.
class License {
  /// This field no longer reflects whether a license charges a usage fee.
  ///
  /// Output only. Deprecated.
  core.bool? chargesUseFee;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#license for licenses.
  ///
  /// Output only.
  core.String? kind;

  /// The unique code used to attach this license to images, snapshots, and
  /// disks.
  ///
  /// Output only.
  core.String? licenseCode;

  /// Name of the resource.
  ///
  /// The name must be 1-63 characters long and comply with RFC1035.
  core.String? name;
  LicenseResourceRequirements? resourceRequirements;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// If false, licenses will not be copied from the source resource when
  /// creating an image from a disk, disk from snapshot, or snapshot from disk.
  core.bool? transferable;

  License({
    this.chargesUseFee,
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.licenseCode,
    this.name,
    this.resourceRequirements,
    this.selfLink,
    this.transferable,
  });

  License.fromJson(core.Map _json)
      : this(
          chargesUseFee: _json.containsKey('chargesUseFee')
              ? _json['chargesUseFee'] as core.bool
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          licenseCode: _json.containsKey('licenseCode')
              ? _json['licenseCode'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          resourceRequirements: _json.containsKey('resourceRequirements')
              ? LicenseResourceRequirements.fromJson(
                  _json['resourceRequirements']
                      as core.Map<core.String, core.dynamic>)
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          transferable: _json.containsKey('transferable')
              ? _json['transferable'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (chargesUseFee != null) 'chargesUseFee': chargesUseFee!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (licenseCode != null) 'licenseCode': licenseCode!,
        if (name != null) 'name': name!,
        if (resourceRequirements != null)
          'resourceRequirements': resourceRequirements!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (transferable != null) 'transferable': transferable!,
      };
}

/// Represents a License Code resource.
///
/// A License Code is a unique identifier used to represent a license resource.
/// *Caution* This resource is intended for use only by third-party partners who
/// are creating Cloud Marketplace images.
class LicenseCode {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Description of this License Code.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#licenseCode for licenses.
  ///
  /// Output only.
  core.String? kind;

  /// URL and description aliases of Licenses with the same License Code.
  ///
  /// Output only.
  core.List<LicenseCodeLicenseAlias>? licenseAlias;

  /// Name of the resource.
  ///
  /// The name is 1-20 characters long and must be a valid 64 bit integer.
  ///
  /// Output only.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Current state of this License Code.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DISABLED" : Machines are not allowed to attach boot disks with this
  /// License Code. Requests to create new resources with this license will be
  /// rejected.
  /// - "ENABLED" : Use is allowed for anyone with USE_READ_ONLY access to this
  /// License Code.
  /// - "RESTRICTED" : Use of this license is limited to a project whitelist.
  /// - "STATE_UNSPECIFIED"
  /// - "TERMINATED" : Reserved state.
  core.String? state;

  /// If true, the license will remain attached when creating images or
  /// snapshots from disks.
  ///
  /// Otherwise, the license is not transferred.
  ///
  /// Output only.
  core.bool? transferable;

  LicenseCode({
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.licenseAlias,
    this.name,
    this.selfLink,
    this.state,
    this.transferable,
  });

  LicenseCode.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          licenseAlias: _json.containsKey('licenseAlias')
              ? (_json['licenseAlias'] as core.List)
                  .map<LicenseCodeLicenseAlias>((value) =>
                      LicenseCodeLicenseAlias.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
          transferable: _json.containsKey('transferable')
              ? _json['transferable'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (licenseAlias != null)
          'licenseAlias': licenseAlias!.map((value) => value.toJson()).toList(),
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (state != null) 'state': state!,
        if (transferable != null) 'transferable': transferable!,
      };
}

class LicenseCodeLicenseAlias {
  /// Description of this License Code.
  ///
  /// Output only.
  core.String? description;

  /// URL of license corresponding to this License Code.
  ///
  /// Output only.
  core.String? selfLink;

  LicenseCodeLicenseAlias({
    this.description,
    this.selfLink,
  });

  LicenseCodeLicenseAlias.fromJson(core.Map _json)
      : this(
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Commitment for a particular license resource.
class LicenseResourceCommitment {
  /// The number of licenses purchased.
  core.String? amount;

  /// Specifies the core range of the instance for which this license applies.
  core.String? coresPerLicense;

  /// Any applicable license URI.
  core.String? license;

  LicenseResourceCommitment({
    this.amount,
    this.coresPerLicense,
    this.license,
  });

  LicenseResourceCommitment.fromJson(core.Map _json)
      : this(
          amount: _json.containsKey('amount')
              ? _json['amount'] as core.String
              : null,
          coresPerLicense: _json.containsKey('coresPerLicense')
              ? _json['coresPerLicense'] as core.String
              : null,
          license: _json.containsKey('license')
              ? _json['license'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (amount != null) 'amount': amount!,
        if (coresPerLicense != null) 'coresPerLicense': coresPerLicense!,
        if (license != null) 'license': license!,
      };
}

class LicenseResourceRequirements {
  /// Minimum number of guest cpus required to use the Instance.
  ///
  /// Enforced at Instance creation and Instance start.
  core.int? minGuestCpuCount;

  /// Minimum memory required to use the Instance.
  ///
  /// Enforced at Instance creation and Instance start.
  core.int? minMemoryMb;

  LicenseResourceRequirements({
    this.minGuestCpuCount,
    this.minMemoryMb,
  });

  LicenseResourceRequirements.fromJson(core.Map _json)
      : this(
          minGuestCpuCount: _json.containsKey('minGuestCpuCount')
              ? _json['minGuestCpuCount'] as core.int
              : null,
          minMemoryMb: _json.containsKey('minMemoryMb')
              ? _json['minMemoryMb'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (minGuestCpuCount != null) 'minGuestCpuCount': minGuestCpuCount!,
        if (minMemoryMb != null) 'minMemoryMb': minMemoryMb!,
      };
}

class LicensesListResponseWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  LicensesListResponseWarningData({
    this.key,
    this.value,
  });

  LicensesListResponseWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class LicensesListResponseWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<LicensesListResponseWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  LicensesListResponseWarning({
    this.code,
    this.data,
    this.message,
  });

  LicensesListResponseWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<LicensesListResponseWarningData>((value) =>
                      LicensesListResponseWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class LicensesListResponse {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of License resources.
  core.List<License>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  LicensesListResponseWarning? warning;

  LicensesListResponse({
    this.id,
    this.items,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  LicensesListResponse.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<License>((value) => License.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? LicensesListResponseWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class LocalDisk {
  /// Specifies the number of such disks.
  core.int? diskCount;

  /// Specifies the size of the disk in base-2 GB.
  core.int? diskSizeGb;

  /// Specifies the desired disk type on the node.
  ///
  /// This disk type must be a local storage type (e.g.: local-ssd). Note that
  /// for nodeTemplates, this should be the name of the disk type and not its
  /// URL.
  core.String? diskType;

  LocalDisk({
    this.diskCount,
    this.diskSizeGb,
    this.diskType,
  });

  LocalDisk.fromJson(core.Map _json)
      : this(
          diskCount: _json.containsKey('diskCount')
              ? _json['diskCount'] as core.int
              : null,
          diskSizeGb: _json.containsKey('diskSizeGb')
              ? _json['diskSizeGb'] as core.int
              : null,
          diskType: _json.containsKey('diskType')
              ? _json['diskType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskCount != null) 'diskCount': diskCount!,
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (diskType != null) 'diskType': diskType!,
      };
}

/// Configuration for location policy among multiple possible locations (e.g.
/// preferences for zone selection among zones in a single region).
class LocationPolicy {
  /// Location configurations mapped by location name.
  ///
  /// Currently only zone names are supported and must be represented as valid
  /// internal URLs, such as zones/us-central1-a.
  core.Map<core.String, LocationPolicyLocation>? locations;

  LocationPolicy({
    this.locations,
  });

  LocationPolicy.fromJson(core.Map _json)
      : this(
          locations: _json.containsKey('locations')
              ? (_json['locations'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    LocationPolicyLocation.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (locations != null)
          'locations':
              locations!.map((key, item) => core.MapEntry(key, item.toJson())),
      };
}

class LocationPolicyLocation {
  /// Preference for a given location: ALLOW or DENY.
  /// Possible string values are:
  /// - "ALLOW" : Location is allowed for use.
  /// - "DENY" : Location is prohibited.
  /// - "PREFERENCE_UNSPECIFIED" : Default value, unused.
  core.String? preference;

  LocationPolicyLocation({
    this.preference,
  });

  LocationPolicyLocation.fromJson(core.Map _json)
      : this(
          preference: _json.containsKey('preference')
              ? _json['preference'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (preference != null) 'preference': preference!,
      };
}

/// This is deprecated and has no effect.
///
/// Do not use.
class LogConfig {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  LogConfigCloudAuditOptions? cloudAudit;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  LogConfigCounterOptions? counter;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  LogConfigDataAccessOptions? dataAccess;

  LogConfig({
    this.cloudAudit,
    this.counter,
    this.dataAccess,
  });

  LogConfig.fromJson(core.Map _json)
      : this(
          cloudAudit: _json.containsKey('cloudAudit')
              ? LogConfigCloudAuditOptions.fromJson(
                  _json['cloudAudit'] as core.Map<core.String, core.dynamic>)
              : null,
          counter: _json.containsKey('counter')
              ? LogConfigCounterOptions.fromJson(
                  _json['counter'] as core.Map<core.String, core.dynamic>)
              : null,
          dataAccess: _json.containsKey('dataAccess')
              ? LogConfigDataAccessOptions.fromJson(
                  _json['dataAccess'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cloudAudit != null) 'cloudAudit': cloudAudit!.toJson(),
        if (counter != null) 'counter': counter!.toJson(),
        if (dataAccess != null) 'dataAccess': dataAccess!.toJson(),
      };
}

/// This is deprecated and has no effect.
///
/// Do not use.
class LogConfigCloudAuditOptions {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  AuthorizationLoggingOptions? authorizationLoggingOptions;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  /// Possible string values are:
  /// - "ADMIN_ACTIVITY" : This is deprecated and has no effect. Do not use.
  /// - "DATA_ACCESS" : This is deprecated and has no effect. Do not use.
  /// - "UNSPECIFIED_LOG_NAME" : This is deprecated and has no effect. Do not
  /// use.
  core.String? logName;

  LogConfigCloudAuditOptions({
    this.authorizationLoggingOptions,
    this.logName,
  });

  LogConfigCloudAuditOptions.fromJson(core.Map _json)
      : this(
          authorizationLoggingOptions:
              _json.containsKey('authorizationLoggingOptions')
                  ? AuthorizationLoggingOptions.fromJson(
                      _json['authorizationLoggingOptions']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          logName: _json.containsKey('logName')
              ? _json['logName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (authorizationLoggingOptions != null)
          'authorizationLoggingOptions': authorizationLoggingOptions!.toJson(),
        if (logName != null) 'logName': logName!,
      };
}

/// This is deprecated and has no effect.
///
/// Do not use.
class LogConfigCounterOptions {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<LogConfigCounterOptionsCustomField>? customFields;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.String? field;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.String? metric;

  LogConfigCounterOptions({
    this.customFields,
    this.field,
    this.metric,
  });

  LogConfigCounterOptions.fromJson(core.Map _json)
      : this(
          customFields: _json.containsKey('customFields')
              ? (_json['customFields'] as core.List)
                  .map<LogConfigCounterOptionsCustomField>((value) =>
                      LogConfigCounterOptionsCustomField.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          field:
              _json.containsKey('field') ? _json['field'] as core.String : null,
          metric: _json.containsKey('metric')
              ? _json['metric'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (customFields != null)
          'customFields': customFields!.map((value) => value.toJson()).toList(),
        if (field != null) 'field': field!,
        if (metric != null) 'metric': metric!,
      };
}

/// This is deprecated and has no effect.
///
/// Do not use.
class LogConfigCounterOptionsCustomField {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.String? name;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.String? value;

  LogConfigCounterOptionsCustomField({
    this.name,
    this.value,
  });

  LogConfigCounterOptionsCustomField.fromJson(core.Map _json)
      : this(
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// This is deprecated and has no effect.
///
/// Do not use.
class LogConfigDataAccessOptions {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  /// Possible string values are:
  /// - "LOG_FAIL_CLOSED" : This is deprecated and has no effect. Do not use.
  /// - "LOG_MODE_UNSPECIFIED" : This is deprecated and has no effect. Do not
  /// use.
  core.String? logMode;

  LogConfigDataAccessOptions({
    this.logMode,
  });

  LogConfigDataAccessOptions.fromJson(core.Map _json)
      : this(
          logMode: _json.containsKey('logMode')
              ? _json['logMode'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (logMode != null) 'logMode': logMode!,
      };
}

class MachineTypeAccelerators {
  /// Number of accelerator cards exposed to the guest.
  core.int? guestAcceleratorCount;

  /// The accelerator type resource name, not a full URL, e.g.
  /// 'nvidia-tesla-k80'.
  core.String? guestAcceleratorType;

  MachineTypeAccelerators({
    this.guestAcceleratorCount,
    this.guestAcceleratorType,
  });

  MachineTypeAccelerators.fromJson(core.Map _json)
      : this(
          guestAcceleratorCount: _json.containsKey('guestAcceleratorCount')
              ? _json['guestAcceleratorCount'] as core.int
              : null,
          guestAcceleratorType: _json.containsKey('guestAcceleratorType')
              ? _json['guestAcceleratorType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (guestAcceleratorCount != null)
          'guestAcceleratorCount': guestAcceleratorCount!,
        if (guestAcceleratorType != null)
          'guestAcceleratorType': guestAcceleratorType!,
      };
}

class MachineTypeScratchDisks {
  /// Size of the scratch disk, defined in GB.
  core.int? diskGb;

  MachineTypeScratchDisks({
    this.diskGb,
  });

  MachineTypeScratchDisks.fromJson(core.Map _json)
      : this(
          diskGb:
              _json.containsKey('diskGb') ? _json['diskGb'] as core.int : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskGb != null) 'diskGb': diskGb!,
      };
}

/// Represents a Machine Type resource.
///
/// You can use specific machine types for your VM instances based on
/// performance and pricing requirements. For more information, read Machine
/// Types.
class MachineType {
  /// A list of accelerator configurations assigned to this machine type.
  ///
  /// Output only.
  core.List<MachineTypeAccelerators>? accelerators;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this machine type.
  ///
  /// Only applicable if the machine type is unavailable.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// An optional textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The number of virtual CPUs that are available to the instance.
  ///
  /// Output only.
  core.int? guestCpus;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// This property is deprecated and will never be populated with any relevant
  /// values.
  ///
  /// Deprecated.
  core.int? imageSpaceGb;

  /// Whether this machine type has a shared CPU.
  ///
  /// See Shared-core machine types for more information.
  ///
  /// Output only.
  core.bool? isSharedCpu;

  /// The type of the resource.
  ///
  /// Always compute#machineType for machine types.
  ///
  /// Output only.
  core.String? kind;

  /// Maximum persistent disks allowed.
  ///
  /// Output only.
  core.int? maximumPersistentDisks;

  /// Maximum total persistent disks size (GB) allowed.
  ///
  /// Output only.
  core.String? maximumPersistentDisksSizeGb;

  /// The amount of physical memory available to the instance, defined in MB.
  ///
  /// Output only.
  core.int? memoryMb;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// A list of extended scratch disks assigned to the instance.
  ///
  /// Output only.
  core.List<MachineTypeScratchDisks>? scratchDisks;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The name of the zone where the machine type resides, such as
  /// us-central1-a.
  ///
  /// Output only.
  core.String? zone;

  MachineType({
    this.accelerators,
    this.creationTimestamp,
    this.deprecated,
    this.description,
    this.guestCpus,
    this.id,
    this.imageSpaceGb,
    this.isSharedCpu,
    this.kind,
    this.maximumPersistentDisks,
    this.maximumPersistentDisksSizeGb,
    this.memoryMb,
    this.name,
    this.scratchDisks,
    this.selfLink,
    this.zone,
  });

  MachineType.fromJson(core.Map _json)
      : this(
          accelerators: _json.containsKey('accelerators')
              ? (_json['accelerators'] as core.List)
                  .map<MachineTypeAccelerators>((value) =>
                      MachineTypeAccelerators.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          deprecated: _json.containsKey('deprecated')
              ? DeprecationStatus.fromJson(
                  _json['deprecated'] as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          guestCpus: _json.containsKey('guestCpus')
              ? _json['guestCpus'] as core.int
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          imageSpaceGb: _json.containsKey('imageSpaceGb')
              ? _json['imageSpaceGb'] as core.int
              : null,
          isSharedCpu: _json.containsKey('isSharedCpu')
              ? _json['isSharedCpu'] as core.bool
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          maximumPersistentDisks: _json.containsKey('maximumPersistentDisks')
              ? _json['maximumPersistentDisks'] as core.int
              : null,
          maximumPersistentDisksSizeGb:
              _json.containsKey('maximumPersistentDisksSizeGb')
                  ? _json['maximumPersistentDisksSizeGb'] as core.String
                  : null,
          memoryMb: _json.containsKey('memoryMb')
              ? _json['memoryMb'] as core.int
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          scratchDisks: _json.containsKey('scratchDisks')
              ? (_json['scratchDisks'] as core.List)
                  .map<MachineTypeScratchDisks>((value) =>
                      MachineTypeScratchDisks.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (accelerators != null)
          'accelerators': accelerators!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (guestCpus != null) 'guestCpus': guestCpus!,
        if (id != null) 'id': id!,
        if (imageSpaceGb != null) 'imageSpaceGb': imageSpaceGb!,
        if (isSharedCpu != null) 'isSharedCpu': isSharedCpu!,
        if (kind != null) 'kind': kind!,
        if (maximumPersistentDisks != null)
          'maximumPersistentDisks': maximumPersistentDisks!,
        if (maximumPersistentDisksSizeGb != null)
          'maximumPersistentDisksSizeGb': maximumPersistentDisksSizeGb!,
        if (memoryMb != null) 'memoryMb': memoryMb!,
        if (name != null) 'name': name!,
        if (scratchDisks != null)
          'scratchDisks': scratchDisks!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (zone != null) 'zone': zone!,
      };
}

class MachineTypeAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  MachineTypeAggregatedListWarningData({
    this.key,
    this.value,
  });

  MachineTypeAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class MachineTypeAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<MachineTypeAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  MachineTypeAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  MachineTypeAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<MachineTypeAggregatedListWarningData>((value) =>
                      MachineTypeAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class MachineTypeAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of MachineTypesScopedList resources.
  core.Map<core.String, MachineTypesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#machineTypeAggregatedList for aggregated lists of machine
  /// types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  MachineTypeAggregatedListWarning? warning;

  MachineTypeAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  MachineTypeAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    MachineTypesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? MachineTypeAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class MachineTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  MachineTypeListWarningData({
    this.key,
    this.value,
  });

  MachineTypeListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class MachineTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<MachineTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  MachineTypeListWarning({
    this.code,
    this.data,
    this.message,
  });

  MachineTypeListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<MachineTypeListWarningData>((value) =>
                      MachineTypeListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of machine types.
class MachineTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of MachineType resources.
  core.List<MachineType>? items;

  /// Type of resource.
  ///
  /// Always compute#machineTypeList for lists of machine types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  MachineTypeListWarning? warning;

  MachineTypeList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  MachineTypeList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<MachineType>((value) => MachineType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? MachineTypeListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class MachineTypesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  MachineTypesScopedListWarningData({
    this.key,
    this.value,
  });

  MachineTypesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the machine types list is empty.
///
/// Output only.
class MachineTypesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<MachineTypesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  MachineTypesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  MachineTypesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<MachineTypesScopedListWarningData>((value) =>
                      MachineTypesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class MachineTypesScopedList {
  /// A list of machine types contained in this scope.
  ///
  /// Output only.
  core.List<MachineType>? machineTypes;

  /// An informational warning that appears when the machine types list is
  /// empty.
  ///
  /// Output only.
  MachineTypesScopedListWarning? warning;

  MachineTypesScopedList({
    this.machineTypes,
    this.warning,
  });

  MachineTypesScopedList.fromJson(core.Map _json)
      : this(
          machineTypes: _json.containsKey('machineTypes')
              ? (_json['machineTypes'] as core.List)
                  .map<MachineType>((value) => MachineType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? MachineTypesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (machineTypes != null)
          'machineTypes': machineTypes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A Managed Instance resource.
class ManagedInstance {
  /// The current action that the managed instance group has scheduled for the
  /// instance.
  ///
  /// Possible values: - NONE The instance is running, and the managed instance
  /// group does not have any scheduled actions for this instance. - CREATING
  /// The managed instance group is creating this instance. If the group fails
  /// to create this instance, it will try again until it is successful. -
  /// CREATING_WITHOUT_RETRIES The managed instance group is attempting to
  /// create this instance only once. If the group fails to create this
  /// instance, it does not try again and the group's targetSize value is
  /// decreased instead. - RECREATING The managed instance group is recreating
  /// this instance. - DELETING The managed instance group is permanently
  /// deleting this instance. - ABANDONING The managed instance group is
  /// abandoning this instance. The instance will be removed from the instance
  /// group and from any target pools that are associated with this group. -
  /// RESTARTING The managed instance group is restarting the instance. -
  /// REFRESHING The managed instance group is applying configuration changes to
  /// the instance without stopping it. For example, the group can update the
  /// target pool list for an instance without stopping that instance. -
  /// VERIFYING The managed instance group has created the instance and it is in
  /// the process of being verified.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ABANDONING" : The managed instance group is abandoning this instance.
  /// The instance will be removed from the instance group and from any target
  /// pools that are associated with this group.
  /// - "CREATING" : The managed instance group is creating this instance. If
  /// the group fails to create this instance, it will try again until it is
  /// successful.
  /// - "CREATING_WITHOUT_RETRIES" : The managed instance group is attempting to
  /// create this instance only once. If the group fails to create this
  /// instance, it does not try again and the group's targetSize value is
  /// decreased.
  /// - "DELETING" : The managed instance group is permanently deleting this
  /// instance.
  /// - "NONE" : The managed instance group has not scheduled any actions for
  /// this instance.
  /// - "RECREATING" : The managed instance group is recreating this instance.
  /// - "REFRESHING" : The managed instance group is applying configuration
  /// changes to the instance without stopping it. For example, the group can
  /// update the target pool list for an instance without stopping that
  /// instance.
  /// - "RESTARTING" : The managed instance group is restarting this instance.
  /// - "VERIFYING" : The managed instance group is verifying this already
  /// created instance. Verification happens every time the instance is
  /// (re)created or restarted and consists of: 1. Waiting until health check
  /// specified as part of this managed instance group's autohealing policy
  /// reports HEALTHY. Note: Applies only if autohealing policy has a health
  /// check specified 2. Waiting for addition verification steps performed as
  /// post-instance creation (subject to future extensions).
  core.String? currentAction;

  /// The unique identifier for this resource.
  ///
  /// This field is empty when instance does not exist.
  ///
  /// Output only.
  core.String? id;

  /// The URL of the instance.
  ///
  /// The URL can exist even if the instance has not yet been created.
  ///
  /// Output only.
  core.String? instance;

  /// Health state of the instance per health-check.
  ///
  /// Output only.
  core.List<ManagedInstanceInstanceHealth>? instanceHealth;

  /// The status of the instance.
  ///
  /// This field is empty when the instance does not exist.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DEPROVISIONING" : The Nanny is halted and we are performing tear down
  /// tasks like network deprogramming, releasing quota, IP, tearing down disks
  /// etc.
  /// - "PROVISIONING" : Resources are being allocated for the instance.
  /// - "REPAIRING" : The instance is in repair.
  /// - "RUNNING" : The instance is running.
  /// - "STAGING" : All required resources have been allocated and the instance
  /// is being started.
  /// - "STOPPED" : The instance has stopped successfully.
  /// - "STOPPING" : The instance is currently stopping (either being deleted or
  /// killed).
  /// - "SUSPENDED" : The instance has suspended.
  /// - "SUSPENDING" : The instance is suspending.
  /// - "TERMINATED" : The instance has stopped (either by explicit action or
  /// underlying failure).
  core.String? instanceStatus;

  /// Information about the last attempt to create or delete the instance.
  ///
  /// Output only.
  ManagedInstanceLastAttempt? lastAttempt;

  /// Preserved state applied from per-instance config for this instance.
  ///
  /// Output only.
  PreservedState? preservedStateFromConfig;

  /// Preserved state generated based on stateful policy for this instance.
  ///
  /// Output only.
  PreservedState? preservedStateFromPolicy;

  /// Intended version of this instance.
  ///
  /// Output only.
  ManagedInstanceVersion? version;

  ManagedInstance({
    this.currentAction,
    this.id,
    this.instance,
    this.instanceHealth,
    this.instanceStatus,
    this.lastAttempt,
    this.preservedStateFromConfig,
    this.preservedStateFromPolicy,
    this.version,
  });

  ManagedInstance.fromJson(core.Map _json)
      : this(
          currentAction: _json.containsKey('currentAction')
              ? _json['currentAction'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          instance: _json.containsKey('instance')
              ? _json['instance'] as core.String
              : null,
          instanceHealth: _json.containsKey('instanceHealth')
              ? (_json['instanceHealth'] as core.List)
                  .map<ManagedInstanceInstanceHealth>((value) =>
                      ManagedInstanceInstanceHealth.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          instanceStatus: _json.containsKey('instanceStatus')
              ? _json['instanceStatus'] as core.String
              : null,
          lastAttempt: _json.containsKey('lastAttempt')
              ? ManagedInstanceLastAttempt.fromJson(
                  _json['lastAttempt'] as core.Map<core.String, core.dynamic>)
              : null,
          preservedStateFromConfig:
              _json.containsKey('preservedStateFromConfig')
                  ? PreservedState.fromJson(_json['preservedStateFromConfig']
                      as core.Map<core.String, core.dynamic>)
                  : null,
          preservedStateFromPolicy:
              _json.containsKey('preservedStateFromPolicy')
                  ? PreservedState.fromJson(_json['preservedStateFromPolicy']
                      as core.Map<core.String, core.dynamic>)
                  : null,
          version: _json.containsKey('version')
              ? ManagedInstanceVersion.fromJson(
                  _json['version'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (currentAction != null) 'currentAction': currentAction!,
        if (id != null) 'id': id!,
        if (instance != null) 'instance': instance!,
        if (instanceHealth != null)
          'instanceHealth':
              instanceHealth!.map((value) => value.toJson()).toList(),
        if (instanceStatus != null) 'instanceStatus': instanceStatus!,
        if (lastAttempt != null) 'lastAttempt': lastAttempt!.toJson(),
        if (preservedStateFromConfig != null)
          'preservedStateFromConfig': preservedStateFromConfig!.toJson(),
        if (preservedStateFromPolicy != null)
          'preservedStateFromPolicy': preservedStateFromPolicy!.toJson(),
        if (version != null) 'version': version!.toJson(),
      };
}

class ManagedInstanceInstanceHealth {
  /// The current detailed instance health state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DRAINING" : The instance is being drained. The existing connections to
  /// the instance have time to complete, but the new ones are being refused.
  /// - "HEALTHY" : The instance is reachable i.e. a connection to the
  /// application health checking endpoint can be established, and conforms to
  /// the requirements defined by the health check.
  /// - "TIMEOUT" : The instance is unreachable i.e. a connection to the
  /// application health checking endpoint cannot be established, or the server
  /// does not respond within the specified timeout.
  /// - "UNHEALTHY" : The instance is reachable, but does not conform to the
  /// requirements defined by the health check.
  /// - "UNKNOWN" : The health checking system is aware of the instance but its
  /// health is not known at the moment.
  core.String? detailedHealthState;

  /// The URL for the health check that verifies whether the instance is
  /// healthy.
  ///
  /// Output only.
  core.String? healthCheck;

  ManagedInstanceInstanceHealth({
    this.detailedHealthState,
    this.healthCheck,
  });

  ManagedInstanceInstanceHealth.fromJson(core.Map _json)
      : this(
          detailedHealthState: _json.containsKey('detailedHealthState')
              ? _json['detailedHealthState'] as core.String
              : null,
          healthCheck: _json.containsKey('healthCheck')
              ? _json['healthCheck'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (detailedHealthState != null)
          'detailedHealthState': detailedHealthState!,
        if (healthCheck != null) 'healthCheck': healthCheck!,
      };
}

class ManagedInstanceLastAttemptErrorsErrors {
  /// The error type identifier for this error.
  ///
  /// Output only.
  core.String? code;

  /// Indicates the field in the request that caused the error.
  ///
  /// This property is optional.
  ///
  /// Output only.
  core.String? location;

  /// An optional, human-readable error message.
  ///
  /// Output only.
  core.String? message;

  ManagedInstanceLastAttemptErrorsErrors({
    this.code,
    this.location,
    this.message,
  });

  ManagedInstanceLastAttemptErrorsErrors.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          location: _json.containsKey('location')
              ? _json['location'] as core.String
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (location != null) 'location': location!,
        if (message != null) 'message': message!,
      };
}

/// Encountered errors during the last attempt to create or delete the instance.
///
/// Output only.
class ManagedInstanceLastAttemptErrors {
  /// The array of errors encountered while processing this operation.
  ///
  /// Output only.
  core.List<ManagedInstanceLastAttemptErrorsErrors>? errors;

  ManagedInstanceLastAttemptErrors({
    this.errors,
  });

  ManagedInstanceLastAttemptErrors.fromJson(core.Map _json)
      : this(
          errors: _json.containsKey('errors')
              ? (_json['errors'] as core.List)
                  .map<ManagedInstanceLastAttemptErrorsErrors>((value) =>
                      ManagedInstanceLastAttemptErrorsErrors.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (errors != null)
          'errors': errors!.map((value) => value.toJson()).toList(),
      };
}

class ManagedInstanceLastAttempt {
  /// Encountered errors during the last attempt to create or delete the
  /// instance.
  ///
  /// Output only.
  ManagedInstanceLastAttemptErrors? errors;

  ManagedInstanceLastAttempt({
    this.errors,
  });

  ManagedInstanceLastAttempt.fromJson(core.Map _json)
      : this(
          errors: _json.containsKey('errors')
              ? ManagedInstanceLastAttemptErrors.fromJson(
                  _json['errors'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (errors != null) 'errors': errors!.toJson(),
      };
}

class ManagedInstanceVersion {
  /// The intended template of the instance.
  ///
  /// This field is empty when current_action is one of { DELETING, ABANDONING
  /// }.
  ///
  /// Output only.
  core.String? instanceTemplate;

  /// Name of the version.
  ///
  /// Output only.
  core.String? name;

  ManagedInstanceVersion({
    this.instanceTemplate,
    this.name,
  });

  ManagedInstanceVersion.fromJson(core.Map _json)
      : this(
          instanceTemplate: _json.containsKey('instanceTemplate')
              ? _json['instanceTemplate'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
        if (name != null) 'name': name!,
      };
}

/// Metadata
class MetadataItems {
  /// Key for the metadata entry.
  ///
  /// Keys must conform to the following regexp: \[a-zA-Z0-9-_\]+, and be less
  /// than 128 bytes in length. This is reflected as part of a URL in the
  /// metadata server. Additionally, to avoid ambiguity, keys must not conflict
  /// with any other metadata keys for the project.
  core.String? key;

  /// Value for the metadata entry.
  ///
  /// These are free-form strings, and only have meaning as interpreted by the
  /// image running in the instance. The only restriction placed on values is
  /// that their size must be less than or equal to 262144 bytes (256 KiB).
  core.String? value;

  MetadataItems({
    this.key,
    this.value,
  });

  MetadataItems.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// A metadata key/value entry.
class Metadata {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update metadata. You must always provide an
  /// up-to-date fingerprint hash in order to update or change metadata,
  /// otherwise the request will fail with error 412 conditionNotMet. To see the
  /// latest fingerprint, make a get() request to retrieve the resource.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Array of key/value pairs.
  ///
  /// The total size of all keys and values must be less than 512 KB.
  core.List<MetadataItems>? items;

  /// Type of the resource.
  ///
  /// Always compute#metadata for metadata.
  ///
  /// Output only.
  core.String? kind;

  Metadata({
    this.fingerprint,
    this.items,
    this.kind,
  });

  Metadata.fromJson(core.Map _json)
      : this(
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<MetadataItems>((value) => MetadataItems.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
      };
}

/// Opaque filter criteria used by loadbalancers to restrict routing
/// configuration to a limited set of loadbalancing proxies.
///
/// Proxies and sidecars involved in loadbalancing would typically present
/// metadata to the loadbalancers which need to match criteria specified here.
/// If a match takes place, the relevant configuration is made available to
/// those proxies. For each metadataFilter in this list, if its
/// filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels
/// must match the corresponding label provided in the metadata. If its
/// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must
/// match with corresponding labels provided in the metadata. An example for
/// using metadataFilters would be: if loadbalancing involves Envoys, they will
/// only receive routing configuration when values in metadataFilters match
/// values supplied in of their XDS requests to loadbalancers.
class MetadataFilter {
  /// The list of label value pairs that must match labels in the provided
  /// metadata based on filterMatchCriteria This list must not be empty and can
  /// have at the most 64 entries.
  core.List<MetadataFilterLabelMatch>? filterLabels;

  /// Specifies how individual filterLabel matches within the list of
  /// filterLabels contribute towards the overall metadataFilter match.
  ///
  /// Supported values are: - MATCH_ANY: At least one of the filterLabels must
  /// have a matching label in the provided metadata. - MATCH_ALL: All
  /// filterLabels must have matching labels in the provided metadata.
  /// Possible string values are:
  /// - "MATCH_ALL" : Specifies that all filterLabels must match for the
  /// metadataFilter to be considered a match.
  /// - "MATCH_ANY" : Specifies that any filterLabel must match for the
  /// metadataFilter to be considered a match.
  /// - "NOT_SET" : Indicates that the match criteria was not set. A
  /// metadataFilter must never be created with this value.
  core.String? filterMatchCriteria;

  MetadataFilter({
    this.filterLabels,
    this.filterMatchCriteria,
  });

  MetadataFilter.fromJson(core.Map _json)
      : this(
          filterLabels: _json.containsKey('filterLabels')
              ? (_json['filterLabels'] as core.List)
                  .map<MetadataFilterLabelMatch>((value) =>
                      MetadataFilterLabelMatch.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          filterMatchCriteria: _json.containsKey('filterMatchCriteria')
              ? _json['filterMatchCriteria'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filterLabels != null)
          'filterLabels': filterLabels!.map((value) => value.toJson()).toList(),
        if (filterMatchCriteria != null)
          'filterMatchCriteria': filterMatchCriteria!,
      };
}

/// MetadataFilter label name value pairs that are expected to match
/// corresponding labels presented as metadata to the loadbalancer.
class MetadataFilterLabelMatch {
  /// Name of metadata label.
  ///
  /// The name can have a maximum length of 1024 characters and must be at least
  /// 1 character long.
  core.String? name;

  /// The value of the label must match the specified value.
  ///
  /// value can have a maximum length of 1024 characters.
  core.String? value;

  MetadataFilterLabelMatch({
    this.name,
    this.value,
  });

  MetadataFilterLabelMatch.fromJson(core.Map _json)
      : this(
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// The named port.
///
/// For example: <"http", 80>.
class NamedPort {
  /// The name for this named port.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String? name;

  /// The port number, which can be a value between 1 and 65535.
  core.int? port;

  NamedPort({
    this.name,
    this.port,
  });

  NamedPort.fromJson(core.Map _json)
      : this(
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (port != null) 'port': port!,
      };
}

/// Represents a VPC Network resource.
///
/// Networks connect resources to each other and to the internet. For more
/// information, read Virtual Private Cloud (VPC) Network.
class Network {
  /// Deprecated in favor of subnet mode networks.
  ///
  /// The range of internal addresses that are legal on this network. This range
  /// is a CIDR specification, for example: 192.168.0.0/16. Provided by the
  /// client when the network is created.
  core.String? IPv4Range;

  /// Must be set to create a VPC network.
  ///
  /// If not set, a legacy network is created. When set to true, the VPC network
  /// is created in auto mode. When set to false, the VPC network is created in
  /// custom mode. An auto mode VPC network starts with one subnet per region.
  /// Each subnet has a predetermined range as described in Auto mode VPC
  /// network IP ranges. For custom mode VPC networks, you can add subnets using
  /// the subnetworks insert method.
  core.bool? autoCreateSubnetworks;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// The gateway address for default routing out of the network, selected by
  /// GCP.
  ///
  /// Output only.
  core.String? gatewayIPv4;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#network for networks.
  ///
  /// Output only.
  core.String? kind;

  /// Maximum Transmission Unit in bytes.
  ///
  /// The minimum value for this field is 1460 and the maximum value is 1500
  /// bytes. If unspecified, defaults to 1460.
  core.int? mtu;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase
  /// letter, and all following characters (except for the last character) must
  /// be a dash, lowercase letter, or digit. The last character must be a
  /// lowercase letter or digit.
  core.String? name;

  /// A list of network peerings for the resource.
  ///
  /// Output only.
  core.List<NetworkPeering>? peerings;

  /// The network-level routing configuration for this network.
  ///
  /// Used by Cloud Router to determine what type of network-wide routing
  /// behavior to enforce.
  NetworkRoutingConfig? routingConfig;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Server-defined fully-qualified URLs for all subnetworks in this VPC
  /// network.
  ///
  /// Output only.
  core.List<core.String>? subnetworks;

  Network({
    this.IPv4Range,
    this.autoCreateSubnetworks,
    this.creationTimestamp,
    this.description,
    this.gatewayIPv4,
    this.id,
    this.kind,
    this.mtu,
    this.name,
    this.peerings,
    this.routingConfig,
    this.selfLink,
    this.subnetworks,
  });

  Network.fromJson(core.Map _json)
      : this(
          IPv4Range: _json.containsKey('IPv4Range')
              ? _json['IPv4Range'] as core.String
              : null,
          autoCreateSubnetworks: _json.containsKey('autoCreateSubnetworks')
              ? _json['autoCreateSubnetworks'] as core.bool
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          gatewayIPv4: _json.containsKey('gatewayIPv4')
              ? _json['gatewayIPv4'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          mtu: _json.containsKey('mtu') ? _json['mtu'] as core.int : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          peerings: _json.containsKey('peerings')
              ? (_json['peerings'] as core.List)
                  .map<NetworkPeering>((value) => NetworkPeering.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          routingConfig: _json.containsKey('routingConfig')
              ? NetworkRoutingConfig.fromJson(
                  _json['routingConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          subnetworks: _json.containsKey('subnetworks')
              ? (_json['subnetworks'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPv4Range != null) 'IPv4Range': IPv4Range!,
        if (autoCreateSubnetworks != null)
          'autoCreateSubnetworks': autoCreateSubnetworks!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (gatewayIPv4 != null) 'gatewayIPv4': gatewayIPv4!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (mtu != null) 'mtu': mtu!,
        if (name != null) 'name': name!,
        if (peerings != null)
          'peerings': peerings!.map((value) => value.toJson()).toList(),
        if (routingConfig != null) 'routingConfig': routingConfig!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (subnetworks != null) 'subnetworks': subnetworks!,
      };
}

/// The network endpoint.
class NetworkEndpoint {
  /// Metadata defined as annotations on the network endpoint.
  core.Map<core.String, core.String>? annotations;

  /// Optional fully qualified domain name of network endpoint.
  ///
  /// This can only be specified when NetworkEndpointGroup.network_endpoint_type
  /// is NON_GCP_FQDN_PORT.
  core.String? fqdn;

  /// The name for a specific VM instance that the IP address belongs to.
  ///
  /// This is required for network endpoints of type GCE_VM_IP_PORT. The
  /// instance must be in the same zone of network endpoint group. The name must
  /// be 1-63 characters long, and comply with RFC1035.
  core.String? instance;

  /// Optional IPv4 address of network endpoint.
  ///
  /// The IP address must belong to a VM in Compute Engine (either the primary
  /// IP or as part of an aliased IP range). If the IP address is not specified,
  /// then the primary IP address for the VM instance in the network that the
  /// network endpoint group belongs to will be used.
  core.String? ipAddress;

  /// Optional port number of network endpoint.
  ///
  /// If not specified, the defaultPort for the network endpoint group will be
  /// used.
  core.int? port;

  NetworkEndpoint({
    this.annotations,
    this.fqdn,
    this.instance,
    this.ipAddress,
    this.port,
  });

  NetworkEndpoint.fromJson(core.Map _json)
      : this(
          annotations: _json.containsKey('annotations')
              ? (_json['annotations'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          fqdn: _json.containsKey('fqdn') ? _json['fqdn'] as core.String : null,
          instance: _json.containsKey('instance')
              ? _json['instance'] as core.String
              : null,
          ipAddress: _json.containsKey('ipAddress')
              ? _json['ipAddress'] as core.String
              : null,
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (fqdn != null) 'fqdn': fqdn!,
        if (instance != null) 'instance': instance!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (port != null) 'port': port!,
      };
}

/// Represents a collection of network endpoints.
///
/// A network endpoint group (NEG) defines how a set of endpoints should be
/// reached, whether they are reachable, and where they are located. For more
/// information about using NEGs, see Setting up external HTTP(S) Load Balancing
/// with internet NEGs, Setting up zonal NEGs, or Setting up external HTTP(S)
/// Load Balancing with serverless NEGs.
class NetworkEndpointGroup {
  /// Metadata defined as annotations on the network endpoint group.
  core.Map<core.String, core.String>? annotations;

  /// Only valid when networkEndpointType is "SERVERLESS".
  ///
  /// Only one of cloudRun, appEngine or cloudFunction may be set.
  NetworkEndpointGroupAppEngine? appEngine;

  /// Only valid when networkEndpointType is "SERVERLESS".
  ///
  /// Only one of cloudRun, appEngine or cloudFunction may be set.
  NetworkEndpointGroupCloudFunction? cloudFunction;

  /// Only valid when networkEndpointType is "SERVERLESS".
  ///
  /// Only one of cloudRun, appEngine or cloudFunction may be set.
  NetworkEndpointGroupCloudRun? cloudRun;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The default port used if the port number is not specified in the network
  /// endpoint.
  core.int? defaultPort;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#networkEndpointGroup for network endpoint group.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The URL of the network to which all network endpoints in the NEG belong.
  ///
  /// Uses "default" project network if unspecified.
  core.String? network;

  /// Type of network endpoints in this network endpoint group.
  ///
  /// Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT,
  /// INTERNET_IP_PORT, SERVERLESS, PRIVATE_SERVICE_CONNECT.
  /// Possible string values are:
  /// - "GCE_VM_IP" : The network endpoint is represented by an IP address.
  /// - "GCE_VM_IP_PORT" : The network endpoint is represented by IP address and
  /// port pair.
  /// - "INTERNET_FQDN_PORT" : The network endpoint is represented by fully
  /// qualified domain name and port.
  /// - "INTERNET_IP_PORT" : The network endpoint is represented by an internet
  /// IP address and port.
  /// - "NON_GCP_PRIVATE_IP_PORT" : The network endpoint is represented by an IP
  /// address and port. The endpoint belongs to a VM or pod running in a
  /// customer's on-premises.
  /// - "SERVERLESS" : The network endpoint is handled by specified serverless
  /// infrastructure.
  core.String? networkEndpointType;

  /// The URL of the region where the network endpoint group is located.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Number of network endpoints in the network endpoint group.
  ///
  /// Output only.
  core.int? size;

  /// Optional URL of the subnetwork to which all network endpoints in the NEG
  /// belong.
  core.String? subnetwork;

  /// The URL of the zone where the network endpoint group is located.
  ///
  /// Output only.
  core.String? zone;

  NetworkEndpointGroup({
    this.annotations,
    this.appEngine,
    this.cloudFunction,
    this.cloudRun,
    this.creationTimestamp,
    this.defaultPort,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.network,
    this.networkEndpointType,
    this.region,
    this.selfLink,
    this.size,
    this.subnetwork,
    this.zone,
  });

  NetworkEndpointGroup.fromJson(core.Map _json)
      : this(
          annotations: _json.containsKey('annotations')
              ? (_json['annotations'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          appEngine: _json.containsKey('appEngine')
              ? NetworkEndpointGroupAppEngine.fromJson(
                  _json['appEngine'] as core.Map<core.String, core.dynamic>)
              : null,
          cloudFunction: _json.containsKey('cloudFunction')
              ? NetworkEndpointGroupCloudFunction.fromJson(
                  _json['cloudFunction'] as core.Map<core.String, core.dynamic>)
              : null,
          cloudRun: _json.containsKey('cloudRun')
              ? NetworkEndpointGroupCloudRun.fromJson(
                  _json['cloudRun'] as core.Map<core.String, core.dynamic>)
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          defaultPort: _json.containsKey('defaultPort')
              ? _json['defaultPort'] as core.int
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          networkEndpointType: _json.containsKey('networkEndpointType')
              ? _json['networkEndpointType'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          size: _json.containsKey('size') ? _json['size'] as core.int : null,
          subnetwork: _json.containsKey('subnetwork')
              ? _json['subnetwork'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (appEngine != null) 'appEngine': appEngine!.toJson(),
        if (cloudFunction != null) 'cloudFunction': cloudFunction!.toJson(),
        if (cloudRun != null) 'cloudRun': cloudRun!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (defaultPort != null) 'defaultPort': defaultPort!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (networkEndpointType != null)
          'networkEndpointType': networkEndpointType!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (size != null) 'size': size!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
        if (zone != null) 'zone': zone!,
      };
}

class NetworkEndpointGroupAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkEndpointGroupAggregatedListWarningData({
    this.key,
    this.value,
  });

  NetworkEndpointGroupAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NetworkEndpointGroupAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkEndpointGroupAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkEndpointGroupAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  NetworkEndpointGroupAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NetworkEndpointGroupAggregatedListWarningData>((value) =>
                      NetworkEndpointGroupAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NetworkEndpointGroupAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NetworkEndpointGroupsScopedList resources.
  core.Map<core.String, NetworkEndpointGroupsScopedList>? items;

  /// The resource type, which is always
  /// compute#networkEndpointGroupAggregatedList for aggregated lists of network
  /// endpoint groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  NetworkEndpointGroupAggregatedListWarning? warning;

  NetworkEndpointGroupAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  NetworkEndpointGroupAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    NetworkEndpointGroupsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? NetworkEndpointGroupAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Configuration for an App Engine network endpoint group (NEG).
///
/// The service is optional, may be provided explicitly or in the URL mask. The
/// version is optional and can only be provided explicitly or in the URL mask
/// when service is present. Note: App Engine service must be in the same
/// project and located in the same region as the Serverless NEG.
class NetworkEndpointGroupAppEngine {
  /// Optional serving service.
  ///
  /// The service name is case-sensitive and must be 1-63 characters long.
  /// Example value: "default", "my-service".
  core.String? service;

  /// A template to parse service and version fields from a request URL.
  ///
  /// URL mask allows for routing to multiple App Engine services without having
  /// to create multiple Network Endpoint Groups and backend services. For
  /// example, the request URLs "foo1-dot-appname.appspot.com/v1" and
  /// "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG
  /// with URL mask "-dot-appname.appspot.com/". The URL mask will parse them to
  /// { service = "foo1", version = "v1" } and { service = "foo1", version =
  /// "v2" } respectively.
  core.String? urlMask;

  /// Optional serving version.
  ///
  /// The version name is case-sensitive and must be 1-100 characters long.
  /// Example value: "v1", "v2".
  core.String? version;

  NetworkEndpointGroupAppEngine({
    this.service,
    this.urlMask,
    this.version,
  });

  NetworkEndpointGroupAppEngine.fromJson(core.Map _json)
      : this(
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
          urlMask: _json.containsKey('urlMask')
              ? _json['urlMask'] as core.String
              : null,
          version: _json.containsKey('version')
              ? _json['version'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (service != null) 'service': service!,
        if (urlMask != null) 'urlMask': urlMask!,
        if (version != null) 'version': version!,
      };
}

/// Configuration for a Cloud Function network endpoint group (NEG).
///
/// The function must be provided explicitly or in the URL mask. Note: Cloud
/// Function must be in the same project and located in the same region as the
/// Serverless NEG.
class NetworkEndpointGroupCloudFunction {
  /// A user-defined name of the Cloud Function.
  ///
  /// The function name is case-sensitive and must be 1-63 characters long.
  /// Example value: "func1".
  core.String? function;

  /// A template to parse function field from a request URL.
  ///
  /// URL mask allows for routing to multiple Cloud Functions without having to
  /// create multiple Network Endpoint Groups and backend services. For example,
  /// request URLs " mydomain.com/function1" and "mydomain.com/function2" can be
  /// backed by the same Serverless NEG with URL mask "/". The URL mask will
  /// parse them to { function = "function1" } and { function = "function2" }
  /// respectively.
  core.String? urlMask;

  NetworkEndpointGroupCloudFunction({
    this.function,
    this.urlMask,
  });

  NetworkEndpointGroupCloudFunction.fromJson(core.Map _json)
      : this(
          function: _json.containsKey('function')
              ? _json['function'] as core.String
              : null,
          urlMask: _json.containsKey('urlMask')
              ? _json['urlMask'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (function != null) 'function': function!,
        if (urlMask != null) 'urlMask': urlMask!,
      };
}

/// Configuration for a Cloud Run network endpoint group (NEG).
///
/// The service must be provided explicitly or in the URL mask. The tag is
/// optional, may be provided explicitly or in the URL mask. Note: Cloud Run
/// service must be in the same project and located in the same region as the
/// Serverless NEG.
class NetworkEndpointGroupCloudRun {
  /// Cloud Run service is the main resource of Cloud Run.
  ///
  /// The service must be 1-63 characters long, and comply with RFC1035. Example
  /// value: "run-service".
  core.String? service;

  /// Optional Cloud Run tag represents the "named-revision" to provide
  /// additional fine-grained traffic routing information.
  ///
  /// The tag must be 1-63 characters long, and comply with RFC1035. Example
  /// value: "revision-0010".
  core.String? tag;

  /// A template to parse service and tag fields from a request URL.
  ///
  /// URL mask allows for routing to multiple Run services without having to
  /// create multiple network endpoint groups and backend services. For example,
  /// request URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2" can be
  /// backed by the same Serverless Network Endpoint Group (NEG) with URL mask
  /// ".domain.com/". The URL mask will parse them to { service="bar1",
  /// tag="foo1" } and { service="bar2", tag="foo2" } respectively.
  core.String? urlMask;

  NetworkEndpointGroupCloudRun({
    this.service,
    this.tag,
    this.urlMask,
  });

  NetworkEndpointGroupCloudRun.fromJson(core.Map _json)
      : this(
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
          tag: _json.containsKey('tag') ? _json['tag'] as core.String : null,
          urlMask: _json.containsKey('urlMask')
              ? _json['urlMask'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (service != null) 'service': service!,
        if (tag != null) 'tag': tag!,
        if (urlMask != null) 'urlMask': urlMask!,
      };
}

class NetworkEndpointGroupListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkEndpointGroupListWarningData({
    this.key,
    this.value,
  });

  NetworkEndpointGroupListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NetworkEndpointGroupListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkEndpointGroupListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkEndpointGroupListWarning({
    this.code,
    this.data,
    this.message,
  });

  NetworkEndpointGroupListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NetworkEndpointGroupListWarningData>((value) =>
                      NetworkEndpointGroupListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NetworkEndpointGroupList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NetworkEndpointGroup resources.
  core.List<NetworkEndpointGroup>? items;

  /// The resource type, which is always compute#networkEndpointGroupList for
  /// network endpoint group lists.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NetworkEndpointGroupListWarning? warning;

  NetworkEndpointGroupList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  NetworkEndpointGroupList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<NetworkEndpointGroup>((value) =>
                      NetworkEndpointGroup.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? NetworkEndpointGroupListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NetworkEndpointGroupsAttachEndpointsRequest {
  /// The list of network endpoints to be attached.
  core.List<NetworkEndpoint>? networkEndpoints;

  NetworkEndpointGroupsAttachEndpointsRequest({
    this.networkEndpoints,
  });

  NetworkEndpointGroupsAttachEndpointsRequest.fromJson(core.Map _json)
      : this(
          networkEndpoints: _json.containsKey('networkEndpoints')
              ? (_json['networkEndpoints'] as core.List)
                  .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpoints != null)
          'networkEndpoints':
              networkEndpoints!.map((value) => value.toJson()).toList(),
      };
}

class NetworkEndpointGroupsDetachEndpointsRequest {
  /// The list of network endpoints to be detached.
  core.List<NetworkEndpoint>? networkEndpoints;

  NetworkEndpointGroupsDetachEndpointsRequest({
    this.networkEndpoints,
  });

  NetworkEndpointGroupsDetachEndpointsRequest.fromJson(core.Map _json)
      : this(
          networkEndpoints: _json.containsKey('networkEndpoints')
              ? (_json['networkEndpoints'] as core.List)
                  .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpoints != null)
          'networkEndpoints':
              networkEndpoints!.map((value) => value.toJson()).toList(),
      };
}

class NetworkEndpointGroupsListEndpointsRequest {
  /// Optional query parameter for showing the health status of each network
  /// endpoint.
  ///
  /// Valid options are SKIP or SHOW. If you don't specify this parameter, the
  /// health status of network endpoints will not be provided.
  /// Possible string values are:
  /// - "SHOW" : Show the health status for each network endpoint. Impacts
  /// latency of the call.
  /// - "SKIP" : Health status for network endpoints will not be provided.
  core.String? healthStatus;

  NetworkEndpointGroupsListEndpointsRequest({
    this.healthStatus,
  });

  NetworkEndpointGroupsListEndpointsRequest.fromJson(core.Map _json)
      : this(
          healthStatus: _json.containsKey('healthStatus')
              ? _json['healthStatus'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthStatus != null) 'healthStatus': healthStatus!,
      };
}

class NetworkEndpointGroupsListNetworkEndpointsWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkEndpointGroupsListNetworkEndpointsWarningData({
    this.key,
    this.value,
  });

  NetworkEndpointGroupsListNetworkEndpointsWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NetworkEndpointGroupsListNetworkEndpointsWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkEndpointGroupsListNetworkEndpointsWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkEndpointGroupsListNetworkEndpointsWarning({
    this.code,
    this.data,
    this.message,
  });

  NetworkEndpointGroupsListNetworkEndpointsWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NetworkEndpointGroupsListNetworkEndpointsWarningData>(
                      (value) =>
                          NetworkEndpointGroupsListNetworkEndpointsWarningData
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NetworkEndpointGroupsListNetworkEndpoints {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NetworkEndpointWithHealthStatus resources.
  core.List<NetworkEndpointWithHealthStatus>? items;

  /// The resource type, which is always
  /// compute#networkEndpointGroupsListNetworkEndpoints for the list of network
  /// endpoints in the specified network endpoint group.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  NetworkEndpointGroupsListNetworkEndpointsWarning? warning;

  NetworkEndpointGroupsListNetworkEndpoints({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.warning,
  });

  NetworkEndpointGroupsListNetworkEndpoints.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<NetworkEndpointWithHealthStatus>((value) =>
                      NetworkEndpointWithHealthStatus.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? NetworkEndpointGroupsListNetworkEndpointsWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NetworkEndpointGroupsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkEndpointGroupsScopedListWarningData({
    this.key,
    this.value,
  });

  NetworkEndpointGroupsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that replaces the list of network endpoint groups
/// when the list is empty.
///
/// Output only.
class NetworkEndpointGroupsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkEndpointGroupsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkEndpointGroupsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  NetworkEndpointGroupsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NetworkEndpointGroupsScopedListWarningData>((value) =>
                      NetworkEndpointGroupsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NetworkEndpointGroupsScopedList {
  /// The list of network endpoint groups that are contained in this scope.
  ///
  /// Output only.
  core.List<NetworkEndpointGroup>? networkEndpointGroups;

  /// An informational warning that replaces the list of network endpoint groups
  /// when the list is empty.
  ///
  /// Output only.
  NetworkEndpointGroupsScopedListWarning? warning;

  NetworkEndpointGroupsScopedList({
    this.networkEndpointGroups,
    this.warning,
  });

  NetworkEndpointGroupsScopedList.fromJson(core.Map _json)
      : this(
          networkEndpointGroups: _json.containsKey('networkEndpointGroups')
              ? (_json['networkEndpointGroups'] as core.List)
                  .map<NetworkEndpointGroup>((value) =>
                      NetworkEndpointGroup.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? NetworkEndpointGroupsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpointGroups != null)
          'networkEndpointGroups':
              networkEndpointGroups!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NetworkEndpointWithHealthStatus {
  /// The health status of network endpoint;
  ///
  /// Output only.
  core.List<HealthStatusForNetworkEndpoint>? healths;

  /// The network endpoint;
  ///
  /// Output only.
  NetworkEndpoint? networkEndpoint;

  NetworkEndpointWithHealthStatus({
    this.healths,
    this.networkEndpoint,
  });

  NetworkEndpointWithHealthStatus.fromJson(core.Map _json)
      : this(
          healths: _json.containsKey('healths')
              ? (_json['healths'] as core.List)
                  .map<HealthStatusForNetworkEndpoint>((value) =>
                      HealthStatusForNetworkEndpoint.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          networkEndpoint: _json.containsKey('networkEndpoint')
              ? NetworkEndpoint.fromJson(_json['networkEndpoint']
                  as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healths != null)
          'healths': healths!.map((value) => value.toJson()).toList(),
        if (networkEndpoint != null)
          'networkEndpoint': networkEndpoint!.toJson(),
      };
}

/// A network interface resource attached to an instance.
class NetworkInterface {
  /// An array of configurations for this interface.
  ///
  /// Currently, only one access config, ONE_TO_ONE_NAT, is supported. If there
  /// are no accessConfigs specified, then this instance will have no external
  /// internet access.
  core.List<AccessConfig>? accessConfigs;

  /// An array of alias IP ranges for this network interface.
  ///
  /// You can only specify this field for network interfaces in VPC networks.
  core.List<AliasIpRange>? aliasIpRanges;

  /// Fingerprint hash of contents stored in this network interface.
  ///
  /// This field will be ignored when inserting an Instance or adding a
  /// NetworkInterface. An up-to-date fingerprint must be provided in order to
  /// update the NetworkInterface. The request will fail with error 400 Bad
  /// Request if the fingerprint is not provided, or 412 Precondition Failed if
  /// the fingerprint is out of date.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// An array of IPv6 access configurations for this interface.
  ///
  /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If
  /// there is no ipv6AccessConfig specified, then this instance will have no
  /// external IPv6 Internet access.
  core.List<AccessConfig>? ipv6AccessConfigs;

  /// One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from
  /// the Internet.
  ///
  /// This field is always inherited from its subnetwork. Valid only if
  /// stackType is IPV4_IPV6.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "EXTERNAL" : This network interface can have external IPv6.
  /// - "UNSPECIFIED_IPV6_ACCESS_TYPE" : IPv6 access type not set. Means this
  /// network interface hasn't been turned on IPv6 yet.
  core.String? ipv6AccessType;

  /// An IPv6 internal network address for this network interface.
  ///
  /// Output only.
  core.String? ipv6Address;

  /// Type of the resource.
  ///
  /// Always compute#networkInterface for network interfaces.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the network interface, which is generated by the server.
  ///
  /// For network devices, these are eth0, eth1, etc.
  ///
  /// Output only.
  core.String? name;

  /// URL of the network resource for this instance.
  ///
  /// When creating an instance, if neither the network nor the subnetwork is
  /// specified, the default network global/networks/default is used; if the
  /// network is not specified but the subnetwork is specified, the network is
  /// inferred. If you specify this property, you can specify the network as a
  /// full or partial URL. For example, the following are all valid URLs: -
  /// https://www.googleapis.com/compute/v1/projects/project/global/networks/
  /// network - projects/project/global/networks/network -
  /// global/networks/default
  core.String? network;

  /// An IPv4 internal IP address to assign to the instance for this network
  /// interface.
  ///
  /// If not specified by the user, an unused internal IP is assigned by the
  /// system.
  core.String? networkIP;

  /// The type of vNIC to be used on this interface.
  ///
  /// This may be gVNIC or VirtioNet.
  /// Possible string values are:
  /// - "GVNIC" : GVNIC
  /// - "UNSPECIFIED_NIC_TYPE" : No type specified.
  /// - "VIRTIO_NET" : VIRTIO
  core.String? nicType;

  /// The networking queue count that's specified by users for the network
  /// interface.
  ///
  /// Both Rx and Tx queues will be set to this number. It'll be empty if not
  /// specified by the users.
  core.int? queueCount;

  /// The stack type for this network interface to identify whether the IPv6
  /// feature is enabled or not.
  ///
  /// If not specified, IPV4_ONLY will be used. This field can be both set at
  /// instance creation and update network interface operations.
  /// Possible string values are:
  /// - "IPV4_IPV6" : The network interface can have both IPv4 and IPv6
  /// addresses.
  /// - "IPV4_ONLY" : The network interface will be assigned IPv4 address.
  /// - "UNSPECIFIED_STACK_TYPE"
  core.String? stackType;

  /// The URL of the Subnetwork resource for this instance.
  ///
  /// If the network resource is in legacy mode, do not specify this field. If
  /// the network is in auto subnet mode, specifying the subnetwork is optional.
  /// If the network is in custom subnet mode, specifying the subnetwork is
  /// required. If you specify this field, you can specify the subnetwork as a
  /// full or partial URL. For example, the following are all valid URLs: -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /subnetworks/subnetwork - regions/region/subnetworks/subnetwork
  core.String? subnetwork;

  NetworkInterface({
    this.accessConfigs,
    this.aliasIpRanges,
    this.fingerprint,
    this.ipv6AccessConfigs,
    this.ipv6AccessType,
    this.ipv6Address,
    this.kind,
    this.name,
    this.network,
    this.networkIP,
    this.nicType,
    this.queueCount,
    this.stackType,
    this.subnetwork,
  });

  NetworkInterface.fromJson(core.Map _json)
      : this(
          accessConfigs: _json.containsKey('accessConfigs')
              ? (_json['accessConfigs'] as core.List)
                  .map<AccessConfig>((value) => AccessConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          aliasIpRanges: _json.containsKey('aliasIpRanges')
              ? (_json['aliasIpRanges'] as core.List)
                  .map<AliasIpRange>((value) => AliasIpRange.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          ipv6AccessConfigs: _json.containsKey('ipv6AccessConfigs')
              ? (_json['ipv6AccessConfigs'] as core.List)
                  .map<AccessConfig>((value) => AccessConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          ipv6AccessType: _json.containsKey('ipv6AccessType')
              ? _json['ipv6AccessType'] as core.String
              : null,
          ipv6Address: _json.containsKey('ipv6Address')
              ? _json['ipv6Address'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          networkIP: _json.containsKey('networkIP')
              ? _json['networkIP'] as core.String
              : null,
          nicType: _json.containsKey('nicType')
              ? _json['nicType'] as core.String
              : null,
          queueCount: _json.containsKey('queueCount')
              ? _json['queueCount'] as core.int
              : null,
          stackType: _json.containsKey('stackType')
              ? _json['stackType'] as core.String
              : null,
          subnetwork: _json.containsKey('subnetwork')
              ? _json['subnetwork'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (accessConfigs != null)
          'accessConfigs':
              accessConfigs!.map((value) => value.toJson()).toList(),
        if (aliasIpRanges != null)
          'aliasIpRanges':
              aliasIpRanges!.map((value) => value.toJson()).toList(),
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (ipv6AccessConfigs != null)
          'ipv6AccessConfigs':
              ipv6AccessConfigs!.map((value) => value.toJson()).toList(),
        if (ipv6AccessType != null) 'ipv6AccessType': ipv6AccessType!,
        if (ipv6Address != null) 'ipv6Address': ipv6Address!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (networkIP != null) 'networkIP': networkIP!,
        if (nicType != null) 'nicType': nicType!,
        if (queueCount != null) 'queueCount': queueCount!,
        if (stackType != null) 'stackType': stackType!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
      };
}

class NetworkListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkListWarningData({
    this.key,
    this.value,
  });

  NetworkListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NetworkListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkListWarning({
    this.code,
    this.data,
    this.message,
  });

  NetworkListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NetworkListWarningData>((value) =>
                      NetworkListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of networks.
class NetworkList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Network resources.
  core.List<Network>? items;

  /// Type of resource.
  ///
  /// Always compute#networkList for lists of networks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NetworkListWarning? warning;

  NetworkList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  NetworkList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Network>((value) => Network.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? NetworkListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A network peering attached to a network resource.
///
/// The message includes the peering name, peer network, peering state, and a
/// flag indicating whether Google Compute Engine should automatically create
/// routes for the peering.
class NetworkPeering {
  /// This field will be deprecated soon.
  ///
  /// Use the exchange_subnet_routes field instead. Indicates whether full mesh
  /// connectivity is created and managed automatically between peered networks.
  /// Currently this field should always be true since Google Compute Engine
  /// will automatically create and manage subnetwork routes between two
  /// networks when peering state is ACTIVE.
  core.bool? autoCreateRoutes;

  /// Indicates whether full mesh connectivity is created and managed
  /// automatically between peered networks.
  ///
  /// Currently this field should always be true since Google Compute Engine
  /// will automatically create and manage subnetwork routes between two
  /// networks when peering state is ACTIVE.
  core.bool? exchangeSubnetRoutes;

  /// Whether to export the custom routes to peer network.
  core.bool? exportCustomRoutes;

  /// Whether subnet routes with public IP range are exported.
  ///
  /// The default value is true, all subnet routes are exported. IPv4
  /// special-use ranges are always exported to peers and are not controlled by
  /// this field.
  core.bool? exportSubnetRoutesWithPublicIp;

  /// Whether to import the custom routes from peer network.
  core.bool? importCustomRoutes;

  /// Whether subnet routes with public IP range are imported.
  ///
  /// The default value is false. IPv4 special-use ranges are always imported
  /// from peers and are not controlled by this field.
  core.bool? importSubnetRoutesWithPublicIp;

  /// Name of this peering.
  ///
  /// Provided by the client when the peering is created. The name must comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character
  /// must be a lowercase letter, and all the following characters must be a
  /// dash, lowercase letter, or digit, except the last character, which cannot
  /// be a dash.
  core.String? name;

  /// The URL of the peer network.
  ///
  /// It can be either full URL or partial URL. The peer network may belong to a
  /// different project. If the partial URL does not contain project, it is
  /// assumed that the peer network is in the same project as the current
  /// network.
  core.String? network;

  /// Maximum Transmission Unit in bytes.
  core.int? peerMtu;

  /// State for the peering, either `ACTIVE` or `INACTIVE`.
  ///
  /// The peering is `ACTIVE` when there's a matching configuration in the peer
  /// network.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE" : Matching configuration exists on the peer.
  /// - "INACTIVE" : There is no matching configuration on the peer, including
  /// the case when peer does not exist.
  core.String? state;

  /// Details about the current state of the peering.
  ///
  /// Output only.
  core.String? stateDetails;

  NetworkPeering({
    this.autoCreateRoutes,
    this.exchangeSubnetRoutes,
    this.exportCustomRoutes,
    this.exportSubnetRoutesWithPublicIp,
    this.importCustomRoutes,
    this.importSubnetRoutesWithPublicIp,
    this.name,
    this.network,
    this.peerMtu,
    this.state,
    this.stateDetails,
  });

  NetworkPeering.fromJson(core.Map _json)
      : this(
          autoCreateRoutes: _json.containsKey('autoCreateRoutes')
              ? _json['autoCreateRoutes'] as core.bool
              : null,
          exchangeSubnetRoutes: _json.containsKey('exchangeSubnetRoutes')
              ? _json['exchangeSubnetRoutes'] as core.bool
              : null,
          exportCustomRoutes: _json.containsKey('exportCustomRoutes')
              ? _json['exportCustomRoutes'] as core.bool
              : null,
          exportSubnetRoutesWithPublicIp:
              _json.containsKey('exportSubnetRoutesWithPublicIp')
                  ? _json['exportSubnetRoutesWithPublicIp'] as core.bool
                  : null,
          importCustomRoutes: _json.containsKey('importCustomRoutes')
              ? _json['importCustomRoutes'] as core.bool
              : null,
          importSubnetRoutesWithPublicIp:
              _json.containsKey('importSubnetRoutesWithPublicIp')
                  ? _json['importSubnetRoutesWithPublicIp'] as core.bool
                  : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          peerMtu: _json.containsKey('peerMtu')
              ? _json['peerMtu'] as core.int
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
          stateDetails: _json.containsKey('stateDetails')
              ? _json['stateDetails'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoCreateRoutes != null) 'autoCreateRoutes': autoCreateRoutes!,
        if (exchangeSubnetRoutes != null)
          'exchangeSubnetRoutes': exchangeSubnetRoutes!,
        if (exportCustomRoutes != null)
          'exportCustomRoutes': exportCustomRoutes!,
        if (exportSubnetRoutesWithPublicIp != null)
          'exportSubnetRoutesWithPublicIp': exportSubnetRoutesWithPublicIp!,
        if (importCustomRoutes != null)
          'importCustomRoutes': importCustomRoutes!,
        if (importSubnetRoutesWithPublicIp != null)
          'importSubnetRoutesWithPublicIp': importSubnetRoutesWithPublicIp!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (peerMtu != null) 'peerMtu': peerMtu!,
        if (state != null) 'state': state!,
        if (stateDetails != null) 'stateDetails': stateDetails!,
      };
}

/// A routing configuration attached to a network resource.
///
/// The message includes the list of routers associated with the network, and a
/// flag indicating the type of routing behavior to enforce network-wide.
class NetworkRoutingConfig {
  /// The network-wide routing mode to use.
  ///
  /// If set to REGIONAL, this network's Cloud Routers will only advertise
  /// routes with subnets of this network in the same region as the router. If
  /// set to GLOBAL, this network's Cloud Routers will advertise routes with all
  /// subnets of this network, across regions.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "REGIONAL"
  core.String? routingMode;

  NetworkRoutingConfig({
    this.routingMode,
  });

  NetworkRoutingConfig.fromJson(core.Map _json)
      : this(
          routingMode: _json.containsKey('routingMode')
              ? _json['routingMode'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (routingMode != null) 'routingMode': routingMode!,
      };
}

class NetworksAddPeeringRequest {
  /// This field will be deprecated soon.
  ///
  /// Use exchange_subnet_routes in network_peering instead. Indicates whether
  /// full mesh connectivity is created and managed automatically between peered
  /// networks. Currently this field should always be true since Google Compute
  /// Engine will automatically create and manage subnetwork routes between two
  /// networks when peering state is ACTIVE.
  core.bool? autoCreateRoutes;

  /// Name of the peering, which should conform to RFC1035.
  core.String? name;

  /// Network peering parameters.
  ///
  /// In order to specify route policies for peering using import and export
  /// custom routes, you must specify all peering related parameters (name, peer
  /// network, exchange_subnet_routes) in the network_peering field. The
  /// corresponding fields in NetworksAddPeeringRequest will be deprecated soon.
  NetworkPeering? networkPeering;

  /// URL of the peer network.
  ///
  /// It can be either full URL or partial URL. The peer network may belong to a
  /// different project. If the partial URL does not contain project, it is
  /// assumed that the peer network is in the same project as the current
  /// network.
  core.String? peerNetwork;

  NetworksAddPeeringRequest({
    this.autoCreateRoutes,
    this.name,
    this.networkPeering,
    this.peerNetwork,
  });

  NetworksAddPeeringRequest.fromJson(core.Map _json)
      : this(
          autoCreateRoutes: _json.containsKey('autoCreateRoutes')
              ? _json['autoCreateRoutes'] as core.bool
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          networkPeering: _json.containsKey('networkPeering')
              ? NetworkPeering.fromJson(_json['networkPeering']
                  as core.Map<core.String, core.dynamic>)
              : null,
          peerNetwork: _json.containsKey('peerNetwork')
              ? _json['peerNetwork'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoCreateRoutes != null) 'autoCreateRoutes': autoCreateRoutes!,
        if (name != null) 'name': name!,
        if (networkPeering != null) 'networkPeering': networkPeering!.toJson(),
        if (peerNetwork != null) 'peerNetwork': peerNetwork!,
      };
}

class NetworksGetEffectiveFirewallsResponse {
  /// Effective firewalls from firewall policy.
  core.List<NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy>?
      firewallPolicys;

  /// Effective firewalls on the network.
  core.List<Firewall>? firewalls;

  NetworksGetEffectiveFirewallsResponse({
    this.firewallPolicys,
    this.firewalls,
  });

  NetworksGetEffectiveFirewallsResponse.fromJson(core.Map _json)
      : this(
          firewallPolicys: _json.containsKey('firewallPolicys')
              ? (_json['firewallPolicys'] as core.List)
                  .map<NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy>(
                      (value) =>
                          NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          firewalls: _json.containsKey('firewalls')
              ? (_json['firewalls'] as core.List)
                  .map<Firewall>((value) => Firewall.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (firewallPolicys != null)
          'firewallPolicys':
              firewallPolicys!.map((value) => value.toJson()).toList(),
        if (firewalls != null)
          'firewalls': firewalls!.map((value) => value.toJson()).toList(),
      };
}

class NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
  /// Deprecated, please use short name instead.
  ///
  /// The display name of the firewall policy.
  ///
  /// Output only.
  core.String? displayName;

  /// The name of the firewall policy.
  ///
  /// Output only.
  core.String? name;

  /// The rules that apply to the network.
  core.List<FirewallPolicyRule>? rules;

  /// The short name of the firewall policy.
  ///
  /// Output only.
  core.String? shortName;

  /// The type of the firewall policy.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HIERARCHY"
  /// - "NETWORK"
  /// - "UNSPECIFIED"
  core.String? type;

  NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy({
    this.displayName,
    this.name,
    this.rules,
    this.shortName,
    this.type,
  });

  NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy.fromJson(
      core.Map _json)
      : this(
          displayName: _json.containsKey('displayName')
              ? _json['displayName'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          rules: _json.containsKey('rules')
              ? (_json['rules'] as core.List)
                  .map<FirewallPolicyRule>((value) =>
                      FirewallPolicyRule.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          shortName: _json.containsKey('shortName')
              ? _json['shortName'] as core.String
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
        if (name != null) 'name': name!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (shortName != null) 'shortName': shortName!,
        if (type != null) 'type': type!,
      };
}

class NetworksRemovePeeringRequest {
  /// Name of the peering, which should conform to RFC1035.
  core.String? name;

  NetworksRemovePeeringRequest({
    this.name,
  });

  NetworksRemovePeeringRequest.fromJson(core.Map _json)
      : this(
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
      };
}

class NetworksUpdatePeeringRequest {
  NetworkPeering? networkPeering;

  NetworksUpdatePeeringRequest({
    this.networkPeering,
  });

  NetworksUpdatePeeringRequest.fromJson(core.Map _json)
      : this(
          networkPeering: _json.containsKey('networkPeering')
              ? NetworkPeering.fromJson(_json['networkPeering']
                  as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkPeering != null) 'networkPeering': networkPeering!.toJson(),
      };
}

/// Represents a sole-tenant Node Group resource.
///
/// A sole-tenant node is a physical server that is dedicated to hosting VM
/// instances only for your specific project. Use sole-tenant nodes to keep your
/// instances physically separated from instances in other projects, or to group
/// your instances together on the same host hardware. For more information,
/// read Sole-tenant nodes.
class NodeGroup {
  /// Specifies how autoscaling should behave.
  NodeGroupAutoscalingPolicy? autoscalingPolicy;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The type of the resource.
  ///
  /// Always compute#nodeGroup for node group.
  ///
  /// Output only.
  core.String? kind;

  /// An opaque location hint used to place the Node close to other resources.
  ///
  /// This field is for use by internal tools that use the public API. The
  /// location hint here on the NodeGroup overrides any location_hint present in
  /// the NodeTemplate.
  core.String? locationHint;

  /// Specifies how to handle instances when a node in the group undergoes
  /// maintenance.
  ///
  /// Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP.
  /// The default value is DEFAULT. For more information, see Maintenance
  /// policies.
  /// Possible string values are:
  /// - "DEFAULT" : Allow the node and corresponding instances to retain default
  /// maintenance behavior.
  /// - "MAINTENANCE_POLICY_UNSPECIFIED"
  /// - "MIGRATE_WITHIN_NODE_GROUP" : When maintenance must be done on a node,
  /// the instances on that node will be moved to other nodes in the group.
  /// Instances with onHostMaintenance = MIGRATE will live migrate to their
  /// destinations while instances with onHostMaintenance = TERMINATE will
  /// terminate and then restart on their destination nodes if automaticRestart
  /// = true.
  /// - "RESTART_IN_PLACE" : Instances in this group will restart on the same
  /// node when maintenance has completed. Instances must have onHostMaintenance
  /// = TERMINATE, and they will only restart if automaticRestart = true.
  core.String? maintenancePolicy;
  NodeGroupMaintenanceWindow? maintenanceWindow;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// URL of the node template to create the node group from.
  core.String? nodeTemplate;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The total number of nodes in the node group.
  ///
  /// Output only.
  core.int? size;

  ///
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String? status;

  /// The name of the zone where the node group resides, such as us-central1-a.
  ///
  /// Output only.
  core.String? zone;

  NodeGroup({
    this.autoscalingPolicy,
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.kind,
    this.locationHint,
    this.maintenancePolicy,
    this.maintenanceWindow,
    this.name,
    this.nodeTemplate,
    this.selfLink,
    this.size,
    this.status,
    this.zone,
  });

  NodeGroup.fromJson(core.Map _json)
      : this(
          autoscalingPolicy: _json.containsKey('autoscalingPolicy')
              ? NodeGroupAutoscalingPolicy.fromJson(_json['autoscalingPolicy']
                  as core.Map<core.String, core.dynamic>)
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          locationHint: _json.containsKey('locationHint')
              ? _json['locationHint'] as core.String
              : null,
          maintenancePolicy: _json.containsKey('maintenancePolicy')
              ? _json['maintenancePolicy'] as core.String
              : null,
          maintenanceWindow: _json.containsKey('maintenanceWindow')
              ? NodeGroupMaintenanceWindow.fromJson(_json['maintenanceWindow']
                  as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          nodeTemplate: _json.containsKey('nodeTemplate')
              ? _json['nodeTemplate'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          size: _json.containsKey('size') ? _json['size'] as core.int : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalingPolicy != null)
          'autoscalingPolicy': autoscalingPolicy!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (locationHint != null) 'locationHint': locationHint!,
        if (maintenancePolicy != null) 'maintenancePolicy': maintenancePolicy!,
        if (maintenanceWindow != null)
          'maintenanceWindow': maintenanceWindow!.toJson(),
        if (name != null) 'name': name!,
        if (nodeTemplate != null) 'nodeTemplate': nodeTemplate!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (size != null) 'size': size!,
        if (status != null) 'status': status!,
        if (zone != null) 'zone': zone!,
      };
}

class NodeGroupAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeGroupAggregatedListWarningData({
    this.key,
    this.value,
  });

  NodeGroupAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeGroupAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeGroupAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeGroupAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeGroupAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeGroupAggregatedListWarningData>((value) =>
                      NodeGroupAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeGroupAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeGroupsScopedList resources.
  core.Map<core.String, NodeGroupsScopedList>? items;

  /// Type of resource.Always compute#nodeGroupAggregatedList for aggregated
  /// lists of node groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  NodeGroupAggregatedListWarning? warning;

  NodeGroupAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  NodeGroupAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    NodeGroupsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? NodeGroupAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeGroupAutoscalingPolicy {
  /// The maximum number of nodes that the group should have.
  ///
  /// Must be set if autoscaling is enabled. Maximum value allowed is 100.
  core.int? maxNodes;

  /// The minimum number of nodes that the group should have.
  core.int? minNodes;

  /// The autoscaling mode.
  ///
  /// Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more information, see
  /// Autoscaler modes.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED"
  /// - "OFF" : Autoscaling is disabled.
  /// - "ON" : Autocaling is fully enabled.
  /// - "ONLY_SCALE_OUT" : Autoscaling will only scale out and will not remove
  /// nodes.
  core.String? mode;

  NodeGroupAutoscalingPolicy({
    this.maxNodes,
    this.minNodes,
    this.mode,
  });

  NodeGroupAutoscalingPolicy.fromJson(core.Map _json)
      : this(
          maxNodes: _json.containsKey('maxNodes')
              ? _json['maxNodes'] as core.int
              : null,
          minNodes: _json.containsKey('minNodes')
              ? _json['minNodes'] as core.int
              : null,
          mode: _json.containsKey('mode') ? _json['mode'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxNodes != null) 'maxNodes': maxNodes!,
        if (minNodes != null) 'minNodes': minNodes!,
        if (mode != null) 'mode': mode!,
      };
}

class NodeGroupListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeGroupListWarningData({
    this.key,
    this.value,
  });

  NodeGroupListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeGroupListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeGroupListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeGroupListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeGroupListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeGroupListWarningData>((value) =>
                      NodeGroupListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of nodeGroups.
class NodeGroupList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeGroup resources.
  core.List<NodeGroup>? items;

  /// Type of resource.Always compute#nodeGroupList for lists of node groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NodeGroupListWarning? warning;

  NodeGroupList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  NodeGroupList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<NodeGroup>((value) => NodeGroup.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? NodeGroupListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Time window specified for daily maintenance operations.
///
/// GCE's internal maintenance will be performed within this window.
class NodeGroupMaintenanceWindow {
  /// A predetermined duration for the window, automatically chosen to be the
  /// smallest possible in the given scenario.
  ///
  /// Output only.
  Duration? maintenanceDuration;

  /// Start time of the window.
  ///
  /// This must be in UTC format that resolves to one of 00:00, 04:00, 08:00,
  /// 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
  core.String? startTime;

  NodeGroupMaintenanceWindow({
    this.maintenanceDuration,
    this.startTime,
  });

  NodeGroupMaintenanceWindow.fromJson(core.Map _json)
      : this(
          maintenanceDuration: _json.containsKey('maintenanceDuration')
              ? Duration.fromJson(_json['maintenanceDuration']
                  as core.Map<core.String, core.dynamic>)
              : null,
          startTime: _json.containsKey('startTime')
              ? _json['startTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maintenanceDuration != null)
          'maintenanceDuration': maintenanceDuration!.toJson(),
        if (startTime != null) 'startTime': startTime!,
      };
}

class NodeGroupNode {
  /// Accelerators for this node.
  core.List<AcceleratorConfig>? accelerators;

  /// CPU overcommit.
  /// Possible string values are:
  /// - "CPU_OVERCOMMIT_TYPE_UNSPECIFIED"
  /// - "ENABLED"
  /// - "NONE"
  core.String? cpuOvercommitType;

  /// Local disk configurations.
  core.List<LocalDisk>? disks;

  /// Instances scheduled on this node.
  core.List<core.String>? instances;

  /// The name of the node.
  core.String? name;

  /// The type of this node.
  core.String? nodeType;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Binding properties for the physical server.
  ServerBinding? serverBinding;

  /// Server ID associated with this node.
  core.String? serverId;

  ///
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  /// - "REPAIRING"
  core.String? status;

  NodeGroupNode({
    this.accelerators,
    this.cpuOvercommitType,
    this.disks,
    this.instances,
    this.name,
    this.nodeType,
    this.satisfiesPzs,
    this.serverBinding,
    this.serverId,
    this.status,
  });

  NodeGroupNode.fromJson(core.Map _json)
      : this(
          accelerators: _json.containsKey('accelerators')
              ? (_json['accelerators'] as core.List)
                  .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          cpuOvercommitType: _json.containsKey('cpuOvercommitType')
              ? _json['cpuOvercommitType'] as core.String
              : null,
          disks: _json.containsKey('disks')
              ? (_json['disks'] as core.List)
                  .map<LocalDisk>((value) => LocalDisk.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          nodeType: _json.containsKey('nodeType')
              ? _json['nodeType'] as core.String
              : null,
          satisfiesPzs: _json.containsKey('satisfiesPzs')
              ? _json['satisfiesPzs'] as core.bool
              : null,
          serverBinding: _json.containsKey('serverBinding')
              ? ServerBinding.fromJson(
                  _json['serverBinding'] as core.Map<core.String, core.dynamic>)
              : null,
          serverId: _json.containsKey('serverId')
              ? _json['serverId'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (accelerators != null)
          'accelerators': accelerators!.map((value) => value.toJson()).toList(),
        if (cpuOvercommitType != null) 'cpuOvercommitType': cpuOvercommitType!,
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (instances != null) 'instances': instances!,
        if (name != null) 'name': name!,
        if (nodeType != null) 'nodeType': nodeType!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (serverBinding != null) 'serverBinding': serverBinding!.toJson(),
        if (serverId != null) 'serverId': serverId!,
        if (status != null) 'status': status!,
      };
}

class NodeGroupsAddNodesRequest {
  /// Count of additional nodes to be added to the node group.
  core.int? additionalNodeCount;

  NodeGroupsAddNodesRequest({
    this.additionalNodeCount,
  });

  NodeGroupsAddNodesRequest.fromJson(core.Map _json)
      : this(
          additionalNodeCount: _json.containsKey('additionalNodeCount')
              ? _json['additionalNodeCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (additionalNodeCount != null)
          'additionalNodeCount': additionalNodeCount!,
      };
}

class NodeGroupsDeleteNodesRequest {
  /// Names of the nodes to delete.
  core.List<core.String>? nodes;

  NodeGroupsDeleteNodesRequest({
    this.nodes,
  });

  NodeGroupsDeleteNodesRequest.fromJson(core.Map _json)
      : this(
          nodes: _json.containsKey('nodes')
              ? (_json['nodes'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodes != null) 'nodes': nodes!,
      };
}

class NodeGroupsListNodesWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeGroupsListNodesWarningData({
    this.key,
    this.value,
  });

  NodeGroupsListNodesWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeGroupsListNodesWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeGroupsListNodesWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeGroupsListNodesWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeGroupsListNodesWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeGroupsListNodesWarningData>((value) =>
                      NodeGroupsListNodesWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeGroupsListNodes {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Node resources.
  core.List<NodeGroupNode>? items;

  /// The resource type, which is always compute.nodeGroupsListNodes for the
  /// list of nodes in the specified node group.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NodeGroupsListNodesWarning? warning;

  NodeGroupsListNodes({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  NodeGroupsListNodes.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<NodeGroupNode>((value) => NodeGroupNode.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? NodeGroupsListNodesWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeGroupsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeGroupsScopedListWarningData({
    this.key,
    this.value,
  });

  NodeGroupsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the nodeGroup list is empty.
///
/// Output only.
class NodeGroupsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeGroupsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeGroupsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeGroupsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeGroupsScopedListWarningData>((value) =>
                      NodeGroupsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeGroupsScopedList {
  /// A list of node groups contained in this scope.
  ///
  /// Output only.
  core.List<NodeGroup>? nodeGroups;

  /// An informational warning that appears when the nodeGroup list is empty.
  ///
  /// Output only.
  NodeGroupsScopedListWarning? warning;

  NodeGroupsScopedList({
    this.nodeGroups,
    this.warning,
  });

  NodeGroupsScopedList.fromJson(core.Map _json)
      : this(
          nodeGroups: _json.containsKey('nodeGroups')
              ? (_json['nodeGroups'] as core.List)
                  .map<NodeGroup>((value) => NodeGroup.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? NodeGroupsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodeGroups != null)
          'nodeGroups': nodeGroups!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeGroupsSetNodeTemplateRequest {
  /// Full or partial URL of the node template resource to be updated for this
  /// node group.
  core.String? nodeTemplate;

  NodeGroupsSetNodeTemplateRequest({
    this.nodeTemplate,
  });

  NodeGroupsSetNodeTemplateRequest.fromJson(core.Map _json)
      : this(
          nodeTemplate: _json.containsKey('nodeTemplate')
              ? _json['nodeTemplate'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodeTemplate != null) 'nodeTemplate': nodeTemplate!,
      };
}

/// Represent a sole-tenant Node Template resource.
///
/// You can use a template to define properties for nodes in a node group. For
/// more information, read Creating node groups and instances.
class NodeTemplate {
  core.List<AcceleratorConfig>? accelerators;

  /// CPU overcommit.
  /// Possible string values are:
  /// - "CPU_OVERCOMMIT_TYPE_UNSPECIFIED"
  /// - "ENABLED"
  /// - "NONE"
  core.String? cpuOvercommitType;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;
  core.List<LocalDisk>? disks;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The type of the resource.
  ///
  /// Always compute#nodeTemplate for node templates.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Labels to use for node affinity, which will be used in instance
  /// scheduling.
  core.Map<core.String, core.String>? nodeAffinityLabels;

  /// The node type to use for nodes group that are created from this template.
  core.String? nodeType;

  /// The flexible properties of the desired node type.
  ///
  /// Node groups that use this node template will create nodes of a type that
  /// matches these properties. This field is mutually exclusive with the
  /// node_type property; you can only define one or the other, but not both.
  NodeTemplateNodeTypeFlexibility? nodeTypeFlexibility;

  /// The name of the region where the node template resides, such as
  /// us-central1.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Sets the binding properties for the physical server.
  ///
  /// Valid values include: - *\[Default\]* RESTART_NODE_ON_ANY_SERVER: Restarts
  /// VMs on any available physical server - RESTART_NODE_ON_MINIMAL_SERVER:
  /// Restarts VMs on the same physical server whenever possible See Sole-tenant
  /// node options for more information.
  ServerBinding? serverBinding;

  /// The status of the node template.
  ///
  /// One of the following values: CREATING, READY, and DELETING.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING" : Resources are being allocated.
  /// - "DELETING" : The node template is currently being deleted.
  /// - "INVALID" : Invalid status.
  /// - "READY" : The node template is ready.
  core.String? status;

  /// An optional, human-readable explanation of the status.
  ///
  /// Output only.
  core.String? statusMessage;

  NodeTemplate({
    this.accelerators,
    this.cpuOvercommitType,
    this.creationTimestamp,
    this.description,
    this.disks,
    this.id,
    this.kind,
    this.name,
    this.nodeAffinityLabels,
    this.nodeType,
    this.nodeTypeFlexibility,
    this.region,
    this.selfLink,
    this.serverBinding,
    this.status,
    this.statusMessage,
  });

  NodeTemplate.fromJson(core.Map _json)
      : this(
          accelerators: _json.containsKey('accelerators')
              ? (_json['accelerators'] as core.List)
                  .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          cpuOvercommitType: _json.containsKey('cpuOvercommitType')
              ? _json['cpuOvercommitType'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          disks: _json.containsKey('disks')
              ? (_json['disks'] as core.List)
                  .map<LocalDisk>((value) => LocalDisk.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          nodeAffinityLabels: _json.containsKey('nodeAffinityLabels')
              ? (_json['nodeAffinityLabels']
                      as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          nodeType: _json.containsKey('nodeType')
              ? _json['nodeType'] as core.String
              : null,
          nodeTypeFlexibility: _json.containsKey('nodeTypeFlexibility')
              ? NodeTemplateNodeTypeFlexibility.fromJson(
                  _json['nodeTypeFlexibility']
                      as core.Map<core.String, core.dynamic>)
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          serverBinding: _json.containsKey('serverBinding')
              ? ServerBinding.fromJson(
                  _json['serverBinding'] as core.Map<core.String, core.dynamic>)
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          statusMessage: _json.containsKey('statusMessage')
              ? _json['statusMessage'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (accelerators != null)
          'accelerators': accelerators!.map((value) => value.toJson()).toList(),
        if (cpuOvercommitType != null) 'cpuOvercommitType': cpuOvercommitType!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (nodeAffinityLabels != null)
          'nodeAffinityLabels': nodeAffinityLabels!,
        if (nodeType != null) 'nodeType': nodeType!,
        if (nodeTypeFlexibility != null)
          'nodeTypeFlexibility': nodeTypeFlexibility!.toJson(),
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (serverBinding != null) 'serverBinding': serverBinding!.toJson(),
        if (status != null) 'status': status!,
        if (statusMessage != null) 'statusMessage': statusMessage!,
      };
}

class NodeTemplateAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTemplateAggregatedListWarningData({
    this.key,
    this.value,
  });

  NodeTemplateAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeTemplateAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTemplateAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTemplateAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeTemplateAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeTemplateAggregatedListWarningData>((value) =>
                      NodeTemplateAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeTemplateAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeTemplatesScopedList resources.
  core.Map<core.String, NodeTemplatesScopedList>? items;

  /// Type of resource.Always compute#nodeTemplateAggregatedList for aggregated
  /// lists of node templates.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  NodeTemplateAggregatedListWarning? warning;

  NodeTemplateAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  NodeTemplateAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    NodeTemplatesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? NodeTemplateAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeTemplateListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTemplateListWarningData({
    this.key,
    this.value,
  });

  NodeTemplateListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeTemplateListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTemplateListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTemplateListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeTemplateListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeTemplateListWarningData>((value) =>
                      NodeTemplateListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of node templates.
class NodeTemplateList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeTemplate resources.
  core.List<NodeTemplate>? items;

  /// Type of resource.Always compute#nodeTemplateList for lists of node
  /// templates.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NodeTemplateListWarning? warning;

  NodeTemplateList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  NodeTemplateList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<NodeTemplate>((value) => NodeTemplate.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? NodeTemplateListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeTemplateNodeTypeFlexibility {
  core.String? cpus;
  core.String? localSsd;
  core.String? memory;

  NodeTemplateNodeTypeFlexibility({
    this.cpus,
    this.localSsd,
    this.memory,
  });

  NodeTemplateNodeTypeFlexibility.fromJson(core.Map _json)
      : this(
          cpus: _json.containsKey('cpus') ? _json['cpus'] as core.String : null,
          localSsd: _json.containsKey('localSsd')
              ? _json['localSsd'] as core.String
              : null,
          memory: _json.containsKey('memory')
              ? _json['memory'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cpus != null) 'cpus': cpus!,
        if (localSsd != null) 'localSsd': localSsd!,
        if (memory != null) 'memory': memory!,
      };
}

class NodeTemplatesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTemplatesScopedListWarningData({
    this.key,
    this.value,
  });

  NodeTemplatesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the node templates list is empty.
///
/// Output only.
class NodeTemplatesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTemplatesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTemplatesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeTemplatesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeTemplatesScopedListWarningData>((value) =>
                      NodeTemplatesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeTemplatesScopedList {
  /// A list of node templates contained in this scope.
  ///
  /// Output only.
  core.List<NodeTemplate>? nodeTemplates;

  /// An informational warning that appears when the node templates list is
  /// empty.
  ///
  /// Output only.
  NodeTemplatesScopedListWarning? warning;

  NodeTemplatesScopedList({
    this.nodeTemplates,
    this.warning,
  });

  NodeTemplatesScopedList.fromJson(core.Map _json)
      : this(
          nodeTemplates: _json.containsKey('nodeTemplates')
              ? (_json['nodeTemplates'] as core.List)
                  .map<NodeTemplate>((value) => NodeTemplate.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? NodeTemplatesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodeTemplates != null)
          'nodeTemplates':
              nodeTemplates!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represent a sole-tenant Node Type resource.
///
/// Each node within a node group must have a node type. A node type specifies
/// the total amount of cores and memory for that node. Currently, the only
/// available node type is n1-node-96-624 node type that has 96 vCPUs and 624 GB
/// of memory, available in multiple zones. For more information read Node
/// types.
class NodeType {
  /// The CPU platform used by this node type.
  ///
  /// Output only.
  core.String? cpuPlatform;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this node type.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// An optional textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The number of virtual CPUs that are available to the node type.
  ///
  /// Output only.
  core.int? guestCpus;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The type of the resource.
  ///
  /// Always compute#nodeType for node types.
  ///
  /// Output only.
  core.String? kind;

  /// Local SSD available to the node type, defined in GB.
  ///
  /// Output only.
  core.int? localSsdGb;

  /// The amount of physical memory available to the node type, defined in MB.
  ///
  /// Output only.
  core.int? memoryMb;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The name of the zone where the node type resides, such as us-central1-a.
  ///
  /// Output only.
  core.String? zone;

  NodeType({
    this.cpuPlatform,
    this.creationTimestamp,
    this.deprecated,
    this.description,
    this.guestCpus,
    this.id,
    this.kind,
    this.localSsdGb,
    this.memoryMb,
    this.name,
    this.selfLink,
    this.zone,
  });

  NodeType.fromJson(core.Map _json)
      : this(
          cpuPlatform: _json.containsKey('cpuPlatform')
              ? _json['cpuPlatform'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          deprecated: _json.containsKey('deprecated')
              ? DeprecationStatus.fromJson(
                  _json['deprecated'] as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          guestCpus: _json.containsKey('guestCpus')
              ? _json['guestCpus'] as core.int
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          localSsdGb: _json.containsKey('localSsdGb')
              ? _json['localSsdGb'] as core.int
              : null,
          memoryMb: _json.containsKey('memoryMb')
              ? _json['memoryMb'] as core.int
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cpuPlatform != null) 'cpuPlatform': cpuPlatform!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (guestCpus != null) 'guestCpus': guestCpus!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (localSsdGb != null) 'localSsdGb': localSsdGb!,
        if (memoryMb != null) 'memoryMb': memoryMb!,
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (zone != null) 'zone': zone!,
      };
}

class NodeTypeAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTypeAggregatedListWarningData({
    this.key,
    this.value,
  });

  NodeTypeAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeTypeAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTypeAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTypeAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeTypeAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeTypeAggregatedListWarningData>((value) =>
                      NodeTypeAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeTypeAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeTypesScopedList resources.
  core.Map<core.String, NodeTypesScopedList>? items;

  /// Type of resource.Always compute#nodeTypeAggregatedList for aggregated
  /// lists of node types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  NodeTypeAggregatedListWarning? warning;

  NodeTypeAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  NodeTypeAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    NodeTypesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? NodeTypeAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTypeListWarningData({
    this.key,
    this.value,
  });

  NodeTypeListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTypeListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeTypeListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeTypeListWarningData>((value) =>
                      NodeTypeListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of node types.
class NodeTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeType resources.
  core.List<NodeType>? items;

  /// Type of resource.Always compute#nodeTypeList for lists of node types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NodeTypeListWarning? warning;

  NodeTypeList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  NodeTypeList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<NodeType>((value) => NodeType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? NodeTypeListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeTypesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTypesScopedListWarningData({
    this.key,
    this.value,
  });

  NodeTypesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the node types list is empty.
///
/// Output only.
class NodeTypesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTypesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTypesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  NodeTypesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NodeTypesScopedListWarningData>((value) =>
                      NodeTypesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeTypesScopedList {
  /// A list of node types contained in this scope.
  ///
  /// Output only.
  core.List<NodeType>? nodeTypes;

  /// An informational warning that appears when the node types list is empty.
  ///
  /// Output only.
  NodeTypesScopedListWarning? warning;

  NodeTypesScopedList({
    this.nodeTypes,
    this.warning,
  });

  NodeTypesScopedList.fromJson(core.Map _json)
      : this(
          nodeTypes: _json.containsKey('nodeTypes')
              ? (_json['nodeTypes'] as core.List)
                  .map<NodeType>((value) => NodeType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? NodeTypesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodeTypes != null)
          'nodeTypes': nodeTypes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a notification endpoint.
///
/// A notification endpoint resource defines an endpoint to receive
/// notifications when there are status changes detected by the associated
/// health check service. For more information, see Health checks overview.
class NotificationEndpoint {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Settings of the gRPC notification endpoint including the endpoint URL and
  /// the retry duration.
  NotificationEndpointGrpcSettings? grpcSettings;

  /// A unique identifier for this resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#notificationEndpoint for notification endpoints.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the region where the notification endpoint resides.
  ///
  /// This field applies only to the regional resource. You must specify this
  /// field as part of the HTTP request URL. It is not settable as a field in
  /// the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  NotificationEndpoint({
    this.creationTimestamp,
    this.description,
    this.grpcSettings,
    this.id,
    this.kind,
    this.name,
    this.region,
    this.selfLink,
  });

  NotificationEndpoint.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          grpcSettings: _json.containsKey('grpcSettings')
              ? NotificationEndpointGrpcSettings.fromJson(
                  _json['grpcSettings'] as core.Map<core.String, core.dynamic>)
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (grpcSettings != null) 'grpcSettings': grpcSettings!.toJson(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Represents a gRPC setting that describes one gRPC notification endpoint and
/// the retry duration attempting to send notification to this endpoint.
class NotificationEndpointGrpcSettings {
  /// If specified, this field is used to set the authority header by the sender
  /// of notifications.
  ///
  /// See https://tools.ietf.org/html/rfc7540#section-8.1.2.3
  ///
  /// Optional.
  core.String? authority;

  /// Endpoint to which gRPC notifications are sent.
  ///
  /// This must be a valid gRPCLB DNS name.
  core.String? endpoint;

  /// If specified, this field is used to populate the "name" field in gRPC
  /// requests.
  ///
  /// Optional.
  core.String? payloadName;

  /// This field is used to configure how often to send a full update of all
  /// non-healthy backends.
  ///
  /// If unspecified, full updates are not sent. If specified, must be in the
  /// range between 600 seconds to 3600 seconds. Nanos are disallowed.
  ///
  /// Optional.
  Duration? resendInterval;

  /// How much time (in seconds) is spent attempting notification retries until
  /// a successful response is received.
  ///
  /// Default is 30s. Limit is 20m (1200s). Must be a positive number.
  core.int? retryDurationSec;

  NotificationEndpointGrpcSettings({
    this.authority,
    this.endpoint,
    this.payloadName,
    this.resendInterval,
    this.retryDurationSec,
  });

  NotificationEndpointGrpcSettings.fromJson(core.Map _json)
      : this(
          authority: _json.containsKey('authority')
              ? _json['authority'] as core.String
              : null,
          endpoint: _json.containsKey('endpoint')
              ? _json['endpoint'] as core.String
              : null,
          payloadName: _json.containsKey('payloadName')
              ? _json['payloadName'] as core.String
              : null,
          resendInterval: _json.containsKey('resendInterval')
              ? Duration.fromJson(_json['resendInterval']
                  as core.Map<core.String, core.dynamic>)
              : null,
          retryDurationSec: _json.containsKey('retryDurationSec')
              ? _json['retryDurationSec'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (authority != null) 'authority': authority!,
        if (endpoint != null) 'endpoint': endpoint!,
        if (payloadName != null) 'payloadName': payloadName!,
        if (resendInterval != null) 'resendInterval': resendInterval!.toJson(),
        if (retryDurationSec != null) 'retryDurationSec': retryDurationSec!,
      };
}

class NotificationEndpointListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NotificationEndpointListWarningData({
    this.key,
    this.value,
  });

  NotificationEndpointListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NotificationEndpointListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NotificationEndpointListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NotificationEndpointListWarning({
    this.code,
    this.data,
    this.message,
  });

  NotificationEndpointListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<NotificationEndpointListWarningData>((value) =>
                      NotificationEndpointListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NotificationEndpointList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NotificationEndpoint resources.
  core.List<NotificationEndpoint>? items;

  /// Type of the resource.
  ///
  /// Always compute#notificationEndpoint for notification endpoints.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NotificationEndpointListWarning? warning;

  NotificationEndpointList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  NotificationEndpointList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<NotificationEndpoint>((value) =>
                      NotificationEndpoint.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? NotificationEndpointListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class OperationErrorErrors {
  /// The error type identifier for this error.
  ///
  /// Output only.
  core.String? code;

  /// Indicates the field in the request that caused the error.
  ///
  /// This property is optional.
  ///
  /// Output only.
  core.String? location;

  /// An optional, human-readable error message.
  ///
  /// Output only.
  core.String? message;

  OperationErrorErrors({
    this.code,
    this.location,
    this.message,
  });

  OperationErrorErrors.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          location: _json.containsKey('location')
              ? _json['location'] as core.String
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (location != null) 'location': location!,
        if (message != null) 'message': message!,
      };
}

/// If errors are generated during processing of the operation, this field will
/// be populated.
///
/// Output only.
class OperationError {
  /// The array of errors encountered while processing this operation.
  ///
  /// Output only.
  core.List<OperationErrorErrors>? errors;

  OperationError({
    this.errors,
  });

  OperationError.fromJson(core.Map _json)
      : this(
          errors: _json.containsKey('errors')
              ? (_json['errors'] as core.List)
                  .map<OperationErrorErrors>((value) =>
                      OperationErrorErrors.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (errors != null)
          'errors': errors!.map((value) => value.toJson()).toList(),
      };
}

class OperationWarningsData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  OperationWarningsData({
    this.key,
    this.value,
  });

  OperationWarningsData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

class OperationWarnings {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<OperationWarningsData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  OperationWarnings({
    this.code,
    this.data,
    this.message,
  });

  OperationWarnings.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<OperationWarningsData>((value) =>
                      OperationWarningsData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Represents an Operation resource.
///
/// Google Compute Engine has three Operation resources: *
/// \[Global\](/compute/docs/reference/rest/v1/globalOperations) *
/// \[Regional\](/compute/docs/reference/rest/v1/regionOperations) *
/// \[Zonal\](/compute/docs/reference/rest/v1/zoneOperations) You can use an
/// operation resource to manage asynchronous API requests. For more
/// information, read Handling API responses. Operations can be global, regional
/// or zonal. - For global operations, use the `globalOperations` resource. -
/// For regional operations, use the `regionOperations` resource. - For zonal
/// operations, use the `zonalOperations` resource. For more information, read
/// Global, Regional, and Zonal Resources.
class Operation {
  /// The value of `requestId` if you provided it in the request.
  ///
  /// Not present otherwise.
  ///
  /// Output only.
  core.String? clientOperationId;

  /// This field is deprecated.
  ///
  /// Deprecated.
  core.String? creationTimestamp;

  /// A textual description of the operation, which is set when the operation is
  /// created.
  ///
  /// Output only.
  core.String? description;

  /// The time that this operation was completed.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? endTime;

  /// If errors are generated during processing of the operation, this field
  /// will be populated.
  ///
  /// Output only.
  OperationError? error;

  /// If the operation fails, this field contains the HTTP error message that
  /// was returned, such as `NOT FOUND`.
  ///
  /// Output only.
  core.String? httpErrorMessage;

  /// If the operation fails, this field contains the HTTP error status code
  /// that was returned.
  ///
  /// For example, a `404` means the resource was not found.
  ///
  /// Output only.
  core.int? httpErrorStatusCode;

  /// The unique identifier for the operation.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The time that this operation was requested.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? insertTime;

  /// Type of the resource.
  ///
  /// Always `compute#operation` for Operation resources.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the operation.
  ///
  /// Output only.
  core.String? name;

  /// An ID that represents a group of operations, such as when a group of
  /// operations results from a `bulkInsert` API request.
  ///
  /// Output only.
  core.String? operationGroupId;

  /// The type of operation, such as `insert`, `update`, or `delete`, and so on.
  ///
  /// Output only.
  core.String? operationType;

  /// An optional progress indicator that ranges from 0 to 100.
  ///
  /// There is no requirement that this be linear or support any granularity of
  /// operations. This should not be used to guess when the operation will be
  /// complete. This number should monotonically increase as the operation
  /// progresses.
  ///
  /// Output only.
  core.int? progress;

  /// The URL of the region where the operation resides.
  ///
  /// Only applicable when performing regional operations.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The time that this operation was started by the server.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? startTime;

  /// The status of the operation, which can be one of the following: `PENDING`,
  /// `RUNNING`, or `DONE`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DONE"
  /// - "PENDING"
  /// - "RUNNING"
  core.String? status;

  /// An optional textual description of the current status of the operation.
  ///
  /// Output only.
  core.String? statusMessage;

  /// The unique target ID, which identifies a specific incarnation of the
  /// target resource.
  ///
  /// Output only.
  core.String? targetId;

  /// The URL of the resource that the operation modifies.
  ///
  /// For operations related to creating a snapshot, this points to the
  /// persistent disk that the snapshot was created from.
  ///
  /// Output only.
  core.String? targetLink;

  /// User who requested the operation, for example: `user@example.com`.
  ///
  /// Output only.
  core.String? user;

  /// If warning messages are generated during processing of the operation, this
  /// field will be populated.
  ///
  /// Output only.
  core.List<OperationWarnings>? warnings;

  /// The URL of the zone where the operation resides.
  ///
  /// Only applicable when performing per-zone operations.
  ///
  /// Output only.
  core.String? zone;

  Operation({
    this.clientOperationId,
    this.creationTimestamp,
    this.description,
    this.endTime,
    this.error,
    this.httpErrorMessage,
    this.httpErrorStatusCode,
    this.id,
    this.insertTime,
    this.kind,
    this.name,
    this.operationGroupId,
    this.operationType,
    this.progress,
    this.region,
    this.selfLink,
    this.startTime,
    this.status,
    this.statusMessage,
    this.targetId,
    this.targetLink,
    this.user,
    this.warnings,
    this.zone,
  });

  Operation.fromJson(core.Map _json)
      : this(
          clientOperationId: _json.containsKey('clientOperationId')
              ? _json['clientOperationId'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          endTime: _json.containsKey('endTime')
              ? _json['endTime'] as core.String
              : null,
          error: _json.containsKey('error')
              ? OperationError.fromJson(
                  _json['error'] as core.Map<core.String, core.dynamic>)
              : null,
          httpErrorMessage: _json.containsKey('httpErrorMessage')
              ? _json['httpErrorMessage'] as core.String
              : null,
          httpErrorStatusCode: _json.containsKey('httpErrorStatusCode')
              ? _json['httpErrorStatusCode'] as core.int
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          insertTime: _json.containsKey('insertTime')
              ? _json['insertTime'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          operationGroupId: _json.containsKey('operationGroupId')
              ? _json['operationGroupId'] as core.String
              : null,
          operationType: _json.containsKey('operationType')
              ? _json['operationType'] as core.String
              : null,
          progress: _json.containsKey('progress')
              ? _json['progress'] as core.int
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          startTime: _json.containsKey('startTime')
              ? _json['startTime'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          statusMessage: _json.containsKey('statusMessage')
              ? _json['statusMessage'] as core.String
              : null,
          targetId: _json.containsKey('targetId')
              ? _json['targetId'] as core.String
              : null,
          targetLink: _json.containsKey('targetLink')
              ? _json['targetLink'] as core.String
              : null,
          user: _json.containsKey('user') ? _json['user'] as core.String : null,
          warnings: _json.containsKey('warnings')
              ? (_json['warnings'] as core.List)
                  .map<OperationWarnings>((value) => OperationWarnings.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientOperationId != null) 'clientOperationId': clientOperationId!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!.toJson(),
        if (httpErrorMessage != null) 'httpErrorMessage': httpErrorMessage!,
        if (httpErrorStatusCode != null)
          'httpErrorStatusCode': httpErrorStatusCode!,
        if (id != null) 'id': id!,
        if (insertTime != null) 'insertTime': insertTime!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (operationGroupId != null) 'operationGroupId': operationGroupId!,
        if (operationType != null) 'operationType': operationType!,
        if (progress != null) 'progress': progress!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (startTime != null) 'startTime': startTime!,
        if (status != null) 'status': status!,
        if (statusMessage != null) 'statusMessage': statusMessage!,
        if (targetId != null) 'targetId': targetId!,
        if (targetLink != null) 'targetLink': targetLink!,
        if (user != null) 'user': user!,
        if (warnings != null)
          'warnings': warnings!.map((value) => value.toJson()).toList(),
        if (zone != null) 'zone': zone!,
      };
}

class OperationAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  OperationAggregatedListWarningData({
    this.key,
    this.value,
  });

  OperationAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class OperationAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<OperationAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  OperationAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  OperationAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<OperationAggregatedListWarningData>((value) =>
                      OperationAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class OperationAggregatedList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A map of scoped operation lists.
  ///
  /// Output only.
  core.Map<core.String, OperationsScopedList>? items;

  /// Type of resource.
  ///
  /// Always `compute#operationAggregatedList` for aggregated lists of
  /// operations.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than `maxResults`, use the
  /// `nextPageToken` as a value for the query parameter `pageToken` in the next
  /// list request. Subsequent list requests will have their own `nextPageToken`
  /// to continue paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  OperationAggregatedListWarning? warning;

  OperationAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  OperationAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    OperationsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? OperationAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class OperationListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  OperationListWarningData({
    this.key,
    this.value,
  });

  OperationListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class OperationListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<OperationListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  OperationListWarning({
    this.code,
    this.data,
    this.message,
  });

  OperationListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<OperationListWarningData>((value) =>
                      OperationListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Operation resources.
class OperationList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Operation resources.
  ///
  /// Output only.
  core.List<Operation>? items;

  /// Type of resource.
  ///
  /// Always `compute#operations` for Operations resource.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than `maxResults`, use the
  /// `nextPageToken` as a value for the query parameter `pageToken` in the next
  /// list request. Subsequent list requests will have their own `nextPageToken`
  /// to continue paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  OperationListWarning? warning;

  OperationList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  OperationList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Operation>((value) => Operation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? OperationListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class OperationsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  OperationsScopedListWarningData({
    this.key,
    this.value,
  });

  OperationsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of operations when the list is
/// empty.
///
/// Output only.
class OperationsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<OperationsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  OperationsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  OperationsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<OperationsScopedListWarningData>((value) =>
                      OperationsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class OperationsScopedList {
  /// A list of operations contained in this scope.
  ///
  /// Output only.
  core.List<Operation>? operations;

  /// Informational warning which replaces the list of operations when the list
  /// is empty.
  ///
  /// Output only.
  OperationsScopedListWarning? warning;

  OperationsScopedList({
    this.operations,
    this.warning,
  });

  OperationsScopedList.fromJson(core.Map _json)
      : this(
          operations: _json.containsKey('operations')
              ? (_json['operations'] as core.List)
                  .map<Operation>((value) => Operation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? OperationsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (operations != null)
          'operations': operations!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Settings controlling the eviction of unhealthy hosts from the load balancing
/// pool for the backend service.
class OutlierDetection {
  /// The base time that a host is ejected for.
  ///
  /// The real ejection time is equal to the base ejection time multiplied by
  /// the number of times the host has been ejected. Defaults to 30000ms or 30s.
  Duration? baseEjectionTime;

  /// Number of errors before a host is ejected from the connection pool.
  ///
  /// When the backend host is accessed over HTTP, a 5xx return code qualifies
  /// as an error. Defaults to 5.
  core.int? consecutiveErrors;

  /// The number of consecutive gateway failures (502, 503, 504 status or
  /// connection errors that are mapped to one of those status codes) before a
  /// consecutive gateway failure ejection occurs.
  ///
  /// Defaults to 3.
  core.int? consecutiveGatewayFailure;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through consecutive 5xx.
  ///
  /// This setting can be used to disable ejection or to ramp it up slowly.
  /// Defaults to 0.
  core.int? enforcingConsecutiveErrors;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through consecutive gateway failures.
  ///
  /// This setting can be used to disable ejection or to ramp it up slowly.
  /// Defaults to 100.
  core.int? enforcingConsecutiveGatewayFailure;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through success rate statistics.
  ///
  /// This setting can be used to disable ejection or to ramp it up slowly.
  /// Defaults to 100.
  core.int? enforcingSuccessRate;

  /// Time interval between ejection analysis sweeps.
  ///
  /// This can result in both new ejections as well as hosts being returned to
  /// service. Defaults to 1 second.
  Duration? interval;

  /// Maximum percentage of hosts in the load balancing pool for the backend
  /// service that can be ejected.
  ///
  /// Defaults to 50%.
  core.int? maxEjectionPercent;

  /// The number of hosts in a cluster that must have enough request volume to
  /// detect success rate outliers.
  ///
  /// If the number of hosts is less than this setting, outlier detection via
  /// success rate statistics is not performed for any host in the cluster.
  /// Defaults to 5.
  core.int? successRateMinimumHosts;

  /// The minimum number of total requests that must be collected in one
  /// interval (as defined by the interval duration above) to include this host
  /// in success rate based outlier detection.
  ///
  /// If the volume is lower than this setting, outlier detection via success
  /// rate statistics is not performed for that host. Defaults to 100.
  core.int? successRateRequestVolume;

  /// This factor is used to determine the ejection threshold for success rate
  /// outlier ejection.
  ///
  /// The ejection threshold is the difference between the mean success rate,
  /// and the product of this factor and the standard deviation of the mean
  /// success rate: mean - (stdev * success_rate_stdev_factor). This factor is
  /// divided by a thousand to get a double. That is, if the desired factor is
  /// 1.9, the runtime value should be 1900. Defaults to 1900.
  core.int? successRateStdevFactor;

  OutlierDetection({
    this.baseEjectionTime,
    this.consecutiveErrors,
    this.consecutiveGatewayFailure,
    this.enforcingConsecutiveErrors,
    this.enforcingConsecutiveGatewayFailure,
    this.enforcingSuccessRate,
    this.interval,
    this.maxEjectionPercent,
    this.successRateMinimumHosts,
    this.successRateRequestVolume,
    this.successRateStdevFactor,
  });

  OutlierDetection.fromJson(core.Map _json)
      : this(
          baseEjectionTime: _json.containsKey('baseEjectionTime')
              ? Duration.fromJson(_json['baseEjectionTime']
                  as core.Map<core.String, core.dynamic>)
              : null,
          consecutiveErrors: _json.containsKey('consecutiveErrors')
              ? _json['consecutiveErrors'] as core.int
              : null,
          consecutiveGatewayFailure:
              _json.containsKey('consecutiveGatewayFailure')
                  ? _json['consecutiveGatewayFailure'] as core.int
                  : null,
          enforcingConsecutiveErrors:
              _json.containsKey('enforcingConsecutiveErrors')
                  ? _json['enforcingConsecutiveErrors'] as core.int
                  : null,
          enforcingConsecutiveGatewayFailure:
              _json.containsKey('enforcingConsecutiveGatewayFailure')
                  ? _json['enforcingConsecutiveGatewayFailure'] as core.int
                  : null,
          enforcingSuccessRate: _json.containsKey('enforcingSuccessRate')
              ? _json['enforcingSuccessRate'] as core.int
              : null,
          interval: _json.containsKey('interval')
              ? Duration.fromJson(
                  _json['interval'] as core.Map<core.String, core.dynamic>)
              : null,
          maxEjectionPercent: _json.containsKey('maxEjectionPercent')
              ? _json['maxEjectionPercent'] as core.int
              : null,
          successRateMinimumHosts: _json.containsKey('successRateMinimumHosts')
              ? _json['successRateMinimumHosts'] as core.int
              : null,
          successRateRequestVolume:
              _json.containsKey('successRateRequestVolume')
                  ? _json['successRateRequestVolume'] as core.int
                  : null,
          successRateStdevFactor: _json.containsKey('successRateStdevFactor')
              ? _json['successRateStdevFactor'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (baseEjectionTime != null)
          'baseEjectionTime': baseEjectionTime!.toJson(),
        if (consecutiveErrors != null) 'consecutiveErrors': consecutiveErrors!,
        if (consecutiveGatewayFailure != null)
          'consecutiveGatewayFailure': consecutiveGatewayFailure!,
        if (enforcingConsecutiveErrors != null)
          'enforcingConsecutiveErrors': enforcingConsecutiveErrors!,
        if (enforcingConsecutiveGatewayFailure != null)
          'enforcingConsecutiveGatewayFailure':
              enforcingConsecutiveGatewayFailure!,
        if (enforcingSuccessRate != null)
          'enforcingSuccessRate': enforcingSuccessRate!,
        if (interval != null) 'interval': interval!.toJson(),
        if (maxEjectionPercent != null)
          'maxEjectionPercent': maxEjectionPercent!,
        if (successRateMinimumHosts != null)
          'successRateMinimumHosts': successRateMinimumHosts!,
        if (successRateRequestVolume != null)
          'successRateRequestVolume': successRateRequestVolume!,
        if (successRateStdevFactor != null)
          'successRateStdevFactor': successRateStdevFactor!,
      };
}

/// Represents a Packet Mirroring resource.
///
/// Packet Mirroring clones the traffic of specified instances in your Virtual
/// Private Cloud (VPC) network and forwards it to a collector destination, such
/// as an instance group of an internal TCP/UDP load balancer, for analysis or
/// examination. For more information about setting up Packet Mirroring, see
/// Using Packet Mirroring.
class PacketMirroring {
  /// The Forwarding Rule resource of type loadBalancingScheme=INTERNAL that
  /// will be used as collector for mirrored traffic.
  ///
  /// The specified forwarding rule must have isMirroringCollector set to true.
  PacketMirroringForwardingRuleInfo? collectorIlb;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Indicates whether or not this packet mirroring takes effect.
  ///
  /// If set to FALSE, this packet mirroring policy will not be enforced on the
  /// network. The default is TRUE.
  /// Possible string values are:
  /// - "FALSE"
  /// - "TRUE"
  core.String? enable;

  /// Filter for mirrored traffic.
  ///
  /// If unspecified, all traffic is mirrored.
  PacketMirroringFilter? filter;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#packetMirroring for packet mirrorings.
  ///
  /// Output only.
  core.String? kind;

  /// PacketMirroring mirroredResourceInfos.
  ///
  /// MirroredResourceInfo specifies a set of mirrored VM instances, subnetworks
  /// and/or tags for which traffic from/to all VM instances will be mirrored.
  PacketMirroringMirroredResourceInfo? mirroredResources;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Specifies the mirrored VPC network.
  ///
  /// Only packets in this network will be mirrored. All mirrored VMs should
  /// have a NIC in the given network. All mirrored subnetworks should belong to
  /// the given network.
  PacketMirroringNetworkInfo? network;

  /// The priority of applying this configuration.
  ///
  /// Priority is used to break ties in cases where there is more than one
  /// matching rule. In the case of two rules that apply for a given Instance,
  /// the one with the lowest-numbered priority value wins. Default value is
  /// 1000. Valid range is 0 through 65535.
  core.int? priority;

  /// URI of the region where the packetMirroring resides.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  PacketMirroring({
    this.collectorIlb,
    this.creationTimestamp,
    this.description,
    this.enable,
    this.filter,
    this.id,
    this.kind,
    this.mirroredResources,
    this.name,
    this.network,
    this.priority,
    this.region,
    this.selfLink,
  });

  PacketMirroring.fromJson(core.Map _json)
      : this(
          collectorIlb: _json.containsKey('collectorIlb')
              ? PacketMirroringForwardingRuleInfo.fromJson(
                  _json['collectorIlb'] as core.Map<core.String, core.dynamic>)
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          enable: _json.containsKey('enable')
              ? _json['enable'] as core.String
              : null,
          filter: _json.containsKey('filter')
              ? PacketMirroringFilter.fromJson(
                  _json['filter'] as core.Map<core.String, core.dynamic>)
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          mirroredResources: _json.containsKey('mirroredResources')
              ? PacketMirroringMirroredResourceInfo.fromJson(
                  _json['mirroredResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? PacketMirroringNetworkInfo.fromJson(
                  _json['network'] as core.Map<core.String, core.dynamic>)
              : null,
          priority: _json.containsKey('priority')
              ? _json['priority'] as core.int
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (collectorIlb != null) 'collectorIlb': collectorIlb!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (enable != null) 'enable': enable!,
        if (filter != null) 'filter': filter!.toJson(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (mirroredResources != null)
          'mirroredResources': mirroredResources!.toJson(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!.toJson(),
        if (priority != null) 'priority': priority!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

class PacketMirroringAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PacketMirroringAggregatedListWarningData({
    this.key,
    this.value,
  });

  PacketMirroringAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class PacketMirroringAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PacketMirroringAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PacketMirroringAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  PacketMirroringAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<PacketMirroringAggregatedListWarningData>((value) =>
                      PacketMirroringAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of packetMirrorings.
class PacketMirroringAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of PacketMirroring resources.
  core.Map<core.String, PacketMirroringsScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  PacketMirroringAggregatedListWarning? warning;

  PacketMirroringAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  PacketMirroringAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    PacketMirroringsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? PacketMirroringAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class PacketMirroringFilter {
  /// Protocols that apply as filter on mirrored traffic.
  ///
  /// If no protocols are specified, all traffic that matches the specified CIDR
  /// ranges is mirrored. If neither cidrRanges nor IPProtocols is specified,
  /// all traffic is mirrored.
  core.List<core.String>? IPProtocols;

  /// IP CIDR ranges that apply as filter on the source (ingress) or destination
  /// (egress) IP in the IP header.
  ///
  /// Only IPv4 is supported. If no ranges are specified, all traffic that
  /// matches the specified IPProtocols is mirrored. If neither cidrRanges nor
  /// IPProtocols is specified, all traffic is mirrored.
  core.List<core.String>? cidrRanges;

  /// Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH.
  ///
  /// The default is BOTH.
  /// Possible string values are:
  /// - "BOTH" : Default, both directions are mirrored.
  /// - "EGRESS" : Only egress traffic is mirrored.
  /// - "INGRESS" : Only ingress traffic is mirrored.
  core.String? direction;

  PacketMirroringFilter({
    this.IPProtocols,
    this.cidrRanges,
    this.direction,
  });

  PacketMirroringFilter.fromJson(core.Map _json)
      : this(
          IPProtocols: _json.containsKey('IPProtocols')
              ? (_json['IPProtocols'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          cidrRanges: _json.containsKey('cidrRanges')
              ? (_json['cidrRanges'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          direction: _json.containsKey('direction')
              ? _json['direction'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPProtocols != null) 'IPProtocols': IPProtocols!,
        if (cidrRanges != null) 'cidrRanges': cidrRanges!,
        if (direction != null) 'direction': direction!,
      };
}

class PacketMirroringForwardingRuleInfo {
  /// Unique identifier for the forwarding rule; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the forwarding rule representing the ILB configured as
  /// destination of the mirrored traffic.
  core.String? url;

  PacketMirroringForwardingRuleInfo({
    this.canonicalUrl,
    this.url,
  });

  PacketMirroringForwardingRuleInfo.fromJson(core.Map _json)
      : this(
          canonicalUrl: _json.containsKey('canonicalUrl')
              ? _json['canonicalUrl'] as core.String
              : null,
          url: _json.containsKey('url') ? _json['url'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
        if (url != null) 'url': url!,
      };
}

class PacketMirroringListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PacketMirroringListWarningData({
    this.key,
    this.value,
  });

  PacketMirroringListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class PacketMirroringListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PacketMirroringListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PacketMirroringListWarning({
    this.code,
    this.data,
    this.message,
  });

  PacketMirroringListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<PacketMirroringListWarningData>((value) =>
                      PacketMirroringListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of PacketMirroring resources.
class PacketMirroringList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of PacketMirroring resources.
  core.List<PacketMirroring>? items;

  /// Type of resource.
  ///
  /// Always compute#packetMirroring for packetMirrorings.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  PacketMirroringListWarning? warning;

  PacketMirroringList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  PacketMirroringList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<PacketMirroring>((value) => PacketMirroring.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? PacketMirroringListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class PacketMirroringMirroredResourceInfo {
  /// A set of virtual machine instances that are being mirrored.
  ///
  /// They must live in zones contained in the same region as this
  /// packetMirroring. Note that this config will apply only to those network
  /// interfaces of the Instances that belong to the network specified in this
  /// packetMirroring. You may specify a maximum of 50 Instances.
  core.List<PacketMirroringMirroredResourceInfoInstanceInfo>? instances;

  /// A set of subnetworks for which traffic from/to all VM instances will be
  /// mirrored.
  ///
  /// They must live in the same region as this packetMirroring. You may specify
  /// a maximum of 5 subnetworks.
  core.List<PacketMirroringMirroredResourceInfoSubnetInfo>? subnetworks;

  /// A set of mirrored tags.
  ///
  /// Traffic from/to all VM instances that have one or more of these tags will
  /// be mirrored.
  core.List<core.String>? tags;

  PacketMirroringMirroredResourceInfo({
    this.instances,
    this.subnetworks,
    this.tags,
  });

  PacketMirroringMirroredResourceInfo.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<PacketMirroringMirroredResourceInfoInstanceInfo>(
                      (value) => PacketMirroringMirroredResourceInfoInstanceInfo
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          subnetworks: _json.containsKey('subnetworks')
              ? (_json['subnetworks'] as core.List)
                  .map<PacketMirroringMirroredResourceInfoSubnetInfo>((value) =>
                      PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          tags: _json.containsKey('tags')
              ? (_json['tags'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
        if (subnetworks != null)
          'subnetworks': subnetworks!.map((value) => value.toJson()).toList(),
        if (tags != null) 'tags': tags!,
      };
}

class PacketMirroringMirroredResourceInfoInstanceInfo {
  /// Unique identifier for the instance; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the virtual machine instance which is being mirrored.
  core.String? url;

  PacketMirroringMirroredResourceInfoInstanceInfo({
    this.canonicalUrl,
    this.url,
  });

  PacketMirroringMirroredResourceInfoInstanceInfo.fromJson(core.Map _json)
      : this(
          canonicalUrl: _json.containsKey('canonicalUrl')
              ? _json['canonicalUrl'] as core.String
              : null,
          url: _json.containsKey('url') ? _json['url'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
        if (url != null) 'url': url!,
      };
}

class PacketMirroringMirroredResourceInfoSubnetInfo {
  /// Unique identifier for the subnetwork; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the subnetwork for which traffic from/to all VM instances
  /// will be mirrored.
  core.String? url;

  PacketMirroringMirroredResourceInfoSubnetInfo({
    this.canonicalUrl,
    this.url,
  });

  PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(core.Map _json)
      : this(
          canonicalUrl: _json.containsKey('canonicalUrl')
              ? _json['canonicalUrl'] as core.String
              : null,
          url: _json.containsKey('url') ? _json['url'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
        if (url != null) 'url': url!,
      };
}

class PacketMirroringNetworkInfo {
  /// Unique identifier for the network; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// URL of the network resource.
  core.String? url;

  PacketMirroringNetworkInfo({
    this.canonicalUrl,
    this.url,
  });

  PacketMirroringNetworkInfo.fromJson(core.Map _json)
      : this(
          canonicalUrl: _json.containsKey('canonicalUrl')
              ? _json['canonicalUrl'] as core.String
              : null,
          url: _json.containsKey('url') ? _json['url'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
        if (url != null) 'url': url!,
      };
}

class PacketMirroringsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PacketMirroringsScopedListWarningData({
    this.key,
    this.value,
  });

  PacketMirroringsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of packetMirrorings when the
/// list is empty.
class PacketMirroringsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PacketMirroringsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PacketMirroringsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  PacketMirroringsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<PacketMirroringsScopedListWarningData>((value) =>
                      PacketMirroringsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class PacketMirroringsScopedList {
  /// A list of packetMirrorings contained in this scope.
  core.List<PacketMirroring>? packetMirrorings;

  /// Informational warning which replaces the list of packetMirrorings when the
  /// list is empty.
  PacketMirroringsScopedListWarning? warning;

  PacketMirroringsScopedList({
    this.packetMirrorings,
    this.warning,
  });

  PacketMirroringsScopedList.fromJson(core.Map _json)
      : this(
          packetMirrorings: _json.containsKey('packetMirrorings')
              ? (_json['packetMirrorings'] as core.List)
                  .map<PacketMirroring>((value) => PacketMirroring.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? PacketMirroringsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (packetMirrorings != null)
          'packetMirrorings':
              packetMirrorings!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A matcher for the path portion of the URL.
///
/// The BackendService from the longest-matched rule will serve the URL. If no
/// rule was matched, the default service will be used.
class PathMatcher {
  /// defaultRouteAction takes effect when none of the pathRules or routeRules
  /// match.
  ///
  /// The load balancer performs advanced routing actions like URL rewrites,
  /// header transformations, etc. prior to forwarding the request to the
  /// selected backend. If defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be set. Conversely if
  /// defaultService is set, defaultRouteAction cannot contain any
  /// weightedBackendServices. Only one of defaultRouteAction or
  /// defaultUrlRedirect must be set. UrlMaps for external HTTP(S) load
  /// balancers support only the urlRewrite action within a pathMatcher's
  /// defaultRouteAction.
  HttpRouteAction? defaultRouteAction;

  /// The full or partial URL to the BackendService resource.
  ///
  /// This will be used if none of the pathRules or routeRules defined by this
  /// PathMatcher are matched. For example, the following are all valid URLs to
  /// a BackendService resource: -
  /// https://www.googleapis.com/compute/v1/projects/project
  /// /global/backendServices/backendService -
  /// compute/v1/projects/project/global/backendServices/backendService -
  /// global/backendServices/backendService If defaultRouteAction is
  /// additionally specified, advanced routing actions like URL Rewrites, etc.
  /// take effect prior to sending the request to the backend. However, if
  /// defaultService is specified, defaultRouteAction cannot contain any
  /// weightedBackendServices. Conversely, if defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be specified. Only one of
  /// defaultService, defaultUrlRedirect or
  /// defaultRouteAction.weightedBackendService must be set. Authorization
  /// requires one or more of the following Google IAM permissions on the
  /// specified resource default_service: - compute.backendBuckets.use -
  /// compute.backendServices.use
  core.String? defaultService;

  /// When none of the specified pathRules or routeRules match, the request is
  /// redirected to a URL specified by defaultUrlRedirect.
  ///
  /// If defaultUrlRedirect is specified, defaultService or defaultRouteAction
  /// must not be set. Not supported when the URL map is bound to target gRPC
  /// proxy.
  HttpRedirectAction? defaultUrlRedirect;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  ///
  /// HeaderAction specified here are applied after the matching HttpRouteRule
  /// HeaderAction and before the HeaderAction in the UrlMap Note that
  /// headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL. Not supported when the URL map is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  HttpHeaderAction? headerAction;

  /// The name to which this PathMatcher is referred by the HostRule.
  core.String? name;

  /// The list of path rules.
  ///
  /// Use this list instead of routeRules when routing based on simple path
  /// matching is all that's required. The order by which path rules are
  /// specified does not matter. Matches are always done on the
  /// longest-path-first basis. For example: a pathRule with a path /a/b/c / *
  /// will match before /a/b / * irrespective of the order in which those paths
  /// appear in this list. Within a given pathMatcher, only one of pathRules or
  /// routeRules must be set.
  core.List<PathRule>? pathRules;

  /// The list of HTTP route rules.
  ///
  /// Use this list instead of pathRules when advanced route matching and
  /// routing actions are desired. routeRules are evaluated in order of
  /// priority, from the lowest to highest number. Within a given pathMatcher,
  /// you can set only one of pathRules or routeRules.
  core.List<HttpRouteRule>? routeRules;

  PathMatcher({
    this.defaultRouteAction,
    this.defaultService,
    this.defaultUrlRedirect,
    this.description,
    this.headerAction,
    this.name,
    this.pathRules,
    this.routeRules,
  });

  PathMatcher.fromJson(core.Map _json)
      : this(
          defaultRouteAction: _json.containsKey('defaultRouteAction')
              ? HttpRouteAction.fromJson(_json['defaultRouteAction']
                  as core.Map<core.String, core.dynamic>)
              : null,
          defaultService: _json.containsKey('defaultService')
              ? _json['defaultService'] as core.String
              : null,
          defaultUrlRedirect: _json.containsKey('defaultUrlRedirect')
              ? HttpRedirectAction.fromJson(_json['defaultUrlRedirect']
                  as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          headerAction: _json.containsKey('headerAction')
              ? HttpHeaderAction.fromJson(
                  _json['headerAction'] as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          pathRules: _json.containsKey('pathRules')
              ? (_json['pathRules'] as core.List)
                  .map<PathRule>((value) => PathRule.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          routeRules: _json.containsKey('routeRules')
              ? (_json['routeRules'] as core.List)
                  .map<HttpRouteRule>((value) => HttpRouteRule.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultRouteAction != null)
          'defaultRouteAction': defaultRouteAction!.toJson(),
        if (defaultService != null) 'defaultService': defaultService!,
        if (defaultUrlRedirect != null)
          'defaultUrlRedirect': defaultUrlRedirect!.toJson(),
        if (description != null) 'description': description!,
        if (headerAction != null) 'headerAction': headerAction!.toJson(),
        if (name != null) 'name': name!,
        if (pathRules != null)
          'pathRules': pathRules!.map((value) => value.toJson()).toList(),
        if (routeRules != null)
          'routeRules': routeRules!.map((value) => value.toJson()).toList(),
      };
}

/// A path-matching rule for a URL.
///
/// If matched, will use the specified BackendService to handle the traffic
/// arriving at this URL.
class PathRule {
  /// The list of path patterns to match.
  ///
  /// Each must start with / and the only place a * is allowed is at the end
  /// following a /. The string fed to the path matcher does not include any
  /// text after the first ? or #, and those chars are not allowed here.
  core.List<core.String>? paths;

  /// In response to a matching path, the load balancer performs advanced
  /// routing actions like URL rewrites, header transformations, etc.
  ///
  /// prior to forwarding the request to the selected backend. If routeAction
  /// specifies any weightedBackendServices, service must not be set. Conversely
  /// if service is set, routeAction cannot contain any weightedBackendServices.
  /// Only one of routeAction or urlRedirect must be set. UrlMaps for external
  /// HTTP(S) load balancers support only the urlRewrite action within a
  /// pathRule's routeAction.
  HttpRouteAction? routeAction;

  /// The full or partial URL of the backend service resource to which traffic
  /// is directed if this rule is matched.
  ///
  /// If routeAction is additionally specified, advanced routing actions like
  /// URL Rewrites, etc. take effect prior to sending the request to the
  /// backend. However, if service is specified, routeAction cannot contain any
  /// weightedBackendService s. Conversely, if routeAction specifies any
  /// weightedBackendServices, service must not be specified. Only one of
  /// urlRedirect, service or routeAction.weightedBackendService must be set.
  core.String? service;

  /// When a path pattern is matched, the request is redirected to a URL
  /// specified by urlRedirect.
  ///
  /// If urlRedirect is specified, service or routeAction must not be set. Not
  /// supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction? urlRedirect;

  PathRule({
    this.paths,
    this.routeAction,
    this.service,
    this.urlRedirect,
  });

  PathRule.fromJson(core.Map _json)
      : this(
          paths: _json.containsKey('paths')
              ? (_json['paths'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          routeAction: _json.containsKey('routeAction')
              ? HttpRouteAction.fromJson(
                  _json['routeAction'] as core.Map<core.String, core.dynamic>)
              : null,
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
          urlRedirect: _json.containsKey('urlRedirect')
              ? HttpRedirectAction.fromJson(
                  _json['urlRedirect'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (paths != null) 'paths': paths!,
        if (routeAction != null) 'routeAction': routeAction!.toJson(),
        if (service != null) 'service': service!,
        if (urlRedirect != null) 'urlRedirect': urlRedirect!.toJson(),
      };
}

class PerInstanceConfig {
  /// Fingerprint of this per-instance config.
  ///
  /// This field can be used in optimistic locking. It is ignored when inserting
  /// a per-instance config. An up-to-date fingerprint must be provided in order
  /// to update an existing per-instance config or the field needs to be unset.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The name of a per-instance config and its corresponding instance.
  ///
  /// Serves as a merge key during UpdatePerInstanceConfigs operations, that is,
  /// if a per-instance config with the same name exists then it will be
  /// updated, otherwise a new one will be created for the VM instance with the
  /// same name. An attempt to create a per-instance config for a VM instance
  /// that either doesn't exist or is not part of the group will result in an
  /// error.
  core.String? name;

  /// The intended preserved state for the given instance.
  ///
  /// Does not contain preserved state generated from a stateful policy.
  PreservedState? preservedState;

  /// The status of applying this per-instance config on the corresponding
  /// managed instance.
  /// Possible string values are:
  /// - "APPLYING" : The per-instance config is being applied to the instance,
  /// but is not yet effective, possibly waiting for the instance to, for
  /// example, REFRESH.
  /// - "DELETING" : The per-instance config deletion is being applied on the
  /// instance, possibly waiting for the instance to, for example, REFRESH.
  /// - "EFFECTIVE" : The per-instance config is effective on the instance,
  /// meaning that all disks, ips and metadata specified in this config are
  /// attached or set on the instance.
  /// - "NONE" : *\[Default\]* The default status, when no per-instance config
  /// exists.
  /// - "UNAPPLIED" : The per-instance config is set on an instance but not been
  /// applied yet.
  /// - "UNAPPLIED_DELETION" : The per-instance config has been deleted, but the
  /// deletion is not yet applied.
  core.String? status;

  PerInstanceConfig({
    this.fingerprint,
    this.name,
    this.preservedState,
    this.status,
  });

  PerInstanceConfig.fromJson(core.Map _json)
      : this(
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          preservedState: _json.containsKey('preservedState')
              ? PreservedState.fromJson(_json['preservedState']
                  as core.Map<core.String, core.dynamic>)
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (name != null) 'name': name!,
        if (preservedState != null) 'preservedState': preservedState!.toJson(),
        if (status != null) 'status': status!,
      };
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members` to a single `role`. Members can be user accounts, service
/// accounts, Google groups, and domains (such as G Suite). A `role` is a named
/// list of permissions; each `role` can be an IAM predefined role or a
/// user-created custom role. For some types of Google Cloud resources, a
/// `binding` can also specify a `condition`, which is a logical expression that
/// allows access to a resource only if the expression evaluates to `true`. A
/// condition can add constraints based on attributes of the request, the
/// resource, or both. To learn which resources support conditions in their IAM
/// policies, see the
/// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
/// **JSON example:** { "bindings": \[ { "role":
/// "roles/resourcemanager.organizationAdmin", "members": \[
/// "user:mike@example.com", "group:admins@example.com", "domain:google.com",
/// "serviceAccount:my-project-id@appspot.gserviceaccount.com" \] }, { "role":
/// "roles/resourcemanager.organizationViewer", "members": \[
/// "user:eve@example.com" \], "condition": { "title": "expirable access",
/// "description": "Does not grant access after Sep 2020", "expression":
/// "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } \], "etag":
/// "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
/// user:mike@example.com - group:admins@example.com - domain:google.com -
/// serviceAccount:my-project-id@appspot.gserviceaccount.com role:
/// roles/resourcemanager.organizationAdmin - members: - user:eve@example.com
/// role: roles/resourcemanager.organizationViewer condition: title: expirable
/// access description: Does not grant access after Sep 2020 expression:
/// request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
/// version: 3 For a description of IAM and its features, see the
/// [IAM documentation](https://cloud.google.com/iam/docs/).
class Policy {
  /// Specifies cloud audit logging configuration for this policy.
  core.List<AuditConfig>? auditConfigs;

  /// Associates a list of `members` to a `role`.
  ///
  /// Optionally, may specify a `condition` that determines how and when the
  /// `bindings` are applied. Each of the `bindings` must contain at least one
  /// member.
  core.List<Binding>? bindings;

  /// `etag` is used for optimistic concurrency control as a way to help prevent
  /// simultaneous updates of a policy from overwriting each other.
  ///
  /// It is strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the
  /// policy. **Important:** If you use IAM Conditions, you must include the
  /// `etag` field whenever you call `setIamPolicy`. If you omit this field,
  /// then IAM allows you to overwrite a version `3` policy with a version `1`
  /// policy, and all of the conditions in the version `3` policy are lost.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.bool? iamOwned;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<Rule>? rules;

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected. Any operation that affects conditional role bindings must
  /// specify version `3`. This requirement applies to the following operations:
  /// * Getting a policy that includes a conditional role binding * Adding a
  /// conditional role binding to a policy * Changing a conditional role binding
  /// in a policy * Removing any role binding, with or without a condition, from
  /// a policy that includes conditions **Important:** If you use IAM
  /// Conditions, you must include the `etag` field whenever you call
  /// `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
  /// version `3` policy with a version `1` policy, and all of the conditions in
  /// the version `3` policy are lost. If a policy does not include any
  /// conditions, operations on that policy may specify any valid version or
  /// leave the field unset. To learn which resources support conditions in
  /// their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  core.int? version;

  Policy({
    this.auditConfigs,
    this.bindings,
    this.etag,
    this.iamOwned,
    this.rules,
    this.version,
  });

  Policy.fromJson(core.Map _json)
      : this(
          auditConfigs: _json.containsKey('auditConfigs')
              ? (_json['auditConfigs'] as core.List)
                  .map<AuditConfig>((value) => AuditConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          bindings: _json.containsKey('bindings')
              ? (_json['bindings'] as core.List)
                  .map<Binding>((value) => Binding.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          etag: _json.containsKey('etag') ? _json['etag'] as core.String : null,
          iamOwned: _json.containsKey('iamOwned')
              ? _json['iamOwned'] as core.bool
              : null,
          rules: _json.containsKey('rules')
              ? (_json['rules'] as core.List)
                  .map<Rule>((value) => Rule.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          version: _json.containsKey('version')
              ? _json['version'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (auditConfigs != null)
          'auditConfigs': auditConfigs!.map((value) => value.toJson()).toList(),
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (iamOwned != null) 'iamOwned': iamOwned!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (version != null) 'version': version!,
      };
}

class PreconfiguredWafSet {
  /// List of entities that are currently supported for WAF rules.
  core.List<WafExpressionSet>? expressionSets;

  PreconfiguredWafSet({
    this.expressionSets,
  });

  PreconfiguredWafSet.fromJson(core.Map _json)
      : this(
          expressionSets: _json.containsKey('expressionSets')
              ? (_json['expressionSets'] as core.List)
                  .map<WafExpressionSet>((value) => WafExpressionSet.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (expressionSets != null)
          'expressionSets':
              expressionSets!.map((value) => value.toJson()).toList(),
      };
}

/// Preserved state for a given instance.
class PreservedState {
  /// Preserved disks defined for this instance.
  ///
  /// This map is keyed with the device names of the disks.
  core.Map<core.String, PreservedStatePreservedDisk>? disks;

  /// Preserved metadata defined for this instance.
  core.Map<core.String, core.String>? metadata;

  PreservedState({
    this.disks,
    this.metadata,
  });

  PreservedState.fromJson(core.Map _json)
      : this(
          disks: _json.containsKey('disks')
              ? (_json['disks'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    PreservedStatePreservedDisk.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          metadata: _json.containsKey('metadata')
              ? (_json['metadata'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disks != null)
          'disks': disks!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (metadata != null) 'metadata': metadata!,
      };
}

class PreservedStatePreservedDisk {
  /// These stateful disks will never be deleted during autohealing, update,
  /// instance recreate operations.
  ///
  /// This flag is used to configure if the disk should be deleted after it is
  /// no longer used by the group, e.g. when the given instance or the whole MIG
  /// is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String? autoDelete;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
  ///
  /// If not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY" : Attaches this disk in read-only mode. Multiple VM
  /// instances can use a disk in READ_ONLY mode at a time.
  /// - "READ_WRITE" : *\[Default\]* Attaches this disk in READ_WRITE mode. Only
  /// one VM instance at a time can be attached to a disk in READ_WRITE mode.
  core.String? mode;

  /// The URL of the disk resource that is stateful and should be attached to
  /// the VM instance.
  core.String? source;

  PreservedStatePreservedDisk({
    this.autoDelete,
    this.mode,
    this.source,
  });

  PreservedStatePreservedDisk.fromJson(core.Map _json)
      : this(
          autoDelete: _json.containsKey('autoDelete')
              ? _json['autoDelete'] as core.String
              : null,
          mode: _json.containsKey('mode') ? _json['mode'] as core.String : null,
          source: _json.containsKey('source')
              ? _json['source'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoDelete != null) 'autoDelete': autoDelete!,
        if (mode != null) 'mode': mode!,
        if (source != null) 'source': source!,
      };
}

/// Represents a Project resource.
///
/// A project is used to organize resources in a Google Cloud Platform
/// environment. For more information, read about the Resource Hierarchy.
class Project {
  /// Metadata key/value pairs available to all instances contained in this
  /// project.
  ///
  /// See Custom metadata for more information.
  Metadata? commonInstanceMetadata;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// This signifies the default network tier used for configuring resources of
  /// the project and can only take the following values: PREMIUM, STANDARD.
  ///
  /// Initially the default network tier is PREMIUM.
  /// Possible string values are:
  /// - "PREMIUM" : High quality, Google-grade network tier, support for all
  /// networking products.
  /// - "STANDARD" : Public internet quality, only limited support for other
  /// networking products.
  core.String? defaultNetworkTier;

  /// Default service account used by VMs running in this project.
  ///
  /// Output only.
  core.String? defaultServiceAccount;

  /// An optional textual description of the resource.
  core.String? description;

  /// Restricted features enabled for use on this project.
  core.List<core.String>? enabledFeatures;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server. This is *not* the project ID,
  /// and is just a unique ID used by Compute Engine to identify resources.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#project for projects.
  ///
  /// Output only.
  core.String? kind;

  /// The project ID.
  ///
  /// For example: my-example-project. Use the project ID to make requests to
  /// Compute Engine.
  core.String? name;

  /// Quotas assigned to this project.
  ///
  /// Output only.
  core.List<Quota>? quotas;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The naming prefix for daily usage reports and the Google Cloud Storage
  /// bucket where they are stored.
  UsageExportLocation? usageExportLocation;

  /// The role this project has in a shared VPC configuration.
  ///
  /// Currently, only projects with the host role, which is specified by the
  /// value HOST, are differentiated.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HOST"
  /// - "UNSPECIFIED_XPN_PROJECT_STATUS"
  core.String? xpnProjectStatus;

  Project({
    this.commonInstanceMetadata,
    this.creationTimestamp,
    this.defaultNetworkTier,
    this.defaultServiceAccount,
    this.description,
    this.enabledFeatures,
    this.id,
    this.kind,
    this.name,
    this.quotas,
    this.selfLink,
    this.usageExportLocation,
    this.xpnProjectStatus,
  });

  Project.fromJson(core.Map _json)
      : this(
          commonInstanceMetadata: _json.containsKey('commonInstanceMetadata')
              ? Metadata.fromJson(_json['commonInstanceMetadata']
                  as core.Map<core.String, core.dynamic>)
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          defaultNetworkTier: _json.containsKey('defaultNetworkTier')
              ? _json['defaultNetworkTier'] as core.String
              : null,
          defaultServiceAccount: _json.containsKey('defaultServiceAccount')
              ? _json['defaultServiceAccount'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          enabledFeatures: _json.containsKey('enabledFeatures')
              ? (_json['enabledFeatures'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          quotas: _json.containsKey('quotas')
              ? (_json['quotas'] as core.List)
                  .map<Quota>((value) => Quota.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          usageExportLocation: _json.containsKey('usageExportLocation')
              ? UsageExportLocation.fromJson(_json['usageExportLocation']
                  as core.Map<core.String, core.dynamic>)
              : null,
          xpnProjectStatus: _json.containsKey('xpnProjectStatus')
              ? _json['xpnProjectStatus'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (commonInstanceMetadata != null)
          'commonInstanceMetadata': commonInstanceMetadata!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (defaultNetworkTier != null)
          'defaultNetworkTier': defaultNetworkTier!,
        if (defaultServiceAccount != null)
          'defaultServiceAccount': defaultServiceAccount!,
        if (description != null) 'description': description!,
        if (enabledFeatures != null) 'enabledFeatures': enabledFeatures!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (quotas != null)
          'quotas': quotas!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (usageExportLocation != null)
          'usageExportLocation': usageExportLocation!.toJson(),
        if (xpnProjectStatus != null) 'xpnProjectStatus': xpnProjectStatus!,
      };
}

class ProjectsDisableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId? xpnResource;

  ProjectsDisableXpnResourceRequest({
    this.xpnResource,
  });

  ProjectsDisableXpnResourceRequest.fromJson(core.Map _json)
      : this(
          xpnResource: _json.containsKey('xpnResource')
              ? XpnResourceId.fromJson(
                  _json['xpnResource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (xpnResource != null) 'xpnResource': xpnResource!.toJson(),
      };
}

class ProjectsEnableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId? xpnResource;

  ProjectsEnableXpnResourceRequest({
    this.xpnResource,
  });

  ProjectsEnableXpnResourceRequest.fromJson(core.Map _json)
      : this(
          xpnResource: _json.containsKey('xpnResource')
              ? XpnResourceId.fromJson(
                  _json['xpnResource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (xpnResource != null) 'xpnResource': xpnResource!.toJson(),
      };
}

class ProjectsGetXpnResources {
  /// Type of resource.
  ///
  /// Always compute#projectsGetXpnResources for lists of service resources
  /// (a.k.a service projects)
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Service resources (a.k.a service projects) attached to this project as
  /// their shared VPC host.
  core.List<XpnResourceId>? resources;

  ProjectsGetXpnResources({
    this.kind,
    this.nextPageToken,
    this.resources,
  });

  ProjectsGetXpnResources.fromJson(core.Map _json)
      : this(
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          resources: _json.containsKey('resources')
              ? (_json['resources'] as core.List)
                  .map<XpnResourceId>((value) => XpnResourceId.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (resources != null)
          'resources': resources!.map((value) => value.toJson()).toList(),
      };
}

class ProjectsListXpnHostsRequest {
  /// Optional organization ID managed by Cloud Resource Manager, for which to
  /// list shared VPC host projects.
  ///
  /// If not specified, the organization will be inferred from the project.
  core.String? organization;

  ProjectsListXpnHostsRequest({
    this.organization,
  });

  ProjectsListXpnHostsRequest.fromJson(core.Map _json)
      : this(
          organization: _json.containsKey('organization')
              ? _json['organization'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (organization != null) 'organization': organization!,
      };
}

class ProjectsSetDefaultNetworkTierRequest {
  /// Default network tier to be set.
  /// Possible string values are:
  /// - "PREMIUM" : High quality, Google-grade network tier, support for all
  /// networking products.
  /// - "STANDARD" : Public internet quality, only limited support for other
  /// networking products.
  core.String? networkTier;

  ProjectsSetDefaultNetworkTierRequest({
    this.networkTier,
  });

  ProjectsSetDefaultNetworkTierRequest.fromJson(core.Map _json)
      : this(
          networkTier: _json.containsKey('networkTier')
              ? _json['networkTier'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkTier != null) 'networkTier': networkTier!,
      };
}

/// A public advertised prefix represents an aggregated IP prefix or netblock
/// which customers bring to cloud.
///
/// The IP prefix is a single unit of route advertisement and is announced
/// globally to the internet.
class PublicAdvertisedPrefix {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The IPv4 address to be used for reverse DNS verification.
  core.String? dnsVerificationIp;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a new
  /// PublicAdvertisedPrefix. An up-to-date fingerprint must be provided in
  /// order to update the PublicAdvertisedPrefix, otherwise the request will
  /// fail with error 412 conditionNotMet. To see the latest fingerprint, make a
  /// get() request to retrieve a PublicAdvertisedPrefix.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// The IPv4 address range, in CIDR format, represented by this public
  /// advertised prefix.
  core.String? ipCidrRange;

  /// Type of the resource.
  ///
  /// Always compute#publicAdvertisedPrefix for public advertised prefixes.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The list of public delegated prefixes that exist for this public
  /// advertised prefix.
  ///
  /// Output only.
  core.List<PublicAdvertisedPrefixPublicDelegatedPrefix>?
      publicDelegatedPrefixs;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The shared secret to be used for reverse DNS verification.
  ///
  /// Output only.
  core.String? sharedSecret;

  /// The status of the public advertised prefix.
  /// Possible string values are:
  /// - "INITIAL"
  /// - "PREFIX_CONFIGURATION_COMPLETE"
  /// - "PREFIX_CONFIGURATION_IN_PROGRESS"
  /// - "PREFIX_REMOVAL_IN_PROGRESS"
  /// - "PTR_CONFIGURED"
  /// - "REVERSE_DNS_LOOKUP_FAILED"
  /// - "VALIDATED"
  core.String? status;

  PublicAdvertisedPrefix({
    this.creationTimestamp,
    this.description,
    this.dnsVerificationIp,
    this.fingerprint,
    this.id,
    this.ipCidrRange,
    this.kind,
    this.name,
    this.publicDelegatedPrefixs,
    this.selfLink,
    this.sharedSecret,
    this.status,
  });

  PublicAdvertisedPrefix.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          dnsVerificationIp: _json.containsKey('dnsVerificationIp')
              ? _json['dnsVerificationIp'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          publicDelegatedPrefixs: _json.containsKey('publicDelegatedPrefixs')
              ? (_json['publicDelegatedPrefixs'] as core.List)
                  .map<PublicAdvertisedPrefixPublicDelegatedPrefix>((value) =>
                      PublicAdvertisedPrefixPublicDelegatedPrefix.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          sharedSecret: _json.containsKey('sharedSecret')
              ? _json['sharedSecret'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (dnsVerificationIp != null) 'dnsVerificationIp': dnsVerificationIp!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (publicDelegatedPrefixs != null)
          'publicDelegatedPrefixs':
              publicDelegatedPrefixs!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (sharedSecret != null) 'sharedSecret': sharedSecret!,
        if (status != null) 'status': status!,
      };
}

class PublicAdvertisedPrefixListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PublicAdvertisedPrefixListWarningData({
    this.key,
    this.value,
  });

  PublicAdvertisedPrefixListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class PublicAdvertisedPrefixListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PublicAdvertisedPrefixListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PublicAdvertisedPrefixListWarning({
    this.code,
    this.data,
    this.message,
  });

  PublicAdvertisedPrefixListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<PublicAdvertisedPrefixListWarningData>((value) =>
                      PublicAdvertisedPrefixListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class PublicAdvertisedPrefixList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of PublicAdvertisedPrefix resources.
  core.List<PublicAdvertisedPrefix>? items;

  /// Type of the resource.
  ///
  /// Always compute#publicAdvertisedPrefix for public advertised prefixes.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  PublicAdvertisedPrefixListWarning? warning;

  PublicAdvertisedPrefixList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  PublicAdvertisedPrefixList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<PublicAdvertisedPrefix>((value) =>
                      PublicAdvertisedPrefix.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? PublicAdvertisedPrefixListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a CIDR range which can be used to assign addresses.
class PublicAdvertisedPrefixPublicDelegatedPrefix {
  /// The IP address range of the public delegated prefix
  core.String? ipRange;

  /// The name of the public delegated prefix
  core.String? name;

  /// The project number of the public delegated prefix
  core.String? project;

  /// The region of the public delegated prefix if it is regional.
  ///
  /// If absent, the prefix is global.
  core.String? region;

  /// The status of the public delegated prefix.
  ///
  /// Possible values are: INITIALIZING: The public delegated prefix is being
  /// initialized and addresses cannot be created yet. ANNOUNCED: The public
  /// delegated prefix is active.
  core.String? status;

  PublicAdvertisedPrefixPublicDelegatedPrefix({
    this.ipRange,
    this.name,
    this.project,
    this.region,
    this.status,
  });

  PublicAdvertisedPrefixPublicDelegatedPrefix.fromJson(core.Map _json)
      : this(
          ipRange: _json.containsKey('ipRange')
              ? _json['ipRange'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          project: _json.containsKey('project')
              ? _json['project'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipRange != null) 'ipRange': ipRange!,
        if (name != null) 'name': name!,
        if (project != null) 'project': project!,
        if (region != null) 'region': region!,
        if (status != null) 'status': status!,
      };
}

/// A PublicDelegatedPrefix resource represents an IP block within a
/// PublicAdvertisedPrefix that is configured within a single cloud scope
/// (global or region).
///
/// IPs in the block can be allocated to resources within that scope. Public
/// delegated prefixes may be further broken up into smaller IP blocks in the
/// same scope as the parent block.
class PublicDelegatedPrefix {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a new
  /// PublicDelegatedPrefix. An up-to-date fingerprint must be provided in order
  /// to update the PublicDelegatedPrefix, otherwise the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve a PublicDelegatedPrefix.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// The IPv4 address range, in CIDR format, represented by this public
  /// delegated prefix.
  core.String? ipCidrRange;

  /// If true, the prefix will be live migrated.
  core.bool? isLiveMigration;

  /// Type of the resource.
  ///
  /// Always compute#publicDelegatedPrefix for public delegated prefixes.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The URL of parent prefix.
  ///
  /// Either PublicAdvertisedPrefix or PublicDelegatedPrefix.
  core.String? parentPrefix;

  /// The list of sub public delegated prefixes that exist for this public
  /// delegated prefix.
  core.List<PublicDelegatedPrefixPublicDelegatedSubPrefix>?
      publicDelegatedSubPrefixs;

  /// URL of the region where the public delegated prefix resides.
  ///
  /// This field applies only to the region resource. You must specify this
  /// field as part of the HTTP request URL. It is not settable as a field in
  /// the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the public delegated prefix.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ANNOUNCED"
  /// - "DELETING"
  /// - "INITIALIZING"
  /// - "READY_TO_ANNOUNCE"
  core.String? status;

  PublicDelegatedPrefix({
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.ipCidrRange,
    this.isLiveMigration,
    this.kind,
    this.name,
    this.parentPrefix,
    this.publicDelegatedSubPrefixs,
    this.region,
    this.selfLink,
    this.status,
  });

  PublicDelegatedPrefix.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
          isLiveMigration: _json.containsKey('isLiveMigration')
              ? _json['isLiveMigration'] as core.bool
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          parentPrefix: _json.containsKey('parentPrefix')
              ? _json['parentPrefix'] as core.String
              : null,
          publicDelegatedSubPrefixs: _json
                  .containsKey('publicDelegatedSubPrefixs')
              ? (_json['publicDelegatedSubPrefixs'] as core.List)
                  .map<PublicDelegatedPrefixPublicDelegatedSubPrefix>((value) =>
                      PublicDelegatedPrefixPublicDelegatedSubPrefix.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (isLiveMigration != null) 'isLiveMigration': isLiveMigration!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (parentPrefix != null) 'parentPrefix': parentPrefix!,
        if (publicDelegatedSubPrefixs != null)
          'publicDelegatedSubPrefixs': publicDelegatedSubPrefixs!
              .map((value) => value.toJson())
              .toList(),
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
      };
}

class PublicDelegatedPrefixAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PublicDelegatedPrefixAggregatedListWarningData({
    this.key,
    this.value,
  });

  PublicDelegatedPrefixAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class PublicDelegatedPrefixAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PublicDelegatedPrefixAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PublicDelegatedPrefixAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  PublicDelegatedPrefixAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<PublicDelegatedPrefixAggregatedListWarningData>(
                      (value) => PublicDelegatedPrefixAggregatedListWarningData
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class PublicDelegatedPrefixAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of PublicDelegatedPrefixesScopedList resources.
  core.Map<core.String, PublicDelegatedPrefixesScopedList>? items;

  /// Type of the resource.
  ///
  /// Always compute#publicDelegatedPrefixAggregatedList for aggregated lists of
  /// public delegated prefixes.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  PublicDelegatedPrefixAggregatedListWarning? warning;

  PublicDelegatedPrefixAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  PublicDelegatedPrefixAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    PublicDelegatedPrefixesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? PublicDelegatedPrefixAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class PublicDelegatedPrefixListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PublicDelegatedPrefixListWarningData({
    this.key,
    this.value,
  });

  PublicDelegatedPrefixListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class PublicDelegatedPrefixListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PublicDelegatedPrefixListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PublicDelegatedPrefixListWarning({
    this.code,
    this.data,
    this.message,
  });

  PublicDelegatedPrefixListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<PublicDelegatedPrefixListWarningData>((value) =>
                      PublicDelegatedPrefixListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class PublicDelegatedPrefixList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of PublicDelegatedPrefix resources.
  core.List<PublicDelegatedPrefix>? items;

  /// Type of the resource.
  ///
  /// Always compute#publicDelegatedPrefixList for public delegated prefixes.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  PublicDelegatedPrefixListWarning? warning;

  PublicDelegatedPrefixList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  PublicDelegatedPrefixList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<PublicDelegatedPrefix>((value) =>
                      PublicDelegatedPrefix.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? PublicDelegatedPrefixListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a sub PublicDelegatedPrefix.
class PublicDelegatedPrefixPublicDelegatedSubPrefix {
  /// Name of the project scoping this PublicDelegatedSubPrefix.
  core.String? delegateeProject;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The IPv4 address range, in CIDR format, represented by this sub public
  /// delegated prefix.
  core.String? ipCidrRange;

  /// Whether the sub prefix is delegated to create Address resources in the
  /// delegatee project.
  core.bool? isAddress;

  /// The name of the sub public delegated prefix.
  core.String? name;

  /// The region of the sub public delegated prefix if it is regional.
  ///
  /// If absent, the sub prefix is global.
  ///
  /// Output only.
  core.String? region;

  /// The status of the sub public delegated prefix.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "INACTIVE"
  core.String? status;

  PublicDelegatedPrefixPublicDelegatedSubPrefix({
    this.delegateeProject,
    this.description,
    this.ipCidrRange,
    this.isAddress,
    this.name,
    this.region,
    this.status,
  });

  PublicDelegatedPrefixPublicDelegatedSubPrefix.fromJson(core.Map _json)
      : this(
          delegateeProject: _json.containsKey('delegateeProject')
              ? _json['delegateeProject'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
          isAddress: _json.containsKey('isAddress')
              ? _json['isAddress'] as core.bool
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (delegateeProject != null) 'delegateeProject': delegateeProject!,
        if (description != null) 'description': description!,
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (isAddress != null) 'isAddress': isAddress!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (status != null) 'status': status!,
      };
}

class PublicDelegatedPrefixesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PublicDelegatedPrefixesScopedListWarningData({
    this.key,
    this.value,
  });

  PublicDelegatedPrefixesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of public delegated prefixes
/// when the list is empty.
///
/// Output only.
class PublicDelegatedPrefixesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PublicDelegatedPrefixesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PublicDelegatedPrefixesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  PublicDelegatedPrefixesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<PublicDelegatedPrefixesScopedListWarningData>((value) =>
                      PublicDelegatedPrefixesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class PublicDelegatedPrefixesScopedList {
  /// A list of PublicDelegatedPrefixes contained in this scope.
  ///
  /// Output only.
  core.List<PublicDelegatedPrefix>? publicDelegatedPrefixes;

  /// Informational warning which replaces the list of public delegated prefixes
  /// when the list is empty.
  ///
  /// Output only.
  PublicDelegatedPrefixesScopedListWarning? warning;

  PublicDelegatedPrefixesScopedList({
    this.publicDelegatedPrefixes,
    this.warning,
  });

  PublicDelegatedPrefixesScopedList.fromJson(core.Map _json)
      : this(
          publicDelegatedPrefixes: _json.containsKey('publicDelegatedPrefixes')
              ? (_json['publicDelegatedPrefixes'] as core.List)
                  .map<PublicDelegatedPrefix>((value) =>
                      PublicDelegatedPrefix.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? PublicDelegatedPrefixesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (publicDelegatedPrefixes != null)
          'publicDelegatedPrefixes':
              publicDelegatedPrefixes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A quotas entry.
class Quota {
  /// Quota limit for this metric.
  ///
  /// Output only.
  core.double? limit;

  /// Name of the quota metric.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "A2_CPUS"
  /// - "AFFINITY_GROUPS"
  /// - "AUTOSCALERS"
  /// - "BACKEND_BUCKETS"
  /// - "BACKEND_SERVICES"
  /// - "C2D_CPUS"
  /// - "C2_CPUS"
  /// - "C3_CPUS"
  /// - "COMMITMENTS"
  /// - "COMMITTED_A2_CPUS"
  /// - "COMMITTED_C2D_CPUS"
  /// - "COMMITTED_C2_CPUS"
  /// - "COMMITTED_C3_CPUS"
  /// - "COMMITTED_CPUS"
  /// - "COMMITTED_E2_CPUS"
  /// - "COMMITTED_LICENSES"
  /// - "COMMITTED_LOCAL_SSD_TOTAL_GB"
  /// - "COMMITTED_MEMORY_OPTIMIZED_CPUS"
  /// - "COMMITTED_N2A_CPUS"
  /// - "COMMITTED_N2D_CPUS"
  /// - "COMMITTED_N2_CPUS"
  /// - "COMMITTED_NVIDIA_A100_GPUS"
  /// - "COMMITTED_NVIDIA_K80_GPUS"
  /// - "COMMITTED_NVIDIA_P100_GPUS"
  /// - "COMMITTED_NVIDIA_P4_GPUS"
  /// - "COMMITTED_NVIDIA_T4_GPUS"
  /// - "COMMITTED_NVIDIA_V100_GPUS"
  /// - "COMMITTED_T2D_CPUS"
  /// - "CPUS" : Guest CPUs
  /// - "CPUS_ALL_REGIONS"
  /// - "DISKS_TOTAL_GB"
  /// - "E2_CPUS"
  /// - "EXTERNAL_NETWORK_LB_FORWARDING_RULES"
  /// - "EXTERNAL_PROTOCOL_FORWARDING_RULES"
  /// - "EXTERNAL_VPN_GATEWAYS"
  /// - "FIREWALLS"
  /// - "FORWARDING_RULES"
  /// - "GLOBAL_INTERNAL_ADDRESSES"
  /// - "GPUS_ALL_REGIONS"
  /// - "HEALTH_CHECKS"
  /// - "IMAGES"
  /// - "INSTANCES"
  /// - "INSTANCE_GROUPS"
  /// - "INSTANCE_GROUP_MANAGERS"
  /// - "INSTANCE_TEMPLATES"
  /// - "INTERCONNECTS"
  /// - "INTERCONNECT_ATTACHMENTS_PER_REGION"
  /// - "INTERCONNECT_ATTACHMENTS_TOTAL_MBPS"
  /// - "INTERCONNECT_TOTAL_GBPS"
  /// - "INTERNAL_ADDRESSES"
  /// - "INTERNAL_TRAFFIC_DIRECTOR_FORWARDING_RULES"
  /// - "IN_PLACE_SNAPSHOTS"
  /// - "IN_USE_ADDRESSES"
  /// - "IN_USE_BACKUP_SCHEDULES"
  /// - "IN_USE_SNAPSHOT_SCHEDULES"
  /// - "LOCAL_SSD_TOTAL_GB"
  /// - "M1_CPUS"
  /// - "M2_CPUS"
  /// - "MACHINE_IMAGES"
  /// - "N2A_CPUS"
  /// - "N2D_CPUS"
  /// - "N2_CPUS"
  /// - "NETWORKS"
  /// - "NETWORK_ENDPOINT_GROUPS"
  /// - "NETWORK_FIREWALL_POLICIES"
  /// - "NODE_GROUPS"
  /// - "NODE_TEMPLATES"
  /// - "NVIDIA_A100_GPUS"
  /// - "NVIDIA_K80_GPUS"
  /// - "NVIDIA_P100_GPUS"
  /// - "NVIDIA_P100_VWS_GPUS"
  /// - "NVIDIA_P4_GPUS"
  /// - "NVIDIA_P4_VWS_GPUS"
  /// - "NVIDIA_T4_GPUS"
  /// - "NVIDIA_T4_VWS_GPUS"
  /// - "NVIDIA_V100_GPUS"
  /// - "PACKET_MIRRORINGS"
  /// - "PD_EXTREME_TOTAL_PROVISIONED_IOPS"
  /// - "PREEMPTIBLE_CPUS"
  /// - "PREEMPTIBLE_LOCAL_SSD_GB"
  /// - "PREEMPTIBLE_NVIDIA_A100_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_K80_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P4_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P4_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_T4_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_T4_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_V100_GPUS"
  /// - "PSC_ILB_CONSUMER_FORWARDING_RULES_PER_PRODUCER_NETWORK"
  /// - "PSC_INTERNAL_LB_FORWARDING_RULES"
  /// - "PUBLIC_ADVERTISED_PREFIXES"
  /// - "PUBLIC_DELEGATED_PREFIXES"
  /// - "REGIONAL_AUTOSCALERS"
  /// - "REGIONAL_INSTANCE_GROUP_MANAGERS"
  /// - "RESERVATIONS"
  /// - "RESOURCE_POLICIES"
  /// - "ROUTERS"
  /// - "ROUTES"
  /// - "SECURITY_POLICIES"
  /// - "SECURITY_POLICIES_PER_REGION"
  /// - "SECURITY_POLICY_CEVAL_RULES"
  /// - "SECURITY_POLICY_RULES"
  /// - "SECURITY_POLICY_RULES_PER_REGION"
  /// - "SERVICE_ATTACHMENTS"
  /// - "SNAPSHOTS" : The total number of snapshots allowed for a single
  /// project.
  /// - "SSD_TOTAL_GB"
  /// - "SSL_CERTIFICATES"
  /// - "STATIC_ADDRESSES"
  /// - "STATIC_BYOIP_ADDRESSES"
  /// - "SUBNETWORKS"
  /// - "T2D_CPUS"
  /// - "TARGET_HTTPS_PROXIES"
  /// - "TARGET_HTTP_PROXIES"
  /// - "TARGET_INSTANCES"
  /// - "TARGET_POOLS"
  /// - "TARGET_SSL_PROXIES"
  /// - "TARGET_TCP_PROXIES"
  /// - "TARGET_VPN_GATEWAYS"
  /// - "URL_MAPS"
  /// - "VPN_GATEWAYS"
  /// - "VPN_TUNNELS"
  /// - "XPN_SERVICE_PROJECTS"
  core.String? metric;

  /// Owning resource.
  ///
  /// This is the resource on which this quota is applied.
  ///
  /// Output only.
  core.String? owner;

  /// Current usage of this metric.
  ///
  /// Output only.
  core.double? usage;

  Quota({
    this.limit,
    this.metric,
    this.owner,
    this.usage,
  });

  Quota.fromJson(core.Map _json)
      : this(
          limit: _json.containsKey('limit')
              ? (_json['limit'] as core.num).toDouble()
              : null,
          metric: _json.containsKey('metric')
              ? _json['metric'] as core.String
              : null,
          owner:
              _json.containsKey('owner') ? _json['owner'] as core.String : null,
          usage: _json.containsKey('usage')
              ? (_json['usage'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (limit != null) 'limit': limit!,
        if (metric != null) 'metric': metric!,
        if (owner != null) 'owner': owner!,
        if (usage != null) 'usage': usage!,
      };
}

/// Represents a reference to a resource.
class Reference {
  /// Type of the resource.
  ///
  /// Always compute#reference for references.
  ///
  /// Output only.
  core.String? kind;

  /// A description of the reference type with no implied semantics.
  ///
  /// Possible values include: 1. MEMBER_OF
  core.String? referenceType;

  /// URL of the resource which refers to the target.
  core.String? referrer;

  /// URL of the resource to which this reference points.
  core.String? target;

  Reference({
    this.kind,
    this.referenceType,
    this.referrer,
    this.target,
  });

  Reference.fromJson(core.Map _json)
      : this(
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          referenceType: _json.containsKey('referenceType')
              ? _json['referenceType'] as core.String
              : null,
          referrer: _json.containsKey('referrer')
              ? _json['referrer'] as core.String
              : null,
          target: _json.containsKey('target')
              ? _json['target'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (referenceType != null) 'referenceType': referenceType!,
        if (referrer != null) 'referrer': referrer!,
        if (target != null) 'target': target!,
      };
}

/// Represents a Region resource.
///
/// A region is a geographical area where a resource is located. For more
/// information, read Regions and Zones.
class Region {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this region.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// Textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#region for regions.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// Quotas assigned to this region.
  ///
  /// Output only.
  core.List<Quota>? quotas;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Status of the region, either UP or DOWN.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String? status;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? supportsPzs;

  /// A list of zones available in this region, in the form of resource URLs.
  ///
  /// Output only.
  core.List<core.String>? zones;

  Region({
    this.creationTimestamp,
    this.deprecated,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.quotas,
    this.selfLink,
    this.status,
    this.supportsPzs,
    this.zones,
  });

  Region.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          deprecated: _json.containsKey('deprecated')
              ? DeprecationStatus.fromJson(
                  _json['deprecated'] as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          quotas: _json.containsKey('quotas')
              ? (_json['quotas'] as core.List)
                  .map<Quota>((value) => Quota.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          supportsPzs: _json.containsKey('supportsPzs')
              ? _json['supportsPzs'] as core.bool
              : null,
          zones: _json.containsKey('zones')
              ? (_json['zones'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (quotas != null)
          'quotas': quotas!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (supportsPzs != null) 'supportsPzs': supportsPzs!,
        if (zones != null) 'zones': zones!,
      };
}

class RegionAutoscalerListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionAutoscalerListWarningData({
    this.key,
    this.value,
  });

  RegionAutoscalerListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionAutoscalerListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionAutoscalerListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionAutoscalerListWarning({
    this.code,
    this.data,
    this.message,
  });

  RegionAutoscalerListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RegionAutoscalerListWarningData>((value) =>
                      RegionAutoscalerListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of autoscalers.
class RegionAutoscalerList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionAutoscalerListWarning? warning;

  RegionAutoscalerList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  RegionAutoscalerList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Autoscaler>((value) => Autoscaler.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RegionAutoscalerListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionDiskTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionDiskTypeListWarningData({
    this.key,
    this.value,
  });

  RegionDiskTypeListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionDiskTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionDiskTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionDiskTypeListWarning({
    this.code,
    this.data,
    this.message,
  });

  RegionDiskTypeListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RegionDiskTypeListWarningData>((value) =>
                      RegionDiskTypeListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class RegionDiskTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of DiskType resources.
  core.List<DiskType>? items;

  /// Type of resource.
  ///
  /// Always compute#regionDiskTypeList for region disk types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionDiskTypeListWarning? warning;

  RegionDiskTypeList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  RegionDiskTypeList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<DiskType>((value) => DiskType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RegionDiskTypeListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionDisksAddResourcePoliciesRequest {
  /// Resource policies to be added to this disk.
  core.List<core.String>? resourcePolicies;

  RegionDisksAddResourcePoliciesRequest({
    this.resourcePolicies,
  });

  RegionDisksAddResourcePoliciesRequest.fromJson(core.Map _json)
      : this(
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class RegionDisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String>? resourcePolicies;

  RegionDisksRemoveResourcePoliciesRequest({
    this.resourcePolicies,
  });

  RegionDisksRemoveResourcePoliciesRequest.fromJson(core.Map _json)
      : this(
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class RegionDisksResizeRequest {
  /// The new size of the regional persistent disk, which is specified in GB.
  core.String? sizeGb;

  RegionDisksResizeRequest({
    this.sizeGb,
  });

  RegionDisksResizeRequest.fromJson(core.Map _json)
      : this(
          sizeGb: _json.containsKey('sizeGb')
              ? _json['sizeGb'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sizeGb != null) 'sizeGb': sizeGb!,
      };
}

class RegionInstanceGroupListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionInstanceGroupListWarningData({
    this.key,
    this.value,
  });

  RegionInstanceGroupListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionInstanceGroupListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionInstanceGroupListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionInstanceGroupListWarning({
    this.code,
    this.data,
    this.message,
  });

  RegionInstanceGroupListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RegionInstanceGroupListWarningData>((value) =>
                      RegionInstanceGroupListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of InstanceGroup resources.
class RegionInstanceGroupList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup>? items;

  /// The resource type.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionInstanceGroupListWarning? warning;

  RegionInstanceGroupList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  RegionInstanceGroupList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceGroup>((value) => InstanceGroup.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RegionInstanceGroupListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// RegionInstanceGroupManagers.deletePerInstanceConfigs
class RegionInstanceGroupManagerDeleteInstanceConfigReq {
  /// The list of instance names for which we want to delete per-instance
  /// configs on this managed instance group.
  core.List<core.String>? names;

  RegionInstanceGroupManagerDeleteInstanceConfigReq({
    this.names,
  });

  RegionInstanceGroupManagerDeleteInstanceConfigReq.fromJson(core.Map _json)
      : this(
          names: _json.containsKey('names')
              ? (_json['names'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (names != null) 'names': names!,
      };
}

class RegionInstanceGroupManagerListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionInstanceGroupManagerListWarningData({
    this.key,
    this.value,
  });

  RegionInstanceGroupManagerListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionInstanceGroupManagerListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionInstanceGroupManagerListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionInstanceGroupManagerListWarning({
    this.code,
    this.data,
    this.message,
  });

  RegionInstanceGroupManagerListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RegionInstanceGroupManagerListWarningData>((value) =>
                      RegionInstanceGroupManagerListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of managed instance groups.
class RegionInstanceGroupManagerList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager>? items;

  /// The resource type, which is always compute#instanceGroupManagerList for a
  /// list of managed instance groups that exist in th regional scope.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionInstanceGroupManagerListWarning? warning;

  RegionInstanceGroupManagerList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  RegionInstanceGroupManagerList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceGroupManager>((value) =>
                      InstanceGroupManager.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RegionInstanceGroupManagerListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// RegionInstanceGroupManagers.patchPerInstanceConfigs
class RegionInstanceGroupManagerPatchInstanceConfigReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig>? perInstanceConfigs;

  RegionInstanceGroupManagerPatchInstanceConfigReq({
    this.perInstanceConfigs,
  });

  RegionInstanceGroupManagerPatchInstanceConfigReq.fromJson(core.Map _json)
      : this(
          perInstanceConfigs: _json.containsKey('perInstanceConfigs')
              ? (_json['perInstanceConfigs'] as core.List)
                  .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (perInstanceConfigs != null)
          'perInstanceConfigs':
              perInstanceConfigs!.map((value) => value.toJson()).toList(),
      };
}

/// RegionInstanceGroupManagers.updatePerInstanceConfigs
class RegionInstanceGroupManagerUpdateInstanceConfigReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig>? perInstanceConfigs;

  RegionInstanceGroupManagerUpdateInstanceConfigReq({
    this.perInstanceConfigs,
  });

  RegionInstanceGroupManagerUpdateInstanceConfigReq.fromJson(core.Map _json)
      : this(
          perInstanceConfigs: _json.containsKey('perInstanceConfigs')
              ? (_json['perInstanceConfigs'] as core.List)
                  .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (perInstanceConfigs != null)
          'perInstanceConfigs':
              perInstanceConfigs!.map((value) => value.toJson()).toList(),
      };
}

class RegionInstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  RegionInstanceGroupManagersAbandonInstancesRequest({
    this.instances,
  });

  RegionInstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

/// RegionInstanceGroupManagers.applyUpdatesToInstances
class RegionInstanceGroupManagersApplyUpdatesRequest {
  /// Flag to update all instances instead of specified list of “instances”.
  ///
  /// If the flag is set to true then the instances may not be specified in the
  /// request.
  core.bool? allInstances;

  /// The list of URLs of one or more instances for which you want to apply
  /// updates.
  ///
  /// Each URL can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// The minimal action that you want to perform on each instance during the
  /// update: - REPLACE: At minimum, delete the instance and create it again.
  ///
  /// - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
  /// the instance. - NONE: Do not disrupt the instance at all. By default, the
  /// minimum action is NONE. If your update requires a more disruptive action
  /// than you set with this flag, the necessary action is performed to execute
  /// the update.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Updates applied in runtime, instances will not be disrupted.
  /// - "REPLACE" : Old instances will be deleted. New instances will be created
  /// from the target template.
  /// - "RESTART" : Every instance will be restarted.
  core.String? minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update: - REPLACE: Delete the instance and create it again.
  ///
  /// - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
  /// the instance. - NONE: Do not disrupt the instance at all. By default, the
  /// most disruptive allowed action is REPLACE. If your update requires a more
  /// disruptive action than you set with this flag, the update request will
  /// fail.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Updates applied in runtime, instances will not be disrupted.
  /// - "REPLACE" : Old instances will be deleted. New instances will be created
  /// from the target template.
  /// - "RESTART" : Every instance will be restarted.
  core.String? mostDisruptiveAllowedAction;

  RegionInstanceGroupManagersApplyUpdatesRequest({
    this.allInstances,
    this.instances,
    this.minimalAction,
    this.mostDisruptiveAllowedAction,
  });

  RegionInstanceGroupManagersApplyUpdatesRequest.fromJson(core.Map _json)
      : this(
          allInstances: _json.containsKey('allInstances')
              ? _json['allInstances'] as core.bool
              : null,
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          minimalAction: _json.containsKey('minimalAction')
              ? _json['minimalAction'] as core.String
              : null,
          mostDisruptiveAllowedAction:
              _json.containsKey('mostDisruptiveAllowedAction')
                  ? _json['mostDisruptiveAllowedAction'] as core.String
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allInstances != null) 'allInstances': allInstances!,
        if (instances != null) 'instances': instances!,
        if (minimalAction != null) 'minimalAction': minimalAction!,
        if (mostDisruptiveAllowedAction != null)
          'mostDisruptiveAllowedAction': mostDisruptiveAllowedAction!,
      };
}

/// RegionInstanceGroupManagers.createInstances
class RegionInstanceGroupManagersCreateInstancesRequest {
  /// List of specifications of per-instance configs.
  ///
  /// Required.
  core.List<PerInstanceConfig>? instances;

  RegionInstanceGroupManagersCreateInstancesRequest({
    this.instances,
  });

  RegionInstanceGroupManagersCreateInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class RegionInstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// Specifies whether the request should proceed despite the inclusion of
  /// instances that are not members of the group or that are already in the
  /// process of being deleted or abandoned.
  ///
  /// If this field is set to `false` and such an instance is specified in the
  /// request, the operation fails. The operation always fails if the request
  /// contains a malformed instance URL or a reference to an instance that
  /// exists in a zone or region other than the group's zone or region.
  core.bool? skipInstancesOnValidationError;

  RegionInstanceGroupManagersDeleteInstancesRequest({
    this.instances,
    this.skipInstancesOnValidationError,
  });

  RegionInstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          skipInstancesOnValidationError:
              _json.containsKey('skipInstancesOnValidationError')
                  ? _json['skipInstancesOnValidationError'] as core.bool
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (skipInstancesOnValidationError != null)
          'skipInstancesOnValidationError': skipInstancesOnValidationError!,
      };
}

class RegionInstanceGroupManagersListErrorsResponse {
  /// The list of errors of the managed instance group.
  ///
  /// Output only.
  core.List<InstanceManagedByIgmError>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  RegionInstanceGroupManagersListErrorsResponse({
    this.items,
    this.nextPageToken,
  });

  RegionInstanceGroupManagersListErrorsResponse.fromJson(core.Map _json)
      : this(
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceManagedByIgmError>((value) =>
                      InstanceManagedByIgmError.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

class RegionInstanceGroupManagersListInstanceConfigsRespWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionInstanceGroupManagersListInstanceConfigsRespWarningData({
    this.key,
    this.value,
  });

  RegionInstanceGroupManagersListInstanceConfigsRespWarningData.fromJson(
      core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionInstanceGroupManagersListInstanceConfigsRespWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionInstanceGroupManagersListInstanceConfigsRespWarningData>?
      data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionInstanceGroupManagersListInstanceConfigsRespWarning({
    this.code,
    this.data,
    this.message,
  });

  RegionInstanceGroupManagersListInstanceConfigsRespWarning.fromJson(
      core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RegionInstanceGroupManagersListInstanceConfigsRespWarningData>(
                      (value) =>
                          RegionInstanceGroupManagersListInstanceConfigsRespWarningData
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class RegionInstanceGroupManagersListInstanceConfigsResp {
  /// The list of PerInstanceConfig.
  ///
  /// Output only.
  core.List<PerInstanceConfig>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  RegionInstanceGroupManagersListInstanceConfigsRespWarning? warning;

  RegionInstanceGroupManagersListInstanceConfigsResp({
    this.items,
    this.nextPageToken,
    this.warning,
  });

  RegionInstanceGroupManagersListInstanceConfigsResp.fromJson(core.Map _json)
      : this(
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RegionInstanceGroupManagersListInstanceConfigsRespWarning
                  .fromJson(
                      _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionInstanceGroupManagersListInstancesResponse {
  /// A list of managed instances.
  core.List<ManagedInstance>? managedInstances;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  RegionInstanceGroupManagersListInstancesResponse({
    this.managedInstances,
    this.nextPageToken,
  });

  RegionInstanceGroupManagersListInstancesResponse.fromJson(core.Map _json)
      : this(
          managedInstances: _json.containsKey('managedInstances')
              ? (_json['managedInstances'] as core.List)
                  .map<ManagedInstance>((value) => ManagedInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (managedInstances != null)
          'managedInstances':
              managedInstances!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

class RegionInstanceGroupManagersRecreateRequest {
  /// The URLs of one or more instances to recreate.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  RegionInstanceGroupManagersRecreateRequest({
    this.instances,
  });

  RegionInstanceGroupManagersRecreateRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

class RegionInstanceGroupManagersSetTargetPoolsRequest {
  /// Fingerprint of the target pools information, which is a hash of the
  /// contents.
  ///
  /// This field is used for optimistic locking when you update the target pool
  /// entries. This field is optional.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The URL of all TargetPool resources to which instances in the
  /// instanceGroup field are added.
  ///
  /// The target pools automatically apply to all of the instances in the
  /// managed instance group.
  core.List<core.String>? targetPools;

  RegionInstanceGroupManagersSetTargetPoolsRequest({
    this.fingerprint,
    this.targetPools,
  });

  RegionInstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json)
      : this(
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          targetPools: _json.containsKey('targetPools')
              ? (_json['targetPools'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (targetPools != null) 'targetPools': targetPools!,
      };
}

class RegionInstanceGroupManagersSetTemplateRequest {
  /// URL of the InstanceTemplate resource from which all new instances will be
  /// created.
  core.String? instanceTemplate;

  RegionInstanceGroupManagersSetTemplateRequest({
    this.instanceTemplate,
  });

  RegionInstanceGroupManagersSetTemplateRequest.fromJson(core.Map _json)
      : this(
          instanceTemplate: _json.containsKey('instanceTemplate')
              ? _json['instanceTemplate'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
      };
}

class RegionInstanceGroupsListInstancesWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionInstanceGroupsListInstancesWarningData({
    this.key,
    this.value,
  });

  RegionInstanceGroupsListInstancesWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionInstanceGroupsListInstancesWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionInstanceGroupsListInstancesWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionInstanceGroupsListInstancesWarning({
    this.code,
    this.data,
    this.message,
  });

  RegionInstanceGroupsListInstancesWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RegionInstanceGroupsListInstancesWarningData>((value) =>
                      RegionInstanceGroupsListInstancesWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class RegionInstanceGroupsListInstances {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts>? items;

  /// The resource type.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionInstanceGroupsListInstancesWarning? warning;

  RegionInstanceGroupsListInstances({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  RegionInstanceGroupsListInstances.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<InstanceWithNamedPorts>((value) =>
                      InstanceWithNamedPorts.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RegionInstanceGroupsListInstancesWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionInstanceGroupsListInstancesRequest {
  /// Instances in which state should be returned.
  ///
  /// Valid options are: 'ALL', 'RUNNING'. By default, it lists all instances.
  /// Possible string values are:
  /// - "ALL" : Matches any status of the instances, running, non-running and
  /// others.
  /// - "RUNNING" : Instance is in RUNNING state if it is running.
  core.String? instanceState;

  /// Name of port user is interested in.
  ///
  /// It is optional. If it is set, only information about this ports will be
  /// returned. If it is not set, all the named ports will be returned. Always
  /// lists all instances.
  core.String? portName;

  RegionInstanceGroupsListInstancesRequest({
    this.instanceState,
    this.portName,
  });

  RegionInstanceGroupsListInstancesRequest.fromJson(core.Map _json)
      : this(
          instanceState: _json.containsKey('instanceState')
              ? _json['instanceState'] as core.String
              : null,
          portName: _json.containsKey('portName')
              ? _json['portName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceState != null) 'instanceState': instanceState!,
        if (portName != null) 'portName': portName!,
      };
}

class RegionInstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  ///
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort>? namedPorts;

  RegionInstanceGroupsSetNamedPortsRequest({
    this.fingerprint,
    this.namedPorts,
  });

  RegionInstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json)
      : this(
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          namedPorts: _json.containsKey('namedPorts')
              ? (_json['namedPorts'] as core.List)
                  .map<NamedPort>((value) => NamedPort.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
      };
}

class RegionListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionListWarningData({
    this.key,
    this.value,
  });

  RegionListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionListWarning({
    this.code,
    this.data,
    this.message,
  });

  RegionListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RegionListWarningData>((value) =>
                      RegionListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of region resources.
class RegionList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Region resources.
  core.List<Region>? items;

  /// Type of resource.
  ///
  /// Always compute#regionList for lists of regions.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionListWarning? warning;

  RegionList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  RegionList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Region>((value) => Region.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RegionListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels. Make a
  /// get() request to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String>? labels;

  RegionSetLabelsRequest({
    this.labelFingerprint,
    this.labels,
  });

  RegionSetLabelsRequest.fromJson(core.Map _json)
      : this(
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
      };
}

class RegionSetPolicyRequest {
  /// Flatten Policy to create a backwacd compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify bindings.
  core.List<Binding>? bindings;

  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify the etag.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is
  /// in general a valid policy but certain services (like Projects) might
  /// reject them.
  Policy? policy;

  RegionSetPolicyRequest({
    this.bindings,
    this.etag,
    this.policy,
  });

  RegionSetPolicyRequest.fromJson(core.Map _json)
      : this(
          bindings: _json.containsKey('bindings')
              ? (_json['bindings'] as core.List)
                  .map<Binding>((value) => Binding.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          etag: _json.containsKey('etag') ? _json['etag'] as core.String : null,
          policy: _json.containsKey('policy')
              ? Policy.fromJson(
                  _json['policy'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (policy != null) 'policy': policy!.toJson(),
      };
}

class RegionTargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource.
  ///
  /// Currently exactly one SslCertificate resource must be specified.
  core.List<core.String>? sslCertificates;

  RegionTargetHttpsProxiesSetSslCertificatesRequest({
    this.sslCertificates,
  });

  RegionTargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json)
      : this(
          sslCertificates: _json.containsKey('sslCertificates')
              ? (_json['sslCertificates'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
      };
}

class RegionUrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap? resource;

  RegionUrlMapsValidateRequest({
    this.resource,
  });

  RegionUrlMapsValidateRequest.fromJson(core.Map _json)
      : this(
          resource: _json.containsKey('resource')
              ? UrlMap.fromJson(
                  _json['resource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resource != null) 'resource': resource!.toJson(),
      };
}

/// A policy that specifies how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service.
///
/// Loadbalancer does not wait for responses from the shadow service. Prior to
/// sending traffic to the shadow service, the host / authority header is
/// suffixed with -shadow.
class RequestMirrorPolicy {
  /// The full or partial URL to the BackendService resource being mirrored to.
  core.String? backendService;

  RequestMirrorPolicy({
    this.backendService,
  });

  RequestMirrorPolicy.fromJson(core.Map _json)
      : this(
          backendService: _json.containsKey('backendService')
              ? _json['backendService'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendService != null) 'backendService': backendService!,
      };
}

/// Represents a reservation resource.
///
/// A reservation ensures that capacity is held in a specific zone even if the
/// reserved VMs are not running. For more information, read Reserving zonal
/// resources.
class Reservation {
  /// Full or partial URL to a parent commitment.
  ///
  /// This field displays for reservations that are tied to a commitment.
  ///
  /// Output only.
  core.String? commitment;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#reservations for reservations.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Reservation for instances with specific machine shapes.
  AllocationSpecificSKUReservation? specificReservation;

  /// Indicates whether the reservation can be consumed by VMs with affinity for
  /// "any" reservation.
  ///
  /// If the field is set, then only VMs that target the reservation by name can
  /// consume from this reservation.
  core.bool? specificReservationRequired;

  /// The status of the reservation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING" : Resources are being allocated for the reservation.
  /// - "DELETING" : Reservation is currently being deleted.
  /// - "INVALID"
  /// - "READY" : Reservation has allocated all its resources.
  /// - "UPDATING" : Reservation is currently being resized.
  core.String? status;

  /// Zone in which the reservation resides.
  ///
  /// A zone must be provided if the reservation is created within a commitment.
  core.String? zone;

  Reservation({
    this.commitment,
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.satisfiesPzs,
    this.selfLink,
    this.specificReservation,
    this.specificReservationRequired,
    this.status,
    this.zone,
  });

  Reservation.fromJson(core.Map _json)
      : this(
          commitment: _json.containsKey('commitment')
              ? _json['commitment'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          satisfiesPzs: _json.containsKey('satisfiesPzs')
              ? _json['satisfiesPzs'] as core.bool
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          specificReservation: _json.containsKey('specificReservation')
              ? AllocationSpecificSKUReservation.fromJson(
                  _json['specificReservation']
                      as core.Map<core.String, core.dynamic>)
              : null,
          specificReservationRequired:
              _json.containsKey('specificReservationRequired')
                  ? _json['specificReservationRequired'] as core.bool
                  : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (commitment != null) 'commitment': commitment!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (specificReservation != null)
          'specificReservation': specificReservation!.toJson(),
        if (specificReservationRequired != null)
          'specificReservationRequired': specificReservationRequired!,
        if (status != null) 'status': status!,
        if (zone != null) 'zone': zone!,
      };
}

/// Specifies the reservations that this instance can consume from.
class ReservationAffinity {
  /// Specifies the type of reservation from which this instance can consume
  /// resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or
  /// NO_RESERVATION.
  ///
  /// See Consuming reserved instances for examples.
  /// Possible string values are:
  /// - "ANY_RESERVATION" : Consume any allocation available.
  /// - "NO_RESERVATION" : Do not consume from any allocated capacity.
  /// - "SPECIFIC_RESERVATION" : Must consume from a specific reservation. Must
  /// specify key value fields for specifying the reservations.
  /// - "UNSPECIFIED"
  core.String? consumeReservationType;

  /// Corresponds to the label key of a reservation resource.
  ///
  /// To target a SPECIFIC_RESERVATION by name, specify
  /// googleapis.com/reservation-name as the key and specify the name of your
  /// reservation as its value.
  core.String? key;

  /// Corresponds to the label values of a reservation resource.
  ///
  /// This can be either a name to a reservation in the same project or
  /// "projects/different-project/reservations/some-reservation-name" to target
  /// a shared reservation in the same zone but in a different project.
  core.List<core.String>? values;

  ReservationAffinity({
    this.consumeReservationType,
    this.key,
    this.values,
  });

  ReservationAffinity.fromJson(core.Map _json)
      : this(
          consumeReservationType: _json.containsKey('consumeReservationType')
              ? _json['consumeReservationType'] as core.String
              : null,
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          values: _json.containsKey('values')
              ? (_json['values'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (consumeReservationType != null)
          'consumeReservationType': consumeReservationType!,
        if (key != null) 'key': key!,
        if (values != null) 'values': values!,
      };
}

class ReservationAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ReservationAggregatedListWarningData({
    this.key,
    this.value,
  });

  ReservationAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ReservationAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ReservationAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ReservationAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  ReservationAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ReservationAggregatedListWarningData>((value) =>
                      ReservationAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of reservations.
class ReservationAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Allocation resources.
  core.Map<core.String, ReservationsScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  ReservationAggregatedListWarning? warning;

  ReservationAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  ReservationAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    ReservationsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? ReservationAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ReservationListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ReservationListWarningData({
    this.key,
    this.value,
  });

  ReservationListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ReservationListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ReservationListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ReservationListWarning({
    this.code,
    this.data,
    this.message,
  });

  ReservationListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ReservationListWarningData>((value) =>
                      ReservationListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ReservationList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Allocation resources.
  ///
  /// Output only.
  core.List<Reservation>? items;

  /// Type of resource.Always compute#reservationsList for listsof reservations
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ReservationListWarning? warning;

  ReservationList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  ReservationList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Reservation>((value) => Reservation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? ReservationListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ReservationsResizeRequest {
  /// Number of allocated resources can be resized with minimum = 1 and maximum
  /// = 1000.
  core.String? specificSkuCount;

  ReservationsResizeRequest({
    this.specificSkuCount,
  });

  ReservationsResizeRequest.fromJson(core.Map _json)
      : this(
          specificSkuCount: _json.containsKey('specificSkuCount')
              ? _json['specificSkuCount'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (specificSkuCount != null) 'specificSkuCount': specificSkuCount!,
      };
}

class ReservationsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ReservationsScopedListWarningData({
    this.key,
    this.value,
  });

  ReservationsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of reservations when the list
/// is empty.
class ReservationsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ReservationsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ReservationsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  ReservationsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ReservationsScopedListWarningData>((value) =>
                      ReservationsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ReservationsScopedList {
  /// A list of reservations contained in this scope.
  core.List<Reservation>? reservations;

  /// Informational warning which replaces the list of reservations when the
  /// list is empty.
  ReservationsScopedListWarning? warning;

  ReservationsScopedList({
    this.reservations,
    this.warning,
  });

  ReservationsScopedList.fromJson(core.Map _json)
      : this(
          reservations: _json.containsKey('reservations')
              ? (_json['reservations'] as core.List)
                  .map<Reservation>((value) => Reservation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? ReservationsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (reservations != null)
          'reservations': reservations!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Commitment for a particular resource (a Commitment is composed of one or
/// more of these).
class ResourceCommitment {
  /// Name of the accelerator type resource.
  ///
  /// Applicable only when the type is ACCELERATOR.
  core.String? acceleratorType;

  /// The amount of the resource purchased (in a type-dependent unit, such as
  /// bytes).
  ///
  /// For vCPUs, this can just be an integer. For memory, this must be provided
  /// in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of memory per
  /// every vCPU.
  core.String? amount;

  /// Type of resource for which this commitment applies.
  ///
  /// Possible values are VCPU and MEMORY
  /// Possible string values are:
  /// - "ACCELERATOR"
  /// - "LOCAL_SSD"
  /// - "MEMORY"
  /// - "UNSPECIFIED"
  /// - "VCPU"
  core.String? type;

  ResourceCommitment({
    this.acceleratorType,
    this.amount,
    this.type,
  });

  ResourceCommitment.fromJson(core.Map _json)
      : this(
          acceleratorType: _json.containsKey('acceleratorType')
              ? _json['acceleratorType'] as core.String
              : null,
          amount: _json.containsKey('amount')
              ? _json['amount'] as core.String
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (acceleratorType != null) 'acceleratorType': acceleratorType!,
        if (amount != null) 'amount': amount!,
        if (type != null) 'type': type!,
      };
}

class ResourceGroupReference {
  /// A URI referencing one of the instance groups or network endpoint groups
  /// listed in the backend service.
  core.String? group;

  ResourceGroupReference({
    this.group,
  });

  ResourceGroupReference.fromJson(core.Map _json)
      : this(
          group:
              _json.containsKey('group') ? _json['group'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (group != null) 'group': group!,
      };
}

class ResourcePoliciesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ResourcePoliciesScopedListWarningData({
    this.key,
    this.value,
  });

  ResourcePoliciesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of resourcePolicies when the
/// list is empty.
class ResourcePoliciesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ResourcePoliciesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ResourcePoliciesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  ResourcePoliciesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ResourcePoliciesScopedListWarningData>((value) =>
                      ResourcePoliciesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ResourcePoliciesScopedList {
  /// A list of resourcePolicies contained in this scope.
  core.List<ResourcePolicy>? resourcePolicies;

  /// Informational warning which replaces the list of resourcePolicies when the
  /// list is empty.
  ResourcePoliciesScopedListWarning? warning;

  ResourcePoliciesScopedList({
    this.resourcePolicies,
    this.warning,
  });

  ResourcePoliciesScopedList.fromJson(core.Map _json)
      : this(
          resourcePolicies: _json.containsKey('resourcePolicies')
              ? (_json['resourcePolicies'] as core.List)
                  .map<ResourcePolicy>((value) => ResourcePolicy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? ResourcePoliciesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null)
          'resourcePolicies':
              resourcePolicies!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Resource Policy resource.
///
/// You can use resource policies to schedule actions for some Compute Engine
/// resources. For example, you can use them to schedule persistent disk
/// snapshots.
class ResourcePolicy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;
  core.String? description;

  /// Resource policy for instances for placement configuration.
  ResourcePolicyGroupPlacementPolicy? groupPlacementPolicy;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Resource policy for scheduling instance operations.
  ResourcePolicyInstanceSchedulePolicy? instanceSchedulePolicy;

  /// Type of the resource.
  ///
  /// Always compute#resource_policies for resource policies.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;
  core.String? region;

  /// The system status of the resource policy.
  ///
  /// Output only.
  ResourcePolicyResourceStatus? resourceStatus;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Resource policy for persistent disks for creating snapshots.
  ResourcePolicySnapshotSchedulePolicy? snapshotSchedulePolicy;

  /// The status of resource policy creation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING" : Resource policy is being created.
  /// - "DELETING" : Resource policy is being deleted.
  /// - "EXPIRED" : Resource policy is expired and will not run again.
  /// - "INVALID"
  /// - "READY" : Resource policy is ready to be used.
  core.String? status;

  ResourcePolicy({
    this.creationTimestamp,
    this.description,
    this.groupPlacementPolicy,
    this.id,
    this.instanceSchedulePolicy,
    this.kind,
    this.name,
    this.region,
    this.resourceStatus,
    this.selfLink,
    this.snapshotSchedulePolicy,
    this.status,
  });

  ResourcePolicy.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          groupPlacementPolicy: _json.containsKey('groupPlacementPolicy')
              ? ResourcePolicyGroupPlacementPolicy.fromJson(
                  _json['groupPlacementPolicy']
                      as core.Map<core.String, core.dynamic>)
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          instanceSchedulePolicy: _json.containsKey('instanceSchedulePolicy')
              ? ResourcePolicyInstanceSchedulePolicy.fromJson(
                  _json['instanceSchedulePolicy']
                      as core.Map<core.String, core.dynamic>)
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          resourceStatus: _json.containsKey('resourceStatus')
              ? ResourcePolicyResourceStatus.fromJson(_json['resourceStatus']
                  as core.Map<core.String, core.dynamic>)
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          snapshotSchedulePolicy: _json.containsKey('snapshotSchedulePolicy')
              ? ResourcePolicySnapshotSchedulePolicy.fromJson(
                  _json['snapshotSchedulePolicy']
                      as core.Map<core.String, core.dynamic>)
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (groupPlacementPolicy != null)
          'groupPlacementPolicy': groupPlacementPolicy!.toJson(),
        if (id != null) 'id': id!,
        if (instanceSchedulePolicy != null)
          'instanceSchedulePolicy': instanceSchedulePolicy!.toJson(),
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (resourceStatus != null) 'resourceStatus': resourceStatus!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (snapshotSchedulePolicy != null)
          'snapshotSchedulePolicy': snapshotSchedulePolicy!.toJson(),
        if (status != null) 'status': status!,
      };
}

class ResourcePolicyAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ResourcePolicyAggregatedListWarningData({
    this.key,
    this.value,
  });

  ResourcePolicyAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ResourcePolicyAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ResourcePolicyAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ResourcePolicyAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  ResourcePolicyAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ResourcePolicyAggregatedListWarningData>((value) =>
                      ResourcePolicyAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of resourcePolicies.
class ResourcePolicyAggregatedList {
  core.String? etag;

  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ResourcePolicy resources.
  core.Map<core.String, ResourcePoliciesScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  ResourcePolicyAggregatedListWarning? warning;

  ResourcePolicyAggregatedList({
    this.etag,
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  ResourcePolicyAggregatedList.fromJson(core.Map _json)
      : this(
          etag: _json.containsKey('etag') ? _json['etag'] as core.String : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    ResourcePoliciesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? ResourcePolicyAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (etag != null) 'etag': etag!,
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Time window specified for daily operations.
class ResourcePolicyDailyCycle {
  /// Defines a schedule with units measured in months.
  ///
  /// The value determines how many months pass between the start of each cycle.
  core.int? daysInCycle;

  /// A predetermined duration for the window, automatically chosen to be the
  /// smallest possible in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Start time of the window.
  ///
  /// This must be in UTC format that resolves to one of 00:00, 04:00, 08:00,
  /// 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
  core.String? startTime;

  ResourcePolicyDailyCycle({
    this.daysInCycle,
    this.duration,
    this.startTime,
  });

  ResourcePolicyDailyCycle.fromJson(core.Map _json)
      : this(
          daysInCycle: _json.containsKey('daysInCycle')
              ? _json['daysInCycle'] as core.int
              : null,
          duration: _json.containsKey('duration')
              ? _json['duration'] as core.String
              : null,
          startTime: _json.containsKey('startTime')
              ? _json['startTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (daysInCycle != null) 'daysInCycle': daysInCycle!,
        if (duration != null) 'duration': duration!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// A GroupPlacementPolicy specifies resource placement configuration.
///
/// It specifies the failure bucket separation as well as network locality
class ResourcePolicyGroupPlacementPolicy {
  /// The number of availability domains instances will be spread across.
  ///
  /// If two instances are in different availability domain, they will not be
  /// put in the same low latency network
  core.int? availabilityDomainCount;

  /// Specifies network collocation
  /// Possible string values are:
  /// - "COLLOCATED"
  /// - "UNSPECIFIED_COLLOCATION"
  core.String? collocation;

  /// Number of vms in this placement group
  core.int? vmCount;

  ResourcePolicyGroupPlacementPolicy({
    this.availabilityDomainCount,
    this.collocation,
    this.vmCount,
  });

  ResourcePolicyGroupPlacementPolicy.fromJson(core.Map _json)
      : this(
          availabilityDomainCount: _json.containsKey('availabilityDomainCount')
              ? _json['availabilityDomainCount'] as core.int
              : null,
          collocation: _json.containsKey('collocation')
              ? _json['collocation'] as core.String
              : null,
          vmCount: _json.containsKey('vmCount')
              ? _json['vmCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (availabilityDomainCount != null)
          'availabilityDomainCount': availabilityDomainCount!,
        if (collocation != null) 'collocation': collocation!,
        if (vmCount != null) 'vmCount': vmCount!,
      };
}

/// Time window specified for hourly operations.
class ResourcePolicyHourlyCycle {
  /// Duration of the time window, automatically chosen to be smallest possible
  /// in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Defines a schedule with units measured in hours.
  ///
  /// The value determines how many hours pass between the start of each cycle.
  core.int? hoursInCycle;

  /// Time within the window to start the operations.
  ///
  /// It must be in format "HH:MM", where HH : \[00-23\] and MM : \[00-00\] GMT.
  core.String? startTime;

  ResourcePolicyHourlyCycle({
    this.duration,
    this.hoursInCycle,
    this.startTime,
  });

  ResourcePolicyHourlyCycle.fromJson(core.Map _json)
      : this(
          duration: _json.containsKey('duration')
              ? _json['duration'] as core.String
              : null,
          hoursInCycle: _json.containsKey('hoursInCycle')
              ? _json['hoursInCycle'] as core.int
              : null,
          startTime: _json.containsKey('startTime')
              ? _json['startTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (duration != null) 'duration': duration!,
        if (hoursInCycle != null) 'hoursInCycle': hoursInCycle!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// An InstanceSchedulePolicy specifies when and how frequent certain operations
/// are performed on the instance.
class ResourcePolicyInstanceSchedulePolicy {
  /// The expiration time of the schedule.
  ///
  /// The timestamp is an RFC3339 string.
  core.String? expirationTime;

  /// The start time of the schedule.
  ///
  /// The timestamp is an RFC3339 string.
  core.String? startTime;

  /// Specifies the time zone to be used in interpreting Schedule.schedule.
  ///
  /// The value of this field must be a time zone name from the tz database:
  /// http://en.wikipedia.org/wiki/Tz_database.
  core.String? timeZone;

  /// Specifies the schedule for starting instances.
  ResourcePolicyInstanceSchedulePolicySchedule? vmStartSchedule;

  /// Specifies the schedule for stopping instances.
  ResourcePolicyInstanceSchedulePolicySchedule? vmStopSchedule;

  ResourcePolicyInstanceSchedulePolicy({
    this.expirationTime,
    this.startTime,
    this.timeZone,
    this.vmStartSchedule,
    this.vmStopSchedule,
  });

  ResourcePolicyInstanceSchedulePolicy.fromJson(core.Map _json)
      : this(
          expirationTime: _json.containsKey('expirationTime')
              ? _json['expirationTime'] as core.String
              : null,
          startTime: _json.containsKey('startTime')
              ? _json['startTime'] as core.String
              : null,
          timeZone: _json.containsKey('timeZone')
              ? _json['timeZone'] as core.String
              : null,
          vmStartSchedule: _json.containsKey('vmStartSchedule')
              ? ResourcePolicyInstanceSchedulePolicySchedule.fromJson(
                  _json['vmStartSchedule']
                      as core.Map<core.String, core.dynamic>)
              : null,
          vmStopSchedule: _json.containsKey('vmStopSchedule')
              ? ResourcePolicyInstanceSchedulePolicySchedule.fromJson(
                  _json['vmStopSchedule']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (expirationTime != null) 'expirationTime': expirationTime!,
        if (startTime != null) 'startTime': startTime!,
        if (timeZone != null) 'timeZone': timeZone!,
        if (vmStartSchedule != null)
          'vmStartSchedule': vmStartSchedule!.toJson(),
        if (vmStopSchedule != null) 'vmStopSchedule': vmStopSchedule!.toJson(),
      };
}

/// Schedule for an instance operation.
class ResourcePolicyInstanceSchedulePolicySchedule {
  /// Specifies the frequency for the operation, using the unix-cron format.
  core.String? schedule;

  ResourcePolicyInstanceSchedulePolicySchedule({
    this.schedule,
  });

  ResourcePolicyInstanceSchedulePolicySchedule.fromJson(core.Map _json)
      : this(
          schedule: _json.containsKey('schedule')
              ? _json['schedule'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (schedule != null) 'schedule': schedule!,
      };
}

class ResourcePolicyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ResourcePolicyListWarningData({
    this.key,
    this.value,
  });

  ResourcePolicyListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ResourcePolicyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ResourcePolicyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ResourcePolicyListWarning({
    this.code,
    this.data,
    this.message,
  });

  ResourcePolicyListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ResourcePolicyListWarningData>((value) =>
                      ResourcePolicyListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ResourcePolicyList {
  core.String? etag;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ResourcePolicy resources.
  ///
  /// Output only.
  core.List<ResourcePolicy>? items;

  /// Type of resource.Always compute#resourcePoliciesList for listsof
  /// resourcePolicies
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ResourcePolicyListWarning? warning;

  ResourcePolicyList({
    this.etag,
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  ResourcePolicyList.fromJson(core.Map _json)
      : this(
          etag: _json.containsKey('etag') ? _json['etag'] as core.String : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<ResourcePolicy>((value) => ResourcePolicy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? ResourcePolicyListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (etag != null) 'etag': etag!,
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Contains output only fields.
///
/// Use this sub-message for all output fields set on ResourcePolicy. The
/// internal structure of this "status" field should mimic the structure of
/// ResourcePolicy proto specification.
class ResourcePolicyResourceStatus {
  /// Specifies a set of output values reffering to the instance_schedule_policy
  /// system status.
  ///
  /// This field should have the same name as corresponding policy field.
  ///
  /// Output only.
  ResourcePolicyResourceStatusInstanceSchedulePolicyStatus?
      instanceSchedulePolicy;

  ResourcePolicyResourceStatus({
    this.instanceSchedulePolicy,
  });

  ResourcePolicyResourceStatus.fromJson(core.Map _json)
      : this(
          instanceSchedulePolicy: _json.containsKey('instanceSchedulePolicy')
              ? ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
                  .fromJson(_json['instanceSchedulePolicy']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceSchedulePolicy != null)
          'instanceSchedulePolicy': instanceSchedulePolicy!.toJson(),
      };
}

class ResourcePolicyResourceStatusInstanceSchedulePolicyStatus {
  /// The last time the schedule successfully ran.
  ///
  /// The timestamp is an RFC3339 string.
  ///
  /// Output only.
  core.String? lastRunStartTime;

  /// The next time the schedule is planned to run.
  ///
  /// The actual time might be slightly different. The timestamp is an RFC3339
  /// string.
  ///
  /// Output only.
  core.String? nextRunStartTime;

  ResourcePolicyResourceStatusInstanceSchedulePolicyStatus({
    this.lastRunStartTime,
    this.nextRunStartTime,
  });

  ResourcePolicyResourceStatusInstanceSchedulePolicyStatus.fromJson(
      core.Map _json)
      : this(
          lastRunStartTime: _json.containsKey('lastRunStartTime')
              ? _json['lastRunStartTime'] as core.String
              : null,
          nextRunStartTime: _json.containsKey('nextRunStartTime')
              ? _json['nextRunStartTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (lastRunStartTime != null) 'lastRunStartTime': lastRunStartTime!,
        if (nextRunStartTime != null) 'nextRunStartTime': nextRunStartTime!,
      };
}

/// A snapshot schedule policy specifies when and how frequently snapshots are
/// to be created for the target disk.
///
/// Also specifies how many and how long these scheduled snapshots should be
/// retained.
class ResourcePolicySnapshotSchedulePolicy {
  /// Retention policy applied to snapshots created by this resource policy.
  ResourcePolicySnapshotSchedulePolicyRetentionPolicy? retentionPolicy;

  /// A Vm Maintenance Policy specifies what kind of infrastructure maintenance
  /// we are allowed to perform on this VM and when.
  ///
  /// Schedule that is applied to disks covered by this policy.
  ResourcePolicySnapshotSchedulePolicySchedule? schedule;

  /// Properties with which snapshots are created such as labels, encryption
  /// keys.
  ResourcePolicySnapshotSchedulePolicySnapshotProperties? snapshotProperties;

  ResourcePolicySnapshotSchedulePolicy({
    this.retentionPolicy,
    this.schedule,
    this.snapshotProperties,
  });

  ResourcePolicySnapshotSchedulePolicy.fromJson(core.Map _json)
      : this(
          retentionPolicy: _json.containsKey('retentionPolicy')
              ? ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(
                  _json['retentionPolicy']
                      as core.Map<core.String, core.dynamic>)
              : null,
          schedule: _json.containsKey('schedule')
              ? ResourcePolicySnapshotSchedulePolicySchedule.fromJson(
                  _json['schedule'] as core.Map<core.String, core.dynamic>)
              : null,
          snapshotProperties: _json.containsKey('snapshotProperties')
              ? ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
                  _json['snapshotProperties']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (retentionPolicy != null)
          'retentionPolicy': retentionPolicy!.toJson(),
        if (schedule != null) 'schedule': schedule!.toJson(),
        if (snapshotProperties != null)
          'snapshotProperties': snapshotProperties!.toJson(),
      };
}

/// Policy for retention of scheduled snapshots.
class ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
  /// Maximum age of the snapshot that is allowed to be kept.
  core.int? maxRetentionDays;

  /// Specifies the behavior to apply to scheduled snapshots when the source
  /// disk is deleted.
  /// Possible string values are:
  /// - "APPLY_RETENTION_POLICY"
  /// - "KEEP_AUTO_SNAPSHOTS"
  /// - "UNSPECIFIED_ON_SOURCE_DISK_DELETE"
  core.String? onSourceDiskDelete;

  ResourcePolicySnapshotSchedulePolicyRetentionPolicy({
    this.maxRetentionDays,
    this.onSourceDiskDelete,
  });

  ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(core.Map _json)
      : this(
          maxRetentionDays: _json.containsKey('maxRetentionDays')
              ? _json['maxRetentionDays'] as core.int
              : null,
          onSourceDiskDelete: _json.containsKey('onSourceDiskDelete')
              ? _json['onSourceDiskDelete'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxRetentionDays != null) 'maxRetentionDays': maxRetentionDays!,
        if (onSourceDiskDelete != null)
          'onSourceDiskDelete': onSourceDiskDelete!,
      };
}

/// A schedule for disks where the schedueled operations are performed.
class ResourcePolicySnapshotSchedulePolicySchedule {
  ResourcePolicyDailyCycle? dailySchedule;
  ResourcePolicyHourlyCycle? hourlySchedule;
  ResourcePolicyWeeklyCycle? weeklySchedule;

  ResourcePolicySnapshotSchedulePolicySchedule({
    this.dailySchedule,
    this.hourlySchedule,
    this.weeklySchedule,
  });

  ResourcePolicySnapshotSchedulePolicySchedule.fromJson(core.Map _json)
      : this(
          dailySchedule: _json.containsKey('dailySchedule')
              ? ResourcePolicyDailyCycle.fromJson(
                  _json['dailySchedule'] as core.Map<core.String, core.dynamic>)
              : null,
          hourlySchedule: _json.containsKey('hourlySchedule')
              ? ResourcePolicyHourlyCycle.fromJson(_json['hourlySchedule']
                  as core.Map<core.String, core.dynamic>)
              : null,
          weeklySchedule: _json.containsKey('weeklySchedule')
              ? ResourcePolicyWeeklyCycle.fromJson(_json['weeklySchedule']
                  as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dailySchedule != null) 'dailySchedule': dailySchedule!.toJson(),
        if (hourlySchedule != null) 'hourlySchedule': hourlySchedule!.toJson(),
        if (weeklySchedule != null) 'weeklySchedule': weeklySchedule!.toJson(),
      };
}

/// Specified snapshot properties for scheduled snapshots created by this
/// policy.
class ResourcePolicySnapshotSchedulePolicySnapshotProperties {
  /// Chain name that the snapshot is created in.
  core.String? chainName;

  /// Indication to perform a 'guest aware' snapshot.
  core.bool? guestFlush;

  /// Labels to apply to scheduled snapshots.
  ///
  /// These can be later modified by the setLabels method. Label values may be
  /// empty.
  core.Map<core.String, core.String>? labels;

  /// Cloud Storage bucket storage location of the auto snapshot (regional or
  /// multi-regional).
  core.List<core.String>? storageLocations;

  ResourcePolicySnapshotSchedulePolicySnapshotProperties({
    this.chainName,
    this.guestFlush,
    this.labels,
    this.storageLocations,
  });

  ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
      core.Map _json)
      : this(
          chainName: _json.containsKey('chainName')
              ? _json['chainName'] as core.String
              : null,
          guestFlush: _json.containsKey('guestFlush')
              ? _json['guestFlush'] as core.bool
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          storageLocations: _json.containsKey('storageLocations')
              ? (_json['storageLocations'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (chainName != null) 'chainName': chainName!,
        if (guestFlush != null) 'guestFlush': guestFlush!,
        if (labels != null) 'labels': labels!,
        if (storageLocations != null) 'storageLocations': storageLocations!,
      };
}

/// Time window specified for weekly operations.
class ResourcePolicyWeeklyCycle {
  /// Up to 7 intervals/windows, one for each day of the week.
  core.List<ResourcePolicyWeeklyCycleDayOfWeek>? dayOfWeeks;

  ResourcePolicyWeeklyCycle({
    this.dayOfWeeks,
  });

  ResourcePolicyWeeklyCycle.fromJson(core.Map _json)
      : this(
          dayOfWeeks: _json.containsKey('dayOfWeeks')
              ? (_json['dayOfWeeks'] as core.List)
                  .map<ResourcePolicyWeeklyCycleDayOfWeek>((value) =>
                      ResourcePolicyWeeklyCycleDayOfWeek.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dayOfWeeks != null)
          'dayOfWeeks': dayOfWeeks!.map((value) => value.toJson()).toList(),
      };
}

class ResourcePolicyWeeklyCycleDayOfWeek {
  /// Defines a schedule that runs on specific days of the week.
  ///
  /// Specify one or more days. The following options are available: MONDAY,
  /// TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
  /// Possible string values are:
  /// - "FRIDAY"
  /// - "INVALID"
  /// - "MONDAY"
  /// - "SATURDAY"
  /// - "SUNDAY"
  /// - "THURSDAY"
  /// - "TUESDAY"
  /// - "WEDNESDAY"
  core.String? day;

  /// Duration of the time window, automatically chosen to be smallest possible
  /// in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Time within the window to start the operations.
  ///
  /// It must be in format "HH:MM", where HH : \[00-23\] and MM : \[00-00\] GMT.
  core.String? startTime;

  ResourcePolicyWeeklyCycleDayOfWeek({
    this.day,
    this.duration,
    this.startTime,
  });

  ResourcePolicyWeeklyCycleDayOfWeek.fromJson(core.Map _json)
      : this(
          day: _json.containsKey('day') ? _json['day'] as core.String : null,
          duration: _json.containsKey('duration')
              ? _json['duration'] as core.String
              : null,
          startTime: _json.containsKey('startTime')
              ? _json['startTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (day != null) 'day': day!,
        if (duration != null) 'duration': duration!,
        if (startTime != null) 'startTime': startTime!,
      };
}

class RouteWarningsData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RouteWarningsData({
    this.key,
    this.value,
  });

  RouteWarningsData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

class RouteWarnings {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RouteWarningsData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RouteWarnings({
    this.code,
    this.data,
    this.message,
  });

  RouteWarnings.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RouteWarningsData>((value) => RouteWarningsData.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Represents a Route resource.
///
/// A route defines a path from VM instances in the VPC network to a specific
/// destination. This destination can be inside or outside the VPC network. For
/// more information, read the Routes overview.
class Route {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// The destination range of outgoing packets that this route applies to.
  ///
  /// Both IPv4 and IPv6 are supported.
  core.String? destRange;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of this resource.
  ///
  /// Always compute#routes for Route resources.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase
  /// letter, and all following characters (except for the last character) must
  /// be a dash, lowercase letter, or digit. The last character must be a
  /// lowercase letter or digit.
  core.String? name;

  /// Fully-qualified URL of the network that this route applies to.
  core.String? network;

  /// The URL to a gateway that should handle matching packets.
  ///
  /// You can only specify the internet gateway using a full or partial valid
  /// URL: projects/ project/global/gateways/default-internet-gateway
  core.String? nextHopGateway;

  /// The URL to a forwarding rule of type loadBalancingScheme=INTERNAL that
  /// should handle matching packets or the IP address of the forwarding Rule.
  ///
  /// For example, the following are all valid URLs: - 10.128.0.56 -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /forwardingRules/forwardingRule -
  /// regions/region/forwardingRules/forwardingRule
  core.String? nextHopIlb;

  /// The URL to an instance that should handle matching packets.
  ///
  /// You can specify this as a full or partial URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/
  core.String? nextHopInstance;

  /// The network IP address of an instance that should handle matching packets.
  ///
  /// Only IPv4 is supported.
  core.String? nextHopIp;

  /// The URL of the local network if it should handle matching packets.
  core.String? nextHopNetwork;

  /// The network peering name that should handle matching packets, which should
  /// conform to RFC1035.
  ///
  /// Output only.
  core.String? nextHopPeering;

  /// The URL to a VpnTunnel that should handle matching packets.
  core.String? nextHopVpnTunnel;

  /// The priority of this route.
  ///
  /// Priority is used to break ties in cases where there is more than one
  /// matching route of equal prefix length. In cases where multiple routes have
  /// equal prefix length, the one with the lowest-numbered priority value wins.
  /// The default value is `1000`. The priority value must be from `0` to
  /// `65535`, inclusive.
  core.int? priority;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// A list of instance tags to which this route applies.
  core.List<core.String>? tags;

  /// If potential misconfigurations are detected for this route, this field
  /// will be populated with warning messages.
  ///
  /// Output only.
  core.List<RouteWarnings>? warnings;

  Route({
    this.creationTimestamp,
    this.description,
    this.destRange,
    this.id,
    this.kind,
    this.name,
    this.network,
    this.nextHopGateway,
    this.nextHopIlb,
    this.nextHopInstance,
    this.nextHopIp,
    this.nextHopNetwork,
    this.nextHopPeering,
    this.nextHopVpnTunnel,
    this.priority,
    this.selfLink,
    this.tags,
    this.warnings,
  });

  Route.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          destRange: _json.containsKey('destRange')
              ? _json['destRange'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          nextHopGateway: _json.containsKey('nextHopGateway')
              ? _json['nextHopGateway'] as core.String
              : null,
          nextHopIlb: _json.containsKey('nextHopIlb')
              ? _json['nextHopIlb'] as core.String
              : null,
          nextHopInstance: _json.containsKey('nextHopInstance')
              ? _json['nextHopInstance'] as core.String
              : null,
          nextHopIp: _json.containsKey('nextHopIp')
              ? _json['nextHopIp'] as core.String
              : null,
          nextHopNetwork: _json.containsKey('nextHopNetwork')
              ? _json['nextHopNetwork'] as core.String
              : null,
          nextHopPeering: _json.containsKey('nextHopPeering')
              ? _json['nextHopPeering'] as core.String
              : null,
          nextHopVpnTunnel: _json.containsKey('nextHopVpnTunnel')
              ? _json['nextHopVpnTunnel'] as core.String
              : null,
          priority: _json.containsKey('priority')
              ? _json['priority'] as core.int
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          tags: _json.containsKey('tags')
              ? (_json['tags'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warnings: _json.containsKey('warnings')
              ? (_json['warnings'] as core.List)
                  .map<RouteWarnings>((value) => RouteWarnings.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (destRange != null) 'destRange': destRange!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (nextHopGateway != null) 'nextHopGateway': nextHopGateway!,
        if (nextHopIlb != null) 'nextHopIlb': nextHopIlb!,
        if (nextHopInstance != null) 'nextHopInstance': nextHopInstance!,
        if (nextHopIp != null) 'nextHopIp': nextHopIp!,
        if (nextHopNetwork != null) 'nextHopNetwork': nextHopNetwork!,
        if (nextHopPeering != null) 'nextHopPeering': nextHopPeering!,
        if (nextHopVpnTunnel != null) 'nextHopVpnTunnel': nextHopVpnTunnel!,
        if (priority != null) 'priority': priority!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (tags != null) 'tags': tags!,
        if (warnings != null)
          'warnings': warnings!.map((value) => value.toJson()).toList(),
      };
}

class RouteListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RouteListWarningData({
    this.key,
    this.value,
  });

  RouteListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RouteListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RouteListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RouteListWarning({
    this.code,
    this.data,
    this.message,
  });

  RouteListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RouteListWarningData>((value) =>
                      RouteListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Route resources.
class RouteList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Route resources.
  core.List<Route>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RouteListWarning? warning;

  RouteList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  RouteList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Route>((value) => Route.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RouteListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Cloud Router resource.
///
/// For more information about Cloud Router, read the Cloud Router overview.
class Router {
  /// BGP information specific to this router.
  RouterBgp? bgp;

  /// BGP information that must be configured into the routing stack to
  /// establish BGP peering.
  ///
  /// This information must specify the peer ASN and either the interface name,
  /// IP address, or peer IP address. Please refer to RFC4273.
  core.List<RouterBgpPeer>? bgpPeers;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Indicates if a router is dedicated for use with encrypted VLAN attachments
  /// (interconnectAttachments).
  ///
  /// Not currently available publicly.
  core.bool? encryptedInterconnectRouter;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Router interfaces.
  ///
  /// Each interface requires either one linked resource, (for example,
  /// linkedVpnTunnel), or IP address and IP address range (for example,
  /// ipRange), or both.
  core.List<RouterInterface>? interfaces;

  /// Type of resource.
  ///
  /// Always compute#router for routers.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// A list of NAT services created in this router.
  core.List<RouterNat>? nats;

  /// URI of the network to which this router belongs.
  core.String? network;

  /// URI of the region where the router resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  Router({
    this.bgp,
    this.bgpPeers,
    this.creationTimestamp,
    this.description,
    this.encryptedInterconnectRouter,
    this.id,
    this.interfaces,
    this.kind,
    this.name,
    this.nats,
    this.network,
    this.region,
    this.selfLink,
  });

  Router.fromJson(core.Map _json)
      : this(
          bgp: _json.containsKey('bgp')
              ? RouterBgp.fromJson(
                  _json['bgp'] as core.Map<core.String, core.dynamic>)
              : null,
          bgpPeers: _json.containsKey('bgpPeers')
              ? (_json['bgpPeers'] as core.List)
                  .map<RouterBgpPeer>((value) => RouterBgpPeer.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          encryptedInterconnectRouter:
              _json.containsKey('encryptedInterconnectRouter')
                  ? _json['encryptedInterconnectRouter'] as core.bool
                  : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          interfaces: _json.containsKey('interfaces')
              ? (_json['interfaces'] as core.List)
                  .map<RouterInterface>((value) => RouterInterface.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          nats: _json.containsKey('nats')
              ? (_json['nats'] as core.List)
                  .map<RouterNat>((value) => RouterNat.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bgp != null) 'bgp': bgp!.toJson(),
        if (bgpPeers != null)
          'bgpPeers': bgpPeers!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (encryptedInterconnectRouter != null)
          'encryptedInterconnectRouter': encryptedInterconnectRouter!,
        if (id != null) 'id': id!,
        if (interfaces != null)
          'interfaces': interfaces!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (nats != null) 'nats': nats!.map((value) => value.toJson()).toList(),
        if (network != null) 'network': network!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Description-tagged IP ranges for the router to advertise.
class RouterAdvertisedIpRange {
  /// User-specified description for the IP range.
  core.String? description;

  /// The IP range to advertise.
  ///
  /// The value must be a CIDR-formatted string.
  core.String? range;

  RouterAdvertisedIpRange({
    this.description,
    this.range,
  });

  RouterAdvertisedIpRange.fromJson(core.Map _json)
      : this(
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          range:
              _json.containsKey('range') ? _json['range'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (range != null) 'range': range!,
      };
}

class RouterAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RouterAggregatedListWarningData({
    this.key,
    this.value,
  });

  RouterAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RouterAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RouterAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RouterAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  RouterAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RouterAggregatedListWarningData>((value) =>
                      RouterAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of routers.
class RouterAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Router resources.
  core.Map<core.String, RoutersScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  RouterAggregatedListWarning? warning;

  RouterAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  RouterAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    RoutersScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? RouterAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RouterBgp {
  /// User-specified flag to indicate which mode to use for advertisement.
  ///
  /// The options are DEFAULT or CUSTOM.
  /// Possible string values are:
  /// - "CUSTOM"
  /// - "DEFAULT"
  core.String? advertiseMode;

  /// User-specified list of prefix groups to advertise in custom mode.
  ///
  /// This field can only be populated if advertise_mode is CUSTOM and is
  /// advertised to all peers of the router. These groups will be advertised in
  /// addition to any specified prefixes. Leave this field blank to advertise no
  /// custom groups.
  core.List<core.String>? advertisedGroups;

  /// User-specified list of individual IP ranges to advertise in custom mode.
  ///
  /// This field can only be populated if advertise_mode is CUSTOM and is
  /// advertised to all peers of the router. These IP ranges will be advertised
  /// in addition to any specified groups. Leave this field blank to advertise
  /// no custom IP ranges.
  core.List<RouterAdvertisedIpRange>? advertisedIpRanges;

  /// Local BGP Autonomous System Number (ASN).
  ///
  /// Must be an RFC6996 private ASN, either 16-bit or 32-bit. The value will be
  /// fixed for this router resource. All VPN tunnels that link to this router
  /// will have the same local ASN.
  core.int? asn;

  /// The interval in seconds between BGP keepalive messages that are sent to
  /// the peer.
  ///
  /// Hold time is three times the interval at which keepalive messages are
  /// sent, and the hold time is the maximum number of seconds allowed to elapse
  /// between successive keepalive messages that BGP receives from a peer. BGP
  /// will use the smaller of either the local hold time value or the peer's
  /// hold time value as the hold time for the BGP connection between the two
  /// peers. If set, this value must be between 20 and 60. The default is 20.
  core.int? keepaliveInterval;

  RouterBgp({
    this.advertiseMode,
    this.advertisedGroups,
    this.advertisedIpRanges,
    this.asn,
    this.keepaliveInterval,
  });

  RouterBgp.fromJson(core.Map _json)
      : this(
          advertiseMode: _json.containsKey('advertiseMode')
              ? _json['advertiseMode'] as core.String
              : null,
          advertisedGroups: _json.containsKey('advertisedGroups')
              ? (_json['advertisedGroups'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          advertisedIpRanges: _json.containsKey('advertisedIpRanges')
              ? (_json['advertisedIpRanges'] as core.List)
                  .map<RouterAdvertisedIpRange>((value) =>
                      RouterAdvertisedIpRange.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          asn: _json.containsKey('asn') ? _json['asn'] as core.int : null,
          keepaliveInterval: _json.containsKey('keepaliveInterval')
              ? _json['keepaliveInterval'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (advertiseMode != null) 'advertiseMode': advertiseMode!,
        if (advertisedGroups != null) 'advertisedGroups': advertisedGroups!,
        if (advertisedIpRanges != null)
          'advertisedIpRanges':
              advertisedIpRanges!.map((value) => value.toJson()).toList(),
        if (asn != null) 'asn': asn!,
        if (keepaliveInterval != null) 'keepaliveInterval': keepaliveInterval!,
      };
}

class RouterBgpPeer {
  /// User-specified flag to indicate which mode to use for advertisement.
  /// Possible string values are:
  /// - "CUSTOM"
  /// - "DEFAULT"
  core.String? advertiseMode;

  /// User-specified list of prefix groups to advertise in custom mode, which
  /// can take one of the following options: - ALL_SUBNETS: Advertises all
  /// available subnets, including peer VPC subnets.
  ///
  /// - ALL_VPC_SUBNETS: Advertises the router's own VPC subnets. Note that this
  /// field can only be populated if advertise_mode is CUSTOM and overrides the
  /// list defined for the router (in the "bgp" message). These groups are
  /// advertised in addition to any specified prefixes. Leave this field blank
  /// to advertise no custom groups.
  core.List<core.String>? advertisedGroups;

  /// User-specified list of individual IP ranges to advertise in custom mode.
  ///
  /// This field can only be populated if advertise_mode is CUSTOM and overrides
  /// the list defined for the router (in the "bgp" message). These IP ranges
  /// are advertised in addition to any specified groups. Leave this field blank
  /// to advertise no custom IP ranges.
  core.List<RouterAdvertisedIpRange>? advertisedIpRanges;

  /// The priority of routes advertised to this BGP peer.
  ///
  /// Where there is more than one matching route of maximum length, the routes
  /// with the lowest priority value win.
  core.int? advertisedRoutePriority;

  /// The status of the BGP peer connection.
  ///
  /// If set to FALSE, any active session with the peer is terminated and all
  /// associated routing information is removed. If set to TRUE, the peer
  /// connection can be established with routing information. The default is
  /// TRUE.
  /// Possible string values are:
  /// - "FALSE"
  /// - "TRUE"
  core.String? enable;

  /// Name of the interface the BGP peer is associated with.
  core.String? interfaceName;

  /// IP address of the interface inside Google Cloud Platform.
  ///
  /// Only IPv4 is supported.
  core.String? ipAddress;

  /// The resource that configures and manages this BGP peer.
  ///
  /// - MANAGED_BY_USER is the default value and can be managed by you or other
  /// users - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed
  /// by Cloud Interconnect, specifically by an InterconnectAttachment of type
  /// PARTNER. Google automatically creates, updates, and deletes this type of
  /// BGP peer when the PARTNER InterconnectAttachment is created, updated, or
  /// deleted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT" : The BGP peer is automatically created for
  /// PARTNER type InterconnectAttachment; Google will automatically
  /// create/delete this BGP peer when the PARTNER InterconnectAttachment is
  /// created/deleted, and Google will update the ipAddress and peerIpAddress
  /// when the PARTNER InterconnectAttachment is provisioned. This type of BGP
  /// peer cannot be created or deleted, but can be modified for all fields
  /// except for name, ipAddress and peerIpAddress.
  /// - "MANAGED_BY_USER" : Default value, the BGP peer is manually created and
  /// managed by user.
  core.String? managementType;

  /// Name of this BGP peer.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Peer BGP Autonomous System Number (ASN).
  ///
  /// Each BGP interface may use a different value.
  core.int? peerAsn;

  /// IP address of the BGP interface outside Google Cloud Platform.
  ///
  /// Only IPv4 is supported.
  core.String? peerIpAddress;

  RouterBgpPeer({
    this.advertiseMode,
    this.advertisedGroups,
    this.advertisedIpRanges,
    this.advertisedRoutePriority,
    this.enable,
    this.interfaceName,
    this.ipAddress,
    this.managementType,
    this.name,
    this.peerAsn,
    this.peerIpAddress,
  });

  RouterBgpPeer.fromJson(core.Map _json)
      : this(
          advertiseMode: _json.containsKey('advertiseMode')
              ? _json['advertiseMode'] as core.String
              : null,
          advertisedGroups: _json.containsKey('advertisedGroups')
              ? (_json['advertisedGroups'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          advertisedIpRanges: _json.containsKey('advertisedIpRanges')
              ? (_json['advertisedIpRanges'] as core.List)
                  .map<RouterAdvertisedIpRange>((value) =>
                      RouterAdvertisedIpRange.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          advertisedRoutePriority: _json.containsKey('advertisedRoutePriority')
              ? _json['advertisedRoutePriority'] as core.int
              : null,
          enable: _json.containsKey('enable')
              ? _json['enable'] as core.String
              : null,
          interfaceName: _json.containsKey('interfaceName')
              ? _json['interfaceName'] as core.String
              : null,
          ipAddress: _json.containsKey('ipAddress')
              ? _json['ipAddress'] as core.String
              : null,
          managementType: _json.containsKey('managementType')
              ? _json['managementType'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          peerAsn: _json.containsKey('peerAsn')
              ? _json['peerAsn'] as core.int
              : null,
          peerIpAddress: _json.containsKey('peerIpAddress')
              ? _json['peerIpAddress'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (advertiseMode != null) 'advertiseMode': advertiseMode!,
        if (advertisedGroups != null) 'advertisedGroups': advertisedGroups!,
        if (advertisedIpRanges != null)
          'advertisedIpRanges':
              advertisedIpRanges!.map((value) => value.toJson()).toList(),
        if (advertisedRoutePriority != null)
          'advertisedRoutePriority': advertisedRoutePriority!,
        if (enable != null) 'enable': enable!,
        if (interfaceName != null) 'interfaceName': interfaceName!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (managementType != null) 'managementType': managementType!,
        if (name != null) 'name': name!,
        if (peerAsn != null) 'peerAsn': peerAsn!,
        if (peerIpAddress != null) 'peerIpAddress': peerIpAddress!,
      };
}

class RouterInterface {
  /// IP address and range of the interface.
  ///
  /// The IP range must be in the RFC3927 link-local IP address space. The value
  /// must be a CIDR-formatted string, for example: 169.254.0.1/30. NOTE: Do not
  /// truncate the address as it represents the IP address of the interface.
  core.String? ipRange;

  /// URI of the linked Interconnect attachment.
  ///
  /// It must be in the same region as the router. Each interface can have one
  /// linked resource, which can be a VPN tunnel, an Interconnect attachment, or
  /// a virtual machine instance.
  core.String? linkedInterconnectAttachment;

  /// URI of the linked VPN tunnel, which must be in the same region as the
  /// router.
  ///
  /// Each interface can have one linked resource, which can be a VPN tunnel, an
  /// Interconnect attachment, or a virtual machine instance.
  core.String? linkedVpnTunnel;

  /// The resource that configures and manages this interface.
  ///
  /// - MANAGED_BY_USER is the default value and can be managed directly by
  /// users. - MANAGED_BY_ATTACHMENT is an interface that is configured and
  /// managed by Cloud Interconnect, specifically, by an InterconnectAttachment
  /// of type PARTNER. Google automatically creates, updates, and deletes this
  /// type of interface when the PARTNER InterconnectAttachment is created,
  /// updated, or deleted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT" : The interface is automatically created for
  /// PARTNER type InterconnectAttachment, Google will automatically
  /// create/update/delete this interface when the PARTNER
  /// InterconnectAttachment is created/provisioned/deleted. This type of
  /// interface cannot be manually managed by user.
  /// - "MANAGED_BY_USER" : Default value, the interface is manually created and
  /// managed by user.
  core.String? managementType;

  /// Name of this interface entry.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  RouterInterface({
    this.ipRange,
    this.linkedInterconnectAttachment,
    this.linkedVpnTunnel,
    this.managementType,
    this.name,
  });

  RouterInterface.fromJson(core.Map _json)
      : this(
          ipRange: _json.containsKey('ipRange')
              ? _json['ipRange'] as core.String
              : null,
          linkedInterconnectAttachment:
              _json.containsKey('linkedInterconnectAttachment')
                  ? _json['linkedInterconnectAttachment'] as core.String
                  : null,
          linkedVpnTunnel: _json.containsKey('linkedVpnTunnel')
              ? _json['linkedVpnTunnel'] as core.String
              : null,
          managementType: _json.containsKey('managementType')
              ? _json['managementType'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipRange != null) 'ipRange': ipRange!,
        if (linkedInterconnectAttachment != null)
          'linkedInterconnectAttachment': linkedInterconnectAttachment!,
        if (linkedVpnTunnel != null) 'linkedVpnTunnel': linkedVpnTunnel!,
        if (managementType != null) 'managementType': managementType!,
        if (name != null) 'name': name!,
      };
}

class RouterListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RouterListWarningData({
    this.key,
    this.value,
  });

  RouterListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RouterListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RouterListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RouterListWarning({
    this.code,
    this.data,
    this.message,
  });

  RouterListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RouterListWarningData>((value) =>
                      RouterListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Router resources.
class RouterList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Router resources.
  core.List<Router>? items;

  /// Type of resource.
  ///
  /// Always compute#router for routers.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RouterListWarning? warning;

  RouterList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  RouterList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Router>((value) => Router.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? RouterListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Nat resource.
///
/// It enables the VMs within the specified subnetworks to access Internet
/// without external IP addresses. It specifies a list of subnetworks (and the
/// ranges within) that want to use NAT. Customers can also provide the external
/// IPs that would be used for NAT. GCP would auto-allocate ephemeral IPs if no
/// external IPs are provided.
class RouterNat {
  /// A list of URLs of the IP resources to be drained.
  ///
  /// These IPs must be valid static external IPs that have been assigned to the
  /// NAT. These IPs should be used for updating/patching a NAT only.
  core.List<core.String>? drainNatIps;
  core.bool? enableEndpointIndependentMapping;

  /// Timeout (in seconds) for ICMP connections.
  ///
  /// Defaults to 30s if not set.
  core.int? icmpIdleTimeoutSec;

  /// Configure logging on this NAT.
  RouterNatLogConfig? logConfig;

  /// Minimum number of ports allocated to a VM from this NAT config.
  ///
  /// If not set, a default number of ports is allocated to a VM. This is
  /// rounded up to the nearest power of 2. For example, if the value of this
  /// field is 50, at least 64 ports are allocated to a VM.
  core.int? minPortsPerVm;

  /// Unique name of this Nat service.
  ///
  /// The name must be 1-63 characters long and comply with RFC1035.
  core.String? name;

  /// Specify the NatIpAllocateOption, which can take one of the following
  /// values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers.
  ///
  /// When there are not enough specified Nat IPs, the Nat service fails for new
  /// VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform;
  /// customers can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip
  /// should be empty.
  /// Possible string values are:
  /// - "AUTO_ONLY" : Nat IPs are allocated by GCP; customers can not specify
  /// any Nat IPs.
  /// - "MANUAL_ONLY" : Only use Nat IPs provided by customers. When specified
  /// Nat IPs are not enough then the Nat service fails for new VMs.
  core.String? natIpAllocateOption;

  /// A list of URLs of the IP resources used for this Nat service.
  ///
  /// These IP addresses must be valid static external IP addresses assigned to
  /// the project.
  core.List<core.String>? natIps;

  /// Specify the Nat option, which can take one of the following values: -
  /// ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork
  /// are allowed to Nat.
  ///
  /// - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in
  /// every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A list of
  /// Subnetworks are allowed to Nat (specified in the field subnetwork below)
  /// The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if
  /// this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or
  /// ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other
  /// Router.Nat section in any Router for this network in this region.
  /// Possible string values are:
  /// - "ALL_SUBNETWORKS_ALL_IP_RANGES" : All the IP ranges in every Subnetwork
  /// are allowed to Nat.
  /// - "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES" : All the primary IP ranges in
  /// every Subnetwork are allowed to Nat.
  /// - "LIST_OF_SUBNETWORKS" : A list of Subnetworks are allowed to Nat
  /// (specified in the field subnetwork below)
  core.String? sourceSubnetworkIpRangesToNat;

  /// A list of Subnetwork resources whose traffic should be translated by NAT
  /// Gateway.
  ///
  /// It is used only when LIST_OF_SUBNETWORKS is selected for the
  /// SubnetworkIpRangeToNatOption above.
  core.List<RouterNatSubnetworkToNat>? subnetworks;

  /// Timeout (in seconds) for TCP established connections.
  ///
  /// Defaults to 1200s if not set.
  core.int? tcpEstablishedIdleTimeoutSec;

  /// Timeout (in seconds) for TCP transitory connections.
  ///
  /// Defaults to 30s if not set.
  core.int? tcpTransitoryIdleTimeoutSec;

  /// Timeout (in seconds) for UDP connections.
  ///
  /// Defaults to 30s if not set.
  core.int? udpIdleTimeoutSec;

  RouterNat({
    this.drainNatIps,
    this.enableEndpointIndependentMapping,
    this.icmpIdleTimeoutSec,
    this.logConfig,
    this.minPortsPerVm,
    this.name,
    this.natIpAllocateOption,
    this.natIps,
    this.sourceSubnetworkIpRangesToNat,
    this.subnetworks,
    this.tcpEstablishedIdleTimeoutSec,
    this.tcpTransitoryIdleTimeoutSec,
    this.udpIdleTimeoutSec,
  });

  RouterNat.fromJson(core.Map _json)
      : this(
          drainNatIps: _json.containsKey('drainNatIps')
              ? (_json['drainNatIps'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          enableEndpointIndependentMapping:
              _json.containsKey('enableEndpointIndependentMapping')
                  ? _json['enableEndpointIndependentMapping'] as core.bool
                  : null,
          icmpIdleTimeoutSec: _json.containsKey('icmpIdleTimeoutSec')
              ? _json['icmpIdleTimeoutSec'] as core.int
              : null,
          logConfig: _json.containsKey('logConfig')
              ? RouterNatLogConfig.fromJson(
                  _json['logConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          minPortsPerVm: _json.containsKey('minPortsPerVm')
              ? _json['minPortsPerVm'] as core.int
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          natIpAllocateOption: _json.containsKey('natIpAllocateOption')
              ? _json['natIpAllocateOption'] as core.String
              : null,
          natIps: _json.containsKey('natIps')
              ? (_json['natIps'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          sourceSubnetworkIpRangesToNat:
              _json.containsKey('sourceSubnetworkIpRangesToNat')
                  ? _json['sourceSubnetworkIpRangesToNat'] as core.String
                  : null,
          subnetworks: _json.containsKey('subnetworks')
              ? (_json['subnetworks'] as core.List)
                  .map<RouterNatSubnetworkToNat>((value) =>
                      RouterNatSubnetworkToNat.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          tcpEstablishedIdleTimeoutSec:
              _json.containsKey('tcpEstablishedIdleTimeoutSec')
                  ? _json['tcpEstablishedIdleTimeoutSec'] as core.int
                  : null,
          tcpTransitoryIdleTimeoutSec:
              _json.containsKey('tcpTransitoryIdleTimeoutSec')
                  ? _json['tcpTransitoryIdleTimeoutSec'] as core.int
                  : null,
          udpIdleTimeoutSec: _json.containsKey('udpIdleTimeoutSec')
              ? _json['udpIdleTimeoutSec'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (drainNatIps != null) 'drainNatIps': drainNatIps!,
        if (enableEndpointIndependentMapping != null)
          'enableEndpointIndependentMapping': enableEndpointIndependentMapping!,
        if (icmpIdleTimeoutSec != null)
          'icmpIdleTimeoutSec': icmpIdleTimeoutSec!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (minPortsPerVm != null) 'minPortsPerVm': minPortsPerVm!,
        if (name != null) 'name': name!,
        if (natIpAllocateOption != null)
          'natIpAllocateOption': natIpAllocateOption!,
        if (natIps != null) 'natIps': natIps!,
        if (sourceSubnetworkIpRangesToNat != null)
          'sourceSubnetworkIpRangesToNat': sourceSubnetworkIpRangesToNat!,
        if (subnetworks != null)
          'subnetworks': subnetworks!.map((value) => value.toJson()).toList(),
        if (tcpEstablishedIdleTimeoutSec != null)
          'tcpEstablishedIdleTimeoutSec': tcpEstablishedIdleTimeoutSec!,
        if (tcpTransitoryIdleTimeoutSec != null)
          'tcpTransitoryIdleTimeoutSec': tcpTransitoryIdleTimeoutSec!,
        if (udpIdleTimeoutSec != null) 'udpIdleTimeoutSec': udpIdleTimeoutSec!,
      };
}

/// Configuration of logging on a NAT.
class RouterNatLogConfig {
  /// Indicates whether or not to export logs.
  ///
  /// This is false by default.
  core.bool? enable;

  /// Specify the desired filtering of logs on this NAT.
  ///
  /// If unspecified, logs are exported for all connections handled by this NAT.
  /// This option can take one of the following values: - ERRORS_ONLY: Export
  /// logs only for connection failures. - TRANSLATIONS_ONLY: Export logs only
  /// for successful connections. - ALL: Export logs for all connections,
  /// successful and unsuccessful.
  /// Possible string values are:
  /// - "ALL" : Export logs for all (successful and unsuccessful) connections.
  /// - "ERRORS_ONLY" : Export logs for connection failures only.
  /// - "TRANSLATIONS_ONLY" : Export logs for successful connections only.
  core.String? filter;

  RouterNatLogConfig({
    this.enable,
    this.filter,
  });

  RouterNatLogConfig.fromJson(core.Map _json)
      : this(
          enable:
              _json.containsKey('enable') ? _json['enable'] as core.bool : null,
          filter: _json.containsKey('filter')
              ? _json['filter'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
        if (filter != null) 'filter': filter!,
      };
}

/// Defines the IP ranges that want to use NAT for a subnetwork.
class RouterNatSubnetworkToNat {
  /// URL for the subnetwork resource that will use NAT.
  core.String? name;

  /// A list of the secondary ranges of the Subnetwork that are allowed to use
  /// NAT.
  ///
  /// This can be populated only if "LIST_OF_SECONDARY_IP_RANGES" is one of the
  /// values in source_ip_ranges_to_nat.
  core.List<core.String>? secondaryIpRangeNames;

  /// Specify the options for NAT ranges in the Subnetwork.
  ///
  /// All options of a single value are valid except
  /// NAT_IP_RANGE_OPTION_UNSPECIFIED. The only valid option with multiple
  /// values is: \["PRIMARY_IP_RANGE", "LIST_OF_SECONDARY_IP_RANGES"\] Default:
  /// \[ALL_IP_RANGES\]
  core.List<core.String>? sourceIpRangesToNat;

  RouterNatSubnetworkToNat({
    this.name,
    this.secondaryIpRangeNames,
    this.sourceIpRangesToNat,
  });

  RouterNatSubnetworkToNat.fromJson(core.Map _json)
      : this(
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          secondaryIpRangeNames: _json.containsKey('secondaryIpRangeNames')
              ? (_json['secondaryIpRangeNames'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          sourceIpRangesToNat: _json.containsKey('sourceIpRangesToNat')
              ? (_json['sourceIpRangesToNat'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (secondaryIpRangeNames != null)
          'secondaryIpRangeNames': secondaryIpRangeNames!,
        if (sourceIpRangesToNat != null)
          'sourceIpRangesToNat': sourceIpRangesToNat!,
      };
}

class RouterStatus {
  /// Best routes for this router's network.
  core.List<Route>? bestRoutes;

  /// Best routes learned by this router.
  core.List<Route>? bestRoutesForRouter;
  core.List<RouterStatusBgpPeerStatus>? bgpPeerStatus;
  core.List<RouterStatusNatStatus>? natStatus;

  /// URI of the network to which this router belongs.
  core.String? network;

  RouterStatus({
    this.bestRoutes,
    this.bestRoutesForRouter,
    this.bgpPeerStatus,
    this.natStatus,
    this.network,
  });

  RouterStatus.fromJson(core.Map _json)
      : this(
          bestRoutes: _json.containsKey('bestRoutes')
              ? (_json['bestRoutes'] as core.List)
                  .map<Route>((value) => Route.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          bestRoutesForRouter: _json.containsKey('bestRoutesForRouter')
              ? (_json['bestRoutesForRouter'] as core.List)
                  .map<Route>((value) => Route.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          bgpPeerStatus: _json.containsKey('bgpPeerStatus')
              ? (_json['bgpPeerStatus'] as core.List)
                  .map<RouterStatusBgpPeerStatus>((value) =>
                      RouterStatusBgpPeerStatus.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          natStatus: _json.containsKey('natStatus')
              ? (_json['natStatus'] as core.List)
                  .map<RouterStatusNatStatus>((value) =>
                      RouterStatusNatStatus.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bestRoutes != null)
          'bestRoutes': bestRoutes!.map((value) => value.toJson()).toList(),
        if (bestRoutesForRouter != null)
          'bestRoutesForRouter':
              bestRoutesForRouter!.map((value) => value.toJson()).toList(),
        if (bgpPeerStatus != null)
          'bgpPeerStatus':
              bgpPeerStatus!.map((value) => value.toJson()).toList(),
        if (natStatus != null)
          'natStatus': natStatus!.map((value) => value.toJson()).toList(),
        if (network != null) 'network': network!,
      };
}

class RouterStatusBgpPeerStatus {
  /// Routes that were advertised to the remote BGP peer
  core.List<Route>? advertisedRoutes;

  /// IP address of the local BGP interface.
  core.String? ipAddress;

  /// URL of the VPN tunnel that this BGP peer controls.
  core.String? linkedVpnTunnel;

  /// Name of this BGP peer.
  ///
  /// Unique within the Routers resource.
  core.String? name;

  /// Number of routes learned from the remote BGP Peer.
  core.int? numLearnedRoutes;

  /// IP address of the remote BGP interface.
  core.String? peerIpAddress;

  /// BGP state as specified in RFC1771.
  core.String? state;

  /// Status of the BGP peer: {UP, DOWN}
  /// Possible string values are:
  /// - "DOWN"
  /// - "UNKNOWN"
  /// - "UP"
  core.String? status;

  /// Time this session has been up.
  ///
  /// Format: 14 years, 51 weeks, 6 days, 23 hours, 59 minutes, 59 seconds
  core.String? uptime;

  /// Time this session has been up, in seconds.
  ///
  /// Format: 145
  core.String? uptimeSeconds;

  RouterStatusBgpPeerStatus({
    this.advertisedRoutes,
    this.ipAddress,
    this.linkedVpnTunnel,
    this.name,
    this.numLearnedRoutes,
    this.peerIpAddress,
    this.state,
    this.status,
    this.uptime,
    this.uptimeSeconds,
  });

  RouterStatusBgpPeerStatus.fromJson(core.Map _json)
      : this(
          advertisedRoutes: _json.containsKey('advertisedRoutes')
              ? (_json['advertisedRoutes'] as core.List)
                  .map<Route>((value) => Route.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          ipAddress: _json.containsKey('ipAddress')
              ? _json['ipAddress'] as core.String
              : null,
          linkedVpnTunnel: _json.containsKey('linkedVpnTunnel')
              ? _json['linkedVpnTunnel'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          numLearnedRoutes: _json.containsKey('numLearnedRoutes')
              ? _json['numLearnedRoutes'] as core.int
              : null,
          peerIpAddress: _json.containsKey('peerIpAddress')
              ? _json['peerIpAddress'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          uptime: _json.containsKey('uptime')
              ? _json['uptime'] as core.String
              : null,
          uptimeSeconds: _json.containsKey('uptimeSeconds')
              ? _json['uptimeSeconds'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (advertisedRoutes != null)
          'advertisedRoutes':
              advertisedRoutes!.map((value) => value.toJson()).toList(),
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (linkedVpnTunnel != null) 'linkedVpnTunnel': linkedVpnTunnel!,
        if (name != null) 'name': name!,
        if (numLearnedRoutes != null) 'numLearnedRoutes': numLearnedRoutes!,
        if (peerIpAddress != null) 'peerIpAddress': peerIpAddress!,
        if (state != null) 'state': state!,
        if (status != null) 'status': status!,
        if (uptime != null) 'uptime': uptime!,
        if (uptimeSeconds != null) 'uptimeSeconds': uptimeSeconds!,
      };
}

/// Status of a NAT contained in this router.
class RouterStatusNatStatus {
  /// A list of IPs auto-allocated for NAT.
  ///
  /// Example: \["1.1.1.1", "129.2.16.89"\]
  core.List<core.String>? autoAllocatedNatIps;

  /// A list of IPs auto-allocated for NAT that are in drain mode.
  ///
  /// Example: \["1.1.1.1", "179.12.26.133"\].
  core.List<core.String>? drainAutoAllocatedNatIps;

  /// A list of IPs user-allocated for NAT that are in drain mode.
  ///
  /// Example: \["1.1.1.1", "179.12.26.133"\].
  core.List<core.String>? drainUserAllocatedNatIps;

  /// The number of extra IPs to allocate.
  ///
  /// This will be greater than 0 only if user-specified IPs are NOT enough to
  /// allow all configured VMs to use NAT. This value is meaningful only when
  /// auto-allocation of NAT IPs is *not* used.
  core.int? minExtraNatIpsNeeded;

  /// Unique name of this NAT.
  core.String? name;

  /// Number of VM endpoints (i.e., Nics) that can use NAT.
  core.int? numVmEndpointsWithNatMappings;

  /// A list of fully qualified URLs of reserved IP address resources.
  core.List<core.String>? userAllocatedNatIpResources;

  /// A list of IPs user-allocated for NAT.
  ///
  /// They will be raw IP strings like "179.12.26.133".
  core.List<core.String>? userAllocatedNatIps;

  RouterStatusNatStatus({
    this.autoAllocatedNatIps,
    this.drainAutoAllocatedNatIps,
    this.drainUserAllocatedNatIps,
    this.minExtraNatIpsNeeded,
    this.name,
    this.numVmEndpointsWithNatMappings,
    this.userAllocatedNatIpResources,
    this.userAllocatedNatIps,
  });

  RouterStatusNatStatus.fromJson(core.Map _json)
      : this(
          autoAllocatedNatIps: _json.containsKey('autoAllocatedNatIps')
              ? (_json['autoAllocatedNatIps'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          drainAutoAllocatedNatIps:
              _json.containsKey('drainAutoAllocatedNatIps')
                  ? (_json['drainAutoAllocatedNatIps'] as core.List)
                      .map<core.String>((value) => value as core.String)
                      .toList()
                  : null,
          drainUserAllocatedNatIps:
              _json.containsKey('drainUserAllocatedNatIps')
                  ? (_json['drainUserAllocatedNatIps'] as core.List)
                      .map<core.String>((value) => value as core.String)
                      .toList()
                  : null,
          minExtraNatIpsNeeded: _json.containsKey('minExtraNatIpsNeeded')
              ? _json['minExtraNatIpsNeeded'] as core.int
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          numVmEndpointsWithNatMappings:
              _json.containsKey('numVmEndpointsWithNatMappings')
                  ? _json['numVmEndpointsWithNatMappings'] as core.int
                  : null,
          userAllocatedNatIpResources:
              _json.containsKey('userAllocatedNatIpResources')
                  ? (_json['userAllocatedNatIpResources'] as core.List)
                      .map<core.String>((value) => value as core.String)
                      .toList()
                  : null,
          userAllocatedNatIps: _json.containsKey('userAllocatedNatIps')
              ? (_json['userAllocatedNatIps'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoAllocatedNatIps != null)
          'autoAllocatedNatIps': autoAllocatedNatIps!,
        if (drainAutoAllocatedNatIps != null)
          'drainAutoAllocatedNatIps': drainAutoAllocatedNatIps!,
        if (drainUserAllocatedNatIps != null)
          'drainUserAllocatedNatIps': drainUserAllocatedNatIps!,
        if (minExtraNatIpsNeeded != null)
          'minExtraNatIpsNeeded': minExtraNatIpsNeeded!,
        if (name != null) 'name': name!,
        if (numVmEndpointsWithNatMappings != null)
          'numVmEndpointsWithNatMappings': numVmEndpointsWithNatMappings!,
        if (userAllocatedNatIpResources != null)
          'userAllocatedNatIpResources': userAllocatedNatIpResources!,
        if (userAllocatedNatIps != null)
          'userAllocatedNatIps': userAllocatedNatIps!,
      };
}

class RouterStatusResponse {
  /// Type of resource.
  core.String? kind;
  RouterStatus? result;

  RouterStatusResponse({
    this.kind,
    this.result,
  });

  RouterStatusResponse.fromJson(core.Map _json)
      : this(
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          result: _json.containsKey('result')
              ? RouterStatus.fromJson(
                  _json['result'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (result != null) 'result': result!.toJson(),
      };
}

class RoutersPreviewResponse {
  /// Preview of given router.
  Router? resource;

  RoutersPreviewResponse({
    this.resource,
  });

  RoutersPreviewResponse.fromJson(core.Map _json)
      : this(
          resource: _json.containsKey('resource')
              ? Router.fromJson(
                  _json['resource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resource != null) 'resource': resource!.toJson(),
      };
}

class RoutersScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RoutersScopedListWarningData({
    this.key,
    this.value,
  });

  RoutersScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of routers when the list is
/// empty.
class RoutersScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RoutersScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RoutersScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  RoutersScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<RoutersScopedListWarningData>((value) =>
                      RoutersScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class RoutersScopedList {
  /// A list of routers contained in this scope.
  core.List<Router>? routers;

  /// Informational warning which replaces the list of routers when the list is
  /// empty.
  RoutersScopedListWarning? warning;

  RoutersScopedList({
    this.routers,
    this.warning,
  });

  RoutersScopedList.fromJson(core.Map _json)
      : this(
          routers: _json.containsKey('routers')
              ? (_json['routers'] as core.List)
                  .map<Router>((value) => Router.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? RoutersScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (routers != null)
          'routers': routers!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// This is deprecated and has no effect.
///
/// Do not use.
class Rule {
  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  /// Possible string values are:
  /// - "ALLOW" : This is deprecated and has no effect. Do not use.
  /// - "ALLOW_WITH_LOG" : This is deprecated and has no effect. Do not use.
  /// - "DENY" : This is deprecated and has no effect. Do not use.
  /// - "DENY_WITH_LOG" : This is deprecated and has no effect. Do not use.
  /// - "LOG" : This is deprecated and has no effect. Do not use.
  /// - "NO_ACTION" : This is deprecated and has no effect. Do not use.
  core.String? action;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<Condition>? conditions;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.String? description;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<core.String>? ins;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<LogConfig>? logConfigs;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<core.String>? notIns;

  /// This is deprecated and has no effect.
  ///
  /// Do not use.
  core.List<core.String>? permissions;

  Rule({
    this.action,
    this.conditions,
    this.description,
    this.ins,
    this.logConfigs,
    this.notIns,
    this.permissions,
  });

  Rule.fromJson(core.Map _json)
      : this(
          action: _json.containsKey('action')
              ? _json['action'] as core.String
              : null,
          conditions: _json.containsKey('conditions')
              ? (_json['conditions'] as core.List)
                  .map<Condition>((value) => Condition.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          ins: _json.containsKey('ins')
              ? (_json['ins'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          logConfigs: _json.containsKey('logConfigs')
              ? (_json['logConfigs'] as core.List)
                  .map<LogConfig>((value) => LogConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          notIns: _json.containsKey('notIns')
              ? (_json['notIns'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          permissions: _json.containsKey('permissions')
              ? (_json['permissions'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (action != null) 'action': action!,
        if (conditions != null)
          'conditions': conditions!.map((value) => value.toJson()).toList(),
        if (description != null) 'description': description!,
        if (ins != null) 'ins': ins!,
        if (logConfigs != null)
          'logConfigs': logConfigs!.map((value) => value.toJson()).toList(),
        if (notIns != null) 'notIns': notIns!,
        if (permissions != null) 'permissions': permissions!,
      };
}

class SSLHealthCheck {
  /// The TCP port number for the health check request.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values: USE_FIXED_PORT: The port number in port is used for
  /// health checking.
  ///
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking. If not specified, SSL health check follows behavior specified in
  /// port and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in port is used for health checking.
  /// - "USE_NAMED_PORT" : The portName is used for health checking.
  /// - "USE_SERVING_PORT" : For NetworkEndpointGroup, the port specified for
  /// each network endpoint is used for health checking. For other backends, the
  /// port or named port specified in the Backend Service is used for health
  /// checking.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The application data to send once the SSL connection has been established
  /// (default value is empty).
  ///
  /// If both request and response are empty, the connection establishment alone
  /// will indicate health. The request data can only be ASCII.
  core.String? request;

  /// The bytes to match against the beginning of the response data.
  ///
  /// If left empty (the default value), any response will indicate health. The
  /// response data can only be ASCII.
  core.String? response;

  SSLHealthCheck({
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.request,
    this.response,
  });

  SSLHealthCheck.fromJson(core.Map _json)
      : this(
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          portName: _json.containsKey('portName')
              ? _json['portName'] as core.String
              : null,
          portSpecification: _json.containsKey('portSpecification')
              ? _json['portSpecification'] as core.String
              : null,
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
          request: _json.containsKey('request')
              ? _json['request'] as core.String
              : null,
          response: _json.containsKey('response')
              ? _json['response'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (request != null) 'request': request!,
        if (response != null) 'response': response!,
      };
}

class ScalingScheduleStatus {
  /// The last time the scaling schedule became active.
  ///
  /// Note: this is a timestamp when a schedule actually became active, not when
  /// it was planned to do so. The timestamp is in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastStartTime;

  /// The next time the scaling schedule is to become active.
  ///
  /// Note: this is a timestamp when a schedule is planned to run, but the
  /// actual time might be slightly different. The timestamp is in RFC3339 text
  /// format.
  ///
  /// Output only.
  core.String? nextStartTime;

  /// The current state of a scaling schedule.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE" : The current autoscaling recommendation is influenced by this
  /// scaling schedule.
  /// - "DISABLED" : This scaling schedule has been disabled by the user.
  /// - "OBSOLETE" : This scaling schedule will never become active again.
  /// - "READY" : The current autoscaling recommendation is not influenced by
  /// this scaling schedule.
  core.String? state;

  ScalingScheduleStatus({
    this.lastStartTime,
    this.nextStartTime,
    this.state,
  });

  ScalingScheduleStatus.fromJson(core.Map _json)
      : this(
          lastStartTime: _json.containsKey('lastStartTime')
              ? _json['lastStartTime'] as core.String
              : null,
          nextStartTime: _json.containsKey('nextStartTime')
              ? _json['nextStartTime'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (lastStartTime != null) 'lastStartTime': lastStartTime!,
        if (nextStartTime != null) 'nextStartTime': nextStartTime!,
        if (state != null) 'state': state!,
      };
}

/// Sets the scheduling options for an Instance.
///
/// NextID: 21
class Scheduling {
  /// Specifies whether the instance should be automatically restarted if it is
  /// terminated by Compute Engine (not terminated by a user).
  ///
  /// You can only set the automatic restart option for standard instances.
  /// Preemptible instances cannot be automatically restarted. By default, this
  /// is set to true so an instance is automatically restarted if it is
  /// terminated by Compute Engine.
  core.bool? automaticRestart;

  /// An opaque location hint used to place the instance close to other
  /// resources.
  ///
  /// This field is for use by internal tools that use the public API.
  core.String? locationHint;

  /// The minimum number of virtual CPUs this instance will consume when running
  /// on a sole-tenant node.
  core.int? minNodeCpus;

  /// A set of node affinity and anti-affinity configurations.
  ///
  /// Refer to Configuring node affinity for more information. Overrides
  /// reservationAffinity.
  core.List<SchedulingNodeAffinity>? nodeAffinities;

  /// Defines the maintenance behavior for this instance.
  ///
  /// For standard instances, the default behavior is MIGRATE. For preemptible
  /// instances, the default and only possible behavior is TERMINATE. For more
  /// information, see Setting Instance Scheduling Options.
  /// Possible string values are:
  /// - "MIGRATE" : *\[Default\]* Allows Compute Engine to automatically migrate
  /// instances out of the way of maintenance events.
  /// - "TERMINATE" : Tells Compute Engine to terminate and (optionally) restart
  /// the instance away from the maintenance activity. If you would like your
  /// instance to be restarted, set the automaticRestart flag to true. Your
  /// instance may be restarted more than once, and it may be restarted outside
  /// the window of maintenance events.
  core.String? onHostMaintenance;

  /// Defines whether the instance is preemptible.
  ///
  /// This can only be set during instance creation or while the instance is
  /// stopped and therefore, in a `TERMINATED` state. See Instance Life Cycle
  /// for more information on the possible instance states.
  core.bool? preemptible;

  Scheduling({
    this.automaticRestart,
    this.locationHint,
    this.minNodeCpus,
    this.nodeAffinities,
    this.onHostMaintenance,
    this.preemptible,
  });

  Scheduling.fromJson(core.Map _json)
      : this(
          automaticRestart: _json.containsKey('automaticRestart')
              ? _json['automaticRestart'] as core.bool
              : null,
          locationHint: _json.containsKey('locationHint')
              ? _json['locationHint'] as core.String
              : null,
          minNodeCpus: _json.containsKey('minNodeCpus')
              ? _json['minNodeCpus'] as core.int
              : null,
          nodeAffinities: _json.containsKey('nodeAffinities')
              ? (_json['nodeAffinities'] as core.List)
                  .map<SchedulingNodeAffinity>((value) =>
                      SchedulingNodeAffinity.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          onHostMaintenance: _json.containsKey('onHostMaintenance')
              ? _json['onHostMaintenance'] as core.String
              : null,
          preemptible: _json.containsKey('preemptible')
              ? _json['preemptible'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (automaticRestart != null) 'automaticRestart': automaticRestart!,
        if (locationHint != null) 'locationHint': locationHint!,
        if (minNodeCpus != null) 'minNodeCpus': minNodeCpus!,
        if (nodeAffinities != null)
          'nodeAffinities':
              nodeAffinities!.map((value) => value.toJson()).toList(),
        if (onHostMaintenance != null) 'onHostMaintenance': onHostMaintenance!,
        if (preemptible != null) 'preemptible': preemptible!,
      };
}

/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled.
class SchedulingNodeAffinity {
  /// Corresponds to the label key of Node resource.
  core.String? key;

  /// Defines the operation of node selection.
  ///
  /// Valid operators are IN for affinity and NOT_IN for anti-affinity.
  /// Possible string values are:
  /// - "IN" : Requires Compute Engine to seek for matched nodes.
  /// - "NOT_IN" : Requires Compute Engine to avoid certain nodes.
  /// - "OPERATOR_UNSPECIFIED"
  core.String? operator;

  /// Corresponds to the label values of Node resource.
  core.List<core.String>? values;

  SchedulingNodeAffinity({
    this.key,
    this.operator,
    this.values,
  });

  SchedulingNodeAffinity.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          operator: _json.containsKey('operator')
              ? _json['operator'] as core.String
              : null,
          values: _json.containsKey('values')
              ? (_json['values'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (operator != null) 'operator': operator!,
        if (values != null) 'values': values!,
      };
}

/// An instance's screenshot.
class Screenshot {
  /// The Base64-encoded screenshot data.
  ///
  /// Output only.
  core.String? contents;

  /// Type of the resource.
  ///
  /// Always compute#screenshot for the screenshots.
  ///
  /// Output only.
  core.String? kind;

  Screenshot({
    this.contents,
    this.kind,
  });

  Screenshot.fromJson(core.Map _json)
      : this(
          contents: _json.containsKey('contents')
              ? _json['contents'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contents != null) 'contents': contents!,
        if (kind != null) 'kind': kind!,
      };
}

class SecurityPoliciesListPreconfiguredExpressionSetsResponse {
  SecurityPoliciesWafConfig? preconfiguredExpressionSets;

  SecurityPoliciesListPreconfiguredExpressionSetsResponse({
    this.preconfiguredExpressionSets,
  });

  SecurityPoliciesListPreconfiguredExpressionSetsResponse.fromJson(
      core.Map _json)
      : this(
          preconfiguredExpressionSets:
              _json.containsKey('preconfiguredExpressionSets')
                  ? SecurityPoliciesWafConfig.fromJson(
                      _json['preconfiguredExpressionSets']
                          as core.Map<core.String, core.dynamic>)
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (preconfiguredExpressionSets != null)
          'preconfiguredExpressionSets': preconfiguredExpressionSets!.toJson(),
      };
}

class SecurityPoliciesWafConfig {
  PreconfiguredWafSet? wafRules;

  SecurityPoliciesWafConfig({
    this.wafRules,
  });

  SecurityPoliciesWafConfig.fromJson(core.Map _json)
      : this(
          wafRules: _json.containsKey('wafRules')
              ? PreconfiguredWafSet.fromJson(
                  _json['wafRules'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (wafRules != null) 'wafRules': wafRules!.toJson(),
      };
}

/// Represents a Google Cloud Armor security policy resource.
///
/// Only external backend services that use load balancers can reference a
/// security policy. For more information, see Google Cloud Armor security
/// policy overview.
class SecurityPolicy {
  SecurityPolicyAdaptiveProtectionConfig? adaptiveProtectionConfig;
  SecurityPolicyAdvancedOptionsConfig? advancedOptionsConfig;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update metadata. You must always provide an
  /// up-to-date fingerprint hash in order to update or change metadata,
  /// otherwise the request will fail with error 412 conditionNotMet. To see the
  /// latest fingerprint, make get() request to the security policy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#securityPolicyfor security policies
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// A list of rules that belong to this policy.
  ///
  /// There must always be a default rule (rule with priority 2147483647 and
  /// match "*"). If no rules are provided when creating a security policy, a
  /// default rule with action "allow" will be added.
  core.List<SecurityPolicyRule>? rules;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  SecurityPolicy({
    this.adaptiveProtectionConfig,
    this.advancedOptionsConfig,
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.rules,
    this.selfLink,
  });

  SecurityPolicy.fromJson(core.Map _json)
      : this(
          adaptiveProtectionConfig:
              _json.containsKey('adaptiveProtectionConfig')
                  ? SecurityPolicyAdaptiveProtectionConfig.fromJson(
                      _json['adaptiveProtectionConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          advancedOptionsConfig: _json.containsKey('advancedOptionsConfig')
              ? SecurityPolicyAdvancedOptionsConfig.fromJson(
                  _json['advancedOptionsConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          rules: _json.containsKey('rules')
              ? (_json['rules'] as core.List)
                  .map<SecurityPolicyRule>((value) =>
                      SecurityPolicyRule.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (adaptiveProtectionConfig != null)
          'adaptiveProtectionConfig': adaptiveProtectionConfig!.toJson(),
        if (advancedOptionsConfig != null)
          'advancedOptionsConfig': advancedOptionsConfig!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Configuration options for Cloud Armor Adaptive Protection (CAAP).
class SecurityPolicyAdaptiveProtectionConfig {
  /// If set to true, enables Cloud Armor Machine Learning.
  SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig?
      layer7DdosDefenseConfig;

  SecurityPolicyAdaptiveProtectionConfig({
    this.layer7DdosDefenseConfig,
  });

  SecurityPolicyAdaptiveProtectionConfig.fromJson(core.Map _json)
      : this(
          layer7DdosDefenseConfig: _json.containsKey('layer7DdosDefenseConfig')
              ? SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig
                  .fromJson(_json['layer7DdosDefenseConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (layer7DdosDefenseConfig != null)
          'layer7DdosDefenseConfig': layer7DdosDefenseConfig!.toJson(),
      };
}

/// Configuration options for L7 DDoS detection.
class SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig {
  /// If set to true, enables CAAP for L7 DDoS detection.
  core.bool? enable;

  /// Rule visibility can be one of the following: STANDARD - opaque rules.
  ///
  /// (default) PREMIUM - transparent rules.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String? ruleVisibility;

  SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig({
    this.enable,
    this.ruleVisibility,
  });

  SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig.fromJson(
      core.Map _json)
      : this(
          enable:
              _json.containsKey('enable') ? _json['enable'] as core.bool : null,
          ruleVisibility: _json.containsKey('ruleVisibility')
              ? _json['ruleVisibility'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
        if (ruleVisibility != null) 'ruleVisibility': ruleVisibility!,
      };
}

class SecurityPolicyAdvancedOptionsConfig {
  ///
  /// Possible string values are:
  /// - "DISABLED"
  /// - "STANDARD"
  core.String? jsonParsing;

  ///
  /// Possible string values are:
  /// - "NORMAL"
  /// - "VERBOSE"
  core.String? logLevel;

  SecurityPolicyAdvancedOptionsConfig({
    this.jsonParsing,
    this.logLevel,
  });

  SecurityPolicyAdvancedOptionsConfig.fromJson(core.Map _json)
      : this(
          jsonParsing: _json.containsKey('jsonParsing')
              ? _json['jsonParsing'] as core.String
              : null,
          logLevel: _json.containsKey('logLevel')
              ? _json['logLevel'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (jsonParsing != null) 'jsonParsing': jsonParsing!,
        if (logLevel != null) 'logLevel': logLevel!,
      };
}

class SecurityPolicyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SecurityPolicyListWarningData({
    this.key,
    this.value,
  });

  SecurityPolicyListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SecurityPolicyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SecurityPolicyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SecurityPolicyListWarning({
    this.code,
    this.data,
    this.message,
  });

  SecurityPolicyListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SecurityPolicyListWarningData>((value) =>
                      SecurityPolicyListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SecurityPolicyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SecurityPolicy resources.
  core.List<SecurityPolicy>? items;

  /// Type of resource.
  ///
  /// Always compute#securityPolicyList for listsof securityPolicies
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  SecurityPolicyListWarning? warning;

  SecurityPolicyList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.warning,
  });

  SecurityPolicyList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<SecurityPolicy>((value) => SecurityPolicy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? SecurityPolicyListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SecurityPolicyReference {
  core.String? securityPolicy;

  SecurityPolicyReference({
    this.securityPolicy,
  });

  SecurityPolicyReference.fromJson(core.Map _json)
      : this(
          securityPolicy: _json.containsKey('securityPolicy')
              ? _json['securityPolicy'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (securityPolicy != null) 'securityPolicy': securityPolicy!,
      };
}

/// Represents a rule that describes one or more match conditions along with the
/// action to be taken when traffic matches this condition (allow or deny).
class SecurityPolicyRule {
  /// The Action to perform when the client connection triggers the rule.
  ///
  /// Can currently be either "allow" or "deny()" where valid values for status
  /// are 403, 404, and 502.
  core.String? action;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Type of the resource.
  ///
  /// Always compute#securityPolicyRule for security policy rules
  ///
  /// Output only.
  core.String? kind;

  /// A match condition that incoming traffic is evaluated against.
  ///
  /// If it evaluates to true, the corresponding 'action' is enforced.
  SecurityPolicyRuleMatcher? match;

  /// If set to true, the specified action is not enforced.
  core.bool? preview;

  /// An integer indicating the priority of a rule in the list.
  ///
  /// The priority must be a positive value between 0 and 2147483647. Rules are
  /// evaluated from highest to lowest priority where 0 is the highest priority
  /// and 2147483647 is the lowest priority.
  core.int? priority;

  SecurityPolicyRule({
    this.action,
    this.description,
    this.kind,
    this.match,
    this.preview,
    this.priority,
  });

  SecurityPolicyRule.fromJson(core.Map _json)
      : this(
          action: _json.containsKey('action')
              ? _json['action'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          match: _json.containsKey('match')
              ? SecurityPolicyRuleMatcher.fromJson(
                  _json['match'] as core.Map<core.String, core.dynamic>)
              : null,
          preview: _json.containsKey('preview')
              ? _json['preview'] as core.bool
              : null,
          priority: _json.containsKey('priority')
              ? _json['priority'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (action != null) 'action': action!,
        if (description != null) 'description': description!,
        if (kind != null) 'kind': kind!,
        if (match != null) 'match': match!.toJson(),
        if (preview != null) 'preview': preview!,
        if (priority != null) 'priority': priority!,
      };
}

/// Represents a match condition that incoming traffic is evaluated against.
///
/// Exactly one field must be specified.
class SecurityPolicyRuleMatcher {
  /// The configuration options available when specifying versioned_expr.
  ///
  /// This field must be specified if versioned_expr is specified and cannot be
  /// specified if versioned_expr is not specified.
  SecurityPolicyRuleMatcherConfig? config;

  /// User defined CEVAL expression.
  ///
  /// A CEVAL expression is used to specify match criteria such as origin.ip,
  /// source.region_code and contents in the request header.
  Expr? expr;

  /// Preconfigured versioned expression.
  ///
  /// If this field is specified, config must also be specified. Available
  /// preconfigured expressions along with their requirements are: SRC_IPS_V1 -
  /// must specify the corresponding src_ip_range field in config.
  /// Possible string values are:
  /// - "SRC_IPS_V1" : Matches the source IP address of a request to the IP
  /// ranges supplied in config.
  core.String? versionedExpr;

  SecurityPolicyRuleMatcher({
    this.config,
    this.expr,
    this.versionedExpr,
  });

  SecurityPolicyRuleMatcher.fromJson(core.Map _json)
      : this(
          config: _json.containsKey('config')
              ? SecurityPolicyRuleMatcherConfig.fromJson(
                  _json['config'] as core.Map<core.String, core.dynamic>)
              : null,
          expr: _json.containsKey('expr')
              ? Expr.fromJson(
                  _json['expr'] as core.Map<core.String, core.dynamic>)
              : null,
          versionedExpr: _json.containsKey('versionedExpr')
              ? _json['versionedExpr'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (config != null) 'config': config!.toJson(),
        if (expr != null) 'expr': expr!.toJson(),
        if (versionedExpr != null) 'versionedExpr': versionedExpr!,
      };
}

class SecurityPolicyRuleMatcherConfig {
  /// CIDR IP address range.
  ///
  /// Maximum number of src_ip_ranges allowed is 10.
  core.List<core.String>? srcIpRanges;

  SecurityPolicyRuleMatcherConfig({
    this.srcIpRanges,
  });

  SecurityPolicyRuleMatcherConfig.fromJson(core.Map _json)
      : this(
          srcIpRanges: _json.containsKey('srcIpRanges')
              ? (_json['srcIpRanges'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (srcIpRanges != null) 'srcIpRanges': srcIpRanges!,
      };
}

/// The authentication and authorization settings for a BackendService.
class SecuritySettings {
  /// A URL referring to a networksecurity.ClientTlsPolicy resource that
  /// describes how clients should authenticate with this service's backends.
  ///
  /// clientTlsPolicy only applies to a global BackendService with the
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED. If left blank,
  /// communications are not encrypted. Note: This field currently has no
  /// impact.
  ///
  /// Optional.
  core.String? clientTlsPolicy;

  /// A list of Subject Alternative Names (SANs) that the client verifies during
  /// a mutual TLS handshake with an server/endpoint for this BackendService.
  ///
  /// When the server presents its X.509 certificate to the client, the client
  /// inspects the certificate's subjectAltName field. If the field contains one
  /// of the specified values, the communication continues. Otherwise, it fails.
  /// This additional check enables the client to verify that the server is
  /// authorized to run the requested service. Note that the contents of the
  /// server certificate's subjectAltName field are configured by the Public Key
  /// Infrastructure which provisions server identities. Only applies to a
  /// global BackendService with loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED. Only applies when BackendService has an attached
  /// clientTlsPolicy with clientCertificate (mTLS mode). Note: This field
  /// currently has no impact.
  ///
  /// Optional.
  core.List<core.String>? subjectAltNames;

  SecuritySettings({
    this.clientTlsPolicy,
    this.subjectAltNames,
  });

  SecuritySettings.fromJson(core.Map _json)
      : this(
          clientTlsPolicy: _json.containsKey('clientTlsPolicy')
              ? _json['clientTlsPolicy'] as core.String
              : null,
          subjectAltNames: _json.containsKey('subjectAltNames')
              ? (_json['subjectAltNames'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientTlsPolicy != null) 'clientTlsPolicy': clientTlsPolicy!,
        if (subjectAltNames != null) 'subjectAltNames': subjectAltNames!,
      };
}

/// An instance serial console output.
class SerialPortOutput {
  /// The contents of the console output.
  ///
  /// Output only.
  core.String? contents;

  /// Type of the resource.
  ///
  /// Always compute#serialPortOutput for serial port output.
  ///
  /// Output only.
  core.String? kind;

  /// The position of the next byte of content, regardless of whether the
  /// content exists, following the output returned in the `contents` property.
  ///
  /// Use this value in the next request as the start parameter.
  ///
  /// Output only.
  core.String? next;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The starting byte position of the output that was returned.
  ///
  /// This should match the start parameter sent with the request. If the serial
  /// console output exceeds the size of the buffer (1 MB), older output is
  /// overwritten by newer content. The output start value will indicate the
  /// byte position of the output that was returned, which might be different
  /// than the `start` value that was specified in the request.
  core.String? start;

  SerialPortOutput({
    this.contents,
    this.kind,
    this.next,
    this.selfLink,
    this.start,
  });

  SerialPortOutput.fromJson(core.Map _json)
      : this(
          contents: _json.containsKey('contents')
              ? _json['contents'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          next: _json.containsKey('next') ? _json['next'] as core.String : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          start:
              _json.containsKey('start') ? _json['start'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contents != null) 'contents': contents!,
        if (kind != null) 'kind': kind!,
        if (next != null) 'next': next!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (start != null) 'start': start!,
      };
}

class ServerBinding {
  ///
  /// Possible string values are:
  /// - "RESTART_NODE_ON_ANY_SERVER" : Node may associate with any physical
  /// server over its lifetime.
  /// - "RESTART_NODE_ON_MINIMAL_SERVERS" : Node may associate with minimal
  /// physical servers over its lifetime.
  /// - "SERVER_BINDING_TYPE_UNSPECIFIED"
  core.String? type;

  ServerBinding({
    this.type,
  });

  ServerBinding.fromJson(core.Map _json)
      : this(
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (type != null) 'type': type!,
      };
}

/// A service account.
class ServiceAccount {
  /// Email address of the service account.
  core.String? email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String>? scopes;

  ServiceAccount({
    this.email,
    this.scopes,
  });

  ServiceAccount.fromJson(core.Map _json)
      : this(
          email:
              _json.containsKey('email') ? _json['email'] as core.String : null,
          scopes: _json.containsKey('scopes')
              ? (_json['scopes'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (email != null) 'email': email!,
        if (scopes != null) 'scopes': scopes!,
      };
}

/// Represents a ServiceAttachment resource.
///
/// A service attachment represents a service that a producer has exposed. It
/// encapsulates the load balancer which fronts the service runs and a list of
/// NAT IP ranges that the producers uses to represent the consumers connecting
/// to the service. next tag = 20
class ServiceAttachment {
  /// An array of connections for all the consumers connected to this service
  /// attachment.
  ///
  /// Output only.
  core.List<ServiceAttachmentConnectedEndpoint>? connectedEndpoints;

  /// The connection preference of service attachment.
  ///
  /// The value can be set to ACCEPT_AUTOMATIC. An ACCEPT_AUTOMATIC service
  /// attachment is one that always accepts the connection from consumer
  /// forwarding rules.
  /// Possible string values are:
  /// - "ACCEPT_AUTOMATIC"
  /// - "ACCEPT_MANUAL"
  /// - "CONNECTION_PREFERENCE_UNSPECIFIED"
  core.String? connectionPreference;

  /// Projects that are allowed to connect to this service attachment.
  core.List<ServiceAttachmentConsumerProjectLimit>? consumerAcceptLists;

  /// Projects that are not allowed to connect to this service attachment.
  ///
  /// The project can be specified using its id or number.
  core.List<core.String>? consumerRejectLists;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// If true, enable the proxy protocol which is for supplying client TCP/IP
  /// address data in TCP connections that traverse proxies on their way to
  /// destination servers.
  core.bool? enableProxyProtocol;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// ServiceAttachment. An up-to-date fingerprint must be provided in order to
  /// patch/update the ServiceAttachment; otherwise, the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve the ServiceAttachment.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#serviceAttachment for service attachments.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// An array of URLs where each entry is the URL of a subnet provided by the
  /// service producer to use for NAT in this service attachment.
  core.List<core.String>? natSubnets;

  /// The URL of a forwarding rule with loadBalancingScheme INTERNAL* that is
  /// serving the endpoint identified by this service attachment.
  core.String? producerForwardingRule;

  /// An 128-bit global unique ID of the PSC service attachment.
  ///
  /// Output only.
  Uint128? pscServiceAttachmentId;

  /// URL of the region where the service attachment resides.
  ///
  /// This field applies only to the region resource. You must specify this
  /// field as part of the HTTP request URL. It is not settable as a field in
  /// the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The URL of a service serving the endpoint identified by this service
  /// attachment.
  core.String? targetService;

  ServiceAttachment({
    this.connectedEndpoints,
    this.connectionPreference,
    this.consumerAcceptLists,
    this.consumerRejectLists,
    this.creationTimestamp,
    this.description,
    this.enableProxyProtocol,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.natSubnets,
    this.producerForwardingRule,
    this.pscServiceAttachmentId,
    this.region,
    this.selfLink,
    this.targetService,
  });

  ServiceAttachment.fromJson(core.Map _json)
      : this(
          connectedEndpoints: _json.containsKey('connectedEndpoints')
              ? (_json['connectedEndpoints'] as core.List)
                  .map<ServiceAttachmentConnectedEndpoint>((value) =>
                      ServiceAttachmentConnectedEndpoint.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          connectionPreference: _json.containsKey('connectionPreference')
              ? _json['connectionPreference'] as core.String
              : null,
          consumerAcceptLists: _json.containsKey('consumerAcceptLists')
              ? (_json['consumerAcceptLists'] as core.List)
                  .map<ServiceAttachmentConsumerProjectLimit>((value) =>
                      ServiceAttachmentConsumerProjectLimit.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          consumerRejectLists: _json.containsKey('consumerRejectLists')
              ? (_json['consumerRejectLists'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          enableProxyProtocol: _json.containsKey('enableProxyProtocol')
              ? _json['enableProxyProtocol'] as core.bool
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          natSubnets: _json.containsKey('natSubnets')
              ? (_json['natSubnets'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          producerForwardingRule: _json.containsKey('producerForwardingRule')
              ? _json['producerForwardingRule'] as core.String
              : null,
          pscServiceAttachmentId: _json.containsKey('pscServiceAttachmentId')
              ? Uint128.fromJson(_json['pscServiceAttachmentId']
                  as core.Map<core.String, core.dynamic>)
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          targetService: _json.containsKey('targetService')
              ? _json['targetService'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (connectedEndpoints != null)
          'connectedEndpoints':
              connectedEndpoints!.map((value) => value.toJson()).toList(),
        if (connectionPreference != null)
          'connectionPreference': connectionPreference!,
        if (consumerAcceptLists != null)
          'consumerAcceptLists':
              consumerAcceptLists!.map((value) => value.toJson()).toList(),
        if (consumerRejectLists != null)
          'consumerRejectLists': consumerRejectLists!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (enableProxyProtocol != null)
          'enableProxyProtocol': enableProxyProtocol!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (natSubnets != null) 'natSubnets': natSubnets!,
        if (producerForwardingRule != null)
          'producerForwardingRule': producerForwardingRule!,
        if (pscServiceAttachmentId != null)
          'pscServiceAttachmentId': pscServiceAttachmentId!.toJson(),
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (targetService != null) 'targetService': targetService!,
      };
}

class ServiceAttachmentAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ServiceAttachmentAggregatedListWarningData({
    this.key,
    this.value,
  });

  ServiceAttachmentAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ServiceAttachmentAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ServiceAttachmentAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ServiceAttachmentAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  ServiceAttachmentAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ServiceAttachmentAggregatedListWarningData>((value) =>
                      ServiceAttachmentAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of ServiceAttachmentsScopedList.
class ServiceAttachmentAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ServiceAttachmentsScopedList resources.
  core.Map<core.String, ServiceAttachmentsScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  ServiceAttachmentAggregatedListWarning? warning;

  ServiceAttachmentAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  ServiceAttachmentAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    ServiceAttachmentsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? ServiceAttachmentAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A connection connected to this service attachment.
///
/// Output only.
class ServiceAttachmentConnectedEndpoint {
  /// The url of a connected endpoint.
  core.String? endpoint;

  /// The PSC connection id of the connected endpoint.
  core.String? pscConnectionId;

  /// The status of a connected endpoint to this service attachment.
  /// Possible string values are:
  /// - "ACCEPTED" : The connection has been accepted by the producer.
  /// - "CLOSED" : The connection has been closed by the producer.
  /// - "PENDING" : The connection is pending acceptance by the producer.
  /// - "REJECTED" : The consumer is still connected but not using the
  /// connection.
  /// - "STATUS_UNSPECIFIED"
  core.String? status;

  ServiceAttachmentConnectedEndpoint({
    this.endpoint,
    this.pscConnectionId,
    this.status,
  });

  ServiceAttachmentConnectedEndpoint.fromJson(core.Map _json)
      : this(
          endpoint: _json.containsKey('endpoint')
              ? _json['endpoint'] as core.String
              : null,
          pscConnectionId: _json.containsKey('pscConnectionId')
              ? _json['pscConnectionId'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoint != null) 'endpoint': endpoint!,
        if (pscConnectionId != null) 'pscConnectionId': pscConnectionId!,
        if (status != null) 'status': status!,
      };
}

class ServiceAttachmentConsumerProjectLimit {
  /// The value of the limit to set.
  core.int? connectionLimit;

  /// The project id or number for the project to set the limit for.
  core.String? projectIdOrNum;

  ServiceAttachmentConsumerProjectLimit({
    this.connectionLimit,
    this.projectIdOrNum,
  });

  ServiceAttachmentConsumerProjectLimit.fromJson(core.Map _json)
      : this(
          connectionLimit: _json.containsKey('connectionLimit')
              ? _json['connectionLimit'] as core.int
              : null,
          projectIdOrNum: _json.containsKey('projectIdOrNum')
              ? _json['projectIdOrNum'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (connectionLimit != null) 'connectionLimit': connectionLimit!,
        if (projectIdOrNum != null) 'projectIdOrNum': projectIdOrNum!,
      };
}

class ServiceAttachmentListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ServiceAttachmentListWarningData({
    this.key,
    this.value,
  });

  ServiceAttachmentListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ServiceAttachmentListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ServiceAttachmentListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ServiceAttachmentListWarning({
    this.code,
    this.data,
    this.message,
  });

  ServiceAttachmentListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ServiceAttachmentListWarningData>((value) =>
                      ServiceAttachmentListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ServiceAttachmentList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ServiceAttachment resources.
  core.List<ServiceAttachment>? items;

  /// Type of the resource.
  ///
  /// Always compute#serviceAttachment for service attachments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ServiceAttachmentListWarning? warning;

  ServiceAttachmentList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  ServiceAttachmentList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<ServiceAttachment>((value) => ServiceAttachment.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? ServiceAttachmentListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ServiceAttachmentsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ServiceAttachmentsScopedListWarningData({
    this.key,
    this.value,
  });

  ServiceAttachmentsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of service attachments when
/// the list is empty.
class ServiceAttachmentsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ServiceAttachmentsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ServiceAttachmentsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  ServiceAttachmentsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ServiceAttachmentsScopedListWarningData>((value) =>
                      ServiceAttachmentsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ServiceAttachmentsScopedList {
  /// A list of ServiceAttachments contained in this scope.
  core.List<ServiceAttachment>? serviceAttachments;

  /// Informational warning which replaces the list of service attachments when
  /// the list is empty.
  ServiceAttachmentsScopedListWarning? warning;

  ServiceAttachmentsScopedList({
    this.serviceAttachments,
    this.warning,
  });

  ServiceAttachmentsScopedList.fromJson(core.Map _json)
      : this(
          serviceAttachments: _json.containsKey('serviceAttachments')
              ? (_json['serviceAttachments'] as core.List)
                  .map<ServiceAttachment>((value) => ServiceAttachment.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? ServiceAttachmentsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (serviceAttachments != null)
          'serviceAttachments':
              serviceAttachments!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A set of Shielded Instance options.
class ShieldedInstanceConfig {
  /// Defines whether the instance has integrity monitoring enabled.
  ///
  /// Enabled by default.
  core.bool? enableIntegrityMonitoring;

  /// Defines whether the instance has Secure Boot enabled.
  ///
  /// Disabled by default.
  core.bool? enableSecureBoot;

  /// Defines whether the instance has the vTPM enabled.
  ///
  /// Enabled by default.
  core.bool? enableVtpm;

  ShieldedInstanceConfig({
    this.enableIntegrityMonitoring,
    this.enableSecureBoot,
    this.enableVtpm,
  });

  ShieldedInstanceConfig.fromJson(core.Map _json)
      : this(
          enableIntegrityMonitoring:
              _json.containsKey('enableIntegrityMonitoring')
                  ? _json['enableIntegrityMonitoring'] as core.bool
                  : null,
          enableSecureBoot: _json.containsKey('enableSecureBoot')
              ? _json['enableSecureBoot'] as core.bool
              : null,
          enableVtpm: _json.containsKey('enableVtpm')
              ? _json['enableVtpm'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableIntegrityMonitoring != null)
          'enableIntegrityMonitoring': enableIntegrityMonitoring!,
        if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
        if (enableVtpm != null) 'enableVtpm': enableVtpm!,
      };
}

/// A Shielded Instance Identity.
class ShieldedInstanceIdentity {
  /// An Endorsement Key (EK) made by the RSA 2048 algorithm issued to the
  /// Shielded Instance's vTPM.
  ShieldedInstanceIdentityEntry? encryptionKey;

  /// Type of the resource.
  ///
  /// Always compute#shieldedInstanceIdentity for shielded Instance identity
  /// entry.
  ///
  /// Output only.
  core.String? kind;

  /// An Attestation Key (AK) made by the RSA 2048 algorithm issued to the
  /// Shielded Instance's vTPM.
  ShieldedInstanceIdentityEntry? signingKey;

  ShieldedInstanceIdentity({
    this.encryptionKey,
    this.kind,
    this.signingKey,
  });

  ShieldedInstanceIdentity.fromJson(core.Map _json)
      : this(
          encryptionKey: _json.containsKey('encryptionKey')
              ? ShieldedInstanceIdentityEntry.fromJson(
                  _json['encryptionKey'] as core.Map<core.String, core.dynamic>)
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          signingKey: _json.containsKey('signingKey')
              ? ShieldedInstanceIdentityEntry.fromJson(
                  _json['signingKey'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (encryptionKey != null) 'encryptionKey': encryptionKey!.toJson(),
        if (kind != null) 'kind': kind!,
        if (signingKey != null) 'signingKey': signingKey!.toJson(),
      };
}

/// A Shielded Instance Identity Entry.
class ShieldedInstanceIdentityEntry {
  /// A PEM-encoded X.509 certificate.
  ///
  /// This field can be empty.
  core.String? ekCert;

  /// A PEM-encoded public key.
  core.String? ekPub;

  ShieldedInstanceIdentityEntry({
    this.ekCert,
    this.ekPub,
  });

  ShieldedInstanceIdentityEntry.fromJson(core.Map _json)
      : this(
          ekCert: _json.containsKey('ekCert')
              ? _json['ekCert'] as core.String
              : null,
          ekPub:
              _json.containsKey('ekPub') ? _json['ekPub'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ekCert != null) 'ekCert': ekCert!,
        if (ekPub != null) 'ekPub': ekPub!,
      };
}

/// The policy describes the baseline against which Instance boot integrity is
/// measured.
class ShieldedInstanceIntegrityPolicy {
  /// Updates the integrity policy baseline using the measurements from the VM
  /// instance's most recent boot.
  core.bool? updateAutoLearnPolicy;

  ShieldedInstanceIntegrityPolicy({
    this.updateAutoLearnPolicy,
  });

  ShieldedInstanceIntegrityPolicy.fromJson(core.Map _json)
      : this(
          updateAutoLearnPolicy: _json.containsKey('updateAutoLearnPolicy')
              ? _json['updateAutoLearnPolicy'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (updateAutoLearnPolicy != null)
          'updateAutoLearnPolicy': updateAutoLearnPolicy!,
      };
}

/// Represents a customer-supplied Signing Key used by Cloud CDN Signed URLs
class SignedUrlKey {
  /// Name of the key.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? keyName;

  /// 128-bit key value used for signing the URL.
  ///
  /// The key value must be a valid RFC 4648 Section 5 base64url encoded string.
  core.String? keyValue;

  SignedUrlKey({
    this.keyName,
    this.keyValue,
  });

  SignedUrlKey.fromJson(core.Map _json)
      : this(
          keyName: _json.containsKey('keyName')
              ? _json['keyName'] as core.String
              : null,
          keyValue: _json.containsKey('keyValue')
              ? _json['keyValue'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (keyName != null) 'keyName': keyName!,
        if (keyValue != null) 'keyValue': keyValue!,
      };
}

/// Represents a Persistent Disk Snapshot resource.
///
/// You can use snapshots to back up data on a regular interval. For more
/// information, read Creating persistent disk snapshots.
class Snapshot {
  /// Set to true if snapshots are automatically created by applying resource
  /// policy on the target disk.
  ///
  /// Output only.
  core.bool? autoCreated;

  /// Creates the new snapshot in the snapshot chain labeled with the specified
  /// name.
  ///
  /// The chain name must be 1-63 characters long and comply with RFC1035. This
  /// is an uncommon option only for advanced service owners who needs to create
  /// separate snapshot chains, for example, for chargeback tracking. When you
  /// describe your snapshot resource, this field is visible only if it has a
  /// non-empty value.
  core.String? chainName;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Size of the source disk, specified in GB.
  ///
  /// Output only.
  core.String? diskSizeGb;

  /// Number of bytes downloaded to restore a snapshot to a disk.
  ///
  /// Output only.
  core.String? downloadBytes;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#snapshot for Snapshot resources.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this snapshot, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve a snapshot.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this snapshot.
  ///
  /// These can be later modified by the setLabels method. Label values may be
  /// empty.
  core.Map<core.String, core.String>? labels;

  /// Integer license codes indicating which licenses are attached to this
  /// snapshot.
  ///
  /// Output only.
  core.List<core.String>? licenseCodes;

  /// A list of public visible licenses that apply to this snapshot.
  ///
  /// This can be because the original image had licenses attached (such as a
  /// Windows image).
  ///
  /// Output only.
  core.List<core.String>? licenses;

  /// An opaque location hint used to place the snapshot close to other
  /// resources.
  ///
  /// This field is for use by internal tools that use the public API.
  core.String? locationHint;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Encrypts the snapshot using a customer-supplied encryption key.
  ///
  /// After you encrypt a snapshot using a customer-supplied key, you must
  /// provide the same key if you use the snapshot later. For example, you must
  /// provide the encryption key when you create a disk from the encrypted
  /// snapshot in a future request. Customer-supplied encryption keys do not
  /// protect access to metadata of the snapshot. If you do not provide an
  /// encryption key when creating the snapshot, then the snapshot will be
  /// encrypted using an automatically generated key and you do not need to
  /// provide a key to use the snapshot later.
  CustomerEncryptionKey? snapshotEncryptionKey;

  /// The source disk used to create this snapshot.
  core.String? sourceDisk;

  /// The customer-supplied encryption key of the source disk.
  ///
  /// Required if the source disk is protected by a customer-supplied encryption
  /// key.
  CustomerEncryptionKey? sourceDiskEncryptionKey;

  /// The ID value of the disk used to create this snapshot.
  ///
  /// This value may be used to determine whether the snapshot was taken from
  /// the current or a previous instance of a given disk name.
  ///
  /// Output only.
  core.String? sourceDiskId;

  /// The status of the snapshot.
  ///
  /// This can be CREATING, DELETING, FAILED, READY, or UPLOADING.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING" : Snapshot creation is in progress.
  /// - "DELETING" : Snapshot is currently being deleted.
  /// - "FAILED" : Snapshot creation failed.
  /// - "READY" : Snapshot has been created successfully.
  /// - "UPLOADING" : Snapshot is being uploaded.
  core.String? status;

  /// A size of the storage used by the snapshot.
  ///
  /// As snapshots share storage, this number is expected to change with
  /// snapshot creation/deletion.
  ///
  /// Output only.
  core.String? storageBytes;

  /// An indicator whether storageBytes is in a stable state or it is being
  /// adjusted as a result of shared storage reallocation.
  ///
  /// This status can either be UPDATING, meaning the size of the snapshot is
  /// being updated, or UP_TO_DATE, meaning the size of the snapshot is
  /// up-to-date.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UPDATING"
  /// - "UP_TO_DATE"
  core.String? storageBytesStatus;

  /// Cloud Storage bucket storage location of the snapshot (regional or
  /// multi-regional).
  core.List<core.String>? storageLocations;

  Snapshot({
    this.autoCreated,
    this.chainName,
    this.creationTimestamp,
    this.description,
    this.diskSizeGb,
    this.downloadBytes,
    this.id,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.licenseCodes,
    this.licenses,
    this.locationHint,
    this.name,
    this.satisfiesPzs,
    this.selfLink,
    this.snapshotEncryptionKey,
    this.sourceDisk,
    this.sourceDiskEncryptionKey,
    this.sourceDiskId,
    this.status,
    this.storageBytes,
    this.storageBytesStatus,
    this.storageLocations,
  });

  Snapshot.fromJson(core.Map _json)
      : this(
          autoCreated: _json.containsKey('autoCreated')
              ? _json['autoCreated'] as core.bool
              : null,
          chainName: _json.containsKey('chainName')
              ? _json['chainName'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          diskSizeGb: _json.containsKey('diskSizeGb')
              ? _json['diskSizeGb'] as core.String
              : null,
          downloadBytes: _json.containsKey('downloadBytes')
              ? _json['downloadBytes'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          licenseCodes: _json.containsKey('licenseCodes')
              ? (_json['licenseCodes'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          licenses: _json.containsKey('licenses')
              ? (_json['licenses'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          locationHint: _json.containsKey('locationHint')
              ? _json['locationHint'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          satisfiesPzs: _json.containsKey('satisfiesPzs')
              ? _json['satisfiesPzs'] as core.bool
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          snapshotEncryptionKey: _json.containsKey('snapshotEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['snapshotEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          sourceDisk: _json.containsKey('sourceDisk')
              ? _json['sourceDisk'] as core.String
              : null,
          sourceDiskEncryptionKey: _json.containsKey('sourceDiskEncryptionKey')
              ? CustomerEncryptionKey.fromJson(_json['sourceDiskEncryptionKey']
                  as core.Map<core.String, core.dynamic>)
              : null,
          sourceDiskId: _json.containsKey('sourceDiskId')
              ? _json['sourceDiskId'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          storageBytes: _json.containsKey('storageBytes')
              ? _json['storageBytes'] as core.String
              : null,
          storageBytesStatus: _json.containsKey('storageBytesStatus')
              ? _json['storageBytesStatus'] as core.String
              : null,
          storageLocations: _json.containsKey('storageLocations')
              ? (_json['storageLocations'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoCreated != null) 'autoCreated': autoCreated!,
        if (chainName != null) 'chainName': chainName!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (downloadBytes != null) 'downloadBytes': downloadBytes!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (licenseCodes != null) 'licenseCodes': licenseCodes!,
        if (licenses != null) 'licenses': licenses!,
        if (locationHint != null) 'locationHint': locationHint!,
        if (name != null) 'name': name!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (snapshotEncryptionKey != null)
          'snapshotEncryptionKey': snapshotEncryptionKey!.toJson(),
        if (sourceDisk != null) 'sourceDisk': sourceDisk!,
        if (sourceDiskEncryptionKey != null)
          'sourceDiskEncryptionKey': sourceDiskEncryptionKey!.toJson(),
        if (sourceDiskId != null) 'sourceDiskId': sourceDiskId!,
        if (status != null) 'status': status!,
        if (storageBytes != null) 'storageBytes': storageBytes!,
        if (storageBytesStatus != null)
          'storageBytesStatus': storageBytesStatus!,
        if (storageLocations != null) 'storageLocations': storageLocations!,
      };
}

class SnapshotListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SnapshotListWarningData({
    this.key,
    this.value,
  });

  SnapshotListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SnapshotListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SnapshotListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SnapshotListWarning({
    this.code,
    this.data,
    this.message,
  });

  SnapshotListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SnapshotListWarningData>((value) =>
                      SnapshotListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Snapshot resources.
class SnapshotList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Snapshot resources.
  core.List<Snapshot>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  SnapshotListWarning? warning;

  SnapshotList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  SnapshotList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Snapshot>((value) => Snapshot.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? SnapshotListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A specification of the parameters to use when creating the instance template
/// from a source instance.
class SourceInstanceParams {
  /// Attached disks configuration.
  ///
  /// If not provided, defaults are applied: For boot disk and any other R/W
  /// disks, new custom images will be created from each disk. For read-only
  /// disks, they will be attached in read-only mode. Local SSD disks will be
  /// created as blank volumes.
  core.List<DiskInstantiationConfig>? diskConfigs;

  SourceInstanceParams({
    this.diskConfigs,
  });

  SourceInstanceParams.fromJson(core.Map _json)
      : this(
          diskConfigs: _json.containsKey('diskConfigs')
              ? (_json['diskConfigs'] as core.List)
                  .map<DiskInstantiationConfig>((value) =>
                      DiskInstantiationConfig.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskConfigs != null)
          'diskConfigs': diskConfigs!.map((value) => value.toJson()).toList(),
      };
}

/// Represents an SSL Certificate resource.
///
/// Google Compute Engine has two SSL Certificate resources: *
/// \[Global\](/compute/docs/reference/rest/v1/sslCertificates) *
/// \[Regional\](/compute/docs/reference/rest/v1/regionSslCertificates) The
/// sslCertificates are used by: - external HTTPS load balancers - SSL proxy
/// load balancers The regionSslCertificates are used by internal HTTPS load
/// balancers. Optionally, certificate file contents that you upload can contain
/// a set of up to five PEM-encoded certificates. The API call creates an object
/// (sslCertificate) that holds this data. You can use SSL keys and certificates
/// to secure connections to a load balancer. For more information, read
/// Creating and using SSL certificates, SSL certificates quotas and limits, and
/// Troubleshooting SSL certificates.
class SslCertificate {
  /// A value read into memory from a certificate file.
  ///
  /// The certificate file must be in PEM format. The certificate chain must be
  /// no greater than 5 certs long. The chain must include at least one
  /// intermediate cert.
  core.String? certificate;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Expire time of the certificate.
  ///
  /// RFC3339
  ///
  /// Output only.
  core.String? expireTime;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#sslCertificate for SSL certificates.
  ///
  /// Output only.
  core.String? kind;

  /// Configuration and status of a managed SSL certificate.
  SslCertificateManagedSslCertificate? managed;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// A value read into memory from a write-only private key file.
  ///
  /// The private key file must be in PEM format. For security, only insert
  /// requests include this field.
  core.String? privateKey;

  /// URL of the region where the regional SSL Certificate resides.
  ///
  /// This field is not applicable to global SSL Certificate.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Configuration and status of a self-managed SSL certificate.
  SslCertificateSelfManagedSslCertificate? selfManaged;

  /// Domains associated with the certificate via Subject Alternative Name.
  ///
  /// Output only.
  core.List<core.String>? subjectAlternativeNames;

  /// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or
  /// "MANAGED".
  ///
  /// If not specified, the certificate is self-managed and the fields
  /// certificate and private_key are used.
  /// Possible string values are:
  /// - "MANAGED" : Google-managed SSLCertificate.
  /// - "SELF_MANAGED" : Certificate uploaded by user.
  /// - "TYPE_UNSPECIFIED"
  core.String? type;

  SslCertificate({
    this.certificate,
    this.creationTimestamp,
    this.description,
    this.expireTime,
    this.id,
    this.kind,
    this.managed,
    this.name,
    this.privateKey,
    this.region,
    this.selfLink,
    this.selfManaged,
    this.subjectAlternativeNames,
    this.type,
  });

  SslCertificate.fromJson(core.Map _json)
      : this(
          certificate: _json.containsKey('certificate')
              ? _json['certificate'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          expireTime: _json.containsKey('expireTime')
              ? _json['expireTime'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          managed: _json.containsKey('managed')
              ? SslCertificateManagedSslCertificate.fromJson(
                  _json['managed'] as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          privateKey: _json.containsKey('privateKey')
              ? _json['privateKey'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          selfManaged: _json.containsKey('selfManaged')
              ? SslCertificateSelfManagedSslCertificate.fromJson(
                  _json['selfManaged'] as core.Map<core.String, core.dynamic>)
              : null,
          subjectAlternativeNames: _json.containsKey('subjectAlternativeNames')
              ? (_json['subjectAlternativeNames'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (certificate != null) 'certificate': certificate!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (expireTime != null) 'expireTime': expireTime!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (managed != null) 'managed': managed!.toJson(),
        if (name != null) 'name': name!,
        if (privateKey != null) 'privateKey': privateKey!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (selfManaged != null) 'selfManaged': selfManaged!.toJson(),
        if (subjectAlternativeNames != null)
          'subjectAlternativeNames': subjectAlternativeNames!,
        if (type != null) 'type': type!,
      };
}

class SslCertificateAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslCertificateAggregatedListWarningData({
    this.key,
    this.value,
  });

  SslCertificateAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SslCertificateAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslCertificateAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslCertificateAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  SslCertificateAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SslCertificateAggregatedListWarningData>((value) =>
                      SslCertificateAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SslCertificateAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SslCertificatesScopedList resources.
  core.Map<core.String, SslCertificatesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#sslCertificateAggregatedList for lists of SSL Certificates.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  SslCertificateAggregatedListWarning? warning;

  SslCertificateAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  SslCertificateAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    SslCertificatesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? SslCertificateAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SslCertificateListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslCertificateListWarningData({
    this.key,
    this.value,
  });

  SslCertificateListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SslCertificateListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslCertificateListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslCertificateListWarning({
    this.code,
    this.data,
    this.message,
  });

  SslCertificateListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SslCertificateListWarningData>((value) =>
                      SslCertificateListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of SslCertificate resources.
class SslCertificateList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SslCertificate resources.
  core.List<SslCertificate>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  SslCertificateListWarning? warning;

  SslCertificateList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  SslCertificateList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<SslCertificate>((value) => SslCertificate.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? SslCertificateListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Configuration and status of a managed SSL certificate.
class SslCertificateManagedSslCertificate {
  /// Detailed statuses of the domains specified for managed certificate
  /// resource.
  ///
  /// Output only.
  core.Map<core.String, core.String>? domainStatus;

  /// The domains for which a managed SSL certificate will be generated.
  ///
  /// Each Google-managed SSL certificate supports up to the \[maximum number of
  /// domains per Google-managed SSL
  /// certificate\](/load-balancing/docs/quotas#ssl_certificates).
  core.List<core.String>? domains;

  /// Status of the managed certificate resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE" : The certificate management is working, and a certificate has
  /// been provisioned.
  /// - "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED"
  /// - "PROVISIONING" : The certificate management is working. GCP will attempt
  /// to provision the first certificate.
  /// - "PROVISIONING_FAILED" : Certificate provisioning failed due to an issue
  /// with the DNS or load balancing configuration. For details of which domain
  /// failed, consult domain_status field.
  /// - "PROVISIONING_FAILED_PERMANENTLY" : Certificate provisioning failed due
  /// to an issue with the DNS or load balancing configuration. It won't be
  /// retried. To try again delete and create a new managed SslCertificate
  /// resource. For details of which domain failed, consult domain_status field.
  /// - "RENEWAL_FAILED" : Renewal of the certificate has failed due to an issue
  /// with the DNS or load balancing configuration. The existing cert is still
  /// serving; however, it will expire shortly. To provision a renewed
  /// certificate, delete and create a new managed SslCertificate resource. For
  /// details on which domain failed, consult domain_status field.
  core.String? status;

  SslCertificateManagedSslCertificate({
    this.domainStatus,
    this.domains,
    this.status,
  });

  SslCertificateManagedSslCertificate.fromJson(core.Map _json)
      : this(
          domainStatus: _json.containsKey('domainStatus')
              ? (_json['domainStatus'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          domains: _json.containsKey('domains')
              ? (_json['domains'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (domainStatus != null) 'domainStatus': domainStatus!,
        if (domains != null) 'domains': domains!,
        if (status != null) 'status': status!,
      };
}

/// Configuration and status of a self-managed SSL certificate.
class SslCertificateSelfManagedSslCertificate {
  /// A local certificate file.
  ///
  /// The certificate must be in PEM format. The certificate chain must be no
  /// greater than 5 certs long. The chain must include at least one
  /// intermediate cert.
  core.String? certificate;

  /// A write-only private key in PEM format.
  ///
  /// Only insert requests will include this field.
  core.String? privateKey;

  SslCertificateSelfManagedSslCertificate({
    this.certificate,
    this.privateKey,
  });

  SslCertificateSelfManagedSslCertificate.fromJson(core.Map _json)
      : this(
          certificate: _json.containsKey('certificate')
              ? _json['certificate'] as core.String
              : null,
          privateKey: _json.containsKey('privateKey')
              ? _json['privateKey'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (certificate != null) 'certificate': certificate!,
        if (privateKey != null) 'privateKey': privateKey!,
      };
}

class SslCertificatesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslCertificatesScopedListWarningData({
    this.key,
    this.value,
  });

  SslCertificatesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class SslCertificatesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslCertificatesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslCertificatesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  SslCertificatesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SslCertificatesScopedListWarningData>((value) =>
                      SslCertificatesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SslCertificatesScopedList {
  /// List of SslCertificates contained in this scope.
  core.List<SslCertificate>? sslCertificates;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  SslCertificatesScopedListWarning? warning;

  SslCertificatesScopedList({
    this.sslCertificates,
    this.warning,
  });

  SslCertificatesScopedList.fromJson(core.Map _json)
      : this(
          sslCertificates: _json.containsKey('sslCertificates')
              ? (_json['sslCertificates'] as core.List)
                  .map<SslCertificate>((value) => SslCertificate.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? SslCertificatesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslCertificates != null)
          'sslCertificates':
              sslCertificates!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SslPoliciesListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslPoliciesListWarningData({
    this.key,
    this.value,
  });

  SslPoliciesListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SslPoliciesListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslPoliciesListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslPoliciesListWarning({
    this.code,
    this.data,
    this.message,
  });

  SslPoliciesListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SslPoliciesListWarningData>((value) =>
                      SslPoliciesListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SslPoliciesList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SslPolicy resources.
  core.List<SslPolicy>? items;

  /// Type of the resource.
  ///
  /// Always compute#sslPoliciesList for lists of sslPolicies.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  SslPoliciesListWarning? warning;

  SslPoliciesList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  SslPoliciesList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<SslPolicy>((value) => SslPolicy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? SslPoliciesListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SslPoliciesListAvailableFeaturesResponse {
  core.List<core.String>? features;

  SslPoliciesListAvailableFeaturesResponse({
    this.features,
  });

  SslPoliciesListAvailableFeaturesResponse.fromJson(core.Map _json)
      : this(
          features: _json.containsKey('features')
              ? (_json['features'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (features != null) 'features': features!,
      };
}

class SslPolicyWarningsData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslPolicyWarningsData({
    this.key,
    this.value,
  });

  SslPolicyWarningsData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

class SslPolicyWarnings {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslPolicyWarningsData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslPolicyWarnings({
    this.code,
    this.data,
    this.message,
  });

  SslPolicyWarnings.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SslPolicyWarningsData>((value) =>
                      SslPolicyWarningsData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Represents an SSL Policy resource.
///
/// Use SSL policies to control the SSL features, such as versions and cipher
/// suites, offered by an HTTPS or SSL Proxy load balancer. For more
/// information, read SSL Policy Concepts.
class SslPolicy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// A list of features enabled when the selected profile is CUSTOM.
  ///
  /// The method returns the set of features that can be specified in this list.
  /// This field must be empty if the profile is not CUSTOM.
  core.List<core.String>? customFeatures;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The list of features enabled in the SSL policy.
  ///
  /// Output only.
  core.List<core.String>? enabledFeatures;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a SslPolicy.
  /// An up-to-date fingerprint must be provided in order to update the
  /// SslPolicy, otherwise the request will fail with error 412 conditionNotMet.
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// SslPolicy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#sslPolicyfor SSL policies.
  ///
  /// Output only.
  core.String? kind;

  /// The minimum version of SSL protocol that can be used by the clients to
  /// establish a connection with the load balancer.
  ///
  /// This can be one of TLS_1_0, TLS_1_1, TLS_1_2.
  /// Possible string values are:
  /// - "TLS_1_0" : TLS 1.0
  /// - "TLS_1_1" : TLS 1.1
  /// - "TLS_1_2" : TLS 1.2
  core.String? minTlsVersion;

  /// Name of the resource.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Profile specifies the set of SSL features that can be used by the load
  /// balancer when negotiating SSL with clients.
  ///
  /// This can be one of COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using
  /// CUSTOM, the set of SSL features to enable must be specified in the
  /// customFeatures field.
  /// Possible string values are:
  /// - "COMPATIBLE" : Compatible profile. Allows the broadset set of clients,
  /// even those which support only out-of-date SSL features to negotiate with
  /// the load balancer.
  /// - "CUSTOM" : Custom profile. Allow only the set of allowed SSL features
  /// specified in the customFeatures field.
  /// - "MODERN" : Modern profile. Supports a wide set of SSL features, allowing
  /// modern clients to negotiate SSL with the load balancer.
  /// - "RESTRICTED" : Restricted profile. Supports a reduced set of SSL
  /// features, intended to meet stricter compliance requirements.
  core.String? profile;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// If potential misconfigurations are detected for this SSL policy, this
  /// field will be populated with warning messages.
  ///
  /// Output only.
  core.List<SslPolicyWarnings>? warnings;

  SslPolicy({
    this.creationTimestamp,
    this.customFeatures,
    this.description,
    this.enabledFeatures,
    this.fingerprint,
    this.id,
    this.kind,
    this.minTlsVersion,
    this.name,
    this.profile,
    this.selfLink,
    this.warnings,
  });

  SslPolicy.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          customFeatures: _json.containsKey('customFeatures')
              ? (_json['customFeatures'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          enabledFeatures: _json.containsKey('enabledFeatures')
              ? (_json['enabledFeatures'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          minTlsVersion: _json.containsKey('minTlsVersion')
              ? _json['minTlsVersion'] as core.String
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          profile: _json.containsKey('profile')
              ? _json['profile'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warnings: _json.containsKey('warnings')
              ? (_json['warnings'] as core.List)
                  .map<SslPolicyWarnings>((value) => SslPolicyWarnings.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customFeatures != null) 'customFeatures': customFeatures!,
        if (description != null) 'description': description!,
        if (enabledFeatures != null) 'enabledFeatures': enabledFeatures!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (minTlsVersion != null) 'minTlsVersion': minTlsVersion!,
        if (name != null) 'name': name!,
        if (profile != null) 'profile': profile!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warnings != null)
          'warnings': warnings!.map((value) => value.toJson()).toList(),
      };
}

class SslPolicyReference {
  /// URL of the SSL policy resource.
  ///
  /// Set this to empty string to clear any existing SSL policy associated with
  /// the target proxy resource.
  core.String? sslPolicy;

  SslPolicyReference({
    this.sslPolicy,
  });

  SslPolicyReference.fromJson(core.Map _json)
      : this(
          sslPolicy: _json.containsKey('sslPolicy')
              ? _json['sslPolicy'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslPolicy != null) 'sslPolicy': sslPolicy!,
      };
}

class StatefulPolicy {
  StatefulPolicyPreservedState? preservedState;

  StatefulPolicy({
    this.preservedState,
  });

  StatefulPolicy.fromJson(core.Map _json)
      : this(
          preservedState: _json.containsKey('preservedState')
              ? StatefulPolicyPreservedState.fromJson(_json['preservedState']
                  as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (preservedState != null) 'preservedState': preservedState!.toJson(),
      };
}

/// Configuration of preserved resources.
class StatefulPolicyPreservedState {
  /// Disks created on the instances that will be preserved on instance delete,
  /// update, etc.
  ///
  /// This map is keyed with the device names of the disks.
  core.Map<core.String, StatefulPolicyPreservedStateDiskDevice>? disks;

  StatefulPolicyPreservedState({
    this.disks,
  });

  StatefulPolicyPreservedState.fromJson(core.Map _json)
      : this(
          disks: _json.containsKey('disks')
              ? (_json['disks'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    StatefulPolicyPreservedStateDiskDevice.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disks != null)
          'disks': disks!.map((key, item) => core.MapEntry(key, item.toJson())),
      };
}

class StatefulPolicyPreservedStateDiskDevice {
  /// These stateful disks will never be deleted during autohealing, update or
  /// VM instance recreate operations.
  ///
  /// This flag is used to configure if the disk should be deleted after it is
  /// no longer used by the group, e.g. when the given instance or the whole
  /// group is deleted. Note: disks attached in READ_ONLY mode cannot be
  /// auto-deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String? autoDelete;

  StatefulPolicyPreservedStateDiskDevice({
    this.autoDelete,
  });

  StatefulPolicyPreservedStateDiskDevice.fromJson(core.Map _json)
      : this(
          autoDelete: _json.containsKey('autoDelete')
              ? _json['autoDelete'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoDelete != null) 'autoDelete': autoDelete!,
      };
}

/// Represents a Subnetwork resource.
///
/// A subnetwork (also known as a subnet) is a logical partition of a Virtual
/// Private Cloud network with one primary IP range and zero or more secondary
/// IP ranges. For more information, read Virtual Private Cloud (VPC) Network.
class Subnetwork {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource. This field can be set
  /// only at resource creation time.
  core.String? description;

  /// Whether to enable flow logging for this subnetwork.
  ///
  /// If this field is not explicitly set, it will not appear in get listings.
  /// If not set the default behavior is to disable flow logging. This field
  /// isn't supported with the purpose field set to
  /// INTERNAL_HTTPS_LOAD_BALANCER.
  core.bool? enableFlowLogs;

  /// The range of external IPv6 addresses that are owned by this subnetwork.
  ///
  /// Output only.
  core.String? externalIpv6Prefix;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// Subnetwork. An up-to-date fingerprint must be provided in order to update
  /// the Subnetwork, otherwise the request will fail with error 412
  /// conditionNotMet. To see the latest fingerprint, make a get() request to
  /// retrieve a Subnetwork.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The gateway address for default routes to reach destination addresses
  /// outside this subnetwork.
  ///
  /// Output only.
  core.String? gatewayAddress;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The range of internal addresses that are owned by this subnetwork.
  ///
  /// Provide this property when you create the subnetwork. For example,
  /// 10.0.0.0/8 or 100.64.0.0/10. Ranges must be unique and non-overlapping
  /// within a network. Only IPv4 is supported. This field is set at resource
  /// creation time. The range can be any range listed in the Valid ranges list.
  /// The range can be expanded after creation using expandIpCidrRange.
  core.String? ipCidrRange;

  /// The access type of IPv6 address this subnet holds.
  ///
  /// It's immutable and can only be specified during creation or the first time
  /// the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is
  /// EXTERNAL then this subnet cannot enable direct path.
  /// Possible string values are:
  /// - "EXTERNAL" : VMs on this subnet will be assigned IPv6 addresses that are
  /// accesible via the Internet, as well as the VPC network.
  /// - "UNSPECIFIED_IPV6_ACCESS_TYPE" : IPv6 access type not set. Means this
  /// subnet hasn't been turned on IPv6 yet.
  core.String? ipv6AccessType;

  /// The range of internal IPv6 addresses that are owned by this subnetwork.
  ///
  /// Output only.
  core.String? ipv6CidrRange;

  /// Type of the resource.
  ///
  /// Always compute#subnetwork for Subnetwork resources.
  ///
  /// Output only.
  core.String? kind;

  /// This field denotes the VPC flow logging options for this subnetwork.
  ///
  /// If logging is enabled, logs are exported to Cloud Logging.
  SubnetworkLogConfig? logConfig;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The URL of the network to which this subnetwork belongs, provided by the
  /// client when initially creating the subnetwork.
  ///
  /// Only networks that are in the distributed mode can have subnetworks. This
  /// field can be set only at resource creation time.
  core.String? network;

  /// Whether the VMs in this subnet can access Google services without assigned
  /// external IP addresses.
  ///
  /// This field can be both set at resource creation time and updated using
  /// setPrivateIpGoogleAccess.
  core.bool? privateIpGoogleAccess;

  /// The private IPv6 google access type for the VMs in this subnet.
  ///
  /// This is an expanded field of enablePrivateV6Access. If both fields are
  /// set, privateIpv6GoogleAccess will take priority. This field can be both
  /// set at resource creation time and updated using patch.
  /// Possible string values are:
  /// - "DISABLE_GOOGLE_ACCESS" : Disable private IPv6 access to/from Google
  /// services.
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" : Bidirectional private IPv6
  /// access to/from Google services.
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" : Outbound private IPv6 access
  /// from VMs in this subnet to Google services.
  core.String? privateIpv6GoogleAccess;

  /// The purpose of the resource.
  ///
  /// This field can be either PRIVATE_RFC_1918 or INTERNAL_HTTPS_LOAD_BALANCER.
  /// A subnetwork with purpose set to INTERNAL_HTTPS_LOAD_BALANCER is a
  /// user-created subnetwork that is reserved for Internal HTTP(S) Load
  /// Balancing. If unspecified, the purpose defaults to PRIVATE_RFC_1918. The
  /// enableFlowLogs field isn't supported with the purpose field set to
  /// INTERNAL_HTTPS_LOAD_BALANCER.
  /// Possible string values are:
  /// - "INTERNAL_HTTPS_LOAD_BALANCER" : Subnet reserved for Internal HTTP(S)
  /// Load Balancing.
  /// - "PRIVATE" : Regular user created or automatically created subnet.
  /// - "PRIVATE_RFC_1918" : Regular user created or automatically created
  /// subnet.
  /// - "PRIVATE_SERVICE_CONNECT" : Subnetworks created for Private Service
  /// Connect in the producer network.
  core.String? purpose;

  /// URL of the region where the Subnetwork resides.
  ///
  /// This field can be set only at resource creation time.
  core.String? region;

  /// The role of subnetwork.
  ///
  /// Currently, this field is only used when purpose =
  /// INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An
  /// ACTIVE subnetwork is one that is currently being used for Internal HTTP(S)
  /// Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to
  /// ACTIVE or is currently draining. This field can be updated with a patch
  /// request.
  /// Possible string values are:
  /// - "ACTIVE" : The ACTIVE subnet that is currently used.
  /// - "BACKUP" : The BACKUP subnet that could be promoted to ACTIVE.
  core.String? role;

  /// An array of configurations for secondary IP ranges for VM instances
  /// contained in this subnetwork.
  ///
  /// The primary IP of such VM must belong to the primary ipCidrRange of the
  /// subnetwork. The alias IPs may belong to either primary or secondary
  /// ranges. This field can be updated with a patch request.
  core.List<SubnetworkSecondaryRange>? secondaryIpRanges;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The stack type for this subnet to identify whether the IPv6 feature is
  /// enabled or not.
  ///
  /// If not specified IPV4_ONLY will be used. This field can be both set at
  /// resource creation time and updated using patch.
  /// Possible string values are:
  /// - "IPV4_IPV6" : New VMs in this subnet can have both IPv4 and IPv6
  /// addresses.
  /// - "IPV4_ONLY" : New VMs in this subnet will only be assigned IPv4
  /// addresses.
  /// - "UNSPECIFIED_STACK_TYPE"
  core.String? stackType;

  /// The state of the subnetwork, which can be one of the following values:
  /// READY: Subnetwork is created and ready to use DRAINING: only applicable to
  /// subnetworks that have the purpose set to INTERNAL_HTTPS_LOAD_BALANCER and
  /// indicates that connections to the load balancer are being drained.
  ///
  /// A subnetwork that is draining cannot be used or modified until it reaches
  /// a status of READY
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DRAINING" : Subnetwork is being drained.
  /// - "READY" : Subnetwork is ready for use.
  core.String? state;

  Subnetwork({
    this.creationTimestamp,
    this.description,
    this.enableFlowLogs,
    this.externalIpv6Prefix,
    this.fingerprint,
    this.gatewayAddress,
    this.id,
    this.ipCidrRange,
    this.ipv6AccessType,
    this.ipv6CidrRange,
    this.kind,
    this.logConfig,
    this.name,
    this.network,
    this.privateIpGoogleAccess,
    this.privateIpv6GoogleAccess,
    this.purpose,
    this.region,
    this.role,
    this.secondaryIpRanges,
    this.selfLink,
    this.stackType,
    this.state,
  });

  Subnetwork.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          enableFlowLogs: _json.containsKey('enableFlowLogs')
              ? _json['enableFlowLogs'] as core.bool
              : null,
          externalIpv6Prefix: _json.containsKey('externalIpv6Prefix')
              ? _json['externalIpv6Prefix'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          gatewayAddress: _json.containsKey('gatewayAddress')
              ? _json['gatewayAddress'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
          ipv6AccessType: _json.containsKey('ipv6AccessType')
              ? _json['ipv6AccessType'] as core.String
              : null,
          ipv6CidrRange: _json.containsKey('ipv6CidrRange')
              ? _json['ipv6CidrRange'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          logConfig: _json.containsKey('logConfig')
              ? SubnetworkLogConfig.fromJson(
                  _json['logConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          privateIpGoogleAccess: _json.containsKey('privateIpGoogleAccess')
              ? _json['privateIpGoogleAccess'] as core.bool
              : null,
          privateIpv6GoogleAccess: _json.containsKey('privateIpv6GoogleAccess')
              ? _json['privateIpv6GoogleAccess'] as core.String
              : null,
          purpose: _json.containsKey('purpose')
              ? _json['purpose'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          role: _json.containsKey('role') ? _json['role'] as core.String : null,
          secondaryIpRanges: _json.containsKey('secondaryIpRanges')
              ? (_json['secondaryIpRanges'] as core.List)
                  .map<SubnetworkSecondaryRange>((value) =>
                      SubnetworkSecondaryRange.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          stackType: _json.containsKey('stackType')
              ? _json['stackType'] as core.String
              : null,
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (enableFlowLogs != null) 'enableFlowLogs': enableFlowLogs!,
        if (externalIpv6Prefix != null)
          'externalIpv6Prefix': externalIpv6Prefix!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (gatewayAddress != null) 'gatewayAddress': gatewayAddress!,
        if (id != null) 'id': id!,
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (ipv6AccessType != null) 'ipv6AccessType': ipv6AccessType!,
        if (ipv6CidrRange != null) 'ipv6CidrRange': ipv6CidrRange!,
        if (kind != null) 'kind': kind!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (privateIpGoogleAccess != null)
          'privateIpGoogleAccess': privateIpGoogleAccess!,
        if (privateIpv6GoogleAccess != null)
          'privateIpv6GoogleAccess': privateIpv6GoogleAccess!,
        if (purpose != null) 'purpose': purpose!,
        if (region != null) 'region': region!,
        if (role != null) 'role': role!,
        if (secondaryIpRanges != null)
          'secondaryIpRanges':
              secondaryIpRanges!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (stackType != null) 'stackType': stackType!,
        if (state != null) 'state': state!,
      };
}

class SubnetworkAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SubnetworkAggregatedListWarningData({
    this.key,
    this.value,
  });

  SubnetworkAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SubnetworkAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SubnetworkAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SubnetworkAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  SubnetworkAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SubnetworkAggregatedListWarningData>((value) =>
                      SubnetworkAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SubnetworkAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SubnetworksScopedList resources.
  core.Map<core.String, SubnetworksScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#subnetworkAggregatedList for aggregated lists of
  /// subnetworks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  SubnetworkAggregatedListWarning? warning;

  SubnetworkAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  SubnetworkAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    SubnetworksScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? SubnetworkAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SubnetworkListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SubnetworkListWarningData({
    this.key,
    this.value,
  });

  SubnetworkListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SubnetworkListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SubnetworkListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SubnetworkListWarning({
    this.code,
    this.data,
    this.message,
  });

  SubnetworkListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SubnetworkListWarningData>((value) =>
                      SubnetworkListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Subnetwork resources.
class SubnetworkList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Subnetwork resources.
  core.List<Subnetwork>? items;

  /// Type of resource.
  ///
  /// Always compute#subnetworkList for lists of subnetworks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  SubnetworkListWarning? warning;

  SubnetworkList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  SubnetworkList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Subnetwork>((value) => Subnetwork.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? SubnetworkListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The available logging options for this subnetwork.
class SubnetworkLogConfig {
  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  ///
  /// Toggles the aggregation interval for collecting flow logs. Increasing the
  /// interval time will reduce the amount of generated flow logs for long
  /// lasting connections. Default is an interval of 5 seconds per connection.
  /// Possible string values are:
  /// - "INTERVAL_10_MIN"
  /// - "INTERVAL_15_MIN"
  /// - "INTERVAL_1_MIN"
  /// - "INTERVAL_30_SEC"
  /// - "INTERVAL_5_MIN"
  /// - "INTERVAL_5_SEC"
  core.String? aggregationInterval;

  /// Whether to enable flow logging for this subnetwork.
  ///
  /// If this field is not explicitly set, it will not appear in get listings.
  /// If not set the default behavior is to disable flow logging.
  core.bool? enable;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  ///
  /// Export filter used to define which VPC flow logs should be logged.
  core.String? filterExpr;

  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  ///
  /// The value of the field must be in \[0, 1\]. Set the sampling rate of VPC
  /// flow logs within the subnetwork where 1.0 means all collected logs are
  /// reported and 0.0 means no logs are reported. Default is 0.5, which means
  /// half of all collected logs are reported.
  core.double? flowSampling;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  ///
  /// Configures whether all, none or a subset of metadata fields should be
  /// added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
  /// Possible string values are:
  /// - "CUSTOM_METADATA"
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String? metadata;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled and
  /// "metadata" was set to CUSTOM_METADATA.
  core.List<core.String>? metadataFields;

  SubnetworkLogConfig({
    this.aggregationInterval,
    this.enable,
    this.filterExpr,
    this.flowSampling,
    this.metadata,
    this.metadataFields,
  });

  SubnetworkLogConfig.fromJson(core.Map _json)
      : this(
          aggregationInterval: _json.containsKey('aggregationInterval')
              ? _json['aggregationInterval'] as core.String
              : null,
          enable:
              _json.containsKey('enable') ? _json['enable'] as core.bool : null,
          filterExpr: _json.containsKey('filterExpr')
              ? _json['filterExpr'] as core.String
              : null,
          flowSampling: _json.containsKey('flowSampling')
              ? (_json['flowSampling'] as core.num).toDouble()
              : null,
          metadata: _json.containsKey('metadata')
              ? _json['metadata'] as core.String
              : null,
          metadataFields: _json.containsKey('metadataFields')
              ? (_json['metadataFields'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (aggregationInterval != null)
          'aggregationInterval': aggregationInterval!,
        if (enable != null) 'enable': enable!,
        if (filterExpr != null) 'filterExpr': filterExpr!,
        if (flowSampling != null) 'flowSampling': flowSampling!,
        if (metadata != null) 'metadata': metadata!,
        if (metadataFields != null) 'metadataFields': metadataFields!,
      };
}

/// Represents a secondary IP range of a subnetwork.
class SubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  ///
  /// Provide this property when you create the subnetwork. Ranges must be
  /// unique and non-overlapping with all primary and secondary IP ranges within
  /// a network. Only IPv4 is supported. The range can be any range listed in
  /// the Valid ranges list.
  core.String? ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035. The name
  /// must be unique within the subnetwork.
  core.String? rangeName;

  SubnetworkSecondaryRange({
    this.ipCidrRange,
    this.rangeName,
  });

  SubnetworkSecondaryRange.fromJson(core.Map _json)
      : this(
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
          rangeName: _json.containsKey('rangeName')
              ? _json['rangeName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (rangeName != null) 'rangeName': rangeName!,
      };
}

class SubnetworksExpandIpCidrRangeRequest {
  /// The IP (in CIDR format or netmask) of internal addresses that are legal on
  /// this Subnetwork.
  ///
  /// This range should be disjoint from other subnetworks within this network.
  /// This range can only be larger than (i.e. a superset of) the range
  /// previously defined before the update.
  core.String? ipCidrRange;

  SubnetworksExpandIpCidrRangeRequest({
    this.ipCidrRange,
  });

  SubnetworksExpandIpCidrRangeRequest.fromJson(core.Map _json)
      : this(
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
      };
}

class SubnetworksScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SubnetworksScopedListWarningData({
    this.key,
    this.value,
  });

  SubnetworksScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the list of addresses is empty.
class SubnetworksScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SubnetworksScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SubnetworksScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  SubnetworksScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<SubnetworksScopedListWarningData>((value) =>
                      SubnetworksScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SubnetworksScopedList {
  /// A list of subnetworks contained in this scope.
  core.List<Subnetwork>? subnetworks;

  /// An informational warning that appears when the list of addresses is empty.
  SubnetworksScopedListWarning? warning;

  SubnetworksScopedList({
    this.subnetworks,
    this.warning,
  });

  SubnetworksScopedList.fromJson(core.Map _json)
      : this(
          subnetworks: _json.containsKey('subnetworks')
              ? (_json['subnetworks'] as core.List)
                  .map<Subnetwork>((value) => Subnetwork.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? SubnetworksScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (subnetworks != null)
          'subnetworks': subnetworks!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SubnetworksSetPrivateIpGoogleAccessRequest {
  core.bool? privateIpGoogleAccess;

  SubnetworksSetPrivateIpGoogleAccessRequest({
    this.privateIpGoogleAccess,
  });

  SubnetworksSetPrivateIpGoogleAccessRequest.fromJson(core.Map _json)
      : this(
          privateIpGoogleAccess: _json.containsKey('privateIpGoogleAccess')
              ? _json['privateIpGoogleAccess'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (privateIpGoogleAccess != null)
          'privateIpGoogleAccess': privateIpGoogleAccess!,
      };
}

class TCPHealthCheck {
  /// The TCP port number for the health check request.
  ///
  /// The default value is 80. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values: USE_FIXED_PORT: The port number in port is used for
  /// health checking.
  ///
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking. If not specified, TCP health check follows behavior specified in
  /// port and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in port is used for health checking.
  /// - "USE_NAMED_PORT" : The portName is used for health checking.
  /// - "USE_SERVING_PORT" : For NetworkEndpointGroup, the port specified for
  /// each network endpoint is used for health checking. For other backends, the
  /// port or named port specified in the Backend Service is used for health
  /// checking.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The application data to send once the TCP connection has been established
  /// (default value is empty).
  ///
  /// If both request and response are empty, the connection establishment alone
  /// will indicate health. The request data can only be ASCII.
  core.String? request;

  /// The bytes to match against the beginning of the response data.
  ///
  /// If left empty (the default value), any response will indicate health. The
  /// response data can only be ASCII.
  core.String? response;

  TCPHealthCheck({
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.request,
    this.response,
  });

  TCPHealthCheck.fromJson(core.Map _json)
      : this(
          port: _json.containsKey('port') ? _json['port'] as core.int : null,
          portName: _json.containsKey('portName')
              ? _json['portName'] as core.String
              : null,
          portSpecification: _json.containsKey('portSpecification')
              ? _json['portSpecification'] as core.String
              : null,
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
          request: _json.containsKey('request')
              ? _json['request'] as core.String
              : null,
          response: _json.containsKey('response')
              ? _json['response'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (request != null) 'request': request!,
        if (response != null) 'response': response!,
      };
}

/// A set of instance tags.
class Tags {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the tags' contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update tags. You must always provide an
  /// up-to-date fingerprint hash in order to update or change tags. To see the
  /// latest fingerprint, make get() request to the instance.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// An array of tags.
  ///
  /// Each tag must be 1-63 characters long, and comply with RFC1035.
  core.List<core.String>? items;

  Tags({
    this.fingerprint,
    this.items,
  });

  Tags.fromJson(core.Map _json)
      : this(
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (items != null) 'items': items!,
      };
}

/// Represents a Target gRPC Proxy resource.
///
/// A target gRPC proxy is a component of load balancers intended for load
/// balancing gRPC traffic. Only global forwarding rules with load balancing
/// scheme INTERNAL_SELF_MANAGED can reference a target gRPC proxy. The target
/// gRPC Proxy references a URL map that specifies how traffic is routed to gRPC
/// backend services.
class TargetGrpcProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// TargetGrpcProxy. An up-to-date fingerprint must be provided in order to
  /// patch/update the TargetGrpcProxy; otherwise, the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve the TargetGrpcProxy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetGrpcProxy for target grpc proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Server-defined URL with id for the resource.
  ///
  /// Output only.
  core.String? selfLinkWithId;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService.
  ///
  /// The protocol field in the BackendService must be set to GRPC.
  core.String? urlMap;

  /// If true, indicates that the BackendServices referenced by the urlMap may
  /// be accessed by gRPC applications without using a sidecar proxy.
  ///
  /// This will enable configuration checks on urlMap and its referenced
  /// BackendServices to not allow unsupported features. A gRPC application must
  /// use "xds:///" scheme in the target URI of the service it is connecting to.
  /// If false, indicates that the BackendServices referenced by the urlMap will
  /// be accessed by gRPC applications via a sidecar proxy. In this case, a gRPC
  /// application must not use "xds:///" scheme in the target URI of the service
  /// it is connecting to
  core.bool? validateForProxyless;

  TargetGrpcProxy({
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.selfLink,
    this.selfLinkWithId,
    this.urlMap,
    this.validateForProxyless,
  });

  TargetGrpcProxy.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          selfLinkWithId: _json.containsKey('selfLinkWithId')
              ? _json['selfLinkWithId'] as core.String
              : null,
          urlMap: _json.containsKey('urlMap')
              ? _json['urlMap'] as core.String
              : null,
          validateForProxyless: _json.containsKey('validateForProxyless')
              ? _json['validateForProxyless'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (selfLinkWithId != null) 'selfLinkWithId': selfLinkWithId!,
        if (urlMap != null) 'urlMap': urlMap!,
        if (validateForProxyless != null)
          'validateForProxyless': validateForProxyless!,
      };
}

class TargetGrpcProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetGrpcProxyListWarningData({
    this.key,
    this.value,
  });

  TargetGrpcProxyListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetGrpcProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetGrpcProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetGrpcProxyListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetGrpcProxyListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetGrpcProxyListWarningData>((value) =>
                      TargetGrpcProxyListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetGrpcProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetGrpcProxy resources.
  core.List<TargetGrpcProxy>? items;

  /// Type of the resource.
  ///
  /// Always compute#targetGrpcProxy for target grpc proxies.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetGrpcProxyListWarning? warning;

  TargetGrpcProxyList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  TargetGrpcProxyList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<TargetGrpcProxy>((value) => TargetGrpcProxy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? TargetGrpcProxyListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetHttpProxiesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpProxiesScopedListWarningData({
    this.key,
    this.value,
  });

  TargetHttpProxiesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class TargetHttpProxiesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpProxiesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpProxiesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetHttpProxiesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetHttpProxiesScopedListWarningData>((value) =>
                      TargetHttpProxiesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetHttpProxiesScopedList {
  /// A list of TargetHttpProxies contained in this scope.
  core.List<TargetHttpProxy>? targetHttpProxies;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  TargetHttpProxiesScopedListWarning? warning;

  TargetHttpProxiesScopedList({
    this.targetHttpProxies,
    this.warning,
  });

  TargetHttpProxiesScopedList.fromJson(core.Map _json)
      : this(
          targetHttpProxies: _json.containsKey('targetHttpProxies')
              ? (_json['targetHttpProxies'] as core.List)
                  .map<TargetHttpProxy>((value) => TargetHttpProxy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetHttpProxiesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetHttpProxies != null)
          'targetHttpProxies':
              targetHttpProxies!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Target HTTP Proxy resource.
///
/// Google Compute Engine has two Target HTTP Proxy resources: *
/// \[Global\](/compute/docs/reference/rest/v1/targetHttpProxies) *
/// \[Regional\](/compute/docs/reference/rest/v1/regionTargetHttpProxies) A
/// target HTTP proxy is a component of GCP HTTP load balancers. *
/// targetHttpProxies are used by external HTTP load balancers and Traffic
/// Director. * regionTargetHttpProxies are used by internal HTTP load
/// balancers. Forwarding rules reference a target HTTP proxy, and the target
/// proxy then references a URL map. For more information, read Using Target
/// Proxies and Forwarding rule concepts.
class TargetHttpProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// TargetHttpProxy. An up-to-date fingerprint must be provided in order to
  /// patch/update the TargetHttpProxy; otherwise, the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve the TargetHttpProxy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#targetHttpProxy for target HTTP proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// This field only applies when the forwarding rule that references this
  /// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  ///
  /// When this field is set to true, Envoy proxies set up inbound traffic
  /// interception and bind to the IP address and port specified in the
  /// forwarding rule. This is generally useful when using Traffic Director to
  /// configure Envoy as a gateway or middle proxy (in other words, not a
  /// sidecar proxy). The Envoy proxy listens for inbound requests and handles
  /// requests when it receives them. The default is false.
  core.bool? proxyBind;

  /// URL of the region where the regional Target HTTP Proxy resides.
  ///
  /// This field is not applicable to global Target HTTP Proxies.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService.
  core.String? urlMap;

  TargetHttpProxy({
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.proxyBind,
    this.region,
    this.selfLink,
    this.urlMap,
  });

  TargetHttpProxy.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          proxyBind: _json.containsKey('proxyBind')
              ? _json['proxyBind'] as core.bool
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          urlMap: _json.containsKey('urlMap')
              ? _json['urlMap'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (proxyBind != null) 'proxyBind': proxyBind!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (urlMap != null) 'urlMap': urlMap!,
      };
}

class TargetHttpProxyAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetHttpProxiesScopedList resources.
  core.Map<core.String, TargetHttpProxiesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#targetHttpProxyAggregatedList for lists of Target HTTP
  /// Proxies.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  TargetHttpProxyAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
  });

  TargetHttpProxyAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    TargetHttpProxiesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
      };
}

class TargetHttpProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpProxyListWarningData({
    this.key,
    this.value,
  });

  TargetHttpProxyListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetHttpProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpProxyListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetHttpProxyListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetHttpProxyListWarningData>((value) =>
                      TargetHttpProxyListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of TargetHttpProxy resources.
class TargetHttpProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetHttpProxy resources.
  core.List<TargetHttpProxy>? items;

  /// Type of resource.
  ///
  /// Always compute#targetHttpProxyList for lists of target HTTP proxies.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetHttpProxyListWarning? warning;

  TargetHttpProxyList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  TargetHttpProxyList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<TargetHttpProxy>((value) => TargetHttpProxy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? TargetHttpProxyListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetHttpsProxiesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpsProxiesScopedListWarningData({
    this.key,
    this.value,
  });

  TargetHttpsProxiesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class TargetHttpsProxiesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpsProxiesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpsProxiesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetHttpsProxiesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetHttpsProxiesScopedListWarningData>((value) =>
                      TargetHttpsProxiesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetHttpsProxiesScopedList {
  /// A list of TargetHttpsProxies contained in this scope.
  core.List<TargetHttpsProxy>? targetHttpsProxies;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  TargetHttpsProxiesScopedListWarning? warning;

  TargetHttpsProxiesScopedList({
    this.targetHttpsProxies,
    this.warning,
  });

  TargetHttpsProxiesScopedList.fromJson(core.Map _json)
      : this(
          targetHttpsProxies: _json.containsKey('targetHttpsProxies')
              ? (_json['targetHttpsProxies'] as core.List)
                  .map<TargetHttpsProxy>((value) => TargetHttpsProxy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetHttpsProxiesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetHttpsProxies != null)
          'targetHttpsProxies':
              targetHttpsProxies!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetHttpsProxiesSetQuicOverrideRequest {
  /// QUIC policy for the TargetHttpsProxy resource.
  /// Possible string values are:
  /// - "DISABLE" : The load balancer will not attempt to negotiate QUIC with
  /// clients.
  /// - "ENABLE" : The load balancer will attempt to negotiate QUIC with
  /// clients.
  /// - "NONE" : No overrides to the default QUIC policy. This option is
  /// implicit if no QUIC override has been specified in the request.
  core.String? quicOverride;

  TargetHttpsProxiesSetQuicOverrideRequest({
    this.quicOverride,
  });

  TargetHttpsProxiesSetQuicOverrideRequest.fromJson(core.Map _json)
      : this(
          quicOverride: _json.containsKey('quicOverride')
              ? _json['quicOverride'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (quicOverride != null) 'quicOverride': quicOverride!,
      };
}

class TargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates.
  core.List<core.String>? sslCertificates;

  TargetHttpsProxiesSetSslCertificatesRequest({
    this.sslCertificates,
  });

  TargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json)
      : this(
          sslCertificates: _json.containsKey('sslCertificates')
              ? (_json['sslCertificates'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
      };
}

/// Represents a Target HTTPS Proxy resource.
///
/// Google Compute Engine has two Target HTTPS Proxy resources: *
/// \[Global\](/compute/docs/reference/rest/v1/targetHttpsProxies) *
/// \[Regional\](/compute/docs/reference/rest/v1/regionTargetHttpsProxies) A
/// target HTTPS proxy is a component of GCP HTTPS load balancers. *
/// targetHttpsProxies are used by external HTTPS load balancers. *
/// regionTargetHttpsProxies are used by internal HTTPS load balancers.
/// Forwarding rules reference a target HTTPS proxy, and the target proxy then
/// references a URL map. For more information, read Using Target Proxies and
/// Forwarding rule concepts.
class TargetHttpsProxy {
  /// A URL referring to a networksecurity.AuthorizationPolicy resource that
  /// describes how the proxy should authorize inbound traffic.
  ///
  /// If left blank, access will not be restricted by an authorization policy.
  /// Refer to the AuthorizationPolicy resource for additional details.
  /// authorizationPolicy only applies to a global TargetHttpsProxy attached to
  /// globalForwardingRules with the loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED. Note: This field currently has no impact.
  ///
  /// Optional.
  core.String? authorizationPolicy;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// TargetHttpsProxy. An up-to-date fingerprint must be provided in order to
  /// patch the TargetHttpsProxy; otherwise, the request will fail with error
  /// 412 conditionNotMet. To see the latest fingerprint, make a get() request
  /// to retrieve the TargetHttpsProxy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#targetHttpsProxy for target HTTPS proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// This field only applies when the forwarding rule that references this
  /// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  ///
  /// When this field is set to true, Envoy proxies set up inbound traffic
  /// interception and bind to the IP address and port specified in the
  /// forwarding rule. This is generally useful when using Traffic Director to
  /// configure Envoy as a gateway or middle proxy (in other words, not a
  /// sidecar proxy). The Envoy proxy listens for inbound requests and handles
  /// requests when it receives them. The default is false.
  core.bool? proxyBind;

  /// Specifies the QUIC override policy for this TargetHttpsProxy resource.
  ///
  /// This setting determines whether the load balancer attempts to negotiate
  /// QUIC with clients. You can specify NONE, ENABLE, or DISABLE. - When
  /// quic-override is set to NONE, Google manages whether QUIC is used. - When
  /// quic-override is set to ENABLE, the load balancer uses QUIC when possible.
  /// - When quic-override is set to DISABLE, the load balancer doesn't use
  /// QUIC. - If the quic-override flag is not specified, NONE is implied.
  /// Possible string values are:
  /// - "DISABLE" : The load balancer will not attempt to negotiate QUIC with
  /// clients.
  /// - "ENABLE" : The load balancer will attempt to negotiate QUIC with
  /// clients.
  /// - "NONE" : No overrides to the default QUIC policy. This option is
  /// implicit if no QUIC override has been specified in the request.
  core.String? quicOverride;

  /// URL of the region where the regional TargetHttpsProxy resides.
  ///
  /// This field is not applicable to global TargetHttpsProxies.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// A URL referring to a networksecurity.ServerTlsPolicy resource that
  /// describes how the proxy should authenticate inbound traffic.
  ///
  /// serverTlsPolicy only applies to a global TargetHttpsProxy attached to
  /// globalForwardingRules with the loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED. If left blank, communications are not encrypted.
  /// Note: This field currently has no impact.
  ///
  /// Optional.
  core.String? serverTlsPolicy;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// between users and the load balancer.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates. sslCertificates do not apply when the load
  /// balancing scheme is set to INTERNAL_SELF_MANAGED.
  core.List<core.String>? sslCertificates;

  /// URL of SslPolicy resource that will be associated with the
  /// TargetHttpsProxy resource.
  ///
  /// If not set, the TargetHttpsProxy resource has no SSL policy configured.
  core.String? sslPolicy;

  /// A fully-qualified or valid partial URL to the UrlMap resource that defines
  /// the mapping from URL to the BackendService.
  ///
  /// For example, the following are all valid URLs for specifying a URL map: -
  /// https://www.googleapis.compute/v1/projects/project/global/urlMaps/ url-map
  /// - projects/project/global/urlMaps/url-map - global/urlMaps/url-map
  core.String? urlMap;

  TargetHttpsProxy({
    this.authorizationPolicy,
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.proxyBind,
    this.quicOverride,
    this.region,
    this.selfLink,
    this.serverTlsPolicy,
    this.sslCertificates,
    this.sslPolicy,
    this.urlMap,
  });

  TargetHttpsProxy.fromJson(core.Map _json)
      : this(
          authorizationPolicy: _json.containsKey('authorizationPolicy')
              ? _json['authorizationPolicy'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          proxyBind: _json.containsKey('proxyBind')
              ? _json['proxyBind'] as core.bool
              : null,
          quicOverride: _json.containsKey('quicOverride')
              ? _json['quicOverride'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          serverTlsPolicy: _json.containsKey('serverTlsPolicy')
              ? _json['serverTlsPolicy'] as core.String
              : null,
          sslCertificates: _json.containsKey('sslCertificates')
              ? (_json['sslCertificates'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          sslPolicy: _json.containsKey('sslPolicy')
              ? _json['sslPolicy'] as core.String
              : null,
          urlMap: _json.containsKey('urlMap')
              ? _json['urlMap'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (authorizationPolicy != null)
          'authorizationPolicy': authorizationPolicy!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (proxyBind != null) 'proxyBind': proxyBind!,
        if (quicOverride != null) 'quicOverride': quicOverride!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (serverTlsPolicy != null) 'serverTlsPolicy': serverTlsPolicy!,
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
        if (sslPolicy != null) 'sslPolicy': sslPolicy!,
        if (urlMap != null) 'urlMap': urlMap!,
      };
}

class TargetHttpsProxyAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpsProxyAggregatedListWarningData({
    this.key,
    this.value,
  });

  TargetHttpsProxyAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetHttpsProxyAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpsProxyAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpsProxyAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetHttpsProxyAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetHttpsProxyAggregatedListWarningData>((value) =>
                      TargetHttpsProxyAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetHttpsProxyAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetHttpsProxiesScopedList resources.
  core.Map<core.String, TargetHttpsProxiesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#targetHttpsProxyAggregatedList for lists of Target HTTP
  /// Proxies.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  TargetHttpsProxyAggregatedListWarning? warning;

  TargetHttpsProxyAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  TargetHttpsProxyAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    TargetHttpsProxiesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetHttpsProxyAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetHttpsProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpsProxyListWarningData({
    this.key,
    this.value,
  });

  TargetHttpsProxyListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetHttpsProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpsProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpsProxyListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetHttpsProxyListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetHttpsProxyListWarningData>((value) =>
                      TargetHttpsProxyListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetHttpsProxy resources.
class TargetHttpsProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetHttpsProxy resources.
  core.List<TargetHttpsProxy>? items;

  /// Type of resource.
  ///
  /// Always compute#targetHttpsProxyList for lists of target HTTPS proxies.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetHttpsProxyListWarning? warning;

  TargetHttpsProxyList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  TargetHttpsProxyList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<TargetHttpsProxy>((value) => TargetHttpsProxy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? TargetHttpsProxyListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Target Instance resource.
///
/// You can use a target instance to handle traffic for one or more forwarding
/// rules, which is ideal for forwarding protocol traffic that is managed by a
/// single source. For example, ESP, AH, TCP, or UDP. For more information, read
/// Target instances.
class TargetInstance {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A URL to the virtual machine instance that handles traffic for this target
  /// instance.
  ///
  /// When creating a target instance, you can provide the fully-qualified URL
  /// or a valid partial URL to the desired virtual machine. For example, the
  /// following are all valid URLs: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /instances/instance - projects/project/zones/zone/instances/instance -
  /// zones/zone/instances/instance
  core.String? instance;

  /// The type of the resource.
  ///
  /// Always compute#targetInstance for target instances.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// NAT option controlling how IPs are NAT'ed to the instance.
  ///
  /// Currently only NO_NAT (default value) is supported.
  /// Possible string values are:
  /// - "NO_NAT" : No NAT performed.
  core.String? natPolicy;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL of the zone where the target instance resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  TargetInstance({
    this.creationTimestamp,
    this.description,
    this.id,
    this.instance,
    this.kind,
    this.name,
    this.natPolicy,
    this.selfLink,
    this.zone,
  });

  TargetInstance.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          instance: _json.containsKey('instance')
              ? _json['instance'] as core.String
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          natPolicy: _json.containsKey('natPolicy')
              ? _json['natPolicy'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          zone: _json.containsKey('zone') ? _json['zone'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (instance != null) 'instance': instance!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (natPolicy != null) 'natPolicy': natPolicy!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (zone != null) 'zone': zone!,
      };
}

class TargetInstanceAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetInstanceAggregatedListWarningData({
    this.key,
    this.value,
  });

  TargetInstanceAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetInstanceAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetInstanceAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetInstanceAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetInstanceAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetInstanceAggregatedListWarningData>((value) =>
                      TargetInstanceAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetInstanceAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetInstance resources.
  core.Map<core.String, TargetInstancesScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  TargetInstanceAggregatedListWarning? warning;

  TargetInstanceAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  TargetInstanceAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    TargetInstancesScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetInstanceAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetInstanceListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetInstanceListWarningData({
    this.key,
    this.value,
  });

  TargetInstanceListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetInstanceListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetInstanceListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetInstanceListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetInstanceListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetInstanceListWarningData>((value) =>
                      TargetInstanceListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetInstance resources.
class TargetInstanceList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetInstance resources.
  core.List<TargetInstance>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetInstanceListWarning? warning;

  TargetInstanceList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  TargetInstanceList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<TargetInstance>((value) => TargetInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? TargetInstanceListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetInstancesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetInstancesScopedListWarningData({
    this.key,
    this.value,
  });

  TargetInstancesScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetInstancesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetInstancesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetInstancesScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetInstancesScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetInstancesScopedListWarningData>((value) =>
                      TargetInstancesScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetInstancesScopedList {
  /// A list of target instances contained in this scope.
  core.List<TargetInstance>? targetInstances;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetInstancesScopedListWarning? warning;

  TargetInstancesScopedList({
    this.targetInstances,
    this.warning,
  });

  TargetInstancesScopedList.fromJson(core.Map _json)
      : this(
          targetInstances: _json.containsKey('targetInstances')
              ? (_json['targetInstances'] as core.List)
                  .map<TargetInstance>((value) => TargetInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetInstancesScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetInstances != null)
          'targetInstances':
              targetInstances!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Target Pool resource.
///
/// Target pools are used for network TCP/UDP load balancing. A target pool
/// references member instances, an associated legacy HttpHealthCheck resource,
/// and, optionally, a backup target pool. For more information, read Using
/// target pools.
class TargetPool {
  /// The server-defined URL for the resource.
  ///
  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool, and its failoverRatio field is
  /// properly set to a value between \[0, 1\]. backupPool and failoverRatio
  /// together define the fallback behavior of the primary target pool: if the
  /// ratio of the healthy instances in the primary pool is at or below
  /// failoverRatio, traffic arriving at the load-balanced IP will be directed
  /// to the backup pool. In case where failoverRatio and backupPool are not
  /// set, or all the instances in the backup pool are unhealthy, the traffic
  /// will be directed back to the primary pool in the "force" mode, where
  /// traffic will be spread to the healthy instances with the best effort, or
  /// to all instances when no instance is healthy.
  core.String? backupPool;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool (i.e., not as a backup pool to some
  /// other target pool).
  ///
  /// The value of the field must be in \[0, 1\]. If set, backupPool must also
  /// be set. They together define the fallback behavior of the primary target
  /// pool: if the ratio of the healthy instances in the primary pool is at or
  /// below this number, traffic arriving at the load-balanced IP will be
  /// directed to the backup pool. In case where failoverRatio is not set or all
  /// the instances in the backup pool are unhealthy, the traffic will be
  /// directed back to the primary pool in the "force" mode, where traffic will
  /// be spread to the healthy instances with the best effort, or to all
  /// instances when no instance is healthy.
  core.double? failoverRatio;

  /// The URL of the HttpHealthCheck resource.
  ///
  /// A member instance in this pool is considered healthy if and only if the
  /// health checks pass. Only legacy HttpHealthChecks are supported. Only one
  /// health check may be specified.
  core.List<core.String>? healthChecks;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of resource URLs to the virtual machine instances serving this
  /// pool.
  ///
  /// They must live in zones contained in the same region as this pool.
  core.List<core.String>? instances;

  /// Type of the resource.
  ///
  /// Always compute#targetPool for target pools.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the region where the target pool resides.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Session affinity option, must be one of the following values: NONE:
  /// Connections from the same client IP may go to any instance in the pool.
  ///
  /// CLIENT_IP: Connections from the same client IP will go to the same
  /// instance in the pool while that instance remains healthy. CLIENT_IP_PROTO:
  /// Connections from the same client IP with the same IP protocol will go to
  /// the same instance in the pool while that instance remains healthy.
  /// Possible string values are:
  /// - "CLIENT_IP" : 2-tuple hash on packet's source and destination IP
  /// addresses. Connections from the same source IP address to the same
  /// destination IP address will be served by the same backend VM while that VM
  /// remains healthy.
  /// - "CLIENT_IP_NO_DESTINATION" : 1-tuple hash only on packet's source IP
  /// address. Connections from the same source IP address will be served by the
  /// same backend VM while that VM remains healthy. This option can only be
  /// used for Internal TCP/UDP Load Balancing.
  /// - "CLIENT_IP_PORT_PROTO" : 5-tuple hash on packet's source and destination
  /// IP addresses, IP protocol, and source and destination ports. Connections
  /// for the same IP protocol from the same source IP address and port to the
  /// same destination IP address and port will be served by the same backend VM
  /// while that VM remains healthy. This option cannot be used for HTTP(S) load
  /// balancing.
  /// - "CLIENT_IP_PROTO" : 3-tuple hash on packet's source and destination IP
  /// addresses, and IP protocol. Connections for the same IP protocol from the
  /// same source IP address to the same destination IP address will be served
  /// by the same backend VM while that VM remains healthy. This option cannot
  /// be used for HTTP(S) load balancing.
  /// - "GENERATED_COOKIE" : Hash based on a cookie generated by the L7
  /// loadbalancer. Only valid for HTTP(S) load balancing.
  /// - "HEADER_FIELD" : The hash is based on a user specified header field.
  /// - "HTTP_COOKIE" : The hash is based on a user provided cookie.
  /// - "NONE" : No session affinity. Connections from the same client IP may go
  /// to any instance in the pool.
  core.String? sessionAffinity;

  TargetPool({
    this.backupPool,
    this.creationTimestamp,
    this.description,
    this.failoverRatio,
    this.healthChecks,
    this.id,
    this.instances,
    this.kind,
    this.name,
    this.region,
    this.selfLink,
    this.sessionAffinity,
  });

  TargetPool.fromJson(core.Map _json)
      : this(
          backupPool: _json.containsKey('backupPool')
              ? _json['backupPool'] as core.String
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          failoverRatio: _json.containsKey('failoverRatio')
              ? (_json['failoverRatio'] as core.num).toDouble()
              : null,
          healthChecks: _json.containsKey('healthChecks')
              ? (_json['healthChecks'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          sessionAffinity: _json.containsKey('sessionAffinity')
              ? _json['sessionAffinity'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (backupPool != null) 'backupPool': backupPool!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (failoverRatio != null) 'failoverRatio': failoverRatio!,
        if (healthChecks != null) 'healthChecks': healthChecks!,
        if (id != null) 'id': id!,
        if (instances != null) 'instances': instances!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sessionAffinity != null) 'sessionAffinity': sessionAffinity!,
      };
}

class TargetPoolAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetPoolAggregatedListWarningData({
    this.key,
    this.value,
  });

  TargetPoolAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetPoolAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetPoolAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetPoolAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetPoolAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetPoolAggregatedListWarningData>((value) =>
                      TargetPoolAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetPoolAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetPool resources.
  core.Map<core.String, TargetPoolsScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#targetPoolAggregatedList for aggregated lists of target
  /// pools.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  TargetPoolAggregatedListWarning? warning;

  TargetPoolAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  TargetPoolAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    TargetPoolsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetPoolAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetPoolInstanceHealth {
  core.List<HealthStatus>? healthStatus;

  /// Type of resource.
  ///
  /// Always compute#targetPoolInstanceHealth when checking the health of an
  /// instance.
  ///
  /// Output only.
  core.String? kind;

  TargetPoolInstanceHealth({
    this.healthStatus,
    this.kind,
  });

  TargetPoolInstanceHealth.fromJson(core.Map _json)
      : this(
          healthStatus: _json.containsKey('healthStatus')
              ? (_json['healthStatus'] as core.List)
                  .map<HealthStatus>((value) => HealthStatus.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthStatus != null)
          'healthStatus': healthStatus!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
      };
}

class TargetPoolListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetPoolListWarningData({
    this.key,
    this.value,
  });

  TargetPoolListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetPoolListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetPoolListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetPoolListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetPoolListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetPoolListWarningData>((value) =>
                      TargetPoolListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetPool resources.
class TargetPoolList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetPool resources.
  core.List<TargetPool>? items;

  /// Type of resource.
  ///
  /// Always compute#targetPoolList for lists of target pools.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetPoolListWarning? warning;

  TargetPoolList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  TargetPoolList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<TargetPool>((value) => TargetPool.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? TargetPoolListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetPoolsAddHealthCheckRequest {
  /// The HttpHealthCheck to add to the target pool.
  core.List<HealthCheckReference>? healthChecks;

  TargetPoolsAddHealthCheckRequest({
    this.healthChecks,
  });

  TargetPoolsAddHealthCheckRequest.fromJson(core.Map _json)
      : this(
          healthChecks: _json.containsKey('healthChecks')
              ? (_json['healthChecks'] as core.List)
                  .map<HealthCheckReference>((value) =>
                      HealthCheckReference.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthChecks != null)
          'healthChecks': healthChecks!.map((value) => value.toJson()).toList(),
      };
}

class TargetPoolsAddInstanceRequest {
  /// A full or partial URL to an instance to add to this target pool.
  ///
  /// This can be a full or partial URL. For example, the following are valid
  /// URLs: -
  /// https://www.googleapis.com/compute/v1/projects/project-id/zones/zone
  /// /instances/instance-name -
  /// projects/project-id/zones/zone/instances/instance-name -
  /// zones/zone/instances/instance-name
  core.List<InstanceReference>? instances;

  TargetPoolsAddInstanceRequest({
    this.instances,
  });

  TargetPoolsAddInstanceRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<InstanceReference>((value) => InstanceReference.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class TargetPoolsRemoveHealthCheckRequest {
  /// Health check URL to be removed.
  ///
  /// This can be a full or valid partial URL. For example, the following are
  /// valid URLs: - https://www.googleapis.com/compute/beta/projects/project
  /// /global/httpHealthChecks/health-check -
  /// projects/project/global/httpHealthChecks/health-check -
  /// global/httpHealthChecks/health-check
  core.List<HealthCheckReference>? healthChecks;

  TargetPoolsRemoveHealthCheckRequest({
    this.healthChecks,
  });

  TargetPoolsRemoveHealthCheckRequest.fromJson(core.Map _json)
      : this(
          healthChecks: _json.containsKey('healthChecks')
              ? (_json['healthChecks'] as core.List)
                  .map<HealthCheckReference>((value) =>
                      HealthCheckReference.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthChecks != null)
          'healthChecks': healthChecks!.map((value) => value.toJson()).toList(),
      };
}

class TargetPoolsRemoveInstanceRequest {
  /// URLs of the instances to be removed from target pool.
  core.List<InstanceReference>? instances;

  TargetPoolsRemoveInstanceRequest({
    this.instances,
  });

  TargetPoolsRemoveInstanceRequest.fromJson(core.Map _json)
      : this(
          instances: _json.containsKey('instances')
              ? (_json['instances'] as core.List)
                  .map<InstanceReference>((value) => InstanceReference.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class TargetPoolsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetPoolsScopedListWarningData({
    this.key,
    this.value,
  });

  TargetPoolsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetPoolsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetPoolsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetPoolsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetPoolsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetPoolsScopedListWarningData>((value) =>
                      TargetPoolsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetPoolsScopedList {
  /// A list of target pools contained in this scope.
  core.List<TargetPool>? targetPools;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetPoolsScopedListWarning? warning;

  TargetPoolsScopedList({
    this.targetPools,
    this.warning,
  });

  TargetPoolsScopedList.fromJson(core.Map _json)
      : this(
          targetPools: _json.containsKey('targetPools')
              ? (_json['targetPools'] as core.List)
                  .map<TargetPool>((value) => TargetPool.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetPoolsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetPools != null)
          'targetPools': targetPools!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetReference {
  core.String? target;

  TargetReference({
    this.target,
  });

  TargetReference.fromJson(core.Map _json)
      : this(
          target: _json.containsKey('target')
              ? _json['target'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (target != null) 'target': target!,
      };
}

class TargetSslProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetSslProxy.
  core.String? service;

  TargetSslProxiesSetBackendServiceRequest({
    this.service,
  });

  TargetSslProxiesSetBackendServiceRequest.fromJson(core.Map _json)
      : this(
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (service != null) 'service': service!,
      };
}

class TargetSslProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  ///
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  TargetSslProxiesSetProxyHeaderRequest({
    this.proxyHeader,
  });

  TargetSslProxiesSetProxyHeaderRequest.fromJson(core.Map _json)
      : this(
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
      };
}

class TargetSslProxiesSetSslCertificatesRequest {
  /// New set of URLs to SslCertificate resources to associate with this
  /// TargetSslProxy.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates.
  core.List<core.String>? sslCertificates;

  TargetSslProxiesSetSslCertificatesRequest({
    this.sslCertificates,
  });

  TargetSslProxiesSetSslCertificatesRequest.fromJson(core.Map _json)
      : this(
          sslCertificates: _json.containsKey('sslCertificates')
              ? (_json['sslCertificates'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
      };
}

/// Represents a Target SSL Proxy resource.
///
/// A target SSL proxy is a component of a SSL Proxy load balancer. Global
/// forwarding rules reference a target SSL proxy, and the target proxy then
/// references an external backend service. For more information, read Using
/// Target Proxies.
class TargetSslProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetSslProxy for target SSL proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL to the BackendService resource.
  core.String? service;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// to Backends.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates. sslCertificates do not apply when the load
  /// balancing scheme is set to INTERNAL_SELF_MANAGED.
  core.List<core.String>? sslCertificates;

  /// URL of SslPolicy resource that will be associated with the TargetSslProxy
  /// resource.
  ///
  /// If not set, the TargetSslProxy resource will not have any SSL policy
  /// configured.
  core.String? sslPolicy;

  TargetSslProxy({
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.proxyHeader,
    this.selfLink,
    this.service,
    this.sslCertificates,
    this.sslPolicy,
  });

  TargetSslProxy.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
          sslCertificates: _json.containsKey('sslCertificates')
              ? (_json['sslCertificates'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          sslPolicy: _json.containsKey('sslPolicy')
              ? _json['sslPolicy'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (service != null) 'service': service!,
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
        if (sslPolicy != null) 'sslPolicy': sslPolicy!,
      };
}

class TargetSslProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetSslProxyListWarningData({
    this.key,
    this.value,
  });

  TargetSslProxyListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetSslProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetSslProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetSslProxyListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetSslProxyListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetSslProxyListWarningData>((value) =>
                      TargetSslProxyListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetSslProxy resources.
class TargetSslProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetSslProxy resources.
  core.List<TargetSslProxy>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetSslProxyListWarning? warning;

  TargetSslProxyList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  TargetSslProxyList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<TargetSslProxy>((value) => TargetSslProxy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? TargetSslProxyListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetTcpProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetTcpProxy.
  core.String? service;

  TargetTcpProxiesSetBackendServiceRequest({
    this.service,
  });

  TargetTcpProxiesSetBackendServiceRequest.fromJson(core.Map _json)
      : this(
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (service != null) 'service': service!,
      };
}

class TargetTcpProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  ///
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  TargetTcpProxiesSetProxyHeaderRequest({
    this.proxyHeader,
  });

  TargetTcpProxiesSetProxyHeaderRequest.fromJson(core.Map _json)
      : this(
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
      };
}

/// Represents a Target TCP Proxy resource.
///
/// A target TCP proxy is a component of a TCP Proxy load balancer. Global
/// forwarding rules reference target TCP proxy, and the target proxy then
/// references an external backend service. For more information, read TCP Proxy
/// Load Balancing overview.
class TargetTcpProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetTcpProxy for target TCP proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// This field only applies when the forwarding rule that references this
  /// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  ///
  /// When this field is set to true, Envoy proxies set up inbound traffic
  /// interception and bind to the IP address and port specified in the
  /// forwarding rule. This is generally useful when using Traffic Director to
  /// configure Envoy as a gateway or middle proxy (in other words, not a
  /// sidecar proxy). The Envoy proxy listens for inbound requests and handles
  /// requests when it receives them. The default is false.
  core.bool? proxyBind;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL to the BackendService resource.
  core.String? service;

  TargetTcpProxy({
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.proxyBind,
    this.proxyHeader,
    this.selfLink,
    this.service,
  });

  TargetTcpProxy.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          proxyBind: _json.containsKey('proxyBind')
              ? _json['proxyBind'] as core.bool
              : null,
          proxyHeader: _json.containsKey('proxyHeader')
              ? _json['proxyHeader'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (proxyBind != null) 'proxyBind': proxyBind!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (service != null) 'service': service!,
      };
}

class TargetTcpProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetTcpProxyListWarningData({
    this.key,
    this.value,
  });

  TargetTcpProxyListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetTcpProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetTcpProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetTcpProxyListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetTcpProxyListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetTcpProxyListWarningData>((value) =>
                      TargetTcpProxyListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetTcpProxy resources.
class TargetTcpProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetTcpProxy resources.
  core.List<TargetTcpProxy>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetTcpProxyListWarning? warning;

  TargetTcpProxyList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  TargetTcpProxyList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<TargetTcpProxy>((value) => TargetTcpProxy.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? TargetTcpProxyListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Target VPN Gateway resource.
///
/// The target VPN gateway resource represents a Classic Cloud VPN gateway. For
/// more information, read the the Cloud VPN Overview.
class TargetVpnGateway {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A list of URLs to the ForwardingRule resources.
  ///
  /// ForwardingRules are created using compute.forwardingRules.insert and
  /// associated with a VPN gateway.
  ///
  /// Output only.
  core.List<core.String>? forwardingRules;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#targetVpnGateway for target VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the network to which this VPN gateway is attached.
  ///
  /// Provided by the client when the VPN gateway is created.
  core.String? network;

  /// URL of the region where the target VPN gateway resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the VPN gateway, which can be one of the following:
  /// CREATING, READY, FAILED, or DELETING.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  core.String? status;

  /// A list of URLs to VpnTunnel resources.
  ///
  /// VpnTunnels are created using the compute.vpntunnels.insert method and
  /// associated with a VPN gateway.
  ///
  /// Output only.
  core.List<core.String>? tunnels;

  TargetVpnGateway({
    this.creationTimestamp,
    this.description,
    this.forwardingRules,
    this.id,
    this.kind,
    this.name,
    this.network,
    this.region,
    this.selfLink,
    this.status,
    this.tunnels,
  });

  TargetVpnGateway.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          forwardingRules: _json.containsKey('forwardingRules')
              ? (_json['forwardingRules'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          tunnels: _json.containsKey('tunnels')
              ? (_json['tunnels'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (forwardingRules != null) 'forwardingRules': forwardingRules!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (tunnels != null) 'tunnels': tunnels!,
      };
}

class TargetVpnGatewayAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetVpnGatewayAggregatedListWarningData({
    this.key,
    this.value,
  });

  TargetVpnGatewayAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetVpnGatewayAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetVpnGatewayAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetVpnGatewayAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetVpnGatewayAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetVpnGatewayAggregatedListWarningData>((value) =>
                      TargetVpnGatewayAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetVpnGatewayAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetVpnGateway resources.
  core.Map<core.String, TargetVpnGatewaysScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#targetVpnGateway for target VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  TargetVpnGatewayAggregatedListWarning? warning;

  TargetVpnGatewayAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  TargetVpnGatewayAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    TargetVpnGatewaysScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetVpnGatewayAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetVpnGatewayListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetVpnGatewayListWarningData({
    this.key,
    this.value,
  });

  TargetVpnGatewayListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetVpnGatewayListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetVpnGatewayListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetVpnGatewayListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetVpnGatewayListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetVpnGatewayListWarningData>((value) =>
                      TargetVpnGatewayListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetVpnGateway resources.
class TargetVpnGatewayList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetVpnGateway resources.
  core.List<TargetVpnGateway>? items;

  /// Type of resource.
  ///
  /// Always compute#targetVpnGateway for target VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetVpnGatewayListWarning? warning;

  TargetVpnGatewayList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  TargetVpnGatewayList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<TargetVpnGateway>((value) => TargetVpnGateway.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? TargetVpnGatewayListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetVpnGatewaysScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetVpnGatewaysScopedListWarningData({
    this.key,
    this.value,
  });

  TargetVpnGatewaysScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
///
/// Output only.
class TargetVpnGatewaysScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetVpnGatewaysScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetVpnGatewaysScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  TargetVpnGatewaysScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<TargetVpnGatewaysScopedListWarningData>((value) =>
                      TargetVpnGatewaysScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetVpnGatewaysScopedList {
  /// A list of target VPN gateways contained in this scope.
  ///
  /// Output only.
  core.List<TargetVpnGateway>? targetVpnGateways;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  ///
  /// Output only.
  TargetVpnGatewaysScopedListWarning? warning;

  TargetVpnGatewaysScopedList({
    this.targetVpnGateways,
    this.warning,
  });

  TargetVpnGatewaysScopedList.fromJson(core.Map _json)
      : this(
          targetVpnGateways: _json.containsKey('targetVpnGateways')
              ? (_json['targetVpnGateways'] as core.List)
                  .map<TargetVpnGateway>((value) => TargetVpnGateway.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? TargetVpnGatewaysScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetVpnGateways != null)
          'targetVpnGateways':
              targetVpnGateways!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TestFailure {
  /// The actual output URL evaluated by load balancer containing the scheme,
  /// host, path and query parameters.
  core.String? actualOutputUrl;

  /// Actual HTTP status code for rule with `urlRedirect` calculated by load
  /// balancer
  core.int? actualRedirectResponseCode;

  /// BackendService or BackendBucket returned by load balancer.
  core.String? actualService;

  /// The expected output URL evaluated by load balancer containing the scheme,
  /// host, path and query parameters.
  core.String? expectedOutputUrl;

  /// Expected HTTP status code for rule with `urlRedirect` calculated by load
  /// balancer
  core.int? expectedRedirectResponseCode;

  /// Expected BackendService or BackendBucket resource the given URL should be
  /// mapped to.
  core.String? expectedService;

  /// HTTP headers of the request.
  core.List<UrlMapTestHeader>? headers;

  /// Host portion of the URL.
  core.String? host;

  /// Path portion including query parameters in the URL.
  core.String? path;

  TestFailure({
    this.actualOutputUrl,
    this.actualRedirectResponseCode,
    this.actualService,
    this.expectedOutputUrl,
    this.expectedRedirectResponseCode,
    this.expectedService,
    this.headers,
    this.host,
    this.path,
  });

  TestFailure.fromJson(core.Map _json)
      : this(
          actualOutputUrl: _json.containsKey('actualOutputUrl')
              ? _json['actualOutputUrl'] as core.String
              : null,
          actualRedirectResponseCode:
              _json.containsKey('actualRedirectResponseCode')
                  ? _json['actualRedirectResponseCode'] as core.int
                  : null,
          actualService: _json.containsKey('actualService')
              ? _json['actualService'] as core.String
              : null,
          expectedOutputUrl: _json.containsKey('expectedOutputUrl')
              ? _json['expectedOutputUrl'] as core.String
              : null,
          expectedRedirectResponseCode:
              _json.containsKey('expectedRedirectResponseCode')
                  ? _json['expectedRedirectResponseCode'] as core.int
                  : null,
          expectedService: _json.containsKey('expectedService')
              ? _json['expectedService'] as core.String
              : null,
          headers: _json.containsKey('headers')
              ? (_json['headers'] as core.List)
                  .map<UrlMapTestHeader>((value) => UrlMapTestHeader.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          host: _json.containsKey('host') ? _json['host'] as core.String : null,
          path: _json.containsKey('path') ? _json['path'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (actualOutputUrl != null) 'actualOutputUrl': actualOutputUrl!,
        if (actualRedirectResponseCode != null)
          'actualRedirectResponseCode': actualRedirectResponseCode!,
        if (actualService != null) 'actualService': actualService!,
        if (expectedOutputUrl != null) 'expectedOutputUrl': expectedOutputUrl!,
        if (expectedRedirectResponseCode != null)
          'expectedRedirectResponseCode': expectedRedirectResponseCode!,
        if (expectedService != null) 'expectedService': expectedService!,
        if (headers != null)
          'headers': headers!.map((value) => value.toJson()).toList(),
        if (host != null) 'host': host!,
        if (path != null) 'path': path!,
      };
}

class TestPermissionsRequest {
  /// The set of permissions to check for the 'resource'.
  ///
  /// Permissions with wildcards (such as '*' or 'storage.*') are not allowed.
  core.List<core.String>? permissions;

  TestPermissionsRequest({
    this.permissions,
  });

  TestPermissionsRequest.fromJson(core.Map _json)
      : this(
          permissions: _json.containsKey('permissions')
              ? (_json['permissions'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (permissions != null) 'permissions': permissions!,
      };
}

class TestPermissionsResponse {
  /// A subset of `TestPermissionsRequest.permissions` that the caller is
  /// allowed.
  core.List<core.String>? permissions;

  TestPermissionsResponse({
    this.permissions,
  });

  TestPermissionsResponse.fromJson(core.Map _json)
      : this(
          permissions: _json.containsKey('permissions')
              ? (_json['permissions'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (permissions != null) 'permissions': permissions!,
      };
}

class Uint128 {
  core.String? high;
  core.String? low;

  Uint128({
    this.high,
    this.low,
  });

  Uint128.fromJson(core.Map _json)
      : this(
          high: _json.containsKey('high') ? _json['high'] as core.String : null,
          low: _json.containsKey('low') ? _json['low'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (high != null) 'high': high!,
        if (low != null) 'low': low!,
      };
}

/// Represents a URL Map resource.
///
/// Google Compute Engine has two URL Map resources: *
/// \[Global\](/compute/docs/reference/rest/v1/urlMaps) *
/// \[Regional\](/compute/docs/reference/rest/v1/regionUrlMaps) A URL map
/// resource is a component of certain types of GCP load balancers and Traffic
/// Director. * urlMaps are used by external HTTP(S) load balancers and Traffic
/// Director. * regionUrlMaps are used by internal HTTP(S) load balancers. For a
/// list of supported URL map features by load balancer type, see the Load
/// balancing features: Routing and traffic management table. For a list of
/// supported URL map features for Traffic Director, see the Traffic Director
/// features: Routing and traffic management table. This resource defines
/// mappings from host names and URL paths to either a backend service or a
/// backend bucket. To use the global urlMaps resource, the backend service must
/// have a loadBalancingScheme of either EXTERNAL or INTERNAL_SELF_MANAGED. To
/// use the regionUrlMaps resource, the backend service must have a
/// loadBalancingScheme of INTERNAL_MANAGED. For more information, read URL Map
/// Concepts.
class UrlMap {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// defaultRouteAction takes effect when none of the hostRules match.
  ///
  /// The load balancer performs advanced routing actions like URL rewrites,
  /// header transformations, etc. prior to forwarding the request to the
  /// selected backend. If defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be set. Conversely if
  /// defaultService is set, defaultRouteAction cannot contain any
  /// weightedBackendServices. Only one of defaultRouteAction or
  /// defaultUrlRedirect must be set. UrlMaps for external HTTP(S) load
  /// balancers support only the urlRewrite action within defaultRouteAction.
  /// defaultRouteAction has no effect when the URL map is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  HttpRouteAction? defaultRouteAction;

  /// The full or partial URL of the defaultService resource to which traffic is
  /// directed if none of the hostRules match.
  ///
  /// If defaultRouteAction is additionally specified, advanced routing actions
  /// like URL Rewrites, etc. take effect prior to sending the request to the
  /// backend. However, if defaultService is specified, defaultRouteAction
  /// cannot contain any weightedBackendServices. Conversely, if routeAction
  /// specifies any weightedBackendServices, service must not be specified. Only
  /// one of defaultService, defaultUrlRedirect or
  /// defaultRouteAction.weightedBackendService must be set. defaultService has
  /// no effect when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  core.String? defaultService;

  /// When none of the specified hostRules match, the request is redirected to a
  /// URL specified by defaultUrlRedirect.
  ///
  /// If defaultUrlRedirect is specified, defaultService or defaultRouteAction
  /// must not be set. Not supported when the URL map is bound to target gRPC
  /// proxy.
  HttpRedirectAction? defaultUrlRedirect;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a UrlMap. An
  /// up-to-date fingerprint must be provided in order to update the UrlMap,
  /// otherwise the request will fail with error 412 conditionNotMet. To see the
  /// latest fingerprint, make a get() request to retrieve a UrlMap.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  ///
  /// The headerAction specified here take effect after headerAction specified
  /// under pathMatcher. Note that headerAction is not supported for
  /// Loadbalancers that have their loadBalancingScheme set to EXTERNAL. Not
  /// supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction? headerAction;

  /// The list of HostRules to use against the URL.
  core.List<HostRule>? hostRules;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#urlMaps for url maps.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The list of named PathMatchers to use against the URL.
  core.List<PathMatcher>? pathMatchers;

  /// URL of the region where the regional URL map resides.
  ///
  /// This field is not applicable to global URL maps. You must specify this
  /// field as part of the HTTP request URL. It is not settable as a field in
  /// the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The list of expected URL mapping tests.
  ///
  /// Request to update this UrlMap will succeed only if all of the test cases
  /// pass. You can specify a maximum of 100 tests per UrlMap. Not supported
  /// when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  core.List<UrlMapTest>? tests;

  UrlMap({
    this.creationTimestamp,
    this.defaultRouteAction,
    this.defaultService,
    this.defaultUrlRedirect,
    this.description,
    this.fingerprint,
    this.headerAction,
    this.hostRules,
    this.id,
    this.kind,
    this.name,
    this.pathMatchers,
    this.region,
    this.selfLink,
    this.tests,
  });

  UrlMap.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          defaultRouteAction: _json.containsKey('defaultRouteAction')
              ? HttpRouteAction.fromJson(_json['defaultRouteAction']
                  as core.Map<core.String, core.dynamic>)
              : null,
          defaultService: _json.containsKey('defaultService')
              ? _json['defaultService'] as core.String
              : null,
          defaultUrlRedirect: _json.containsKey('defaultUrlRedirect')
              ? HttpRedirectAction.fromJson(_json['defaultUrlRedirect']
                  as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          fingerprint: _json.containsKey('fingerprint')
              ? _json['fingerprint'] as core.String
              : null,
          headerAction: _json.containsKey('headerAction')
              ? HttpHeaderAction.fromJson(
                  _json['headerAction'] as core.Map<core.String, core.dynamic>)
              : null,
          hostRules: _json.containsKey('hostRules')
              ? (_json['hostRules'] as core.List)
                  .map<HostRule>((value) => HostRule.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          pathMatchers: _json.containsKey('pathMatchers')
              ? (_json['pathMatchers'] as core.List)
                  .map<PathMatcher>((value) => PathMatcher.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          tests: _json.containsKey('tests')
              ? (_json['tests'] as core.List)
                  .map<UrlMapTest>((value) => UrlMapTest.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (defaultRouteAction != null)
          'defaultRouteAction': defaultRouteAction!.toJson(),
        if (defaultService != null) 'defaultService': defaultService!,
        if (defaultUrlRedirect != null)
          'defaultUrlRedirect': defaultUrlRedirect!.toJson(),
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (headerAction != null) 'headerAction': headerAction!.toJson(),
        if (hostRules != null)
          'hostRules': hostRules!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (pathMatchers != null)
          'pathMatchers': pathMatchers!.map((value) => value.toJson()).toList(),
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (tests != null)
          'tests': tests!.map((value) => value.toJson()).toList(),
      };
}

class UrlMapListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  UrlMapListWarningData({
    this.key,
    this.value,
  });

  UrlMapListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class UrlMapListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<UrlMapListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  UrlMapListWarning({
    this.code,
    this.data,
    this.message,
  });

  UrlMapListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<UrlMapListWarningData>((value) =>
                      UrlMapListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of UrlMap resources.
class UrlMapList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of UrlMap resources.
  core.List<UrlMap>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  UrlMapListWarning? warning;

  UrlMapList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  UrlMapList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<UrlMap>((value) => UrlMap.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? UrlMapListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class UrlMapReference {
  core.String? urlMap;

  UrlMapReference({
    this.urlMap,
  });

  UrlMapReference.fromJson(core.Map _json)
      : this(
          urlMap: _json.containsKey('urlMap')
              ? _json['urlMap'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (urlMap != null) 'urlMap': urlMap!,
      };
}

/// Message for the expected URL mappings.
class UrlMapTest {
  /// Description of this test case.
  core.String? description;

  /// The expected output URL evaluated by load balancer containing the scheme,
  /// host, path and query parameters.
  ///
  /// For rules that forward requests to backends, the test passes only when
  /// expectedOutputUrl matches the request forwarded by load balancer to
  /// backends. For rules with urlRewrite, the test verifies that the forwarded
  /// request matches hostRewrite and pathPrefixRewrite in the urlRewrite
  /// action. When service is specified, expectedOutputUrl\`s scheme is ignored.
  /// For rules with urlRedirect, the test passes only if expectedOutputUrl
  /// matches the URL in the load balancer's redirect response. If urlRedirect
  /// specifies https_redirect, the test passes only if the scheme in
  /// expectedOutputUrl is also set to https. If urlRedirect specifies
  /// strip_query, the test passes only if expectedOutputUrl does not contain
  /// any query parameters. expectedOutputUrl is optional when service is
  /// specified.
  core.String? expectedOutputUrl;

  /// For rules with urlRedirect, the test passes only if
  /// expectedRedirectResponseCode matches the HTTP status code in load
  /// balancer's redirect response.
  ///
  /// expectedRedirectResponseCode cannot be set when service is set.
  core.int? expectedRedirectResponseCode;

  /// HTTP headers for this request.
  ///
  /// If headers contains a host header, then host must also match the header
  /// value.
  core.List<UrlMapTestHeader>? headers;

  /// Host portion of the URL.
  ///
  /// If headers contains a host header, then host must also match the header
  /// value.
  core.String? host;

  /// Path portion of the URL.
  core.String? path;

  /// Expected BackendService or BackendBucket resource the given URL should be
  /// mapped to.
  ///
  /// service cannot be set if expectedRedirectResponseCode is set.
  core.String? service;

  UrlMapTest({
    this.description,
    this.expectedOutputUrl,
    this.expectedRedirectResponseCode,
    this.headers,
    this.host,
    this.path,
    this.service,
  });

  UrlMapTest.fromJson(core.Map _json)
      : this(
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          expectedOutputUrl: _json.containsKey('expectedOutputUrl')
              ? _json['expectedOutputUrl'] as core.String
              : null,
          expectedRedirectResponseCode:
              _json.containsKey('expectedRedirectResponseCode')
                  ? _json['expectedRedirectResponseCode'] as core.int
                  : null,
          headers: _json.containsKey('headers')
              ? (_json['headers'] as core.List)
                  .map<UrlMapTestHeader>((value) => UrlMapTestHeader.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          host: _json.containsKey('host') ? _json['host'] as core.String : null,
          path: _json.containsKey('path') ? _json['path'] as core.String : null,
          service: _json.containsKey('service')
              ? _json['service'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (expectedOutputUrl != null) 'expectedOutputUrl': expectedOutputUrl!,
        if (expectedRedirectResponseCode != null)
          'expectedRedirectResponseCode': expectedRedirectResponseCode!,
        if (headers != null)
          'headers': headers!.map((value) => value.toJson()).toList(),
        if (host != null) 'host': host!,
        if (path != null) 'path': path!,
        if (service != null) 'service': service!,
      };
}

/// HTTP headers used in UrlMapTests.
class UrlMapTestHeader {
  /// Header name.
  core.String? name;

  /// Header value.
  core.String? value;

  UrlMapTestHeader({
    this.name,
    this.value,
  });

  UrlMapTestHeader.fromJson(core.Map _json)
      : this(
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// Message representing the validation result for a UrlMap.
class UrlMapValidationResult {
  core.List<core.String>? loadErrors;

  /// Whether the given UrlMap can be successfully loaded.
  ///
  /// If false, 'loadErrors' indicates the reasons.
  core.bool? loadSucceeded;
  core.List<TestFailure>? testFailures;

  /// If successfully loaded, this field indicates whether the test passed.
  ///
  /// If false, 'testFailures's indicate the reason of failure.
  core.bool? testPassed;

  UrlMapValidationResult({
    this.loadErrors,
    this.loadSucceeded,
    this.testFailures,
    this.testPassed,
  });

  UrlMapValidationResult.fromJson(core.Map _json)
      : this(
          loadErrors: _json.containsKey('loadErrors')
              ? (_json['loadErrors'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          loadSucceeded: _json.containsKey('loadSucceeded')
              ? _json['loadSucceeded'] as core.bool
              : null,
          testFailures: _json.containsKey('testFailures')
              ? (_json['testFailures'] as core.List)
                  .map<TestFailure>((value) => TestFailure.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          testPassed: _json.containsKey('testPassed')
              ? _json['testPassed'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (loadErrors != null) 'loadErrors': loadErrors!,
        if (loadSucceeded != null) 'loadSucceeded': loadSucceeded!,
        if (testFailures != null)
          'testFailures': testFailures!.map((value) => value.toJson()).toList(),
        if (testPassed != null) 'testPassed': testPassed!,
      };
}

class UrlMapsAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  UrlMapsAggregatedListWarningData({
    this.key,
    this.value,
  });

  UrlMapsAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class UrlMapsAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<UrlMapsAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  UrlMapsAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  UrlMapsAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<UrlMapsAggregatedListWarningData>((value) =>
                      UrlMapsAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class UrlMapsAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of UrlMapsScopedList resources.
  core.Map<core.String, UrlMapsScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  UrlMapsAggregatedListWarning? warning;

  UrlMapsAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  UrlMapsAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    UrlMapsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? UrlMapsAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class UrlMapsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  UrlMapsScopedListWarningData({
    this.key,
    this.value,
  });

  UrlMapsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class UrlMapsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<UrlMapsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  UrlMapsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  UrlMapsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<UrlMapsScopedListWarningData>((value) =>
                      UrlMapsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class UrlMapsScopedList {
  /// A list of UrlMaps contained in this scope.
  core.List<UrlMap>? urlMaps;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  UrlMapsScopedListWarning? warning;

  UrlMapsScopedList({
    this.urlMaps,
    this.warning,
  });

  UrlMapsScopedList.fromJson(core.Map _json)
      : this(
          urlMaps: _json.containsKey('urlMaps')
              ? (_json['urlMaps'] as core.List)
                  .map<UrlMap>((value) => UrlMap.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? UrlMapsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (urlMaps != null)
          'urlMaps': urlMaps!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class UrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap? resource;

  UrlMapsValidateRequest({
    this.resource,
  });

  UrlMapsValidateRequest.fromJson(core.Map _json)
      : this(
          resource: _json.containsKey('resource')
              ? UrlMap.fromJson(
                  _json['resource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resource != null) 'resource': resource!.toJson(),
      };
}

class UrlMapsValidateResponse {
  UrlMapValidationResult? result;

  UrlMapsValidateResponse({
    this.result,
  });

  UrlMapsValidateResponse.fromJson(core.Map _json)
      : this(
          result: _json.containsKey('result')
              ? UrlMapValidationResult.fromJson(
                  _json['result'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (result != null) 'result': result!.toJson(),
      };
}

/// The spec for modifying the path before sending the request to the matched
/// backend service.
class UrlRewrite {
  /// Prior to forwarding the request to the selected service, the request's
  /// host header is replaced with contents of hostRewrite.
  ///
  /// The value must be between 1 and 255 characters.
  core.String? hostRewrite;

  /// Prior to forwarding the request to the selected backend service, the
  /// matching portion of the request's path is replaced by pathPrefixRewrite.
  ///
  /// The value must be between 1 and 1024 characters.
  core.String? pathPrefixRewrite;

  UrlRewrite({
    this.hostRewrite,
    this.pathPrefixRewrite,
  });

  UrlRewrite.fromJson(core.Map _json)
      : this(
          hostRewrite: _json.containsKey('hostRewrite')
              ? _json['hostRewrite'] as core.String
              : null,
          pathPrefixRewrite: _json.containsKey('pathPrefixRewrite')
              ? _json['pathPrefixRewrite'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (hostRewrite != null) 'hostRewrite': hostRewrite!,
        if (pathPrefixRewrite != null) 'pathPrefixRewrite': pathPrefixRewrite!,
      };
}

/// Subnetwork which the current user has compute.subnetworks.use permission on.
class UsableSubnetwork {
  /// The range of internal addresses that are owned by this subnetwork.
  core.String? ipCidrRange;

  /// Network URL.
  core.String? network;

  /// Secondary IP ranges.
  core.List<UsableSubnetworkSecondaryRange>? secondaryIpRanges;

  /// Subnetwork URL.
  core.String? subnetwork;

  UsableSubnetwork({
    this.ipCidrRange,
    this.network,
    this.secondaryIpRanges,
    this.subnetwork,
  });

  UsableSubnetwork.fromJson(core.Map _json)
      : this(
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          secondaryIpRanges: _json.containsKey('secondaryIpRanges')
              ? (_json['secondaryIpRanges'] as core.List)
                  .map<UsableSubnetworkSecondaryRange>((value) =>
                      UsableSubnetworkSecondaryRange.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          subnetwork: _json.containsKey('subnetwork')
              ? _json['subnetwork'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (network != null) 'network': network!,
        if (secondaryIpRanges != null)
          'secondaryIpRanges':
              secondaryIpRanges!.map((value) => value.toJson()).toList(),
        if (subnetwork != null) 'subnetwork': subnetwork!,
      };
}

/// Secondary IP range of a usable subnetwork.
class UsableSubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  core.String? ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035. The name
  /// must be unique within the subnetwork.
  core.String? rangeName;

  UsableSubnetworkSecondaryRange({
    this.ipCidrRange,
    this.rangeName,
  });

  UsableSubnetworkSecondaryRange.fromJson(core.Map _json)
      : this(
          ipCidrRange: _json.containsKey('ipCidrRange')
              ? _json['ipCidrRange'] as core.String
              : null,
          rangeName: _json.containsKey('rangeName')
              ? _json['rangeName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (rangeName != null) 'rangeName': rangeName!,
      };
}

class UsableSubnetworksAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  UsableSubnetworksAggregatedListWarningData({
    this.key,
    this.value,
  });

  UsableSubnetworksAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class UsableSubnetworksAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<UsableSubnetworksAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  UsableSubnetworksAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  UsableSubnetworksAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<UsableSubnetworksAggregatedListWarningData>((value) =>
                      UsableSubnetworksAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class UsableSubnetworksAggregatedList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// \[Output\] A list of usable subnetwork URLs.
  core.List<UsableSubnetwork>? items;

  /// Type of resource.
  ///
  /// Always compute#usableSubnetworksAggregatedList for aggregated lists of
  /// usable subnetworks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results. In special cases listUsable may return 0
  /// subnetworks and nextPageToken which still should be used to get the next
  /// page of results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  UsableSubnetworksAggregatedListWarning? warning;

  UsableSubnetworksAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  UsableSubnetworksAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<UsableSubnetwork>((value) => UsableSubnetwork.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? UsableSubnetworksAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The location in Cloud Storage and naming method of the daily usage report.
///
/// Contains bucket_name and report_name prefix.
class UsageExportLocation {
  /// The name of an existing bucket in Cloud Storage where the usage report
  /// object is stored.
  ///
  /// The Google Service Account is granted write access to this bucket. This
  /// can either be the bucket name by itself, such as example-bucket, or the
  /// bucket name with gs:// or https://storage.googleapis.com/ in front of it,
  /// such as gs://example-bucket.
  core.String? bucketName;

  /// An optional prefix for the name of the usage report object stored in
  /// bucketName.
  ///
  /// If not supplied, defaults to usage_gce. The report is stored as a CSV file
  /// named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the day of the
  /// usage according to Pacific Time. If you supply a prefix, it should conform
  /// to Cloud Storage object naming conventions.
  core.String? reportNamePrefix;

  UsageExportLocation({
    this.bucketName,
    this.reportNamePrefix,
  });

  UsageExportLocation.fromJson(core.Map _json)
      : this(
          bucketName: _json.containsKey('bucketName')
              ? _json['bucketName'] as core.String
              : null,
          reportNamePrefix: _json.containsKey('reportNamePrefix')
              ? _json['reportNamePrefix'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bucketName != null) 'bucketName': bucketName!,
        if (reportNamePrefix != null) 'reportNamePrefix': reportNamePrefix!,
      };
}

/// Contain information of Nat mapping for a VM endpoint (i.e., NIC).
class VmEndpointNatMappings {
  /// Name of the VM instance which the endpoint belongs to
  core.String? instanceName;
  core.List<VmEndpointNatMappingsInterfaceNatMappings>? interfaceNatMappings;

  VmEndpointNatMappings({
    this.instanceName,
    this.interfaceNatMappings,
  });

  VmEndpointNatMappings.fromJson(core.Map _json)
      : this(
          instanceName: _json.containsKey('instanceName')
              ? _json['instanceName'] as core.String
              : null,
          interfaceNatMappings: _json.containsKey('interfaceNatMappings')
              ? (_json['interfaceNatMappings'] as core.List)
                  .map<VmEndpointNatMappingsInterfaceNatMappings>((value) =>
                      VmEndpointNatMappingsInterfaceNatMappings.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceName != null) 'instanceName': instanceName!,
        if (interfaceNatMappings != null)
          'interfaceNatMappings':
              interfaceNatMappings!.map((value) => value.toJson()).toList(),
      };
}

/// Contain information of Nat mapping for an interface of this endpoint.
class VmEndpointNatMappingsInterfaceNatMappings {
  /// List of all drain IP:port-range mappings assigned to this interface.
  ///
  /// These ranges are inclusive, that is, both the first and the last ports can
  /// be used for NAT. Example: \["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"\].
  core.List<core.String>? drainNatIpPortRanges;

  /// A list of all IP:port-range mappings assigned to this interface.
  ///
  /// These ranges are inclusive, that is, both the first and the last ports can
  /// be used for NAT. Example: \["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"\].
  core.List<core.String>? natIpPortRanges;

  /// Total number of drain ports across all NAT IPs allocated to this
  /// interface.
  ///
  /// It equals to the aggregated port number in the field
  /// drain_nat_ip_port_ranges.
  core.int? numTotalDrainNatPorts;

  /// Total number of ports across all NAT IPs allocated to this interface.
  ///
  /// It equals to the aggregated port number in the field nat_ip_port_ranges.
  core.int? numTotalNatPorts;

  /// Alias IP range for this interface endpoint.
  ///
  /// It will be a private (RFC 1918) IP range. Examples: "10.33.4.55/32", or
  /// "192.168.5.0/24".
  core.String? sourceAliasIpRange;

  /// Primary IP of the VM for this NIC.
  core.String? sourceVirtualIp;

  VmEndpointNatMappingsInterfaceNatMappings({
    this.drainNatIpPortRanges,
    this.natIpPortRanges,
    this.numTotalDrainNatPorts,
    this.numTotalNatPorts,
    this.sourceAliasIpRange,
    this.sourceVirtualIp,
  });

  VmEndpointNatMappingsInterfaceNatMappings.fromJson(core.Map _json)
      : this(
          drainNatIpPortRanges: _json.containsKey('drainNatIpPortRanges')
              ? (_json['drainNatIpPortRanges'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          natIpPortRanges: _json.containsKey('natIpPortRanges')
              ? (_json['natIpPortRanges'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          numTotalDrainNatPorts: _json.containsKey('numTotalDrainNatPorts')
              ? _json['numTotalDrainNatPorts'] as core.int
              : null,
          numTotalNatPorts: _json.containsKey('numTotalNatPorts')
              ? _json['numTotalNatPorts'] as core.int
              : null,
          sourceAliasIpRange: _json.containsKey('sourceAliasIpRange')
              ? _json['sourceAliasIpRange'] as core.String
              : null,
          sourceVirtualIp: _json.containsKey('sourceVirtualIp')
              ? _json['sourceVirtualIp'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (drainNatIpPortRanges != null)
          'drainNatIpPortRanges': drainNatIpPortRanges!,
        if (natIpPortRanges != null) 'natIpPortRanges': natIpPortRanges!,
        if (numTotalDrainNatPorts != null)
          'numTotalDrainNatPorts': numTotalDrainNatPorts!,
        if (numTotalNatPorts != null) 'numTotalNatPorts': numTotalNatPorts!,
        if (sourceAliasIpRange != null)
          'sourceAliasIpRange': sourceAliasIpRange!,
        if (sourceVirtualIp != null) 'sourceVirtualIp': sourceVirtualIp!,
      };
}

class VmEndpointNatMappingsListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VmEndpointNatMappingsListWarningData({
    this.key,
    this.value,
  });

  VmEndpointNatMappingsListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VmEndpointNatMappingsListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VmEndpointNatMappingsListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VmEndpointNatMappingsListWarning({
    this.code,
    this.data,
    this.message,
  });

  VmEndpointNatMappingsListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<VmEndpointNatMappingsListWarningData>((value) =>
                      VmEndpointNatMappingsListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of VmEndpointNatMappings.
class VmEndpointNatMappingsList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#vmEndpointNatMappingsList for lists of Nat mappings of VM
  /// endpoints.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// A list of Nat mapping information of VM endpoints.
  ///
  /// Output only.
  core.List<VmEndpointNatMappings>? result;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  VmEndpointNatMappingsListWarning? warning;

  VmEndpointNatMappingsList({
    this.id,
    this.kind,
    this.nextPageToken,
    this.result,
    this.selfLink,
    this.warning,
  });

  VmEndpointNatMappingsList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          result: _json.containsKey('result')
              ? (_json['result'] as core.List)
                  .map<VmEndpointNatMappings>((value) =>
                      VmEndpointNatMappings.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? VmEndpointNatMappingsListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (result != null)
          'result': result!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a HA VPN gateway.
///
/// HA VPN is a high-availability (HA) Cloud VPN solution that lets you securely
/// connect your on-premises network to your Google Cloud Virtual Private Cloud
/// network through an IPsec VPN connection in a single region. For more
/// information about Cloud HA VPN solutions, see Cloud VPN topologies .
class VpnGateway {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#vpnGateway for VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this VpnGateway, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve an VpnGateway.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels for this resource.
  ///
  /// These can only be added or modified by the setLabels method. Each label
  /// key/value pair must comply with RFC1035. Label values may be empty.
  core.Map<core.String, core.String>? labels;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the network to which this VPN gateway is attached.
  ///
  /// Provided by the client when the VPN gateway is created.
  core.String? network;

  /// URL of the region where the VPN gateway resides.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The list of VPN interfaces associated with this VPN gateway.
  core.List<VpnGatewayVpnGatewayInterface>? vpnInterfaces;

  VpnGateway({
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.name,
    this.network,
    this.region,
    this.selfLink,
    this.vpnInterfaces,
  });

  VpnGateway.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          network: _json.containsKey('network')
              ? _json['network'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          vpnInterfaces: _json.containsKey('vpnInterfaces')
              ? (_json['vpnInterfaces'] as core.List)
                  .map<VpnGatewayVpnGatewayInterface>((value) =>
                      VpnGatewayVpnGatewayInterface.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (vpnInterfaces != null)
          'vpnInterfaces':
              vpnInterfaces!.map((value) => value.toJson()).toList(),
      };
}

class VpnGatewayAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnGatewayAggregatedListWarningData({
    this.key,
    this.value,
  });

  VpnGatewayAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VpnGatewayAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnGatewayAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnGatewayAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  VpnGatewayAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<VpnGatewayAggregatedListWarningData>((value) =>
                      VpnGatewayAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class VpnGatewayAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of VpnGateway resources.
  core.Map<core.String, VpnGatewaysScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#vpnGateway for VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  VpnGatewayAggregatedListWarning? warning;

  VpnGatewayAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  VpnGatewayAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    VpnGatewaysScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? VpnGatewayAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class VpnGatewayListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnGatewayListWarningData({
    this.key,
    this.value,
  });

  VpnGatewayListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VpnGatewayListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnGatewayListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnGatewayListWarning({
    this.code,
    this.data,
    this.message,
  });

  VpnGatewayListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<VpnGatewayListWarningData>((value) =>
                      VpnGatewayListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of VpnGateway resources.
class VpnGatewayList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of VpnGateway resources.
  core.List<VpnGateway>? items;

  /// Type of resource.
  ///
  /// Always compute#vpnGateway for VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  VpnGatewayListWarning? warning;

  VpnGatewayList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  VpnGatewayList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<VpnGateway>((value) => VpnGateway.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? VpnGatewayListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class VpnGatewayStatus {
  /// List of VPN connection for this VpnGateway.
  core.List<VpnGatewayStatusVpnConnection>? vpnConnections;

  VpnGatewayStatus({
    this.vpnConnections,
  });

  VpnGatewayStatus.fromJson(core.Map _json)
      : this(
          vpnConnections: _json.containsKey('vpnConnections')
              ? (_json['vpnConnections'] as core.List)
                  .map<VpnGatewayStatusVpnConnection>((value) =>
                      VpnGatewayStatusVpnConnection.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (vpnConnections != null)
          'vpnConnections':
              vpnConnections!.map((value) => value.toJson()).toList(),
      };
}

/// Describes the high availability requirement state for the VPN connection
/// between this Cloud VPN gateway and a peer gateway.
class VpnGatewayStatusHighAvailabilityRequirementState {
  /// Indicates the high availability requirement state for the VPN connection.
  ///
  /// Valid values are CONNECTION_REDUNDANCY_MET, CONNECTION_REDUNDANCY_NOT_MET.
  /// Possible string values are:
  /// - "CONNECTION_REDUNDANCY_MET" : VPN tunnels are configured with adequate
  /// redundancy from Cloud VPN gateway to the peer VPN gateway. For both
  /// GCP-to-non-GCP and GCP-to-GCP connections, the adequate redundancy is a
  /// pre-requirement for users to get 99.99% availability on GCP side; please
  /// note that for any connection, end-to-end 99.99% availability is subject to
  /// proper configuration on the peer VPN gateway.
  /// - "CONNECTION_REDUNDANCY_NOT_MET" : VPN tunnels are not configured with
  /// adequate redundancy from the Cloud VPN gateway to the peer gateway
  core.String? state;

  /// Indicates the reason why the VPN connection does not meet the high
  /// availability redundancy criteria/requirement.
  ///
  /// Valid values is INCOMPLETE_TUNNELS_COVERAGE.
  /// Possible string values are:
  /// - "INCOMPLETE_TUNNELS_COVERAGE"
  core.String? unsatisfiedReason;

  VpnGatewayStatusHighAvailabilityRequirementState({
    this.state,
    this.unsatisfiedReason,
  });

  VpnGatewayStatusHighAvailabilityRequirementState.fromJson(core.Map _json)
      : this(
          state:
              _json.containsKey('state') ? _json['state'] as core.String : null,
          unsatisfiedReason: _json.containsKey('unsatisfiedReason')
              ? _json['unsatisfiedReason'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (state != null) 'state': state!,
        if (unsatisfiedReason != null) 'unsatisfiedReason': unsatisfiedReason!,
      };
}

/// Contains some information about a VPN tunnel.
class VpnGatewayStatusTunnel {
  /// The VPN gateway interface this VPN tunnel is associated with.
  core.int? localGatewayInterface;

  /// The peer gateway interface this VPN tunnel is connected to, the peer
  /// gateway could either be an external VPN gateway or GCP VPN gateway.
  core.int? peerGatewayInterface;

  /// URL reference to the VPN tunnel.
  core.String? tunnelUrl;

  VpnGatewayStatusTunnel({
    this.localGatewayInterface,
    this.peerGatewayInterface,
    this.tunnelUrl,
  });

  VpnGatewayStatusTunnel.fromJson(core.Map _json)
      : this(
          localGatewayInterface: _json.containsKey('localGatewayInterface')
              ? _json['localGatewayInterface'] as core.int
              : null,
          peerGatewayInterface: _json.containsKey('peerGatewayInterface')
              ? _json['peerGatewayInterface'] as core.int
              : null,
          tunnelUrl: _json.containsKey('tunnelUrl')
              ? _json['tunnelUrl'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (localGatewayInterface != null)
          'localGatewayInterface': localGatewayInterface!,
        if (peerGatewayInterface != null)
          'peerGatewayInterface': peerGatewayInterface!,
        if (tunnelUrl != null) 'tunnelUrl': tunnelUrl!,
      };
}

/// A VPN connection contains all VPN tunnels connected from this VpnGateway to
/// the same peer gateway.
///
/// The peer gateway could either be a external VPN gateway or GCP VPN gateway.
class VpnGatewayStatusVpnConnection {
  /// URL reference to the peer external VPN gateways to which the VPN tunnels
  /// in this VPN connection are connected.
  ///
  /// This field is mutually exclusive with peer_gcp_gateway.
  core.String? peerExternalGateway;

  /// URL reference to the peer side VPN gateways to which the VPN tunnels in
  /// this VPN connection are connected.
  ///
  /// This field is mutually exclusive with peer_gcp_gateway.
  core.String? peerGcpGateway;

  /// HighAvailabilityRequirementState for the VPN connection.
  VpnGatewayStatusHighAvailabilityRequirementState? state;

  /// List of VPN tunnels that are in this VPN connection.
  core.List<VpnGatewayStatusTunnel>? tunnels;

  VpnGatewayStatusVpnConnection({
    this.peerExternalGateway,
    this.peerGcpGateway,
    this.state,
    this.tunnels,
  });

  VpnGatewayStatusVpnConnection.fromJson(core.Map _json)
      : this(
          peerExternalGateway: _json.containsKey('peerExternalGateway')
              ? _json['peerExternalGateway'] as core.String
              : null,
          peerGcpGateway: _json.containsKey('peerGcpGateway')
              ? _json['peerGcpGateway'] as core.String
              : null,
          state: _json.containsKey('state')
              ? VpnGatewayStatusHighAvailabilityRequirementState.fromJson(
                  _json['state'] as core.Map<core.String, core.dynamic>)
              : null,
          tunnels: _json.containsKey('tunnels')
              ? (_json['tunnels'] as core.List)
                  .map<VpnGatewayStatusTunnel>((value) =>
                      VpnGatewayStatusTunnel.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (peerExternalGateway != null)
          'peerExternalGateway': peerExternalGateway!,
        if (peerGcpGateway != null) 'peerGcpGateway': peerGcpGateway!,
        if (state != null) 'state': state!.toJson(),
        if (tunnels != null)
          'tunnels': tunnels!.map((value) => value.toJson()).toList(),
      };
}

/// A VPN gateway interface.
class VpnGatewayVpnGatewayInterface {
  /// Numeric identifier for this VPN interface associated with the VPN gateway.
  ///
  /// Output only.
  core.int? id;

  /// URL of the VLAN attachment (interconnectAttachment) resource for this VPN
  /// gateway interface.
  ///
  /// When the value of this field is present, the VPN gateway is used for
  /// IPsec-encrypted Cloud Interconnect; all egress or ingress traffic for this
  /// VPN gateway interface goes through the specified VLAN attachment resource.
  /// Not currently available publicly.
  core.String? interconnectAttachment;

  /// IP address for this VPN interface associated with the VPN gateway.
  ///
  /// The IP address could be either a regional external IP address or a
  /// regional internal IP address. The two IP addresses for a VPN gateway must
  /// be all regional external or regional internal IP addresses. There cannot
  /// be a mix of regional external IP addresses and regional internal IP
  /// addresses. For IPsec-encrypted Cloud Interconnect, the IP addresses for
  /// both interfaces could either be regional internal IP addresses or regional
  /// external IP addresses. For regular (non IPsec-encrypted Cloud
  /// Interconnect) HA VPN tunnels, the IP address must be a regional external
  /// IP address.
  ///
  /// Output only.
  core.String? ipAddress;

  VpnGatewayVpnGatewayInterface({
    this.id,
    this.interconnectAttachment,
    this.ipAddress,
  });

  VpnGatewayVpnGatewayInterface.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.int : null,
          interconnectAttachment: _json.containsKey('interconnectAttachment')
              ? _json['interconnectAttachment'] as core.String
              : null,
          ipAddress: _json.containsKey('ipAddress')
              ? _json['ipAddress'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (interconnectAttachment != null)
          'interconnectAttachment': interconnectAttachment!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
      };
}

class VpnGatewaysGetStatusResponse {
  VpnGatewayStatus? result;

  VpnGatewaysGetStatusResponse({
    this.result,
  });

  VpnGatewaysGetStatusResponse.fromJson(core.Map _json)
      : this(
          result: _json.containsKey('result')
              ? VpnGatewayStatus.fromJson(
                  _json['result'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (result != null) 'result': result!.toJson(),
      };
}

class VpnGatewaysScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnGatewaysScopedListWarningData({
    this.key,
    this.value,
  });

  VpnGatewaysScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
///
/// Output only.
class VpnGatewaysScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnGatewaysScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnGatewaysScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  VpnGatewaysScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<VpnGatewaysScopedListWarningData>((value) =>
                      VpnGatewaysScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class VpnGatewaysScopedList {
  /// A list of VPN gateways contained in this scope.
  ///
  /// Output only.
  core.List<VpnGateway>? vpnGateways;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  ///
  /// Output only.
  VpnGatewaysScopedListWarning? warning;

  VpnGatewaysScopedList({
    this.vpnGateways,
    this.warning,
  });

  VpnGatewaysScopedList.fromJson(core.Map _json)
      : this(
          vpnGateways: _json.containsKey('vpnGateways')
              ? (_json['vpnGateways'] as core.List)
                  .map<VpnGateway>((value) => VpnGateway.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? VpnGatewaysScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (vpnGateways != null)
          'vpnGateways': vpnGateways!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Cloud VPN Tunnel resource.
///
/// For more information about VPN, read the the Cloud VPN Overview.
class VpnTunnel {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Detailed status message for the VPN tunnel.
  ///
  /// Output only.
  core.String? detailedStatus;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// IKE protocol version to use when establishing the VPN tunnel with the peer
  /// VPN gateway.
  ///
  /// Acceptable IKE versions are 1 or 2. The default version is 2.
  core.int? ikeVersion;

  /// Type of resource.
  ///
  /// Always compute#vpnTunnel for VPN tunnels.
  ///
  /// Output only.
  core.String? kind;

  /// Local traffic selector to use when establishing the VPN tunnel with the
  /// peer VPN gateway.
  ///
  /// The value should be a CIDR formatted string, for example: 192.168.0.0/16.
  /// The ranges must be disjoint. Only IPv4 is supported.
  core.List<core.String>? localTrafficSelector;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the peer side external VPN gateway to which this VPN tunnel is
  /// connected.
  ///
  /// Provided by the client when the VPN tunnel is created. This field is
  /// exclusive with the field peerGcpGateway.
  core.String? peerExternalGateway;

  /// The interface ID of the external VPN gateway to which this VPN tunnel is
  /// connected.
  ///
  /// Provided by the client when the VPN tunnel is created.
  core.int? peerExternalGatewayInterface;

  /// URL of the peer side HA GCP VPN gateway to which this VPN tunnel is
  /// connected.
  ///
  /// Provided by the client when the VPN tunnel is created. This field can be
  /// used when creating highly available VPN from VPC network to VPC network,
  /// the field is exclusive with the field peerExternalGateway. If provided,
  /// the VPN tunnel will automatically use the same vpnGatewayInterface ID in
  /// the peer GCP VPN gateway.
  core.String? peerGcpGateway;

  /// IP address of the peer VPN gateway.
  ///
  /// Only IPv4 is supported.
  core.String? peerIp;

  /// URL of the region where the VPN tunnel resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Remote traffic selectors to use when establishing the VPN tunnel with the
  /// peer VPN gateway.
  ///
  /// The value should be a CIDR formatted string, for example: 192.168.0.0/16.
  /// The ranges should be disjoint. Only IPv4 is supported.
  core.List<core.String>? remoteTrafficSelector;

  /// URL of the router resource to be used for dynamic routing.
  core.String? router;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Shared secret used to set the secure session between the Cloud VPN gateway
  /// and the peer VPN gateway.
  core.String? sharedSecret;

  /// Hash of the shared secret.
  core.String? sharedSecretHash;

  /// The status of the VPN tunnel, which can be one of the following: -
  /// PROVISIONING: Resource is being allocated for the VPN tunnel.
  ///
  /// - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from
  /// the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route
  /// resources are needed to setup the VPN tunnel. - FIRST_HANDSHAKE:
  /// Successful first handshake with the peer VPN. - ESTABLISHED: Secure
  /// session is successfully established with the peer VPN. - NETWORK_ERROR:
  /// Deprecated, replaced by NO_INCOMING_PACKETS - AUTHORIZATION_ERROR: Auth
  /// error (for example, bad shared secret). - NEGOTIATION_FAILURE: Handshake
  /// failed. - DEPROVISIONING: Resources are being deallocated for the VPN
  /// tunnel. - FAILED: Tunnel creation has failed and the tunnel is not ready
  /// to be used. - NO_INCOMING_PACKETS: No incoming packets from peer. -
  /// REJECTED: Tunnel configuration was rejected, can be result of being denied
  /// access. - ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating
  /// all required resources. - STOPPED: Tunnel is stopped due to its Forwarding
  /// Rules being deleted for Classic VPN tunnels or the project is in frozen
  /// state. - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP,
  /// probably behind NAT. - TS_NARROWING_NOT_ALLOWED: Traffic selector
  /// narrowing not allowed for an HA-VPN tunnel.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ALLOCATING_RESOURCES" : Cloud VPN is in the process of allocating all
  /// required resources (specifically, a borg task).
  /// - "AUTHORIZATION_ERROR" : Auth error (e.g. bad shared secret).
  /// - "DEPROVISIONING" : Resources is being deallocated for the VPN tunnel.
  /// - "ESTABLISHED" : Secure session is successfully established with peer
  /// VPN.
  /// - "FAILED" : Tunnel creation has failed and the tunnel is not ready to be
  /// used.
  /// - "FIRST_HANDSHAKE" : Successful first handshake with peer VPN.
  /// - "NEGOTIATION_FAILURE" : Handshake failed.
  /// - "NETWORK_ERROR" : Deprecated, replaced by NO_INCOMING_PACKETS
  /// - "NO_INCOMING_PACKETS" : No incoming packets from peer
  /// - "PROVISIONING" : Resource is being allocated for the VPN tunnel.
  /// - "REJECTED" : Tunnel configuration was rejected, can be result of being
  /// denylisted.
  /// - "STOPPED" : Tunnel is stopped due to its Forwarding Rules being deleted.
  /// - "WAITING_FOR_FULL_CONFIG" : Waiting to receive all VPN-related configs
  /// from user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule and Route
  /// resources are needed to setup VPN tunnel.
  core.String? status;

  /// URL of the Target VPN gateway with which this VPN tunnel is associated.
  ///
  /// Provided by the client when the VPN tunnel is created.
  core.String? targetVpnGateway;

  /// URL of the VPN gateway with which this VPN tunnel is associated.
  ///
  /// Provided by the client when the VPN tunnel is created. This must be used
  /// (instead of target_vpn_gateway) if a High Availability VPN gateway
  /// resource is created.
  core.String? vpnGateway;

  /// The interface ID of the VPN gateway with which this VPN tunnel is
  /// associated.
  core.int? vpnGatewayInterface;

  VpnTunnel({
    this.creationTimestamp,
    this.description,
    this.detailedStatus,
    this.id,
    this.ikeVersion,
    this.kind,
    this.localTrafficSelector,
    this.name,
    this.peerExternalGateway,
    this.peerExternalGatewayInterface,
    this.peerGcpGateway,
    this.peerIp,
    this.region,
    this.remoteTrafficSelector,
    this.router,
    this.selfLink,
    this.sharedSecret,
    this.sharedSecretHash,
    this.status,
    this.targetVpnGateway,
    this.vpnGateway,
    this.vpnGatewayInterface,
  });

  VpnTunnel.fromJson(core.Map _json)
      : this(
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          detailedStatus: _json.containsKey('detailedStatus')
              ? _json['detailedStatus'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          ikeVersion: _json.containsKey('ikeVersion')
              ? _json['ikeVersion'] as core.int
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          localTrafficSelector: _json.containsKey('localTrafficSelector')
              ? (_json['localTrafficSelector'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          peerExternalGateway: _json.containsKey('peerExternalGateway')
              ? _json['peerExternalGateway'] as core.String
              : null,
          peerExternalGatewayInterface:
              _json.containsKey('peerExternalGatewayInterface')
                  ? _json['peerExternalGatewayInterface'] as core.int
                  : null,
          peerGcpGateway: _json.containsKey('peerGcpGateway')
              ? _json['peerGcpGateway'] as core.String
              : null,
          peerIp: _json.containsKey('peerIp')
              ? _json['peerIp'] as core.String
              : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          remoteTrafficSelector: _json.containsKey('remoteTrafficSelector')
              ? (_json['remoteTrafficSelector'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          router: _json.containsKey('router')
              ? _json['router'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          sharedSecret: _json.containsKey('sharedSecret')
              ? _json['sharedSecret'] as core.String
              : null,
          sharedSecretHash: _json.containsKey('sharedSecretHash')
              ? _json['sharedSecretHash'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          targetVpnGateway: _json.containsKey('targetVpnGateway')
              ? _json['targetVpnGateway'] as core.String
              : null,
          vpnGateway: _json.containsKey('vpnGateway')
              ? _json['vpnGateway'] as core.String
              : null,
          vpnGatewayInterface: _json.containsKey('vpnGatewayInterface')
              ? _json['vpnGatewayInterface'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (detailedStatus != null) 'detailedStatus': detailedStatus!,
        if (id != null) 'id': id!,
        if (ikeVersion != null) 'ikeVersion': ikeVersion!,
        if (kind != null) 'kind': kind!,
        if (localTrafficSelector != null)
          'localTrafficSelector': localTrafficSelector!,
        if (name != null) 'name': name!,
        if (peerExternalGateway != null)
          'peerExternalGateway': peerExternalGateway!,
        if (peerExternalGatewayInterface != null)
          'peerExternalGatewayInterface': peerExternalGatewayInterface!,
        if (peerGcpGateway != null) 'peerGcpGateway': peerGcpGateway!,
        if (peerIp != null) 'peerIp': peerIp!,
        if (region != null) 'region': region!,
        if (remoteTrafficSelector != null)
          'remoteTrafficSelector': remoteTrafficSelector!,
        if (router != null) 'router': router!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sharedSecret != null) 'sharedSecret': sharedSecret!,
        if (sharedSecretHash != null) 'sharedSecretHash': sharedSecretHash!,
        if (status != null) 'status': status!,
        if (targetVpnGateway != null) 'targetVpnGateway': targetVpnGateway!,
        if (vpnGateway != null) 'vpnGateway': vpnGateway!,
        if (vpnGatewayInterface != null)
          'vpnGatewayInterface': vpnGatewayInterface!,
      };
}

class VpnTunnelAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnTunnelAggregatedListWarningData({
    this.key,
    this.value,
  });

  VpnTunnelAggregatedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VpnTunnelAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnTunnelAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnTunnelAggregatedListWarning({
    this.code,
    this.data,
    this.message,
  });

  VpnTunnelAggregatedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<VpnTunnelAggregatedListWarningData>((value) =>
                      VpnTunnelAggregatedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class VpnTunnelAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of VpnTunnelsScopedList resources.
  core.Map<core.String, VpnTunnelsScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#vpnTunnel for VPN tunnels.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  VpnTunnelAggregatedListWarning? warning;

  VpnTunnelAggregatedList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.unreachables,
    this.warning,
  });

  VpnTunnelAggregatedList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    VpnTunnelsScopedList.fromJson(
                        item as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          unreachables: _json.containsKey('unreachables')
              ? (_json['unreachables'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? VpnTunnelAggregatedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class VpnTunnelListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnTunnelListWarningData({
    this.key,
    this.value,
  });

  VpnTunnelListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VpnTunnelListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnTunnelListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnTunnelListWarning({
    this.code,
    this.data,
    this.message,
  });

  VpnTunnelListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<VpnTunnelListWarningData>((value) =>
                      VpnTunnelListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of VpnTunnel resources.
class VpnTunnelList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of VpnTunnel resources.
  core.List<VpnTunnel>? items;

  /// Type of resource.
  ///
  /// Always compute#vpnTunnel for VPN tunnels.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  VpnTunnelListWarning? warning;

  VpnTunnelList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  VpnTunnelList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<VpnTunnel>((value) => VpnTunnel.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? VpnTunnelListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class VpnTunnelsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnTunnelsScopedListWarningData({
    this.key,
    this.value,
  });

  VpnTunnelsScopedListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class VpnTunnelsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnTunnelsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnTunnelsScopedListWarning({
    this.code,
    this.data,
    this.message,
  });

  VpnTunnelsScopedListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<VpnTunnelsScopedListWarningData>((value) =>
                      VpnTunnelsScopedListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class VpnTunnelsScopedList {
  /// A list of VPN tunnels contained in this scope.
  core.List<VpnTunnel>? vpnTunnels;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  VpnTunnelsScopedListWarning? warning;

  VpnTunnelsScopedList({
    this.vpnTunnels,
    this.warning,
  });

  VpnTunnelsScopedList.fromJson(core.Map _json)
      : this(
          vpnTunnels: _json.containsKey('vpnTunnels')
              ? (_json['vpnTunnels'] as core.List)
                  .map<VpnTunnel>((value) => VpnTunnel.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          warning: _json.containsKey('warning')
              ? VpnTunnelsScopedListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (vpnTunnels != null)
          'vpnTunnels': vpnTunnels!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class WafExpressionSet {
  /// A list of alternate IDs.
  ///
  /// The format should be: - E.g. XSS-stable Generic suffix like "stable" is
  /// particularly useful if a policy likes to avail newer set of expressions
  /// without having to change the policy. A given alias name can't be used for
  /// more than one entity set.
  core.List<core.String>? aliases;

  /// List of available expressions.
  core.List<WafExpressionSetExpression>? expressions;

  /// Google specified expression set ID.
  ///
  /// The format should be: - E.g. XSS-20170329 required
  core.String? id;

  WafExpressionSet({
    this.aliases,
    this.expressions,
    this.id,
  });

  WafExpressionSet.fromJson(core.Map _json)
      : this(
          aliases: _json.containsKey('aliases')
              ? (_json['aliases'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          expressions: _json.containsKey('expressions')
              ? (_json['expressions'] as core.List)
                  .map<WafExpressionSetExpression>((value) =>
                      WafExpressionSetExpression.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (aliases != null) 'aliases': aliases!,
        if (expressions != null)
          'expressions': expressions!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
      };
}

class WafExpressionSetExpression {
  /// Expression ID should uniquely identify the origin of the expression.
  ///
  /// E.g. owasp-crs-v020901-id973337 identifies Owasp core rule set version
  /// 2.9.1 rule id 973337. The ID could be used to determine the individual
  /// attack definition that has been detected. It could also be used to exclude
  /// it from the policy in case of false positive. required
  core.String? id;

  WafExpressionSetExpression({
    this.id,
  });

  WafExpressionSetExpression.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
      };
}

/// In contrast to a single BackendService in HttpRouteAction to which all
/// matching traffic is directed to, WeightedBackendService allows traffic to be
/// split across multiple BackendServices.
///
/// The volume of traffic for each BackendService is proportional to the weight
/// specified in each WeightedBackendService
class WeightedBackendService {
  /// The full or partial URL to the default BackendService resource.
  ///
  /// Before forwarding the request to backendService, the loadbalancer applies
  /// any relevant headerActions specified as part of this backendServiceWeight.
  core.String? backendService;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  ///
  /// headerAction specified here take effect before headerAction in the
  /// enclosing HttpRouteRule, PathMatcher and UrlMap. Note that headerAction is
  /// not supported for Loadbalancers that have their loadBalancingScheme set to
  /// EXTERNAL. Not supported when the URL map is bound to target gRPC proxy
  /// that has validateForProxyless field set to true.
  HttpHeaderAction? headerAction;

  /// Specifies the fraction of traffic sent to backendService, computed as
  /// weight / (sum of all weightedBackendService weights in routeAction) .
  ///
  /// The selection of a backend service is determined only for new traffic.
  /// Once a user's request has been directed to a backendService, subsequent
  /// requests will be sent to the same backendService as determined by the
  /// BackendService's session affinity policy. The value must be between 0 and
  /// 1000
  core.int? weight;

  WeightedBackendService({
    this.backendService,
    this.headerAction,
    this.weight,
  });

  WeightedBackendService.fromJson(core.Map _json)
      : this(
          backendService: _json.containsKey('backendService')
              ? _json['backendService'] as core.String
              : null,
          headerAction: _json.containsKey('headerAction')
              ? HttpHeaderAction.fromJson(
                  _json['headerAction'] as core.Map<core.String, core.dynamic>)
              : null,
          weight:
              _json.containsKey('weight') ? _json['weight'] as core.int : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendService != null) 'backendService': backendService!,
        if (headerAction != null) 'headerAction': headerAction!.toJson(),
        if (weight != null) 'weight': weight!,
      };
}

class XpnHostListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  XpnHostListWarningData({
    this.key,
    this.value,
  });

  XpnHostListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class XpnHostListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<XpnHostListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  XpnHostListWarning({
    this.code,
    this.data,
    this.message,
  });

  XpnHostListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<XpnHostListWarningData>((value) =>
                      XpnHostListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class XpnHostList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of shared VPC host project URLs.
  ///
  /// Output only.
  core.List<Project>? items;

  /// Type of resource.
  ///
  /// Always compute#xpnHostList for lists of shared VPC hosts.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  XpnHostListWarning? warning;

  XpnHostList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  XpnHostList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Project>((value) => Project.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? XpnHostListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Service resource (a.k.a service project) ID.
class XpnResourceId {
  /// The ID of the service resource.
  ///
  /// In the case of projects, this field supports project id (e.g.,
  /// my-project-123) and project number (e.g. 12345678).
  core.String? id;

  /// The type of the service resource.
  /// Possible string values are:
  /// - "PROJECT"
  /// - "XPN_RESOURCE_TYPE_UNSPECIFIED"
  core.String? type;

  XpnResourceId({
    this.id,
    this.type,
  });

  XpnResourceId.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          type: _json.containsKey('type') ? _json['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (type != null) 'type': type!,
      };
}

/// Represents a Zone resource.
///
/// A zone is a deployment area. These deployment areas are subsets of a region.
/// For example the zone us-east1-a is located in the us-east1 region. For more
/// information, read Regions and Zones.
class Zone {
  /// Available cpu/platform selections for the zone.
  ///
  /// Output only.
  core.List<core.String>? availableCpuPlatforms;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this zone.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// Textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#zone for zones.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// Full URL reference to the region which hosts the zone.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Status of the zone, either UP or DOWN.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String? status;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? supportsPzs;

  Zone({
    this.availableCpuPlatforms,
    this.creationTimestamp,
    this.deprecated,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.region,
    this.selfLink,
    this.status,
    this.supportsPzs,
  });

  Zone.fromJson(core.Map _json)
      : this(
          availableCpuPlatforms: _json.containsKey('availableCpuPlatforms')
              ? (_json['availableCpuPlatforms'] as core.List)
                  .map<core.String>((value) => value as core.String)
                  .toList()
              : null,
          creationTimestamp: _json.containsKey('creationTimestamp')
              ? _json['creationTimestamp'] as core.String
              : null,
          deprecated: _json.containsKey('deprecated')
              ? DeprecationStatus.fromJson(
                  _json['deprecated'] as core.Map<core.String, core.dynamic>)
              : null,
          description: _json.containsKey('description')
              ? _json['description'] as core.String
              : null,
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          name: _json.containsKey('name') ? _json['name'] as core.String : null,
          region: _json.containsKey('region')
              ? _json['region'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          status: _json.containsKey('status')
              ? _json['status'] as core.String
              : null,
          supportsPzs: _json.containsKey('supportsPzs')
              ? _json['supportsPzs'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (availableCpuPlatforms != null)
          'availableCpuPlatforms': availableCpuPlatforms!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (supportsPzs != null) 'supportsPzs': supportsPzs!,
      };
}

class ZoneListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ZoneListWarningData({
    this.key,
    this.value,
  });

  ZoneListWarningData.fromJson(core.Map _json)
      : this(
          key: _json.containsKey('key') ? _json['key'] as core.String : null,
          value:
              _json.containsKey('value') ? _json['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ZoneListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED" : Warning about failed cleanup of transient changes
  /// made by a failed operation.
  /// - "DEPRECATED_RESOURCE_USED" : A link to a deprecated resource was
  /// created.
  /// - "DEPRECATED_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as deprecated
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" : The user created a boot disk that
  /// is larger than image size.
  /// - "EXPERIMENTAL_TYPE_USED" : When deploying and at least one of the
  /// resources has a type marked as experimental
  /// - "EXTERNAL_API_WARNING" : Warning that is present in an external api call
  /// - "FIELD_VALUE_OVERRIDEN" : Warning that value of a field has been
  /// overridden. Deprecated unused field.
  /// - "INJECTED_KERNELS_DEPRECATED" : The operation involved use of an
  /// injected kernel, which is deprecated.
  /// - "LARGE_DEPLOYMENT_WARNING" : When deploying a deployment with a
  /// exceedingly large number of resources
  /// - "MISSING_TYPE_DEPENDENCY" : A resource depends on a missing type
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED" : The route's nextHopIp address is not
  /// assigned to an instance on the network.
  /// - "NEXT_HOP_CANNOT_IP_FORWARD" : The route's next hop instance cannot ip
  /// forward.
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND" : The route's nextHopInstance URL refers
  /// to an instance that does not exist.
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" : The route's nextHopInstance URL
  /// refers to an instance that is not on the same network as the route.
  /// - "NEXT_HOP_NOT_RUNNING" : The route's next hop instance does not have a
  /// status of RUNNING.
  /// - "NOT_CRITICAL_ERROR" : Error which is not critical. We decided to
  /// continue the process despite the mentioned error.
  /// - "NO_RESULTS_ON_PAGE" : No results are present on a particular list page.
  /// - "PARTIAL_SUCCESS" : Success is reported, but some results may be missing
  /// due to errors
  /// - "REQUIRED_TOS_AGREEMENT" : The user attempted to use a resource that
  /// requires a TOS they have not accepted.
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" : Warning that a resource is
  /// in use.
  /// - "RESOURCE_NOT_DELETED" : One or more of the resources set to auto-delete
  /// could not be deleted because they were in use.
  /// - "SCHEMA_VALIDATION_IGNORED" : When a resource schema validation is
  /// ignored.
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE" : Instance template used in instance
  /// group manager is valid as such, but its application does not make a lot of
  /// sense, because it allows only single instance in instance group.
  /// - "UNDECLARED_PROPERTIES" : When undeclared properties in the schema are
  /// present
  /// - "UNREACHABLE" : A given scope cannot be reached.
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example: "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ZoneListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ZoneListWarning({
    this.code,
    this.data,
    this.message,
  });

  ZoneListWarning.fromJson(core.Map _json)
      : this(
          code: _json.containsKey('code') ? _json['code'] as core.String : null,
          data: _json.containsKey('data')
              ? (_json['data'] as core.List)
                  .map<ZoneListWarningData>((value) =>
                      ZoneListWarningData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          message: _json.containsKey('message')
              ? _json['message'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of zone resources.
class ZoneList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Zone resources.
  core.List<Zone>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ZoneListWarning? warning;

  ZoneList({
    this.id,
    this.items,
    this.kind,
    this.nextPageToken,
    this.selfLink,
    this.warning,
  });

  ZoneList.fromJson(core.Map _json)
      : this(
          id: _json.containsKey('id') ? _json['id'] as core.String : null,
          items: _json.containsKey('items')
              ? (_json['items'] as core.List)
                  .map<Zone>((value) => Zone.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          kind: _json.containsKey('kind') ? _json['kind'] as core.String : null,
          nextPageToken: _json.containsKey('nextPageToken')
              ? _json['nextPageToken'] as core.String
              : null,
          selfLink: _json.containsKey('selfLink')
              ? _json['selfLink'] as core.String
              : null,
          warning: _json.containsKey('warning')
              ? ZoneListWarning.fromJson(
                  _json['warning'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ZoneSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels. Make a
  /// get() request to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String>? labels;

  ZoneSetLabelsRequest({
    this.labelFingerprint,
    this.labels,
  });

  ZoneSetLabelsRequest.fromJson(core.Map _json)
      : this(
          labelFingerprint: _json.containsKey('labelFingerprint')
              ? _json['labelFingerprint'] as core.String
              : null,
          labels: _json.containsKey('labels')
              ? (_json['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, item) => core.MapEntry(
                    key,
                    item as core.String,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
      };
}

class ZoneSetPolicyRequest {
  /// Flatten Policy to create a backwacd compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify bindings.
  core.List<Binding>? bindings;

  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify the etag.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is
  /// in general a valid policy but certain services (like Projects) might
  /// reject them.
  Policy? policy;

  ZoneSetPolicyRequest({
    this.bindings,
    this.etag,
    this.policy,
  });

  ZoneSetPolicyRequest.fromJson(core.Map _json)
      : this(
          bindings: _json.containsKey('bindings')
              ? (_json['bindings'] as core.List)
                  .map<Binding>((value) => Binding.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          etag: _json.containsKey('etag') ? _json['etag'] as core.String : null,
          policy: _json.containsKey('policy')
              ? Policy.fromJson(
                  _json['policy'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (policy != null) 'policy': policy!.toJson(),
      };
}
