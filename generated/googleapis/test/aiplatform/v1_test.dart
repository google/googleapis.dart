// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_const_declarations
// ignore_for_file: prefer_expression_function_bodies
// ignore_for_file: prefer_final_locals
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_string_interpolations
// ignore_for_file: unreachable_from_main
// ignore_for_file: unused_local_variable

import 'dart:async' as async;
import 'dart:convert' as convert;
import 'dart:core' as core;

import 'package:googleapis/aiplatform/v1.dart' as api;
import 'package:http/http.dart' as http;
import 'package:test/test.dart' as unittest;

import '../test_shared.dart';

core.Map<core.String, core.Object?> buildUnnamed0() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed0(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted1 = (o['x']!) as core.Map;
  unittest.expect(casted1, unittest.hasLength(3));
  unittest.expect(
    casted1['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted1['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted1['string'],
    unittest.equals('foo'),
  );
  var casted2 = (o['y']!) as core.Map;
  unittest.expect(casted2, unittest.hasLength(3));
  unittest.expect(
    casted2['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted2['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted2['string'],
    unittest.equals('foo'),
  );
}

core.List<core.Map<core.String, core.Object?>> buildUnnamed1() => [
      buildUnnamed0(),
      buildUnnamed0(),
    ];

void checkUnnamed1(core.List<core.Map<core.String, core.Object?>> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkUnnamed0(o[0]);
  checkUnnamed0(o[1]);
}

core.int buildCounterGoogleApiHttpBody = 0;
api.GoogleApiHttpBody buildGoogleApiHttpBody() {
  final o = api.GoogleApiHttpBody();
  buildCounterGoogleApiHttpBody++;
  if (buildCounterGoogleApiHttpBody < 3) {
    o.contentType = 'foo';
    o.data = 'foo';
    o.extensions = buildUnnamed1();
  }
  buildCounterGoogleApiHttpBody--;
  return o;
}

void checkGoogleApiHttpBody(api.GoogleApiHttpBody o) {
  buildCounterGoogleApiHttpBody++;
  if (buildCounterGoogleApiHttpBody < 3) {
    unittest.expect(
      o.contentType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.data!,
      unittest.equals('foo'),
    );
    checkUnnamed1(o.extensions!);
  }
  buildCounterGoogleApiHttpBody--;
}

core.int buildCounterGoogleCloudAiplatformV1ActiveLearningConfig = 0;
api.GoogleCloudAiplatformV1ActiveLearningConfig
    buildGoogleCloudAiplatformV1ActiveLearningConfig() {
  final o = api.GoogleCloudAiplatformV1ActiveLearningConfig();
  buildCounterGoogleCloudAiplatformV1ActiveLearningConfig++;
  if (buildCounterGoogleCloudAiplatformV1ActiveLearningConfig < 3) {
    o.maxDataItemCount = 'foo';
    o.maxDataItemPercentage = 42;
    o.sampleConfig = buildGoogleCloudAiplatformV1SampleConfig();
    o.trainingConfig = buildGoogleCloudAiplatformV1TrainingConfig();
  }
  buildCounterGoogleCloudAiplatformV1ActiveLearningConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ActiveLearningConfig(
    api.GoogleCloudAiplatformV1ActiveLearningConfig o) {
  buildCounterGoogleCloudAiplatformV1ActiveLearningConfig++;
  if (buildCounterGoogleCloudAiplatformV1ActiveLearningConfig < 3) {
    unittest.expect(
      o.maxDataItemCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.maxDataItemPercentage!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1SampleConfig(o.sampleConfig!);
    checkGoogleCloudAiplatformV1TrainingConfig(o.trainingConfig!);
  }
  buildCounterGoogleCloudAiplatformV1ActiveLearningConfig--;
}

core.List<core.String> buildUnnamed2() => [
      'foo',
      'foo',
    ];

void checkUnnamed2(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed3() => [
      'foo',
      'foo',
    ];

void checkUnnamed3(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest =
    0;
api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest
    buildGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest() {
  final o =
      api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest();
  buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest++;
  if (buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest <
      3) {
    o.artifacts = buildUnnamed2();
    o.executions = buildUnnamed3();
  }
  buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest(
    api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest o) {
  buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest++;
  if (buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest <
      3) {
    checkUnnamed2(o.artifacts!);
    checkUnnamed3(o.executions!);
  }
  buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse =
    0;
api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse
    buildGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse() {
  final o =
      api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse();
  buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse++;
  if (buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse <
      3) {}
  buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse(
    api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse o) {
  buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse++;
  if (buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse <
      3) {}
  buildCounterGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse--;
}

core.List<core.String> buildUnnamed4() => [
      'foo',
      'foo',
    ];

void checkUnnamed4(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1AddContextChildrenRequest = 0;
api.GoogleCloudAiplatformV1AddContextChildrenRequest
    buildGoogleCloudAiplatformV1AddContextChildrenRequest() {
  final o = api.GoogleCloudAiplatformV1AddContextChildrenRequest();
  buildCounterGoogleCloudAiplatformV1AddContextChildrenRequest++;
  if (buildCounterGoogleCloudAiplatformV1AddContextChildrenRequest < 3) {
    o.childContexts = buildUnnamed4();
  }
  buildCounterGoogleCloudAiplatformV1AddContextChildrenRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1AddContextChildrenRequest(
    api.GoogleCloudAiplatformV1AddContextChildrenRequest o) {
  buildCounterGoogleCloudAiplatformV1AddContextChildrenRequest++;
  if (buildCounterGoogleCloudAiplatformV1AddContextChildrenRequest < 3) {
    checkUnnamed4(o.childContexts!);
  }
  buildCounterGoogleCloudAiplatformV1AddContextChildrenRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1AddContextChildrenResponse = 0;
api.GoogleCloudAiplatformV1AddContextChildrenResponse
    buildGoogleCloudAiplatformV1AddContextChildrenResponse() {
  final o = api.GoogleCloudAiplatformV1AddContextChildrenResponse();
  buildCounterGoogleCloudAiplatformV1AddContextChildrenResponse++;
  if (buildCounterGoogleCloudAiplatformV1AddContextChildrenResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1AddContextChildrenResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1AddContextChildrenResponse(
    api.GoogleCloudAiplatformV1AddContextChildrenResponse o) {
  buildCounterGoogleCloudAiplatformV1AddContextChildrenResponse++;
  if (buildCounterGoogleCloudAiplatformV1AddContextChildrenResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1AddContextChildrenResponse--;
}

core.List<api.GoogleCloudAiplatformV1Event> buildUnnamed5() => [
      buildGoogleCloudAiplatformV1Event(),
      buildGoogleCloudAiplatformV1Event(),
    ];

void checkUnnamed5(core.List<api.GoogleCloudAiplatformV1Event> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Event(o[0]);
  checkGoogleCloudAiplatformV1Event(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1AddExecutionEventsRequest = 0;
api.GoogleCloudAiplatformV1AddExecutionEventsRequest
    buildGoogleCloudAiplatformV1AddExecutionEventsRequest() {
  final o = api.GoogleCloudAiplatformV1AddExecutionEventsRequest();
  buildCounterGoogleCloudAiplatformV1AddExecutionEventsRequest++;
  if (buildCounterGoogleCloudAiplatformV1AddExecutionEventsRequest < 3) {
    o.events = buildUnnamed5();
  }
  buildCounterGoogleCloudAiplatformV1AddExecutionEventsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1AddExecutionEventsRequest(
    api.GoogleCloudAiplatformV1AddExecutionEventsRequest o) {
  buildCounterGoogleCloudAiplatformV1AddExecutionEventsRequest++;
  if (buildCounterGoogleCloudAiplatformV1AddExecutionEventsRequest < 3) {
    checkUnnamed5(o.events!);
  }
  buildCounterGoogleCloudAiplatformV1AddExecutionEventsRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1AddExecutionEventsResponse = 0;
api.GoogleCloudAiplatformV1AddExecutionEventsResponse
    buildGoogleCloudAiplatformV1AddExecutionEventsResponse() {
  final o = api.GoogleCloudAiplatformV1AddExecutionEventsResponse();
  buildCounterGoogleCloudAiplatformV1AddExecutionEventsResponse++;
  if (buildCounterGoogleCloudAiplatformV1AddExecutionEventsResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1AddExecutionEventsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1AddExecutionEventsResponse(
    api.GoogleCloudAiplatformV1AddExecutionEventsResponse o) {
  buildCounterGoogleCloudAiplatformV1AddExecutionEventsResponse++;
  if (buildCounterGoogleCloudAiplatformV1AddExecutionEventsResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1AddExecutionEventsResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1AddTrialMeasurementRequest = 0;
api.GoogleCloudAiplatformV1AddTrialMeasurementRequest
    buildGoogleCloudAiplatformV1AddTrialMeasurementRequest() {
  final o = api.GoogleCloudAiplatformV1AddTrialMeasurementRequest();
  buildCounterGoogleCloudAiplatformV1AddTrialMeasurementRequest++;
  if (buildCounterGoogleCloudAiplatformV1AddTrialMeasurementRequest < 3) {
    o.measurement = buildGoogleCloudAiplatformV1Measurement();
  }
  buildCounterGoogleCloudAiplatformV1AddTrialMeasurementRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1AddTrialMeasurementRequest(
    api.GoogleCloudAiplatformV1AddTrialMeasurementRequest o) {
  buildCounterGoogleCloudAiplatformV1AddTrialMeasurementRequest++;
  if (buildCounterGoogleCloudAiplatformV1AddTrialMeasurementRequest < 3) {
    checkGoogleCloudAiplatformV1Measurement(o.measurement!);
  }
  buildCounterGoogleCloudAiplatformV1AddTrialMeasurementRequest--;
}

core.Map<core.String, core.String> buildUnnamed6() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed6(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Annotation = 0;
api.GoogleCloudAiplatformV1Annotation buildGoogleCloudAiplatformV1Annotation() {
  final o = api.GoogleCloudAiplatformV1Annotation();
  buildCounterGoogleCloudAiplatformV1Annotation++;
  if (buildCounterGoogleCloudAiplatformV1Annotation < 3) {
    o.annotationSource = buildGoogleCloudAiplatformV1UserActionReference();
    o.createTime = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed6();
    o.name = 'foo';
    o.payload = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.payloadSchemaUri = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Annotation--;
  return o;
}

void checkGoogleCloudAiplatformV1Annotation(
    api.GoogleCloudAiplatformV1Annotation o) {
  buildCounterGoogleCloudAiplatformV1Annotation++;
  if (buildCounterGoogleCloudAiplatformV1Annotation < 3) {
    checkGoogleCloudAiplatformV1UserActionReference(o.annotationSource!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed6(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    var casted3 = (o.payload!) as core.Map;
    unittest.expect(casted3, unittest.hasLength(3));
    unittest.expect(
      casted3['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted3['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted3['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.payloadSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Annotation--;
}

core.int buildCounterGoogleCloudAiplatformV1AnnotationSpec = 0;
api.GoogleCloudAiplatformV1AnnotationSpec
    buildGoogleCloudAiplatformV1AnnotationSpec() {
  final o = api.GoogleCloudAiplatformV1AnnotationSpec();
  buildCounterGoogleCloudAiplatformV1AnnotationSpec++;
  if (buildCounterGoogleCloudAiplatformV1AnnotationSpec < 3) {
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.name = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1AnnotationSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1AnnotationSpec(
    api.GoogleCloudAiplatformV1AnnotationSpec o) {
  buildCounterGoogleCloudAiplatformV1AnnotationSpec++;
  if (buildCounterGoogleCloudAiplatformV1AnnotationSpec < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1AnnotationSpec--;
}

core.Map<core.String, core.String> buildUnnamed7() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed7(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.Object?> buildUnnamed8() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed8(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted4 = (o['x']!) as core.Map;
  unittest.expect(casted4, unittest.hasLength(3));
  unittest.expect(
    casted4['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted4['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted4['string'],
    unittest.equals('foo'),
  );
  var casted5 = (o['y']!) as core.Map;
  unittest.expect(casted5, unittest.hasLength(3));
  unittest.expect(
    casted5['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted5['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted5['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Artifact = 0;
api.GoogleCloudAiplatformV1Artifact buildGoogleCloudAiplatformV1Artifact() {
  final o = api.GoogleCloudAiplatformV1Artifact();
  buildCounterGoogleCloudAiplatformV1Artifact++;
  if (buildCounterGoogleCloudAiplatformV1Artifact < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed7();
    o.metadata = buildUnnamed8();
    o.name = 'foo';
    o.schemaTitle = 'foo';
    o.schemaVersion = 'foo';
    o.state = 'foo';
    o.updateTime = 'foo';
    o.uri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Artifact--;
  return o;
}

void checkGoogleCloudAiplatformV1Artifact(
    api.GoogleCloudAiplatformV1Artifact o) {
  buildCounterGoogleCloudAiplatformV1Artifact++;
  if (buildCounterGoogleCloudAiplatformV1Artifact < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed7(o.labels!);
    checkUnnamed8(o.metadata!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.schemaTitle!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.schemaVersion!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.uri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Artifact--;
}

core.int buildCounterGoogleCloudAiplatformV1AssignNotebookRuntimeRequest = 0;
api.GoogleCloudAiplatformV1AssignNotebookRuntimeRequest
    buildGoogleCloudAiplatformV1AssignNotebookRuntimeRequest() {
  final o = api.GoogleCloudAiplatformV1AssignNotebookRuntimeRequest();
  buildCounterGoogleCloudAiplatformV1AssignNotebookRuntimeRequest++;
  if (buildCounterGoogleCloudAiplatformV1AssignNotebookRuntimeRequest < 3) {
    o.notebookRuntime = buildGoogleCloudAiplatformV1NotebookRuntime();
    o.notebookRuntimeId = 'foo';
    o.notebookRuntimeTemplate = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1AssignNotebookRuntimeRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1AssignNotebookRuntimeRequest(
    api.GoogleCloudAiplatformV1AssignNotebookRuntimeRequest o) {
  buildCounterGoogleCloudAiplatformV1AssignNotebookRuntimeRequest++;
  if (buildCounterGoogleCloudAiplatformV1AssignNotebookRuntimeRequest < 3) {
    checkGoogleCloudAiplatformV1NotebookRuntime(o.notebookRuntime!);
    unittest.expect(
      o.notebookRuntimeId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.notebookRuntimeTemplate!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1AssignNotebookRuntimeRequest--;
}

core.List<core.int> buildUnnamed9() => [
      42,
      42,
    ];

void checkUnnamed9(core.List<core.int> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42),
  );
  unittest.expect(
    o[1],
    unittest.equals(42),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Attribution = 0;
api.GoogleCloudAiplatformV1Attribution
    buildGoogleCloudAiplatformV1Attribution() {
  final o = api.GoogleCloudAiplatformV1Attribution();
  buildCounterGoogleCloudAiplatformV1Attribution++;
  if (buildCounterGoogleCloudAiplatformV1Attribution < 3) {
    o.approximationError = 42.0;
    o.baselineOutputValue = 42.0;
    o.featureAttributions = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.instanceOutputValue = 42.0;
    o.outputDisplayName = 'foo';
    o.outputIndex = buildUnnamed9();
    o.outputName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Attribution--;
  return o;
}

void checkGoogleCloudAiplatformV1Attribution(
    api.GoogleCloudAiplatformV1Attribution o) {
  buildCounterGoogleCloudAiplatformV1Attribution++;
  if (buildCounterGoogleCloudAiplatformV1Attribution < 3) {
    unittest.expect(
      o.approximationError!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.baselineOutputValue!,
      unittest.equals(42.0),
    );
    var casted6 = (o.featureAttributions!) as core.Map;
    unittest.expect(casted6, unittest.hasLength(3));
    unittest.expect(
      casted6['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted6['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted6['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.instanceOutputValue!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.outputDisplayName!,
      unittest.equals('foo'),
    );
    checkUnnamed9(o.outputIndex!);
    unittest.expect(
      o.outputName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Attribution--;
}

core.int buildCounterGoogleCloudAiplatformV1AutomaticResources = 0;
api.GoogleCloudAiplatformV1AutomaticResources
    buildGoogleCloudAiplatformV1AutomaticResources() {
  final o = api.GoogleCloudAiplatformV1AutomaticResources();
  buildCounterGoogleCloudAiplatformV1AutomaticResources++;
  if (buildCounterGoogleCloudAiplatformV1AutomaticResources < 3) {
    o.maxReplicaCount = 42;
    o.minReplicaCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1AutomaticResources--;
  return o;
}

void checkGoogleCloudAiplatformV1AutomaticResources(
    api.GoogleCloudAiplatformV1AutomaticResources o) {
  buildCounterGoogleCloudAiplatformV1AutomaticResources++;
  if (buildCounterGoogleCloudAiplatformV1AutomaticResources < 3) {
    unittest.expect(
      o.maxReplicaCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.minReplicaCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1AutomaticResources--;
}

core.int buildCounterGoogleCloudAiplatformV1AutoscalingMetricSpec = 0;
api.GoogleCloudAiplatformV1AutoscalingMetricSpec
    buildGoogleCloudAiplatformV1AutoscalingMetricSpec() {
  final o = api.GoogleCloudAiplatformV1AutoscalingMetricSpec();
  buildCounterGoogleCloudAiplatformV1AutoscalingMetricSpec++;
  if (buildCounterGoogleCloudAiplatformV1AutoscalingMetricSpec < 3) {
    o.metricName = 'foo';
    o.target = 42;
  }
  buildCounterGoogleCloudAiplatformV1AutoscalingMetricSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1AutoscalingMetricSpec(
    api.GoogleCloudAiplatformV1AutoscalingMetricSpec o) {
  buildCounterGoogleCloudAiplatformV1AutoscalingMetricSpec++;
  if (buildCounterGoogleCloudAiplatformV1AutoscalingMetricSpec < 3) {
    unittest.expect(
      o.metricName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.target!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1AutoscalingMetricSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1AvroSource = 0;
api.GoogleCloudAiplatformV1AvroSource buildGoogleCloudAiplatformV1AvroSource() {
  final o = api.GoogleCloudAiplatformV1AvroSource();
  buildCounterGoogleCloudAiplatformV1AvroSource++;
  if (buildCounterGoogleCloudAiplatformV1AvroSource < 3) {
    o.gcsSource = buildGoogleCloudAiplatformV1GcsSource();
  }
  buildCounterGoogleCloudAiplatformV1AvroSource--;
  return o;
}

void checkGoogleCloudAiplatformV1AvroSource(
    api.GoogleCloudAiplatformV1AvroSource o) {
  buildCounterGoogleCloudAiplatformV1AvroSource++;
  if (buildCounterGoogleCloudAiplatformV1AvroSource < 3) {
    checkGoogleCloudAiplatformV1GcsSource(o.gcsSource!);
  }
  buildCounterGoogleCloudAiplatformV1AvroSource--;
}

core.List<core.String> buildUnnamed10() => [
      'foo',
      'foo',
    ];

void checkUnnamed10(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest = 0;
api.GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest
    buildGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest() {
  final o = api.GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest();
  buildCounterGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest < 3) {
    o.names = buildUnnamed10();
  }
  buildCounterGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest(
    api.GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest o) {
  buildCounterGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest < 3) {
    checkUnnamed10(o.names!);
  }
  buildCounterGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest--;
}

core.List<api.GoogleCloudAiplatformV1CreateFeatureRequest> buildUnnamed11() => [
      buildGoogleCloudAiplatformV1CreateFeatureRequest(),
      buildGoogleCloudAiplatformV1CreateFeatureRequest(),
    ];

void checkUnnamed11(
    core.List<api.GoogleCloudAiplatformV1CreateFeatureRequest> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1CreateFeatureRequest(o[0]);
  checkGoogleCloudAiplatformV1CreateFeatureRequest(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1BatchCreateFeaturesRequest = 0;
api.GoogleCloudAiplatformV1BatchCreateFeaturesRequest
    buildGoogleCloudAiplatformV1BatchCreateFeaturesRequest() {
  final o = api.GoogleCloudAiplatformV1BatchCreateFeaturesRequest();
  buildCounterGoogleCloudAiplatformV1BatchCreateFeaturesRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateFeaturesRequest < 3) {
    o.requests = buildUnnamed11();
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateFeaturesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchCreateFeaturesRequest(
    api.GoogleCloudAiplatformV1BatchCreateFeaturesRequest o) {
  buildCounterGoogleCloudAiplatformV1BatchCreateFeaturesRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateFeaturesRequest < 3) {
    checkUnnamed11(o.requests!);
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateFeaturesRequest--;
}

core.List<api.GoogleCloudAiplatformV1CreateTensorboardRunRequest>
    buildUnnamed12() => [
          buildGoogleCloudAiplatformV1CreateTensorboardRunRequest(),
          buildGoogleCloudAiplatformV1CreateTensorboardRunRequest(),
        ];

void checkUnnamed12(
    core.List<api.GoogleCloudAiplatformV1CreateTensorboardRunRequest> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1CreateTensorboardRunRequest(o[0]);
  checkGoogleCloudAiplatformV1CreateTensorboardRunRequest(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest =
    0;
api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest
    buildGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest() {
  final o = api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest();
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest <
      3) {
    o.requests = buildUnnamed12();
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest(
    api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest o) {
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest <
      3) {
    checkUnnamed12(o.requests!);
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest--;
}

core.List<api.GoogleCloudAiplatformV1TensorboardRun> buildUnnamed13() => [
      buildGoogleCloudAiplatformV1TensorboardRun(),
      buildGoogleCloudAiplatformV1TensorboardRun(),
    ];

void checkUnnamed13(core.List<api.GoogleCloudAiplatformV1TensorboardRun> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TensorboardRun(o[0]);
  checkGoogleCloudAiplatformV1TensorboardRun(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse =
    0;
api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse
    buildGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse() {
  final o = api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse();
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse <
      3) {
    o.tensorboardRuns = buildUnnamed13();
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse(
    api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse o) {
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse <
      3) {
    checkUnnamed13(o.tensorboardRuns!);
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse--;
}

core.List<api.GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest>
    buildUnnamed14() => [
          buildGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest(),
          buildGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest(),
        ];

void checkUnnamed14(
    core.List<api.GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest(o[0]);
  checkGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest =
    0;
api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest
    buildGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest() {
  final o =
      api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest();
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest <
      3) {
    o.requests = buildUnnamed14();
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest(
    api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest o) {
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest <
      3) {
    checkUnnamed14(o.requests!);
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest--;
}

core.List<api.GoogleCloudAiplatformV1TensorboardTimeSeries> buildUnnamed15() =>
    [
      buildGoogleCloudAiplatformV1TensorboardTimeSeries(),
      buildGoogleCloudAiplatformV1TensorboardTimeSeries(),
    ];

void checkUnnamed15(
    core.List<api.GoogleCloudAiplatformV1TensorboardTimeSeries> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TensorboardTimeSeries(o[0]);
  checkGoogleCloudAiplatformV1TensorboardTimeSeries(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse =
    0;
api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse
    buildGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse() {
  final o =
      api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse();
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse <
      3) {
    o.tensorboardTimeSeries = buildUnnamed15();
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse(
    api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse o) {
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse++;
  if (buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse <
      3) {
    checkUnnamed15(o.tensorboardTimeSeries!);
  }
  buildCounterGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1BatchDedicatedResources = 0;
api.GoogleCloudAiplatformV1BatchDedicatedResources
    buildGoogleCloudAiplatformV1BatchDedicatedResources() {
  final o = api.GoogleCloudAiplatformV1BatchDedicatedResources();
  buildCounterGoogleCloudAiplatformV1BatchDedicatedResources++;
  if (buildCounterGoogleCloudAiplatformV1BatchDedicatedResources < 3) {
    o.machineSpec = buildGoogleCloudAiplatformV1MachineSpec();
    o.maxReplicaCount = 42;
    o.startingReplicaCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1BatchDedicatedResources--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchDedicatedResources(
    api.GoogleCloudAiplatformV1BatchDedicatedResources o) {
  buildCounterGoogleCloudAiplatformV1BatchDedicatedResources++;
  if (buildCounterGoogleCloudAiplatformV1BatchDedicatedResources < 3) {
    checkGoogleCloudAiplatformV1MachineSpec(o.machineSpec!);
    unittest.expect(
      o.maxReplicaCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.startingReplicaCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchDedicatedResources--;
}

core.List<core.String> buildUnnamed16() => [
      'foo',
      'foo',
    ];

void checkUnnamed16(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest = 0;
api.GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest
    buildGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest() {
  final o = api.GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest();
  buildCounterGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest < 3) {
    o.names = buildUnnamed16();
  }
  buildCounterGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest(
    api.GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest o) {
  buildCounterGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest < 3) {
    checkUnnamed16(o.names!);
  }
  buildCounterGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest--;
}

core.List<api.GoogleCloudAiplatformV1EvaluatedAnnotation> buildUnnamed17() => [
      buildGoogleCloudAiplatformV1EvaluatedAnnotation(),
      buildGoogleCloudAiplatformV1EvaluatedAnnotation(),
    ];

void checkUnnamed17(
    core.List<api.GoogleCloudAiplatformV1EvaluatedAnnotation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1EvaluatedAnnotation(o[0]);
  checkGoogleCloudAiplatformV1EvaluatedAnnotation(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest =
    0;
api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest
    buildGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest() {
  final o = api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest();
  buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest <
      3) {
    o.evaluatedAnnotations = buildUnnamed17();
  }
  buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest(
    api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest o) {
  buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest <
      3) {
    checkUnnamed17(o.evaluatedAnnotations!);
  }
  buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse =
    0;
api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse
    buildGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse() {
  final o =
      api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse();
  buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse++;
  if (buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse <
      3) {
    o.importedEvaluatedAnnotationsCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse(
    api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse o) {
  buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse++;
  if (buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse <
      3) {
    unittest.expect(
      o.importedEvaluatedAnnotationsCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse--;
}

core.List<api.GoogleCloudAiplatformV1MigrateResourceRequest> buildUnnamed18() =>
    [
      buildGoogleCloudAiplatformV1MigrateResourceRequest(),
      buildGoogleCloudAiplatformV1MigrateResourceRequest(),
    ];

void checkUnnamed18(
    core.List<api.GoogleCloudAiplatformV1MigrateResourceRequest> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1MigrateResourceRequest(o[0]);
  checkGoogleCloudAiplatformV1MigrateResourceRequest(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1BatchMigrateResourcesRequest = 0;
api.GoogleCloudAiplatformV1BatchMigrateResourcesRequest
    buildGoogleCloudAiplatformV1BatchMigrateResourcesRequest() {
  final o = api.GoogleCloudAiplatformV1BatchMigrateResourcesRequest();
  buildCounterGoogleCloudAiplatformV1BatchMigrateResourcesRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchMigrateResourcesRequest < 3) {
    o.migrateResourceRequests = buildUnnamed18();
  }
  buildCounterGoogleCloudAiplatformV1BatchMigrateResourcesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchMigrateResourcesRequest(
    api.GoogleCloudAiplatformV1BatchMigrateResourcesRequest o) {
  buildCounterGoogleCloudAiplatformV1BatchMigrateResourcesRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchMigrateResourcesRequest < 3) {
    checkUnnamed18(o.migrateResourceRequests!);
  }
  buildCounterGoogleCloudAiplatformV1BatchMigrateResourcesRequest--;
}

core.Map<core.String, core.String> buildUnnamed19() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed19(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<api.GoogleRpcStatus> buildUnnamed20() => [
      buildGoogleRpcStatus(),
      buildGoogleRpcStatus(),
    ];

void checkUnnamed20(core.List<api.GoogleRpcStatus> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleRpcStatus(o[0]);
  checkGoogleRpcStatus(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1BatchPredictionJob = 0;
api.GoogleCloudAiplatformV1BatchPredictionJob
    buildGoogleCloudAiplatformV1BatchPredictionJob() {
  final o = api.GoogleCloudAiplatformV1BatchPredictionJob();
  buildCounterGoogleCloudAiplatformV1BatchPredictionJob++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJob < 3) {
    o.completionStats = buildGoogleCloudAiplatformV1CompletionStats();
    o.createTime = 'foo';
    o.dedicatedResources =
        buildGoogleCloudAiplatformV1BatchDedicatedResources();
    o.disableContainerLogging = true;
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.endTime = 'foo';
    o.error = buildGoogleRpcStatus();
    o.explanationSpec = buildGoogleCloudAiplatformV1ExplanationSpec();
    o.generateExplanation = true;
    o.inputConfig = buildGoogleCloudAiplatformV1BatchPredictionJobInputConfig();
    o.instanceConfig =
        buildGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig();
    o.labels = buildUnnamed19();
    o.manualBatchTuningParameters =
        buildGoogleCloudAiplatformV1ManualBatchTuningParameters();
    o.model = 'foo';
    o.modelParameters = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.modelVersionId = 'foo';
    o.name = 'foo';
    o.outputConfig =
        buildGoogleCloudAiplatformV1BatchPredictionJobOutputConfig();
    o.outputInfo = buildGoogleCloudAiplatformV1BatchPredictionJobOutputInfo();
    o.partialFailures = buildUnnamed20();
    o.resourcesConsumed = buildGoogleCloudAiplatformV1ResourcesConsumed();
    o.serviceAccount = 'foo';
    o.startTime = 'foo';
    o.state = 'foo';
    o.unmanagedContainerModel =
        buildGoogleCloudAiplatformV1UnmanagedContainerModel();
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJob--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchPredictionJob(
    api.GoogleCloudAiplatformV1BatchPredictionJob o) {
  buildCounterGoogleCloudAiplatformV1BatchPredictionJob++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJob < 3) {
    checkGoogleCloudAiplatformV1CompletionStats(o.completionStats!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1BatchDedicatedResources(o.dedicatedResources!);
    unittest.expect(o.disableContainerLogging!, unittest.isTrue);
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.error!);
    checkGoogleCloudAiplatformV1ExplanationSpec(o.explanationSpec!);
    unittest.expect(o.generateExplanation!, unittest.isTrue);
    checkGoogleCloudAiplatformV1BatchPredictionJobInputConfig(o.inputConfig!);
    checkGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig(
        o.instanceConfig!);
    checkUnnamed19(o.labels!);
    checkGoogleCloudAiplatformV1ManualBatchTuningParameters(
        o.manualBatchTuningParameters!);
    unittest.expect(
      o.model!,
      unittest.equals('foo'),
    );
    var casted7 = (o.modelParameters!) as core.Map;
    unittest.expect(casted7, unittest.hasLength(3));
    unittest.expect(
      casted7['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted7['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted7['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modelVersionId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1BatchPredictionJobOutputConfig(o.outputConfig!);
    checkGoogleCloudAiplatformV1BatchPredictionJobOutputInfo(o.outputInfo!);
    checkUnnamed20(o.partialFailures!);
    checkGoogleCloudAiplatformV1ResourcesConsumed(o.resourcesConsumed!);
    unittest.expect(
      o.serviceAccount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1UnmanagedContainerModel(
        o.unmanagedContainerModel!);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJob--;
}

core.int buildCounterGoogleCloudAiplatformV1BatchPredictionJobInputConfig = 0;
api.GoogleCloudAiplatformV1BatchPredictionJobInputConfig
    buildGoogleCloudAiplatformV1BatchPredictionJobInputConfig() {
  final o = api.GoogleCloudAiplatformV1BatchPredictionJobInputConfig();
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobInputConfig++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJobInputConfig < 3) {
    o.bigquerySource = buildGoogleCloudAiplatformV1BigQuerySource();
    o.gcsSource = buildGoogleCloudAiplatformV1GcsSource();
    o.instancesFormat = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobInputConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchPredictionJobInputConfig(
    api.GoogleCloudAiplatformV1BatchPredictionJobInputConfig o) {
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobInputConfig++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJobInputConfig < 3) {
    checkGoogleCloudAiplatformV1BigQuerySource(o.bigquerySource!);
    checkGoogleCloudAiplatformV1GcsSource(o.gcsSource!);
    unittest.expect(
      o.instancesFormat!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobInputConfig--;
}

core.List<core.String> buildUnnamed21() => [
      'foo',
      'foo',
    ];

void checkUnnamed21(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed22() => [
      'foo',
      'foo',
    ];

void checkUnnamed22(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig =
    0;
api.GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig
    buildGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig() {
  final o = api.GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig();
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig < 3) {
    o.excludedFields = buildUnnamed21();
    o.includedFields = buildUnnamed22();
    o.instanceType = 'foo';
    o.keyField = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig(
    api.GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig o) {
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig < 3) {
    checkUnnamed21(o.excludedFields!);
    checkUnnamed22(o.includedFields!);
    unittest.expect(
      o.instanceType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.keyField!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputConfig = 0;
api.GoogleCloudAiplatformV1BatchPredictionJobOutputConfig
    buildGoogleCloudAiplatformV1BatchPredictionJobOutputConfig() {
  final o = api.GoogleCloudAiplatformV1BatchPredictionJobOutputConfig();
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputConfig++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputConfig < 3) {
    o.bigqueryDestination = buildGoogleCloudAiplatformV1BigQueryDestination();
    o.gcsDestination = buildGoogleCloudAiplatformV1GcsDestination();
    o.predictionsFormat = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchPredictionJobOutputConfig(
    api.GoogleCloudAiplatformV1BatchPredictionJobOutputConfig o) {
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputConfig++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputConfig < 3) {
    checkGoogleCloudAiplatformV1BigQueryDestination(o.bigqueryDestination!);
    checkGoogleCloudAiplatformV1GcsDestination(o.gcsDestination!);
    unittest.expect(
      o.predictionsFormat!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputInfo = 0;
api.GoogleCloudAiplatformV1BatchPredictionJobOutputInfo
    buildGoogleCloudAiplatformV1BatchPredictionJobOutputInfo() {
  final o = api.GoogleCloudAiplatformV1BatchPredictionJobOutputInfo();
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputInfo++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputInfo < 3) {
    o.bigqueryOutputDataset = 'foo';
    o.bigqueryOutputTable = 'foo';
    o.gcsOutputDirectory = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputInfo--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchPredictionJobOutputInfo(
    api.GoogleCloudAiplatformV1BatchPredictionJobOutputInfo o) {
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputInfo++;
  if (buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputInfo < 3) {
    unittest.expect(
      o.bigqueryOutputDataset!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.bigqueryOutputTable!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.gcsOutputDirectory!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchPredictionJobOutputInfo--;
}

core.List<
        api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec>
    buildUnnamed23() => [
          buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec(),
          buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec(),
        ];

void checkUnnamed23(
    core.List<
            api
            .GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec(o[0]);
  checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec(o[1]);
}

core.List<
        api
        .GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField>
    buildUnnamed24() => [
          buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField(),
          buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField(),
        ];

void checkUnnamed24(
    core.List<
            api
            .GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField(
      o[0]);
  checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField(
      o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequest = 0;
api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequest
    buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequest() {
  final o = api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequest();
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequest < 3) {
    o.bigqueryReadInstances = buildGoogleCloudAiplatformV1BigQuerySource();
    o.csvReadInstances = buildGoogleCloudAiplatformV1CsvSource();
    o.destination = buildGoogleCloudAiplatformV1FeatureValueDestination();
    o.entityTypeSpecs = buildUnnamed23();
    o.passThroughFields = buildUnnamed24();
    o.startTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequest(
    api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequest o) {
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequest < 3) {
    checkGoogleCloudAiplatformV1BigQuerySource(o.bigqueryReadInstances!);
    checkGoogleCloudAiplatformV1CsvSource(o.csvReadInstances!);
    checkGoogleCloudAiplatformV1FeatureValueDestination(o.destination!);
    checkUnnamed23(o.entityTypeSpecs!);
    checkUnnamed24(o.passThroughFields!);
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequest--;
}

core.List<api.GoogleCloudAiplatformV1DestinationFeatureSetting>
    buildUnnamed25() => [
          buildGoogleCloudAiplatformV1DestinationFeatureSetting(),
          buildGoogleCloudAiplatformV1DestinationFeatureSetting(),
        ];

void checkUnnamed25(
    core.List<api.GoogleCloudAiplatformV1DestinationFeatureSetting> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DestinationFeatureSetting(o[0]);
  checkGoogleCloudAiplatformV1DestinationFeatureSetting(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec =
    0;
api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec
    buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec() {
  final o =
      api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec();
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec++;
  if (buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec <
      3) {
    o.entityTypeId = 'foo';
    o.featureSelector = buildGoogleCloudAiplatformV1FeatureSelector();
    o.settings = buildUnnamed25();
  }
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec(
    api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec o) {
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec++;
  if (buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec <
      3) {
    unittest.expect(
      o.entityTypeId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FeatureSelector(o.featureSelector!);
    checkUnnamed25(o.settings!);
  }
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField =
    0;
api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField
    buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField() {
  final o = api
      .GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField();
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField++;
  if (buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField <
      3) {
    o.fieldName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField(
    api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField
        o) {
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField++;
  if (buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField <
      3) {
    unittest.expect(
      o.fieldName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField--;
}

core.List<api.GoogleCloudAiplatformV1TimeSeriesData> buildUnnamed26() => [
      buildGoogleCloudAiplatformV1TimeSeriesData(),
      buildGoogleCloudAiplatformV1TimeSeriesData(),
    ];

void checkUnnamed26(core.List<api.GoogleCloudAiplatformV1TimeSeriesData> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TimeSeriesData(o[0]);
  checkGoogleCloudAiplatformV1TimeSeriesData(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse =
    0;
api.GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse
    buildGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse() {
  final o =
      api.GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse();
  buildCounterGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse <
      3) {
    o.timeSeriesData = buildUnnamed26();
  }
  buildCounterGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse(
    api.GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse o) {
  buildCounterGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse <
      3) {
    checkUnnamed26(o.timeSeriesData!);
  }
  buildCounterGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1BigQueryDestination = 0;
api.GoogleCloudAiplatformV1BigQueryDestination
    buildGoogleCloudAiplatformV1BigQueryDestination() {
  final o = api.GoogleCloudAiplatformV1BigQueryDestination();
  buildCounterGoogleCloudAiplatformV1BigQueryDestination++;
  if (buildCounterGoogleCloudAiplatformV1BigQueryDestination < 3) {
    o.outputUri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BigQueryDestination--;
  return o;
}

void checkGoogleCloudAiplatformV1BigQueryDestination(
    api.GoogleCloudAiplatformV1BigQueryDestination o) {
  buildCounterGoogleCloudAiplatformV1BigQueryDestination++;
  if (buildCounterGoogleCloudAiplatformV1BigQueryDestination < 3) {
    unittest.expect(
      o.outputUri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BigQueryDestination--;
}

core.int buildCounterGoogleCloudAiplatformV1BigQuerySource = 0;
api.GoogleCloudAiplatformV1BigQuerySource
    buildGoogleCloudAiplatformV1BigQuerySource() {
  final o = api.GoogleCloudAiplatformV1BigQuerySource();
  buildCounterGoogleCloudAiplatformV1BigQuerySource++;
  if (buildCounterGoogleCloudAiplatformV1BigQuerySource < 3) {
    o.inputUri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1BigQuerySource--;
  return o;
}

void checkGoogleCloudAiplatformV1BigQuerySource(
    api.GoogleCloudAiplatformV1BigQuerySource o) {
  buildCounterGoogleCloudAiplatformV1BigQuerySource++;
  if (buildCounterGoogleCloudAiplatformV1BigQuerySource < 3) {
    unittest.expect(
      o.inputUri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1BigQuerySource--;
}

core.int buildCounterGoogleCloudAiplatformV1Blob = 0;
api.GoogleCloudAiplatformV1Blob buildGoogleCloudAiplatformV1Blob() {
  final o = api.GoogleCloudAiplatformV1Blob();
  buildCounterGoogleCloudAiplatformV1Blob++;
  if (buildCounterGoogleCloudAiplatformV1Blob < 3) {
    o.data = 'foo';
    o.mimeType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Blob--;
  return o;
}

void checkGoogleCloudAiplatformV1Blob(api.GoogleCloudAiplatformV1Blob o) {
  buildCounterGoogleCloudAiplatformV1Blob++;
  if (buildCounterGoogleCloudAiplatformV1Blob < 3) {
    unittest.expect(
      o.data!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.mimeType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Blob--;
}

core.int buildCounterGoogleCloudAiplatformV1BlurBaselineConfig = 0;
api.GoogleCloudAiplatformV1BlurBaselineConfig
    buildGoogleCloudAiplatformV1BlurBaselineConfig() {
  final o = api.GoogleCloudAiplatformV1BlurBaselineConfig();
  buildCounterGoogleCloudAiplatformV1BlurBaselineConfig++;
  if (buildCounterGoogleCloudAiplatformV1BlurBaselineConfig < 3) {
    o.maxBlurSigma = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1BlurBaselineConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1BlurBaselineConfig(
    api.GoogleCloudAiplatformV1BlurBaselineConfig o) {
  buildCounterGoogleCloudAiplatformV1BlurBaselineConfig++;
  if (buildCounterGoogleCloudAiplatformV1BlurBaselineConfig < 3) {
    unittest.expect(
      o.maxBlurSigma!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1BlurBaselineConfig--;
}

core.List<core.bool> buildUnnamed27() => [
      true,
      true,
    ];

void checkUnnamed27(core.List<core.bool> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(o[0], unittest.isTrue);
  unittest.expect(o[1], unittest.isTrue);
}

core.int buildCounterGoogleCloudAiplatformV1BoolArray = 0;
api.GoogleCloudAiplatformV1BoolArray buildGoogleCloudAiplatformV1BoolArray() {
  final o = api.GoogleCloudAiplatformV1BoolArray();
  buildCounterGoogleCloudAiplatformV1BoolArray++;
  if (buildCounterGoogleCloudAiplatformV1BoolArray < 3) {
    o.values = buildUnnamed27();
  }
  buildCounterGoogleCloudAiplatformV1BoolArray--;
  return o;
}

void checkGoogleCloudAiplatformV1BoolArray(
    api.GoogleCloudAiplatformV1BoolArray o) {
  buildCounterGoogleCloudAiplatformV1BoolArray++;
  if (buildCounterGoogleCloudAiplatformV1BoolArray < 3) {
    checkUnnamed27(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1BoolArray--;
}

core.int buildCounterGoogleCloudAiplatformV1CancelBatchPredictionJobRequest = 0;
api.GoogleCloudAiplatformV1CancelBatchPredictionJobRequest
    buildGoogleCloudAiplatformV1CancelBatchPredictionJobRequest() {
  final o = api.GoogleCloudAiplatformV1CancelBatchPredictionJobRequest();
  buildCounterGoogleCloudAiplatformV1CancelBatchPredictionJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelBatchPredictionJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelBatchPredictionJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CancelBatchPredictionJobRequest(
    api.GoogleCloudAiplatformV1CancelBatchPredictionJobRequest o) {
  buildCounterGoogleCloudAiplatformV1CancelBatchPredictionJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelBatchPredictionJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelBatchPredictionJobRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CancelCustomJobRequest = 0;
api.GoogleCloudAiplatformV1CancelCustomJobRequest
    buildGoogleCloudAiplatformV1CancelCustomJobRequest() {
  final o = api.GoogleCloudAiplatformV1CancelCustomJobRequest();
  buildCounterGoogleCloudAiplatformV1CancelCustomJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelCustomJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelCustomJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CancelCustomJobRequest(
    api.GoogleCloudAiplatformV1CancelCustomJobRequest o) {
  buildCounterGoogleCloudAiplatformV1CancelCustomJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelCustomJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelCustomJobRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CancelDataLabelingJobRequest = 0;
api.GoogleCloudAiplatformV1CancelDataLabelingJobRequest
    buildGoogleCloudAiplatformV1CancelDataLabelingJobRequest() {
  final o = api.GoogleCloudAiplatformV1CancelDataLabelingJobRequest();
  buildCounterGoogleCloudAiplatformV1CancelDataLabelingJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelDataLabelingJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelDataLabelingJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CancelDataLabelingJobRequest(
    api.GoogleCloudAiplatformV1CancelDataLabelingJobRequest o) {
  buildCounterGoogleCloudAiplatformV1CancelDataLabelingJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelDataLabelingJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelDataLabelingJobRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest = 0;
api.GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest
    buildGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest() {
  final o = api.GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest();
  buildCounterGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest <
      3) {}
  buildCounterGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest(
    api.GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest o) {
  buildCounterGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest <
      3) {}
  buildCounterGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CancelNasJobRequest = 0;
api.GoogleCloudAiplatformV1CancelNasJobRequest
    buildGoogleCloudAiplatformV1CancelNasJobRequest() {
  final o = api.GoogleCloudAiplatformV1CancelNasJobRequest();
  buildCounterGoogleCloudAiplatformV1CancelNasJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelNasJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelNasJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CancelNasJobRequest(
    api.GoogleCloudAiplatformV1CancelNasJobRequest o) {
  buildCounterGoogleCloudAiplatformV1CancelNasJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelNasJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelNasJobRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CancelPipelineJobRequest = 0;
api.GoogleCloudAiplatformV1CancelPipelineJobRequest
    buildGoogleCloudAiplatformV1CancelPipelineJobRequest() {
  final o = api.GoogleCloudAiplatformV1CancelPipelineJobRequest();
  buildCounterGoogleCloudAiplatformV1CancelPipelineJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelPipelineJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelPipelineJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CancelPipelineJobRequest(
    api.GoogleCloudAiplatformV1CancelPipelineJobRequest o) {
  buildCounterGoogleCloudAiplatformV1CancelPipelineJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelPipelineJobRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelPipelineJobRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CancelTrainingPipelineRequest = 0;
api.GoogleCloudAiplatformV1CancelTrainingPipelineRequest
    buildGoogleCloudAiplatformV1CancelTrainingPipelineRequest() {
  final o = api.GoogleCloudAiplatformV1CancelTrainingPipelineRequest();
  buildCounterGoogleCloudAiplatformV1CancelTrainingPipelineRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelTrainingPipelineRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelTrainingPipelineRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CancelTrainingPipelineRequest(
    api.GoogleCloudAiplatformV1CancelTrainingPipelineRequest o) {
  buildCounterGoogleCloudAiplatformV1CancelTrainingPipelineRequest++;
  if (buildCounterGoogleCloudAiplatformV1CancelTrainingPipelineRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1CancelTrainingPipelineRequest--;
}

core.List<api.GoogleCloudAiplatformV1SafetyRating> buildUnnamed28() => [
      buildGoogleCloudAiplatformV1SafetyRating(),
      buildGoogleCloudAiplatformV1SafetyRating(),
    ];

void checkUnnamed28(core.List<api.GoogleCloudAiplatformV1SafetyRating> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1SafetyRating(o[0]);
  checkGoogleCloudAiplatformV1SafetyRating(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1Candidate = 0;
api.GoogleCloudAiplatformV1Candidate buildGoogleCloudAiplatformV1Candidate() {
  final o = api.GoogleCloudAiplatformV1Candidate();
  buildCounterGoogleCloudAiplatformV1Candidate++;
  if (buildCounterGoogleCloudAiplatformV1Candidate < 3) {
    o.citationMetadata = buildGoogleCloudAiplatformV1CitationMetadata();
    o.content = buildGoogleCloudAiplatformV1Content();
    o.finishMessage = 'foo';
    o.finishReason = 'foo';
    o.groundingMetadata = buildGoogleCloudAiplatformV1GroundingMetadata();
    o.index = 42;
    o.safetyRatings = buildUnnamed28();
  }
  buildCounterGoogleCloudAiplatformV1Candidate--;
  return o;
}

void checkGoogleCloudAiplatformV1Candidate(
    api.GoogleCloudAiplatformV1Candidate o) {
  buildCounterGoogleCloudAiplatformV1Candidate++;
  if (buildCounterGoogleCloudAiplatformV1Candidate < 3) {
    checkGoogleCloudAiplatformV1CitationMetadata(o.citationMetadata!);
    checkGoogleCloudAiplatformV1Content(o.content!);
    unittest.expect(
      o.finishMessage!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.finishReason!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1GroundingMetadata(o.groundingMetadata!);
    unittest.expect(
      o.index!,
      unittest.equals(42),
    );
    checkUnnamed28(o.safetyRatings!);
  }
  buildCounterGoogleCloudAiplatformV1Candidate--;
}

core.int
    buildCounterGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest = 0;
api.GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest
    buildGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest() {
  final o = api.GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest();
  buildCounterGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest++;
  if (buildCounterGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest <
      3) {}
  buildCounterGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest(
    api.GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest o) {
  buildCounterGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest++;
  if (buildCounterGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest <
      3) {}
  buildCounterGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1Citation = 0;
api.GoogleCloudAiplatformV1Citation buildGoogleCloudAiplatformV1Citation() {
  final o = api.GoogleCloudAiplatformV1Citation();
  buildCounterGoogleCloudAiplatformV1Citation++;
  if (buildCounterGoogleCloudAiplatformV1Citation < 3) {
    o.endIndex = 42;
    o.license = 'foo';
    o.publicationDate = buildGoogleTypeDate();
    o.startIndex = 42;
    o.title = 'foo';
    o.uri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Citation--;
  return o;
}

void checkGoogleCloudAiplatformV1Citation(
    api.GoogleCloudAiplatformV1Citation o) {
  buildCounterGoogleCloudAiplatformV1Citation++;
  if (buildCounterGoogleCloudAiplatformV1Citation < 3) {
    unittest.expect(
      o.endIndex!,
      unittest.equals(42),
    );
    unittest.expect(
      o.license!,
      unittest.equals('foo'),
    );
    checkGoogleTypeDate(o.publicationDate!);
    unittest.expect(
      o.startIndex!,
      unittest.equals(42),
    );
    unittest.expect(
      o.title!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.uri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Citation--;
}

core.List<api.GoogleCloudAiplatformV1Citation> buildUnnamed29() => [
      buildGoogleCloudAiplatformV1Citation(),
      buildGoogleCloudAiplatformV1Citation(),
    ];

void checkUnnamed29(core.List<api.GoogleCloudAiplatformV1Citation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Citation(o[0]);
  checkGoogleCloudAiplatformV1Citation(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1CitationMetadata = 0;
api.GoogleCloudAiplatformV1CitationMetadata
    buildGoogleCloudAiplatformV1CitationMetadata() {
  final o = api.GoogleCloudAiplatformV1CitationMetadata();
  buildCounterGoogleCloudAiplatformV1CitationMetadata++;
  if (buildCounterGoogleCloudAiplatformV1CitationMetadata < 3) {
    o.citations = buildUnnamed29();
  }
  buildCounterGoogleCloudAiplatformV1CitationMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1CitationMetadata(
    api.GoogleCloudAiplatformV1CitationMetadata o) {
  buildCounterGoogleCloudAiplatformV1CitationMetadata++;
  if (buildCounterGoogleCloudAiplatformV1CitationMetadata < 3) {
    checkUnnamed29(o.citations!);
  }
  buildCounterGoogleCloudAiplatformV1CitationMetadata--;
}

core.int buildCounterGoogleCloudAiplatformV1CompleteTrialRequest = 0;
api.GoogleCloudAiplatformV1CompleteTrialRequest
    buildGoogleCloudAiplatformV1CompleteTrialRequest() {
  final o = api.GoogleCloudAiplatformV1CompleteTrialRequest();
  buildCounterGoogleCloudAiplatformV1CompleteTrialRequest++;
  if (buildCounterGoogleCloudAiplatformV1CompleteTrialRequest < 3) {
    o.finalMeasurement = buildGoogleCloudAiplatformV1Measurement();
    o.infeasibleReason = 'foo';
    o.trialInfeasible = true;
  }
  buildCounterGoogleCloudAiplatformV1CompleteTrialRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CompleteTrialRequest(
    api.GoogleCloudAiplatformV1CompleteTrialRequest o) {
  buildCounterGoogleCloudAiplatformV1CompleteTrialRequest++;
  if (buildCounterGoogleCloudAiplatformV1CompleteTrialRequest < 3) {
    checkGoogleCloudAiplatformV1Measurement(o.finalMeasurement!);
    unittest.expect(
      o.infeasibleReason!,
      unittest.equals('foo'),
    );
    unittest.expect(o.trialInfeasible!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1CompleteTrialRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CompletionStats = 0;
api.GoogleCloudAiplatformV1CompletionStats
    buildGoogleCloudAiplatformV1CompletionStats() {
  final o = api.GoogleCloudAiplatformV1CompletionStats();
  buildCounterGoogleCloudAiplatformV1CompletionStats++;
  if (buildCounterGoogleCloudAiplatformV1CompletionStats < 3) {
    o.failedCount = 'foo';
    o.incompleteCount = 'foo';
    o.successfulCount = 'foo';
    o.successfulForecastPointCount = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1CompletionStats--;
  return o;
}

void checkGoogleCloudAiplatformV1CompletionStats(
    api.GoogleCloudAiplatformV1CompletionStats o) {
  buildCounterGoogleCloudAiplatformV1CompletionStats++;
  if (buildCounterGoogleCloudAiplatformV1CompletionStats < 3) {
    unittest.expect(
      o.failedCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.incompleteCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.successfulCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.successfulForecastPointCount!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1CompletionStats--;
}

core.List<core.Object?> buildUnnamed30() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed30(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted8 = (o[0]) as core.Map;
  unittest.expect(casted8, unittest.hasLength(3));
  unittest.expect(
    casted8['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted8['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted8['string'],
    unittest.equals('foo'),
  );
  var casted9 = (o[1]) as core.Map;
  unittest.expect(casted9, unittest.hasLength(3));
  unittest.expect(
    casted9['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted9['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted9['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ComputeTokensRequest = 0;
api.GoogleCloudAiplatformV1ComputeTokensRequest
    buildGoogleCloudAiplatformV1ComputeTokensRequest() {
  final o = api.GoogleCloudAiplatformV1ComputeTokensRequest();
  buildCounterGoogleCloudAiplatformV1ComputeTokensRequest++;
  if (buildCounterGoogleCloudAiplatformV1ComputeTokensRequest < 3) {
    o.instances = buildUnnamed30();
  }
  buildCounterGoogleCloudAiplatformV1ComputeTokensRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ComputeTokensRequest(
    api.GoogleCloudAiplatformV1ComputeTokensRequest o) {
  buildCounterGoogleCloudAiplatformV1ComputeTokensRequest++;
  if (buildCounterGoogleCloudAiplatformV1ComputeTokensRequest < 3) {
    checkUnnamed30(o.instances!);
  }
  buildCounterGoogleCloudAiplatformV1ComputeTokensRequest--;
}

core.List<api.GoogleCloudAiplatformV1TokensInfo> buildUnnamed31() => [
      buildGoogleCloudAiplatformV1TokensInfo(),
      buildGoogleCloudAiplatformV1TokensInfo(),
    ];

void checkUnnamed31(core.List<api.GoogleCloudAiplatformV1TokensInfo> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TokensInfo(o[0]);
  checkGoogleCloudAiplatformV1TokensInfo(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ComputeTokensResponse = 0;
api.GoogleCloudAiplatformV1ComputeTokensResponse
    buildGoogleCloudAiplatformV1ComputeTokensResponse() {
  final o = api.GoogleCloudAiplatformV1ComputeTokensResponse();
  buildCounterGoogleCloudAiplatformV1ComputeTokensResponse++;
  if (buildCounterGoogleCloudAiplatformV1ComputeTokensResponse < 3) {
    o.tokensInfo = buildUnnamed31();
  }
  buildCounterGoogleCloudAiplatformV1ComputeTokensResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ComputeTokensResponse(
    api.GoogleCloudAiplatformV1ComputeTokensResponse o) {
  buildCounterGoogleCloudAiplatformV1ComputeTokensResponse++;
  if (buildCounterGoogleCloudAiplatformV1ComputeTokensResponse < 3) {
    checkUnnamed31(o.tokensInfo!);
  }
  buildCounterGoogleCloudAiplatformV1ComputeTokensResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1ContainerRegistryDestination = 0;
api.GoogleCloudAiplatformV1ContainerRegistryDestination
    buildGoogleCloudAiplatformV1ContainerRegistryDestination() {
  final o = api.GoogleCloudAiplatformV1ContainerRegistryDestination();
  buildCounterGoogleCloudAiplatformV1ContainerRegistryDestination++;
  if (buildCounterGoogleCloudAiplatformV1ContainerRegistryDestination < 3) {
    o.outputUri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ContainerRegistryDestination--;
  return o;
}

void checkGoogleCloudAiplatformV1ContainerRegistryDestination(
    api.GoogleCloudAiplatformV1ContainerRegistryDestination o) {
  buildCounterGoogleCloudAiplatformV1ContainerRegistryDestination++;
  if (buildCounterGoogleCloudAiplatformV1ContainerRegistryDestination < 3) {
    unittest.expect(
      o.outputUri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ContainerRegistryDestination--;
}

core.List<core.String> buildUnnamed32() => [
      'foo',
      'foo',
    ];

void checkUnnamed32(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed33() => [
      'foo',
      'foo',
    ];

void checkUnnamed33(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1EnvVar> buildUnnamed34() => [
      buildGoogleCloudAiplatformV1EnvVar(),
      buildGoogleCloudAiplatformV1EnvVar(),
    ];

void checkUnnamed34(core.List<api.GoogleCloudAiplatformV1EnvVar> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1EnvVar(o[0]);
  checkGoogleCloudAiplatformV1EnvVar(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ContainerSpec = 0;
api.GoogleCloudAiplatformV1ContainerSpec
    buildGoogleCloudAiplatformV1ContainerSpec() {
  final o = api.GoogleCloudAiplatformV1ContainerSpec();
  buildCounterGoogleCloudAiplatformV1ContainerSpec++;
  if (buildCounterGoogleCloudAiplatformV1ContainerSpec < 3) {
    o.args = buildUnnamed32();
    o.command = buildUnnamed33();
    o.env = buildUnnamed34();
    o.imageUri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ContainerSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1ContainerSpec(
    api.GoogleCloudAiplatformV1ContainerSpec o) {
  buildCounterGoogleCloudAiplatformV1ContainerSpec++;
  if (buildCounterGoogleCloudAiplatformV1ContainerSpec < 3) {
    checkUnnamed32(o.args!);
    checkUnnamed33(o.command!);
    checkUnnamed34(o.env!);
    unittest.expect(
      o.imageUri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ContainerSpec--;
}

core.List<api.GoogleCloudAiplatformV1Part> buildUnnamed35() => [
      buildGoogleCloudAiplatformV1Part(),
      buildGoogleCloudAiplatformV1Part(),
    ];

void checkUnnamed35(core.List<api.GoogleCloudAiplatformV1Part> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Part(o[0]);
  checkGoogleCloudAiplatformV1Part(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1Content = 0;
api.GoogleCloudAiplatformV1Content buildGoogleCloudAiplatformV1Content() {
  final o = api.GoogleCloudAiplatformV1Content();
  buildCounterGoogleCloudAiplatformV1Content++;
  if (buildCounterGoogleCloudAiplatformV1Content < 3) {
    o.parts = buildUnnamed35();
    o.role = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Content--;
  return o;
}

void checkGoogleCloudAiplatformV1Content(api.GoogleCloudAiplatformV1Content o) {
  buildCounterGoogleCloudAiplatformV1Content++;
  if (buildCounterGoogleCloudAiplatformV1Content < 3) {
    checkUnnamed35(o.parts!);
    unittest.expect(
      o.role!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Content--;
}

core.Map<core.String, core.String> buildUnnamed36() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed36(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.Object?> buildUnnamed37() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed37(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted10 = (o['x']!) as core.Map;
  unittest.expect(casted10, unittest.hasLength(3));
  unittest.expect(
    casted10['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted10['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted10['string'],
    unittest.equals('foo'),
  );
  var casted11 = (o['y']!) as core.Map;
  unittest.expect(casted11, unittest.hasLength(3));
  unittest.expect(
    casted11['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted11['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted11['string'],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed38() => [
      'foo',
      'foo',
    ];

void checkUnnamed38(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Context = 0;
api.GoogleCloudAiplatformV1Context buildGoogleCloudAiplatformV1Context() {
  final o = api.GoogleCloudAiplatformV1Context();
  buildCounterGoogleCloudAiplatformV1Context++;
  if (buildCounterGoogleCloudAiplatformV1Context < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed36();
    o.metadata = buildUnnamed37();
    o.name = 'foo';
    o.parentContexts = buildUnnamed38();
    o.schemaTitle = 'foo';
    o.schemaVersion = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Context--;
  return o;
}

void checkGoogleCloudAiplatformV1Context(api.GoogleCloudAiplatformV1Context o) {
  buildCounterGoogleCloudAiplatformV1Context++;
  if (buildCounterGoogleCloudAiplatformV1Context < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed36(o.labels!);
    checkUnnamed37(o.metadata!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed38(o.parentContexts!);
    unittest.expect(
      o.schemaTitle!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.schemaVersion!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Context--;
}

core.int buildCounterGoogleCloudAiplatformV1CopyModelRequest = 0;
api.GoogleCloudAiplatformV1CopyModelRequest
    buildGoogleCloudAiplatformV1CopyModelRequest() {
  final o = api.GoogleCloudAiplatformV1CopyModelRequest();
  buildCounterGoogleCloudAiplatformV1CopyModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1CopyModelRequest < 3) {
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.modelId = 'foo';
    o.parentModel = 'foo';
    o.sourceModel = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1CopyModelRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CopyModelRequest(
    api.GoogleCloudAiplatformV1CopyModelRequest o) {
  buildCounterGoogleCloudAiplatformV1CopyModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1CopyModelRequest < 3) {
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.modelId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.parentModel!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.sourceModel!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1CopyModelRequest--;
}

core.List<api.GoogleCloudAiplatformV1Content> buildUnnamed39() => [
      buildGoogleCloudAiplatformV1Content(),
      buildGoogleCloudAiplatformV1Content(),
    ];

void checkUnnamed39(core.List<api.GoogleCloudAiplatformV1Content> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Content(o[0]);
  checkGoogleCloudAiplatformV1Content(o[1]);
}

core.List<core.Object?> buildUnnamed40() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed40(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted12 = (o[0]) as core.Map;
  unittest.expect(casted12, unittest.hasLength(3));
  unittest.expect(
    casted12['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted12['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted12['string'],
    unittest.equals('foo'),
  );
  var casted13 = (o[1]) as core.Map;
  unittest.expect(casted13, unittest.hasLength(3));
  unittest.expect(
    casted13['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted13['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted13['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1CountTokensRequest = 0;
api.GoogleCloudAiplatformV1CountTokensRequest
    buildGoogleCloudAiplatformV1CountTokensRequest() {
  final o = api.GoogleCloudAiplatformV1CountTokensRequest();
  buildCounterGoogleCloudAiplatformV1CountTokensRequest++;
  if (buildCounterGoogleCloudAiplatformV1CountTokensRequest < 3) {
    o.contents = buildUnnamed39();
    o.instances = buildUnnamed40();
    o.model = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1CountTokensRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CountTokensRequest(
    api.GoogleCloudAiplatformV1CountTokensRequest o) {
  buildCounterGoogleCloudAiplatformV1CountTokensRequest++;
  if (buildCounterGoogleCloudAiplatformV1CountTokensRequest < 3) {
    checkUnnamed39(o.contents!);
    checkUnnamed40(o.instances!);
    unittest.expect(
      o.model!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1CountTokensRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CountTokensResponse = 0;
api.GoogleCloudAiplatformV1CountTokensResponse
    buildGoogleCloudAiplatformV1CountTokensResponse() {
  final o = api.GoogleCloudAiplatformV1CountTokensResponse();
  buildCounterGoogleCloudAiplatformV1CountTokensResponse++;
  if (buildCounterGoogleCloudAiplatformV1CountTokensResponse < 3) {
    o.totalBillableCharacters = 42;
    o.totalTokens = 42;
  }
  buildCounterGoogleCloudAiplatformV1CountTokensResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1CountTokensResponse(
    api.GoogleCloudAiplatformV1CountTokensResponse o) {
  buildCounterGoogleCloudAiplatformV1CountTokensResponse++;
  if (buildCounterGoogleCloudAiplatformV1CountTokensResponse < 3) {
    unittest.expect(
      o.totalBillableCharacters!,
      unittest.equals(42),
    );
    unittest.expect(
      o.totalTokens!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1CountTokensResponse--;
}

core.int
    buildCounterGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest = 0;
api.GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest
    buildGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest() {
  final o = api.GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest();
  buildCounterGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest <
      3) {
    o.deploymentResourcePool =
        buildGoogleCloudAiplatformV1DeploymentResourcePool();
    o.deploymentResourcePoolId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest(
    api.GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest o) {
  buildCounterGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest <
      3) {
    checkGoogleCloudAiplatformV1DeploymentResourcePool(
        o.deploymentResourcePool!);
    unittest.expect(
      o.deploymentResourcePoolId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CreateFeatureRequest = 0;
api.GoogleCloudAiplatformV1CreateFeatureRequest
    buildGoogleCloudAiplatformV1CreateFeatureRequest() {
  final o = api.GoogleCloudAiplatformV1CreateFeatureRequest();
  buildCounterGoogleCloudAiplatformV1CreateFeatureRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreateFeatureRequest < 3) {
    o.feature = buildGoogleCloudAiplatformV1Feature();
    o.featureId = 'foo';
    o.parent = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1CreateFeatureRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CreateFeatureRequest(
    api.GoogleCloudAiplatformV1CreateFeatureRequest o) {
  buildCounterGoogleCloudAiplatformV1CreateFeatureRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreateFeatureRequest < 3) {
    checkGoogleCloudAiplatformV1Feature(o.feature!);
    unittest.expect(
      o.featureId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.parent!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1CreateFeatureRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CreatePipelineJobRequest = 0;
api.GoogleCloudAiplatformV1CreatePipelineJobRequest
    buildGoogleCloudAiplatformV1CreatePipelineJobRequest() {
  final o = api.GoogleCloudAiplatformV1CreatePipelineJobRequest();
  buildCounterGoogleCloudAiplatformV1CreatePipelineJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreatePipelineJobRequest < 3) {
    o.parent = 'foo';
    o.pipelineJob = buildGoogleCloudAiplatformV1PipelineJob();
    o.pipelineJobId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1CreatePipelineJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CreatePipelineJobRequest(
    api.GoogleCloudAiplatformV1CreatePipelineJobRequest o) {
  buildCounterGoogleCloudAiplatformV1CreatePipelineJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreatePipelineJobRequest < 3) {
    unittest.expect(
      o.parent!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PipelineJob(o.pipelineJob!);
    unittest.expect(
      o.pipelineJobId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1CreatePipelineJobRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CreateTensorboardRunRequest = 0;
api.GoogleCloudAiplatformV1CreateTensorboardRunRequest
    buildGoogleCloudAiplatformV1CreateTensorboardRunRequest() {
  final o = api.GoogleCloudAiplatformV1CreateTensorboardRunRequest();
  buildCounterGoogleCloudAiplatformV1CreateTensorboardRunRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreateTensorboardRunRequest < 3) {
    o.parent = 'foo';
    o.tensorboardRun = buildGoogleCloudAiplatformV1TensorboardRun();
    o.tensorboardRunId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1CreateTensorboardRunRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CreateTensorboardRunRequest(
    api.GoogleCloudAiplatformV1CreateTensorboardRunRequest o) {
  buildCounterGoogleCloudAiplatformV1CreateTensorboardRunRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreateTensorboardRunRequest < 3) {
    unittest.expect(
      o.parent!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1TensorboardRun(o.tensorboardRun!);
    unittest.expect(
      o.tensorboardRunId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1CreateTensorboardRunRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest =
    0;
api.GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest
    buildGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest() {
  final o = api.GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest();
  buildCounterGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest <
      3) {
    o.parent = 'foo';
    o.tensorboardTimeSeries =
        buildGoogleCloudAiplatformV1TensorboardTimeSeries();
    o.tensorboardTimeSeriesId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest(
    api.GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest o) {
  buildCounterGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest++;
  if (buildCounterGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest <
      3) {
    unittest.expect(
      o.parent!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1TensorboardTimeSeries(o.tensorboardTimeSeries!);
    unittest.expect(
      o.tensorboardTimeSeriesId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1CsvDestination = 0;
api.GoogleCloudAiplatformV1CsvDestination
    buildGoogleCloudAiplatformV1CsvDestination() {
  final o = api.GoogleCloudAiplatformV1CsvDestination();
  buildCounterGoogleCloudAiplatformV1CsvDestination++;
  if (buildCounterGoogleCloudAiplatformV1CsvDestination < 3) {
    o.gcsDestination = buildGoogleCloudAiplatformV1GcsDestination();
  }
  buildCounterGoogleCloudAiplatformV1CsvDestination--;
  return o;
}

void checkGoogleCloudAiplatformV1CsvDestination(
    api.GoogleCloudAiplatformV1CsvDestination o) {
  buildCounterGoogleCloudAiplatformV1CsvDestination++;
  if (buildCounterGoogleCloudAiplatformV1CsvDestination < 3) {
    checkGoogleCloudAiplatformV1GcsDestination(o.gcsDestination!);
  }
  buildCounterGoogleCloudAiplatformV1CsvDestination--;
}

core.int buildCounterGoogleCloudAiplatformV1CsvSource = 0;
api.GoogleCloudAiplatformV1CsvSource buildGoogleCloudAiplatformV1CsvSource() {
  final o = api.GoogleCloudAiplatformV1CsvSource();
  buildCounterGoogleCloudAiplatformV1CsvSource++;
  if (buildCounterGoogleCloudAiplatformV1CsvSource < 3) {
    o.gcsSource = buildGoogleCloudAiplatformV1GcsSource();
  }
  buildCounterGoogleCloudAiplatformV1CsvSource--;
  return o;
}

void checkGoogleCloudAiplatformV1CsvSource(
    api.GoogleCloudAiplatformV1CsvSource o) {
  buildCounterGoogleCloudAiplatformV1CsvSource++;
  if (buildCounterGoogleCloudAiplatformV1CsvSource < 3) {
    checkGoogleCloudAiplatformV1GcsSource(o.gcsSource!);
  }
  buildCounterGoogleCloudAiplatformV1CsvSource--;
}

core.Map<core.String, core.String> buildUnnamed41() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed41(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.String> buildUnnamed42() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed42(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1CustomJob = 0;
api.GoogleCloudAiplatformV1CustomJob buildGoogleCloudAiplatformV1CustomJob() {
  final o = api.GoogleCloudAiplatformV1CustomJob();
  buildCounterGoogleCloudAiplatformV1CustomJob++;
  if (buildCounterGoogleCloudAiplatformV1CustomJob < 3) {
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.endTime = 'foo';
    o.error = buildGoogleRpcStatus();
    o.jobSpec = buildGoogleCloudAiplatformV1CustomJobSpec();
    o.labels = buildUnnamed41();
    o.name = 'foo';
    o.startTime = 'foo';
    o.state = 'foo';
    o.updateTime = 'foo';
    o.webAccessUris = buildUnnamed42();
  }
  buildCounterGoogleCloudAiplatformV1CustomJob--;
  return o;
}

void checkGoogleCloudAiplatformV1CustomJob(
    api.GoogleCloudAiplatformV1CustomJob o) {
  buildCounterGoogleCloudAiplatformV1CustomJob++;
  if (buildCounterGoogleCloudAiplatformV1CustomJob < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.error!);
    checkGoogleCloudAiplatformV1CustomJobSpec(o.jobSpec!);
    checkUnnamed41(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
    checkUnnamed42(o.webAccessUris!);
  }
  buildCounterGoogleCloudAiplatformV1CustomJob--;
}

core.List<core.String> buildUnnamed43() => [
      'foo',
      'foo',
    ];

void checkUnnamed43(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed44() => [
      'foo',
      'foo',
    ];

void checkUnnamed44(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1WorkerPoolSpec> buildUnnamed45() => [
      buildGoogleCloudAiplatformV1WorkerPoolSpec(),
      buildGoogleCloudAiplatformV1WorkerPoolSpec(),
    ];

void checkUnnamed45(core.List<api.GoogleCloudAiplatformV1WorkerPoolSpec> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1WorkerPoolSpec(o[0]);
  checkGoogleCloudAiplatformV1WorkerPoolSpec(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1CustomJobSpec = 0;
api.GoogleCloudAiplatformV1CustomJobSpec
    buildGoogleCloudAiplatformV1CustomJobSpec() {
  final o = api.GoogleCloudAiplatformV1CustomJobSpec();
  buildCounterGoogleCloudAiplatformV1CustomJobSpec++;
  if (buildCounterGoogleCloudAiplatformV1CustomJobSpec < 3) {
    o.baseOutputDirectory = buildGoogleCloudAiplatformV1GcsDestination();
    o.enableDashboardAccess = true;
    o.enableWebAccess = true;
    o.experiment = 'foo';
    o.experimentRun = 'foo';
    o.models = buildUnnamed43();
    o.network = 'foo';
    o.protectedArtifactLocationId = 'foo';
    o.reservedIpRanges = buildUnnamed44();
    o.scheduling = buildGoogleCloudAiplatformV1Scheduling();
    o.serviceAccount = 'foo';
    o.tensorboard = 'foo';
    o.workerPoolSpecs = buildUnnamed45();
  }
  buildCounterGoogleCloudAiplatformV1CustomJobSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1CustomJobSpec(
    api.GoogleCloudAiplatformV1CustomJobSpec o) {
  buildCounterGoogleCloudAiplatformV1CustomJobSpec++;
  if (buildCounterGoogleCloudAiplatformV1CustomJobSpec < 3) {
    checkGoogleCloudAiplatformV1GcsDestination(o.baseOutputDirectory!);
    unittest.expect(o.enableDashboardAccess!, unittest.isTrue);
    unittest.expect(o.enableWebAccess!, unittest.isTrue);
    unittest.expect(
      o.experiment!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.experimentRun!,
      unittest.equals('foo'),
    );
    checkUnnamed43(o.models!);
    unittest.expect(
      o.network!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.protectedArtifactLocationId!,
      unittest.equals('foo'),
    );
    checkUnnamed44(o.reservedIpRanges!);
    checkGoogleCloudAiplatformV1Scheduling(o.scheduling!);
    unittest.expect(
      o.serviceAccount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.tensorboard!,
      unittest.equals('foo'),
    );
    checkUnnamed45(o.workerPoolSpecs!);
  }
  buildCounterGoogleCloudAiplatformV1CustomJobSpec--;
}

core.Map<core.String, core.String> buildUnnamed46() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed46(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1DataItem = 0;
api.GoogleCloudAiplatformV1DataItem buildGoogleCloudAiplatformV1DataItem() {
  final o = api.GoogleCloudAiplatformV1DataItem();
  buildCounterGoogleCloudAiplatformV1DataItem++;
  if (buildCounterGoogleCloudAiplatformV1DataItem < 3) {
    o.createTime = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed46();
    o.name = 'foo';
    o.payload = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DataItem--;
  return o;
}

void checkGoogleCloudAiplatformV1DataItem(
    api.GoogleCloudAiplatformV1DataItem o) {
  buildCounterGoogleCloudAiplatformV1DataItem++;
  if (buildCounterGoogleCloudAiplatformV1DataItem < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed46(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    var casted14 = (o.payload!) as core.Map;
    unittest.expect(casted14, unittest.hasLength(3));
    unittest.expect(
      casted14['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted14['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted14['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DataItem--;
}

core.List<api.GoogleCloudAiplatformV1Annotation> buildUnnamed47() => [
      buildGoogleCloudAiplatformV1Annotation(),
      buildGoogleCloudAiplatformV1Annotation(),
    ];

void checkUnnamed47(core.List<api.GoogleCloudAiplatformV1Annotation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Annotation(o[0]);
  checkGoogleCloudAiplatformV1Annotation(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1DataItemView = 0;
api.GoogleCloudAiplatformV1DataItemView
    buildGoogleCloudAiplatformV1DataItemView() {
  final o = api.GoogleCloudAiplatformV1DataItemView();
  buildCounterGoogleCloudAiplatformV1DataItemView++;
  if (buildCounterGoogleCloudAiplatformV1DataItemView < 3) {
    o.annotations = buildUnnamed47();
    o.dataItem = buildGoogleCloudAiplatformV1DataItem();
    o.hasTruncatedAnnotations = true;
  }
  buildCounterGoogleCloudAiplatformV1DataItemView--;
  return o;
}

void checkGoogleCloudAiplatformV1DataItemView(
    api.GoogleCloudAiplatformV1DataItemView o) {
  buildCounterGoogleCloudAiplatformV1DataItemView++;
  if (buildCounterGoogleCloudAiplatformV1DataItemView < 3) {
    checkUnnamed47(o.annotations!);
    checkGoogleCloudAiplatformV1DataItem(o.dataItem!);
    unittest.expect(o.hasTruncatedAnnotations!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1DataItemView--;
}

core.Map<core.String, core.String> buildUnnamed48() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed48(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed49() => [
      'foo',
      'foo',
    ];

void checkUnnamed49(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.String> buildUnnamed50() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed50(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed51() => [
      'foo',
      'foo',
    ];

void checkUnnamed51(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1DataLabelingJob = 0;
api.GoogleCloudAiplatformV1DataLabelingJob
    buildGoogleCloudAiplatformV1DataLabelingJob() {
  final o = api.GoogleCloudAiplatformV1DataLabelingJob();
  buildCounterGoogleCloudAiplatformV1DataLabelingJob++;
  if (buildCounterGoogleCloudAiplatformV1DataLabelingJob < 3) {
    o.activeLearningConfig = buildGoogleCloudAiplatformV1ActiveLearningConfig();
    o.annotationLabels = buildUnnamed48();
    o.createTime = 'foo';
    o.currentSpend = buildGoogleTypeMoney();
    o.datasets = buildUnnamed49();
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.error = buildGoogleRpcStatus();
    o.inputs = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.inputsSchemaUri = 'foo';
    o.instructionUri = 'foo';
    o.labelerCount = 42;
    o.labelingProgress = 42;
    o.labels = buildUnnamed50();
    o.name = 'foo';
    o.specialistPools = buildUnnamed51();
    o.state = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DataLabelingJob--;
  return o;
}

void checkGoogleCloudAiplatformV1DataLabelingJob(
    api.GoogleCloudAiplatformV1DataLabelingJob o) {
  buildCounterGoogleCloudAiplatformV1DataLabelingJob++;
  if (buildCounterGoogleCloudAiplatformV1DataLabelingJob < 3) {
    checkGoogleCloudAiplatformV1ActiveLearningConfig(o.activeLearningConfig!);
    checkUnnamed48(o.annotationLabels!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleTypeMoney(o.currentSpend!);
    checkUnnamed49(o.datasets!);
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    checkGoogleRpcStatus(o.error!);
    var casted15 = (o.inputs!) as core.Map;
    unittest.expect(casted15, unittest.hasLength(3));
    unittest.expect(
      casted15['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted15['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted15['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.inputsSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.instructionUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.labelerCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.labelingProgress!,
      unittest.equals(42),
    );
    checkUnnamed50(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed51(o.specialistPools!);
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DataLabelingJob--;
}

core.Map<core.String, core.String> buildUnnamed52() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed52(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1SavedQuery> buildUnnamed53() => [
      buildGoogleCloudAiplatformV1SavedQuery(),
      buildGoogleCloudAiplatformV1SavedQuery(),
    ];

void checkUnnamed53(core.List<api.GoogleCloudAiplatformV1SavedQuery> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1SavedQuery(o[0]);
  checkGoogleCloudAiplatformV1SavedQuery(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1Dataset = 0;
api.GoogleCloudAiplatformV1Dataset buildGoogleCloudAiplatformV1Dataset() {
  final o = api.GoogleCloudAiplatformV1Dataset();
  buildCounterGoogleCloudAiplatformV1Dataset++;
  if (buildCounterGoogleCloudAiplatformV1Dataset < 3) {
    o.createTime = 'foo';
    o.dataItemCount = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.etag = 'foo';
    o.labels = buildUnnamed52();
    o.metadata = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.metadataArtifact = 'foo';
    o.metadataSchemaUri = 'foo';
    o.name = 'foo';
    o.savedQueries = buildUnnamed53();
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Dataset--;
  return o;
}

void checkGoogleCloudAiplatformV1Dataset(api.GoogleCloudAiplatformV1Dataset o) {
  buildCounterGoogleCloudAiplatformV1Dataset++;
  if (buildCounterGoogleCloudAiplatformV1Dataset < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.dataItemCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed52(o.labels!);
    var casted16 = (o.metadata!) as core.Map;
    unittest.expect(casted16, unittest.hasLength(3));
    unittest.expect(
      casted16['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted16['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted16['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metadataArtifact!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metadataSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed53(o.savedQueries!);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Dataset--;
}

core.int buildCounterGoogleCloudAiplatformV1DatasetVersion = 0;
api.GoogleCloudAiplatformV1DatasetVersion
    buildGoogleCloudAiplatformV1DatasetVersion() {
  final o = api.GoogleCloudAiplatformV1DatasetVersion();
  buildCounterGoogleCloudAiplatformV1DatasetVersion++;
  if (buildCounterGoogleCloudAiplatformV1DatasetVersion < 3) {
    o.bigQueryDatasetName = 'foo';
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.metadata = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.name = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DatasetVersion--;
  return o;
}

void checkGoogleCloudAiplatformV1DatasetVersion(
    api.GoogleCloudAiplatformV1DatasetVersion o) {
  buildCounterGoogleCloudAiplatformV1DatasetVersion++;
  if (buildCounterGoogleCloudAiplatformV1DatasetVersion < 3) {
    unittest.expect(
      o.bigQueryDatasetName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    var casted17 = (o.metadata!) as core.Map;
    unittest.expect(casted17, unittest.hasLength(3));
    unittest.expect(
      casted17['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted17['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted17['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DatasetVersion--;
}

core.List<api.GoogleCloudAiplatformV1AutoscalingMetricSpec> buildUnnamed54() =>
    [
      buildGoogleCloudAiplatformV1AutoscalingMetricSpec(),
      buildGoogleCloudAiplatformV1AutoscalingMetricSpec(),
    ];

void checkUnnamed54(
    core.List<api.GoogleCloudAiplatformV1AutoscalingMetricSpec> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1AutoscalingMetricSpec(o[0]);
  checkGoogleCloudAiplatformV1AutoscalingMetricSpec(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1DedicatedResources = 0;
api.GoogleCloudAiplatformV1DedicatedResources
    buildGoogleCloudAiplatformV1DedicatedResources() {
  final o = api.GoogleCloudAiplatformV1DedicatedResources();
  buildCounterGoogleCloudAiplatformV1DedicatedResources++;
  if (buildCounterGoogleCloudAiplatformV1DedicatedResources < 3) {
    o.autoscalingMetricSpecs = buildUnnamed54();
    o.machineSpec = buildGoogleCloudAiplatformV1MachineSpec();
    o.maxReplicaCount = 42;
    o.minReplicaCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1DedicatedResources--;
  return o;
}

void checkGoogleCloudAiplatformV1DedicatedResources(
    api.GoogleCloudAiplatformV1DedicatedResources o) {
  buildCounterGoogleCloudAiplatformV1DedicatedResources++;
  if (buildCounterGoogleCloudAiplatformV1DedicatedResources < 3) {
    checkUnnamed54(o.autoscalingMetricSpecs!);
    checkGoogleCloudAiplatformV1MachineSpec(o.machineSpec!);
    unittest.expect(
      o.maxReplicaCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.minReplicaCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1DedicatedResources--;
}

core.int buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequest = 0;
api.GoogleCloudAiplatformV1DeleteFeatureValuesRequest
    buildGoogleCloudAiplatformV1DeleteFeatureValuesRequest() {
  final o = api.GoogleCloudAiplatformV1DeleteFeatureValuesRequest();
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequest < 3) {
    o.selectEntity =
        buildGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity();
    o.selectTimeRangeAndFeature =
        buildGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature();
  }
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1DeleteFeatureValuesRequest(
    api.GoogleCloudAiplatformV1DeleteFeatureValuesRequest o) {
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequest < 3) {
    checkGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity(
        o.selectEntity!);
    checkGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature(
        o.selectTimeRangeAndFeature!);
  }
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity =
    0;
api.GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity
    buildGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity() {
  final o = api.GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity();
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity++;
  if (buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity <
      3) {
    o.entityIdSelector = buildGoogleCloudAiplatformV1EntityIdSelector();
  }
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity--;
  return o;
}

void checkGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity(
    api.GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity o) {
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity++;
  if (buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity <
      3) {
    checkGoogleCloudAiplatformV1EntityIdSelector(o.entityIdSelector!);
  }
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity--;
}

core.int
    buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature =
    0;
api.GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature
    buildGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature() {
  final o = api
      .GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature();
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature++;
  if (buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature <
      3) {
    o.featureSelector = buildGoogleCloudAiplatformV1FeatureSelector();
    o.skipOnlineStorageDelete = true;
    o.timeRange = buildGoogleTypeInterval();
  }
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature--;
  return o;
}

void checkGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature(
    api.GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature
        o) {
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature++;
  if (buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature <
      3) {
    checkGoogleCloudAiplatformV1FeatureSelector(o.featureSelector!);
    unittest.expect(o.skipOnlineStorageDelete!, unittest.isTrue);
    checkGoogleTypeInterval(o.timeRange!);
  }
  buildCounterGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature--;
}

core.int buildCounterGoogleCloudAiplatformV1DeployIndexRequest = 0;
api.GoogleCloudAiplatformV1DeployIndexRequest
    buildGoogleCloudAiplatformV1DeployIndexRequest() {
  final o = api.GoogleCloudAiplatformV1DeployIndexRequest();
  buildCounterGoogleCloudAiplatformV1DeployIndexRequest++;
  if (buildCounterGoogleCloudAiplatformV1DeployIndexRequest < 3) {
    o.deployedIndex = buildGoogleCloudAiplatformV1DeployedIndex();
  }
  buildCounterGoogleCloudAiplatformV1DeployIndexRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1DeployIndexRequest(
    api.GoogleCloudAiplatformV1DeployIndexRequest o) {
  buildCounterGoogleCloudAiplatformV1DeployIndexRequest++;
  if (buildCounterGoogleCloudAiplatformV1DeployIndexRequest < 3) {
    checkGoogleCloudAiplatformV1DeployedIndex(o.deployedIndex!);
  }
  buildCounterGoogleCloudAiplatformV1DeployIndexRequest--;
}

core.Map<core.String, core.int> buildUnnamed55() => {
      'x': 42,
      'y': 42,
    };

void checkUnnamed55(core.Map<core.String, core.int> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals(42),
  );
  unittest.expect(
    o['y']!,
    unittest.equals(42),
  );
}

core.int buildCounterGoogleCloudAiplatformV1DeployModelRequest = 0;
api.GoogleCloudAiplatformV1DeployModelRequest
    buildGoogleCloudAiplatformV1DeployModelRequest() {
  final o = api.GoogleCloudAiplatformV1DeployModelRequest();
  buildCounterGoogleCloudAiplatformV1DeployModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1DeployModelRequest < 3) {
    o.deployedModel = buildGoogleCloudAiplatformV1DeployedModel();
    o.trafficSplit = buildUnnamed55();
  }
  buildCounterGoogleCloudAiplatformV1DeployModelRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1DeployModelRequest(
    api.GoogleCloudAiplatformV1DeployModelRequest o) {
  buildCounterGoogleCloudAiplatformV1DeployModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1DeployModelRequest < 3) {
    checkGoogleCloudAiplatformV1DeployedModel(o.deployedModel!);
    checkUnnamed55(o.trafficSplit!);
  }
  buildCounterGoogleCloudAiplatformV1DeployModelRequest--;
}

core.List<core.String> buildUnnamed56() => [
      'foo',
      'foo',
    ];

void checkUnnamed56(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1DeployedIndex = 0;
api.GoogleCloudAiplatformV1DeployedIndex
    buildGoogleCloudAiplatformV1DeployedIndex() {
  final o = api.GoogleCloudAiplatformV1DeployedIndex();
  buildCounterGoogleCloudAiplatformV1DeployedIndex++;
  if (buildCounterGoogleCloudAiplatformV1DeployedIndex < 3) {
    o.automaticResources = buildGoogleCloudAiplatformV1AutomaticResources();
    o.createTime = 'foo';
    o.dedicatedResources = buildGoogleCloudAiplatformV1DedicatedResources();
    o.deployedIndexAuthConfig =
        buildGoogleCloudAiplatformV1DeployedIndexAuthConfig();
    o.deploymentGroup = 'foo';
    o.displayName = 'foo';
    o.enableAccessLogging = true;
    o.id = 'foo';
    o.index = 'foo';
    o.indexSyncTime = 'foo';
    o.privateEndpoints = buildGoogleCloudAiplatformV1IndexPrivateEndpoints();
    o.reservedIpRanges = buildUnnamed56();
  }
  buildCounterGoogleCloudAiplatformV1DeployedIndex--;
  return o;
}

void checkGoogleCloudAiplatformV1DeployedIndex(
    api.GoogleCloudAiplatformV1DeployedIndex o) {
  buildCounterGoogleCloudAiplatformV1DeployedIndex++;
  if (buildCounterGoogleCloudAiplatformV1DeployedIndex < 3) {
    checkGoogleCloudAiplatformV1AutomaticResources(o.automaticResources!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1DedicatedResources(o.dedicatedResources!);
    checkGoogleCloudAiplatformV1DeployedIndexAuthConfig(
        o.deployedIndexAuthConfig!);
    unittest.expect(
      o.deploymentGroup!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(o.enableAccessLogging!, unittest.isTrue);
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.index!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.indexSyncTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1IndexPrivateEndpoints(o.privateEndpoints!);
    checkUnnamed56(o.reservedIpRanges!);
  }
  buildCounterGoogleCloudAiplatformV1DeployedIndex--;
}

core.int buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfig = 0;
api.GoogleCloudAiplatformV1DeployedIndexAuthConfig
    buildGoogleCloudAiplatformV1DeployedIndexAuthConfig() {
  final o = api.GoogleCloudAiplatformV1DeployedIndexAuthConfig();
  buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfig++;
  if (buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfig < 3) {
    o.authProvider =
        buildGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider();
  }
  buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1DeployedIndexAuthConfig(
    api.GoogleCloudAiplatformV1DeployedIndexAuthConfig o) {
  buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfig++;
  if (buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfig < 3) {
    checkGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider(
        o.authProvider!);
  }
  buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfig--;
}

core.List<core.String> buildUnnamed57() => [
      'foo',
      'foo',
    ];

void checkUnnamed57(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed58() => [
      'foo',
      'foo',
    ];

void checkUnnamed58(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider = 0;
api.GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider
    buildGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider() {
  final o = api.GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider();
  buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider++;
  if (buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider <
      3) {
    o.allowedIssuers = buildUnnamed57();
    o.audiences = buildUnnamed58();
  }
  buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider--;
  return o;
}

void checkGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider(
    api.GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider o) {
  buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider++;
  if (buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider <
      3) {
    checkUnnamed57(o.allowedIssuers!);
    checkUnnamed58(o.audiences!);
  }
  buildCounterGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider--;
}

core.int buildCounterGoogleCloudAiplatformV1DeployedIndexRef = 0;
api.GoogleCloudAiplatformV1DeployedIndexRef
    buildGoogleCloudAiplatformV1DeployedIndexRef() {
  final o = api.GoogleCloudAiplatformV1DeployedIndexRef();
  buildCounterGoogleCloudAiplatformV1DeployedIndexRef++;
  if (buildCounterGoogleCloudAiplatformV1DeployedIndexRef < 3) {
    o.deployedIndexId = 'foo';
    o.displayName = 'foo';
    o.indexEndpoint = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DeployedIndexRef--;
  return o;
}

void checkGoogleCloudAiplatformV1DeployedIndexRef(
    api.GoogleCloudAiplatformV1DeployedIndexRef o) {
  buildCounterGoogleCloudAiplatformV1DeployedIndexRef++;
  if (buildCounterGoogleCloudAiplatformV1DeployedIndexRef < 3) {
    unittest.expect(
      o.deployedIndexId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.indexEndpoint!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DeployedIndexRef--;
}

core.int buildCounterGoogleCloudAiplatformV1DeployedModel = 0;
api.GoogleCloudAiplatformV1DeployedModel
    buildGoogleCloudAiplatformV1DeployedModel() {
  final o = api.GoogleCloudAiplatformV1DeployedModel();
  buildCounterGoogleCloudAiplatformV1DeployedModel++;
  if (buildCounterGoogleCloudAiplatformV1DeployedModel < 3) {
    o.automaticResources = buildGoogleCloudAiplatformV1AutomaticResources();
    o.createTime = 'foo';
    o.dedicatedResources = buildGoogleCloudAiplatformV1DedicatedResources();
    o.disableContainerLogging = true;
    o.displayName = 'foo';
    o.enableAccessLogging = true;
    o.explanationSpec = buildGoogleCloudAiplatformV1ExplanationSpec();
    o.id = 'foo';
    o.model = 'foo';
    o.modelVersionId = 'foo';
    o.privateEndpoints = buildGoogleCloudAiplatformV1PrivateEndpoints();
    o.serviceAccount = 'foo';
    o.sharedResources = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DeployedModel--;
  return o;
}

void checkGoogleCloudAiplatformV1DeployedModel(
    api.GoogleCloudAiplatformV1DeployedModel o) {
  buildCounterGoogleCloudAiplatformV1DeployedModel++;
  if (buildCounterGoogleCloudAiplatformV1DeployedModel < 3) {
    checkGoogleCloudAiplatformV1AutomaticResources(o.automaticResources!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1DedicatedResources(o.dedicatedResources!);
    unittest.expect(o.disableContainerLogging!, unittest.isTrue);
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(o.enableAccessLogging!, unittest.isTrue);
    checkGoogleCloudAiplatformV1ExplanationSpec(o.explanationSpec!);
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.model!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modelVersionId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PrivateEndpoints(o.privateEndpoints!);
    unittest.expect(
      o.serviceAccount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.sharedResources!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DeployedModel--;
}

core.int buildCounterGoogleCloudAiplatformV1DeployedModelRef = 0;
api.GoogleCloudAiplatformV1DeployedModelRef
    buildGoogleCloudAiplatformV1DeployedModelRef() {
  final o = api.GoogleCloudAiplatformV1DeployedModelRef();
  buildCounterGoogleCloudAiplatformV1DeployedModelRef++;
  if (buildCounterGoogleCloudAiplatformV1DeployedModelRef < 3) {
    o.deployedModelId = 'foo';
    o.endpoint = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DeployedModelRef--;
  return o;
}

void checkGoogleCloudAiplatformV1DeployedModelRef(
    api.GoogleCloudAiplatformV1DeployedModelRef o) {
  buildCounterGoogleCloudAiplatformV1DeployedModelRef++;
  if (buildCounterGoogleCloudAiplatformV1DeployedModelRef < 3) {
    unittest.expect(
      o.deployedModelId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.endpoint!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DeployedModelRef--;
}

core.int buildCounterGoogleCloudAiplatformV1DeploymentResourcePool = 0;
api.GoogleCloudAiplatformV1DeploymentResourcePool
    buildGoogleCloudAiplatformV1DeploymentResourcePool() {
  final o = api.GoogleCloudAiplatformV1DeploymentResourcePool();
  buildCounterGoogleCloudAiplatformV1DeploymentResourcePool++;
  if (buildCounterGoogleCloudAiplatformV1DeploymentResourcePool < 3) {
    o.createTime = 'foo';
    o.dedicatedResources = buildGoogleCloudAiplatformV1DedicatedResources();
    o.name = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DeploymentResourcePool--;
  return o;
}

void checkGoogleCloudAiplatformV1DeploymentResourcePool(
    api.GoogleCloudAiplatformV1DeploymentResourcePool o) {
  buildCounterGoogleCloudAiplatformV1DeploymentResourcePool++;
  if (buildCounterGoogleCloudAiplatformV1DeploymentResourcePool < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1DedicatedResources(o.dedicatedResources!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DeploymentResourcePool--;
}

core.int buildCounterGoogleCloudAiplatformV1DestinationFeatureSetting = 0;
api.GoogleCloudAiplatformV1DestinationFeatureSetting
    buildGoogleCloudAiplatformV1DestinationFeatureSetting() {
  final o = api.GoogleCloudAiplatformV1DestinationFeatureSetting();
  buildCounterGoogleCloudAiplatformV1DestinationFeatureSetting++;
  if (buildCounterGoogleCloudAiplatformV1DestinationFeatureSetting < 3) {
    o.destinationField = 'foo';
    o.featureId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DestinationFeatureSetting--;
  return o;
}

void checkGoogleCloudAiplatformV1DestinationFeatureSetting(
    api.GoogleCloudAiplatformV1DestinationFeatureSetting o) {
  buildCounterGoogleCloudAiplatformV1DestinationFeatureSetting++;
  if (buildCounterGoogleCloudAiplatformV1DestinationFeatureSetting < 3) {
    unittest.expect(
      o.destinationField!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.featureId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DestinationFeatureSetting--;
}

core.List<api.GoogleCloudAiplatformV1Tensor> buildUnnamed59() => [
      buildGoogleCloudAiplatformV1Tensor(),
      buildGoogleCloudAiplatformV1Tensor(),
    ];

void checkUnnamed59(core.List<api.GoogleCloudAiplatformV1Tensor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Tensor(o[0]);
  checkGoogleCloudAiplatformV1Tensor(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1DirectPredictRequest = 0;
api.GoogleCloudAiplatformV1DirectPredictRequest
    buildGoogleCloudAiplatformV1DirectPredictRequest() {
  final o = api.GoogleCloudAiplatformV1DirectPredictRequest();
  buildCounterGoogleCloudAiplatformV1DirectPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1DirectPredictRequest < 3) {
    o.inputs = buildUnnamed59();
    o.parameters = buildGoogleCloudAiplatformV1Tensor();
  }
  buildCounterGoogleCloudAiplatformV1DirectPredictRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1DirectPredictRequest(
    api.GoogleCloudAiplatformV1DirectPredictRequest o) {
  buildCounterGoogleCloudAiplatformV1DirectPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1DirectPredictRequest < 3) {
    checkUnnamed59(o.inputs!);
    checkGoogleCloudAiplatformV1Tensor(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1DirectPredictRequest--;
}

core.List<api.GoogleCloudAiplatformV1Tensor> buildUnnamed60() => [
      buildGoogleCloudAiplatformV1Tensor(),
      buildGoogleCloudAiplatformV1Tensor(),
    ];

void checkUnnamed60(core.List<api.GoogleCloudAiplatformV1Tensor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Tensor(o[0]);
  checkGoogleCloudAiplatformV1Tensor(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1DirectPredictResponse = 0;
api.GoogleCloudAiplatformV1DirectPredictResponse
    buildGoogleCloudAiplatformV1DirectPredictResponse() {
  final o = api.GoogleCloudAiplatformV1DirectPredictResponse();
  buildCounterGoogleCloudAiplatformV1DirectPredictResponse++;
  if (buildCounterGoogleCloudAiplatformV1DirectPredictResponse < 3) {
    o.outputs = buildUnnamed60();
    o.parameters = buildGoogleCloudAiplatformV1Tensor();
  }
  buildCounterGoogleCloudAiplatformV1DirectPredictResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1DirectPredictResponse(
    api.GoogleCloudAiplatformV1DirectPredictResponse o) {
  buildCounterGoogleCloudAiplatformV1DirectPredictResponse++;
  if (buildCounterGoogleCloudAiplatformV1DirectPredictResponse < 3) {
    checkUnnamed60(o.outputs!);
    checkGoogleCloudAiplatformV1Tensor(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1DirectPredictResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1DirectRawPredictRequest = 0;
api.GoogleCloudAiplatformV1DirectRawPredictRequest
    buildGoogleCloudAiplatformV1DirectRawPredictRequest() {
  final o = api.GoogleCloudAiplatformV1DirectRawPredictRequest();
  buildCounterGoogleCloudAiplatformV1DirectRawPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1DirectRawPredictRequest < 3) {
    o.input = 'foo';
    o.methodName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DirectRawPredictRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1DirectRawPredictRequest(
    api.GoogleCloudAiplatformV1DirectRawPredictRequest o) {
  buildCounterGoogleCloudAiplatformV1DirectRawPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1DirectRawPredictRequest < 3) {
    unittest.expect(
      o.input!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.methodName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DirectRawPredictRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1DirectRawPredictResponse = 0;
api.GoogleCloudAiplatformV1DirectRawPredictResponse
    buildGoogleCloudAiplatformV1DirectRawPredictResponse() {
  final o = api.GoogleCloudAiplatformV1DirectRawPredictResponse();
  buildCounterGoogleCloudAiplatformV1DirectRawPredictResponse++;
  if (buildCounterGoogleCloudAiplatformV1DirectRawPredictResponse < 3) {
    o.output = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DirectRawPredictResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1DirectRawPredictResponse(
    api.GoogleCloudAiplatformV1DirectRawPredictResponse o) {
  buildCounterGoogleCloudAiplatformV1DirectRawPredictResponse++;
  if (buildCounterGoogleCloudAiplatformV1DirectRawPredictResponse < 3) {
    unittest.expect(
      o.output!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DirectRawPredictResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1DiskSpec = 0;
api.GoogleCloudAiplatformV1DiskSpec buildGoogleCloudAiplatformV1DiskSpec() {
  final o = api.GoogleCloudAiplatformV1DiskSpec();
  buildCounterGoogleCloudAiplatformV1DiskSpec++;
  if (buildCounterGoogleCloudAiplatformV1DiskSpec < 3) {
    o.bootDiskSizeGb = 42;
    o.bootDiskType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1DiskSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1DiskSpec(
    api.GoogleCloudAiplatformV1DiskSpec o) {
  buildCounterGoogleCloudAiplatformV1DiskSpec++;
  if (buildCounterGoogleCloudAiplatformV1DiskSpec < 3) {
    unittest.expect(
      o.bootDiskSizeGb!,
      unittest.equals(42),
    );
    unittest.expect(
      o.bootDiskType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1DiskSpec--;
}

core.List<core.double> buildUnnamed61() => [
      42.0,
      42.0,
    ];

void checkUnnamed61(core.List<core.double> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42.0),
  );
  unittest.expect(
    o[1],
    unittest.equals(42.0),
  );
}

core.int buildCounterGoogleCloudAiplatformV1DoubleArray = 0;
api.GoogleCloudAiplatformV1DoubleArray
    buildGoogleCloudAiplatformV1DoubleArray() {
  final o = api.GoogleCloudAiplatformV1DoubleArray();
  buildCounterGoogleCloudAiplatformV1DoubleArray++;
  if (buildCounterGoogleCloudAiplatformV1DoubleArray < 3) {
    o.values = buildUnnamed61();
  }
  buildCounterGoogleCloudAiplatformV1DoubleArray--;
  return o;
}

void checkGoogleCloudAiplatformV1DoubleArray(
    api.GoogleCloudAiplatformV1DoubleArray o) {
  buildCounterGoogleCloudAiplatformV1DoubleArray++;
  if (buildCounterGoogleCloudAiplatformV1DoubleArray < 3) {
    checkUnnamed61(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1DoubleArray--;
}

core.int buildCounterGoogleCloudAiplatformV1EncryptionSpec = 0;
api.GoogleCloudAiplatformV1EncryptionSpec
    buildGoogleCloudAiplatformV1EncryptionSpec() {
  final o = api.GoogleCloudAiplatformV1EncryptionSpec();
  buildCounterGoogleCloudAiplatformV1EncryptionSpec++;
  if (buildCounterGoogleCloudAiplatformV1EncryptionSpec < 3) {
    o.kmsKeyName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1EncryptionSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1EncryptionSpec(
    api.GoogleCloudAiplatformV1EncryptionSpec o) {
  buildCounterGoogleCloudAiplatformV1EncryptionSpec++;
  if (buildCounterGoogleCloudAiplatformV1EncryptionSpec < 3) {
    unittest.expect(
      o.kmsKeyName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1EncryptionSpec--;
}

core.List<api.GoogleCloudAiplatformV1DeployedModel> buildUnnamed62() => [
      buildGoogleCloudAiplatformV1DeployedModel(),
      buildGoogleCloudAiplatformV1DeployedModel(),
    ];

void checkUnnamed62(core.List<api.GoogleCloudAiplatformV1DeployedModel> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DeployedModel(o[0]);
  checkGoogleCloudAiplatformV1DeployedModel(o[1]);
}

core.Map<core.String, core.String> buildUnnamed63() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed63(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.int> buildUnnamed64() => {
      'x': 42,
      'y': 42,
    };

void checkUnnamed64(core.Map<core.String, core.int> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals(42),
  );
  unittest.expect(
    o['y']!,
    unittest.equals(42),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Endpoint = 0;
api.GoogleCloudAiplatformV1Endpoint buildGoogleCloudAiplatformV1Endpoint() {
  final o = api.GoogleCloudAiplatformV1Endpoint();
  buildCounterGoogleCloudAiplatformV1Endpoint++;
  if (buildCounterGoogleCloudAiplatformV1Endpoint < 3) {
    o.createTime = 'foo';
    o.deployedModels = buildUnnamed62();
    o.description = 'foo';
    o.displayName = 'foo';
    o.enablePrivateServiceConnect = true;
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.etag = 'foo';
    o.labels = buildUnnamed63();
    o.modelDeploymentMonitoringJob = 'foo';
    o.name = 'foo';
    o.network = 'foo';
    o.predictRequestResponseLoggingConfig =
        buildGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig();
    o.privateServiceConnectConfig =
        buildGoogleCloudAiplatformV1PrivateServiceConnectConfig();
    o.trafficSplit = buildUnnamed64();
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Endpoint--;
  return o;
}

void checkGoogleCloudAiplatformV1Endpoint(
    api.GoogleCloudAiplatformV1Endpoint o) {
  buildCounterGoogleCloudAiplatformV1Endpoint++;
  if (buildCounterGoogleCloudAiplatformV1Endpoint < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkUnnamed62(o.deployedModels!);
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(o.enablePrivateServiceConnect!, unittest.isTrue);
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed63(o.labels!);
    unittest.expect(
      o.modelDeploymentMonitoringJob!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.network!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig(
        o.predictRequestResponseLoggingConfig!);
    checkGoogleCloudAiplatformV1PrivateServiceConnectConfig(
        o.privateServiceConnectConfig!);
    checkUnnamed64(o.trafficSplit!);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Endpoint--;
}

core.int buildCounterGoogleCloudAiplatformV1EntityIdSelector = 0;
api.GoogleCloudAiplatformV1EntityIdSelector
    buildGoogleCloudAiplatformV1EntityIdSelector() {
  final o = api.GoogleCloudAiplatformV1EntityIdSelector();
  buildCounterGoogleCloudAiplatformV1EntityIdSelector++;
  if (buildCounterGoogleCloudAiplatformV1EntityIdSelector < 3) {
    o.csvSource = buildGoogleCloudAiplatformV1CsvSource();
    o.entityIdField = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1EntityIdSelector--;
  return o;
}

void checkGoogleCloudAiplatformV1EntityIdSelector(
    api.GoogleCloudAiplatformV1EntityIdSelector o) {
  buildCounterGoogleCloudAiplatformV1EntityIdSelector++;
  if (buildCounterGoogleCloudAiplatformV1EntityIdSelector < 3) {
    checkGoogleCloudAiplatformV1CsvSource(o.csvSource!);
    unittest.expect(
      o.entityIdField!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1EntityIdSelector--;
}

core.Map<core.String, core.String> buildUnnamed65() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed65(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1EntityType = 0;
api.GoogleCloudAiplatformV1EntityType buildGoogleCloudAiplatformV1EntityType() {
  final o = api.GoogleCloudAiplatformV1EntityType();
  buildCounterGoogleCloudAiplatformV1EntityType++;
  if (buildCounterGoogleCloudAiplatformV1EntityType < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed65();
    o.monitoringConfig =
        buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfig();
    o.name = 'foo';
    o.offlineStorageTtlDays = 42;
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1EntityType--;
  return o;
}

void checkGoogleCloudAiplatformV1EntityType(
    api.GoogleCloudAiplatformV1EntityType o) {
  buildCounterGoogleCloudAiplatformV1EntityType++;
  if (buildCounterGoogleCloudAiplatformV1EntityType < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed65(o.labels!);
    checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfig(
        o.monitoringConfig!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.offlineStorageTtlDays!,
      unittest.equals(42),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1EntityType--;
}

core.int buildCounterGoogleCloudAiplatformV1EnvVar = 0;
api.GoogleCloudAiplatformV1EnvVar buildGoogleCloudAiplatformV1EnvVar() {
  final o = api.GoogleCloudAiplatformV1EnvVar();
  buildCounterGoogleCloudAiplatformV1EnvVar++;
  if (buildCounterGoogleCloudAiplatformV1EnvVar < 3) {
    o.name = 'foo';
    o.value = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1EnvVar--;
  return o;
}

void checkGoogleCloudAiplatformV1EnvVar(api.GoogleCloudAiplatformV1EnvVar o) {
  buildCounterGoogleCloudAiplatformV1EnvVar++;
  if (buildCounterGoogleCloudAiplatformV1EnvVar < 3) {
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.value!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1EnvVar--;
}

core.List<api.GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem>
    buildUnnamed66() => [
          buildGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem(),
          buildGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem(),
        ];

void checkUnnamed66(
    core.List<api.GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem(o[0]);
  checkGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotation = 0;
api.GoogleCloudAiplatformV1ErrorAnalysisAnnotation
    buildGoogleCloudAiplatformV1ErrorAnalysisAnnotation() {
  final o = api.GoogleCloudAiplatformV1ErrorAnalysisAnnotation();
  buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotation++;
  if (buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotation < 3) {
    o.attributedItems = buildUnnamed66();
    o.outlierScore = 42.0;
    o.outlierThreshold = 42.0;
    o.queryType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotation--;
  return o;
}

void checkGoogleCloudAiplatformV1ErrorAnalysisAnnotation(
    api.GoogleCloudAiplatformV1ErrorAnalysisAnnotation o) {
  buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotation++;
  if (buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotation < 3) {
    checkUnnamed66(o.attributedItems!);
    unittest.expect(
      o.outlierScore!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.outlierThreshold!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.queryType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotation--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem =
    0;
api.GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem
    buildGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem() {
  final o = api.GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem();
  buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem++;
  if (buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem <
      3) {
    o.annotationResourceName = 'foo';
    o.distance = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem--;
  return o;
}

void checkGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem(
    api.GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem o) {
  buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem++;
  if (buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem <
      3) {
    unittest.expect(
      o.annotationResourceName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.distance!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem--;
}

core.List<api.GoogleCloudAiplatformV1ErrorAnalysisAnnotation>
    buildUnnamed67() => [
          buildGoogleCloudAiplatformV1ErrorAnalysisAnnotation(),
          buildGoogleCloudAiplatformV1ErrorAnalysisAnnotation(),
        ];

void checkUnnamed67(
    core.List<api.GoogleCloudAiplatformV1ErrorAnalysisAnnotation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ErrorAnalysisAnnotation(o[0]);
  checkGoogleCloudAiplatformV1ErrorAnalysisAnnotation(o[1]);
}

core.List<api.GoogleCloudAiplatformV1EvaluatedAnnotationExplanation>
    buildUnnamed68() => [
          buildGoogleCloudAiplatformV1EvaluatedAnnotationExplanation(),
          buildGoogleCloudAiplatformV1EvaluatedAnnotationExplanation(),
        ];

void checkUnnamed68(
    core.List<api.GoogleCloudAiplatformV1EvaluatedAnnotationExplanation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1EvaluatedAnnotationExplanation(o[0]);
  checkGoogleCloudAiplatformV1EvaluatedAnnotationExplanation(o[1]);
}

core.List<core.Object?> buildUnnamed69() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed69(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted18 = (o[0]) as core.Map;
  unittest.expect(casted18, unittest.hasLength(3));
  unittest.expect(
    casted18['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted18['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted18['string'],
    unittest.equals('foo'),
  );
  var casted19 = (o[1]) as core.Map;
  unittest.expect(casted19, unittest.hasLength(3));
  unittest.expect(
    casted19['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted19['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted19['string'],
    unittest.equals('foo'),
  );
}

core.List<core.Object?> buildUnnamed70() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed70(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted20 = (o[0]) as core.Map;
  unittest.expect(casted20, unittest.hasLength(3));
  unittest.expect(
    casted20['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted20['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted20['string'],
    unittest.equals('foo'),
  );
  var casted21 = (o[1]) as core.Map;
  unittest.expect(casted21, unittest.hasLength(3));
  unittest.expect(
    casted21['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted21['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted21['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1EvaluatedAnnotation = 0;
api.GoogleCloudAiplatformV1EvaluatedAnnotation
    buildGoogleCloudAiplatformV1EvaluatedAnnotation() {
  final o = api.GoogleCloudAiplatformV1EvaluatedAnnotation();
  buildCounterGoogleCloudAiplatformV1EvaluatedAnnotation++;
  if (buildCounterGoogleCloudAiplatformV1EvaluatedAnnotation < 3) {
    o.dataItemPayload = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.errorAnalysisAnnotations = buildUnnamed67();
    o.evaluatedDataItemViewId = 'foo';
    o.explanations = buildUnnamed68();
    o.groundTruths = buildUnnamed69();
    o.predictions = buildUnnamed70();
    o.type = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1EvaluatedAnnotation--;
  return o;
}

void checkGoogleCloudAiplatformV1EvaluatedAnnotation(
    api.GoogleCloudAiplatformV1EvaluatedAnnotation o) {
  buildCounterGoogleCloudAiplatformV1EvaluatedAnnotation++;
  if (buildCounterGoogleCloudAiplatformV1EvaluatedAnnotation < 3) {
    var casted22 = (o.dataItemPayload!) as core.Map;
    unittest.expect(casted22, unittest.hasLength(3));
    unittest.expect(
      casted22['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted22['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted22['string'],
      unittest.equals('foo'),
    );
    checkUnnamed67(o.errorAnalysisAnnotations!);
    unittest.expect(
      o.evaluatedDataItemViewId!,
      unittest.equals('foo'),
    );
    checkUnnamed68(o.explanations!);
    checkUnnamed69(o.groundTruths!);
    checkUnnamed70(o.predictions!);
    unittest.expect(
      o.type!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1EvaluatedAnnotation--;
}

core.int buildCounterGoogleCloudAiplatformV1EvaluatedAnnotationExplanation = 0;
api.GoogleCloudAiplatformV1EvaluatedAnnotationExplanation
    buildGoogleCloudAiplatformV1EvaluatedAnnotationExplanation() {
  final o = api.GoogleCloudAiplatformV1EvaluatedAnnotationExplanation();
  buildCounterGoogleCloudAiplatformV1EvaluatedAnnotationExplanation++;
  if (buildCounterGoogleCloudAiplatformV1EvaluatedAnnotationExplanation < 3) {
    o.explanation = buildGoogleCloudAiplatformV1Explanation();
    o.explanationType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1EvaluatedAnnotationExplanation--;
  return o;
}

void checkGoogleCloudAiplatformV1EvaluatedAnnotationExplanation(
    api.GoogleCloudAiplatformV1EvaluatedAnnotationExplanation o) {
  buildCounterGoogleCloudAiplatformV1EvaluatedAnnotationExplanation++;
  if (buildCounterGoogleCloudAiplatformV1EvaluatedAnnotationExplanation < 3) {
    checkGoogleCloudAiplatformV1Explanation(o.explanation!);
    unittest.expect(
      o.explanationType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1EvaluatedAnnotationExplanation--;
}

core.Map<core.String, core.String> buildUnnamed71() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed71(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Event = 0;
api.GoogleCloudAiplatformV1Event buildGoogleCloudAiplatformV1Event() {
  final o = api.GoogleCloudAiplatformV1Event();
  buildCounterGoogleCloudAiplatformV1Event++;
  if (buildCounterGoogleCloudAiplatformV1Event < 3) {
    o.artifact = 'foo';
    o.eventTime = 'foo';
    o.execution = 'foo';
    o.labels = buildUnnamed71();
    o.type = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Event--;
  return o;
}

void checkGoogleCloudAiplatformV1Event(api.GoogleCloudAiplatformV1Event o) {
  buildCounterGoogleCloudAiplatformV1Event++;
  if (buildCounterGoogleCloudAiplatformV1Event < 3) {
    unittest.expect(
      o.artifact!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.eventTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.execution!,
      unittest.equals('foo'),
    );
    checkUnnamed71(o.labels!);
    unittest.expect(
      o.type!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Event--;
}

core.int buildCounterGoogleCloudAiplatformV1Examples = 0;
api.GoogleCloudAiplatformV1Examples buildGoogleCloudAiplatformV1Examples() {
  final o = api.GoogleCloudAiplatformV1Examples();
  buildCounterGoogleCloudAiplatformV1Examples++;
  if (buildCounterGoogleCloudAiplatformV1Examples < 3) {
    o.exampleGcsSource = buildGoogleCloudAiplatformV1ExamplesExampleGcsSource();
    o.nearestNeighborSearchConfig = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.neighborCount = 42;
    o.presets = buildGoogleCloudAiplatformV1Presets();
  }
  buildCounterGoogleCloudAiplatformV1Examples--;
  return o;
}

void checkGoogleCloudAiplatformV1Examples(
    api.GoogleCloudAiplatformV1Examples o) {
  buildCounterGoogleCloudAiplatformV1Examples++;
  if (buildCounterGoogleCloudAiplatformV1Examples < 3) {
    checkGoogleCloudAiplatformV1ExamplesExampleGcsSource(o.exampleGcsSource!);
    var casted23 = (o.nearestNeighborSearchConfig!) as core.Map;
    unittest.expect(casted23, unittest.hasLength(3));
    unittest.expect(
      casted23['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted23['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted23['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.neighborCount!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1Presets(o.presets!);
  }
  buildCounterGoogleCloudAiplatformV1Examples--;
}

core.int buildCounterGoogleCloudAiplatformV1ExamplesExampleGcsSource = 0;
api.GoogleCloudAiplatformV1ExamplesExampleGcsSource
    buildGoogleCloudAiplatformV1ExamplesExampleGcsSource() {
  final o = api.GoogleCloudAiplatformV1ExamplesExampleGcsSource();
  buildCounterGoogleCloudAiplatformV1ExamplesExampleGcsSource++;
  if (buildCounterGoogleCloudAiplatformV1ExamplesExampleGcsSource < 3) {
    o.dataFormat = 'foo';
    o.gcsSource = buildGoogleCloudAiplatformV1GcsSource();
  }
  buildCounterGoogleCloudAiplatformV1ExamplesExampleGcsSource--;
  return o;
}

void checkGoogleCloudAiplatformV1ExamplesExampleGcsSource(
    api.GoogleCloudAiplatformV1ExamplesExampleGcsSource o) {
  buildCounterGoogleCloudAiplatformV1ExamplesExampleGcsSource++;
  if (buildCounterGoogleCloudAiplatformV1ExamplesExampleGcsSource < 3) {
    unittest.expect(
      o.dataFormat!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1GcsSource(o.gcsSource!);
  }
  buildCounterGoogleCloudAiplatformV1ExamplesExampleGcsSource--;
}

core.List<api.GoogleCloudAiplatformV1ExamplesRestrictionsNamespace>
    buildUnnamed72() => [
          buildGoogleCloudAiplatformV1ExamplesRestrictionsNamespace(),
          buildGoogleCloudAiplatformV1ExamplesRestrictionsNamespace(),
        ];

void checkUnnamed72(
    core.List<api.GoogleCloudAiplatformV1ExamplesRestrictionsNamespace> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ExamplesRestrictionsNamespace(o[0]);
  checkGoogleCloudAiplatformV1ExamplesRestrictionsNamespace(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ExamplesOverride = 0;
api.GoogleCloudAiplatformV1ExamplesOverride
    buildGoogleCloudAiplatformV1ExamplesOverride() {
  final o = api.GoogleCloudAiplatformV1ExamplesOverride();
  buildCounterGoogleCloudAiplatformV1ExamplesOverride++;
  if (buildCounterGoogleCloudAiplatformV1ExamplesOverride < 3) {
    o.crowdingCount = 42;
    o.dataFormat = 'foo';
    o.neighborCount = 42;
    o.restrictions = buildUnnamed72();
    o.returnEmbeddings = true;
  }
  buildCounterGoogleCloudAiplatformV1ExamplesOverride--;
  return o;
}

void checkGoogleCloudAiplatformV1ExamplesOverride(
    api.GoogleCloudAiplatformV1ExamplesOverride o) {
  buildCounterGoogleCloudAiplatformV1ExamplesOverride++;
  if (buildCounterGoogleCloudAiplatformV1ExamplesOverride < 3) {
    unittest.expect(
      o.crowdingCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.dataFormat!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.neighborCount!,
      unittest.equals(42),
    );
    checkUnnamed72(o.restrictions!);
    unittest.expect(o.returnEmbeddings!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1ExamplesOverride--;
}

core.List<core.String> buildUnnamed73() => [
      'foo',
      'foo',
    ];

void checkUnnamed73(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed74() => [
      'foo',
      'foo',
    ];

void checkUnnamed74(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ExamplesRestrictionsNamespace = 0;
api.GoogleCloudAiplatformV1ExamplesRestrictionsNamespace
    buildGoogleCloudAiplatformV1ExamplesRestrictionsNamespace() {
  final o = api.GoogleCloudAiplatformV1ExamplesRestrictionsNamespace();
  buildCounterGoogleCloudAiplatformV1ExamplesRestrictionsNamespace++;
  if (buildCounterGoogleCloudAiplatformV1ExamplesRestrictionsNamespace < 3) {
    o.allow = buildUnnamed73();
    o.deny = buildUnnamed74();
    o.namespaceName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ExamplesRestrictionsNamespace--;
  return o;
}

void checkGoogleCloudAiplatformV1ExamplesRestrictionsNamespace(
    api.GoogleCloudAiplatformV1ExamplesRestrictionsNamespace o) {
  buildCounterGoogleCloudAiplatformV1ExamplesRestrictionsNamespace++;
  if (buildCounterGoogleCloudAiplatformV1ExamplesRestrictionsNamespace < 3) {
    checkUnnamed73(o.allow!);
    checkUnnamed74(o.deny!);
    unittest.expect(
      o.namespaceName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExamplesRestrictionsNamespace--;
}

core.Map<core.String, core.String> buildUnnamed75() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed75(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.Object?> buildUnnamed76() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed76(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted24 = (o['x']!) as core.Map;
  unittest.expect(casted24, unittest.hasLength(3));
  unittest.expect(
    casted24['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted24['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted24['string'],
    unittest.equals('foo'),
  );
  var casted25 = (o['y']!) as core.Map;
  unittest.expect(casted25, unittest.hasLength(3));
  unittest.expect(
    casted25['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted25['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted25['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Execution = 0;
api.GoogleCloudAiplatformV1Execution buildGoogleCloudAiplatformV1Execution() {
  final o = api.GoogleCloudAiplatformV1Execution();
  buildCounterGoogleCloudAiplatformV1Execution++;
  if (buildCounterGoogleCloudAiplatformV1Execution < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed75();
    o.metadata = buildUnnamed76();
    o.name = 'foo';
    o.schemaTitle = 'foo';
    o.schemaVersion = 'foo';
    o.state = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Execution--;
  return o;
}

void checkGoogleCloudAiplatformV1Execution(
    api.GoogleCloudAiplatformV1Execution o) {
  buildCounterGoogleCloudAiplatformV1Execution++;
  if (buildCounterGoogleCloudAiplatformV1Execution < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed75(o.labels!);
    checkUnnamed76(o.metadata!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.schemaTitle!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.schemaVersion!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Execution--;
}

core.List<core.Object?> buildUnnamed77() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed77(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted26 = (o[0]) as core.Map;
  unittest.expect(casted26, unittest.hasLength(3));
  unittest.expect(
    casted26['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted26['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted26['string'],
    unittest.equals('foo'),
  );
  var casted27 = (o[1]) as core.Map;
  unittest.expect(casted27, unittest.hasLength(3));
  unittest.expect(
    casted27['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted27['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted27['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ExplainRequest = 0;
api.GoogleCloudAiplatformV1ExplainRequest
    buildGoogleCloudAiplatformV1ExplainRequest() {
  final o = api.GoogleCloudAiplatformV1ExplainRequest();
  buildCounterGoogleCloudAiplatformV1ExplainRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExplainRequest < 3) {
    o.deployedModelId = 'foo';
    o.explanationSpecOverride =
        buildGoogleCloudAiplatformV1ExplanationSpecOverride();
    o.instances = buildUnnamed77();
    o.parameters = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
  }
  buildCounterGoogleCloudAiplatformV1ExplainRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplainRequest(
    api.GoogleCloudAiplatformV1ExplainRequest o) {
  buildCounterGoogleCloudAiplatformV1ExplainRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExplainRequest < 3) {
    unittest.expect(
      o.deployedModelId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ExplanationSpecOverride(
        o.explanationSpecOverride!);
    checkUnnamed77(o.instances!);
    var casted28 = (o.parameters!) as core.Map;
    unittest.expect(casted28, unittest.hasLength(3));
    unittest.expect(
      casted28['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted28['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted28['string'],
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExplainRequest--;
}

core.List<api.GoogleCloudAiplatformV1Explanation> buildUnnamed78() => [
      buildGoogleCloudAiplatformV1Explanation(),
      buildGoogleCloudAiplatformV1Explanation(),
    ];

void checkUnnamed78(core.List<api.GoogleCloudAiplatformV1Explanation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Explanation(o[0]);
  checkGoogleCloudAiplatformV1Explanation(o[1]);
}

core.List<core.Object?> buildUnnamed79() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed79(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted29 = (o[0]) as core.Map;
  unittest.expect(casted29, unittest.hasLength(3));
  unittest.expect(
    casted29['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted29['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted29['string'],
    unittest.equals('foo'),
  );
  var casted30 = (o[1]) as core.Map;
  unittest.expect(casted30, unittest.hasLength(3));
  unittest.expect(
    casted30['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted30['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted30['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ExplainResponse = 0;
api.GoogleCloudAiplatformV1ExplainResponse
    buildGoogleCloudAiplatformV1ExplainResponse() {
  final o = api.GoogleCloudAiplatformV1ExplainResponse();
  buildCounterGoogleCloudAiplatformV1ExplainResponse++;
  if (buildCounterGoogleCloudAiplatformV1ExplainResponse < 3) {
    o.deployedModelId = 'foo';
    o.explanations = buildUnnamed78();
    o.predictions = buildUnnamed79();
  }
  buildCounterGoogleCloudAiplatformV1ExplainResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplainResponse(
    api.GoogleCloudAiplatformV1ExplainResponse o) {
  buildCounterGoogleCloudAiplatformV1ExplainResponse++;
  if (buildCounterGoogleCloudAiplatformV1ExplainResponse < 3) {
    unittest.expect(
      o.deployedModelId!,
      unittest.equals('foo'),
    );
    checkUnnamed78(o.explanations!);
    checkUnnamed79(o.predictions!);
  }
  buildCounterGoogleCloudAiplatformV1ExplainResponse--;
}

core.List<api.GoogleCloudAiplatformV1Attribution> buildUnnamed80() => [
      buildGoogleCloudAiplatformV1Attribution(),
      buildGoogleCloudAiplatformV1Attribution(),
    ];

void checkUnnamed80(core.List<api.GoogleCloudAiplatformV1Attribution> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Attribution(o[0]);
  checkGoogleCloudAiplatformV1Attribution(o[1]);
}

core.List<api.GoogleCloudAiplatformV1Neighbor> buildUnnamed81() => [
      buildGoogleCloudAiplatformV1Neighbor(),
      buildGoogleCloudAiplatformV1Neighbor(),
    ];

void checkUnnamed81(core.List<api.GoogleCloudAiplatformV1Neighbor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Neighbor(o[0]);
  checkGoogleCloudAiplatformV1Neighbor(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1Explanation = 0;
api.GoogleCloudAiplatformV1Explanation
    buildGoogleCloudAiplatformV1Explanation() {
  final o = api.GoogleCloudAiplatformV1Explanation();
  buildCounterGoogleCloudAiplatformV1Explanation++;
  if (buildCounterGoogleCloudAiplatformV1Explanation < 3) {
    o.attributions = buildUnnamed80();
    o.neighbors = buildUnnamed81();
  }
  buildCounterGoogleCloudAiplatformV1Explanation--;
  return o;
}

void checkGoogleCloudAiplatformV1Explanation(
    api.GoogleCloudAiplatformV1Explanation o) {
  buildCounterGoogleCloudAiplatformV1Explanation++;
  if (buildCounterGoogleCloudAiplatformV1Explanation < 3) {
    checkUnnamed80(o.attributions!);
    checkUnnamed81(o.neighbors!);
  }
  buildCounterGoogleCloudAiplatformV1Explanation--;
}

core.Map<core.String,
        api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadata>
    buildUnnamed82() => {
          'x': buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadata(),
          'y': buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadata(),
        };

void checkUnnamed82(
    core.Map<core.String,
            api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadata>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadata(o['x']!);
  checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadata(o['y']!);
}

core.Map<core.String,
        api.GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata>
    buildUnnamed83() => {
          'x': buildGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata(),
          'y': buildGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata(),
        };

void checkUnnamed83(
    core.Map<core.String,
            api.GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata(o['x']!);
  checkGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata(o['y']!);
}

core.int buildCounterGoogleCloudAiplatformV1ExplanationMetadata = 0;
api.GoogleCloudAiplatformV1ExplanationMetadata
    buildGoogleCloudAiplatformV1ExplanationMetadata() {
  final o = api.GoogleCloudAiplatformV1ExplanationMetadata();
  buildCounterGoogleCloudAiplatformV1ExplanationMetadata++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadata < 3) {
    o.featureAttributionsSchemaUri = 'foo';
    o.inputs = buildUnnamed82();
    o.latentSpaceSource = 'foo';
    o.outputs = buildUnnamed83();
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationMetadata(
    api.GoogleCloudAiplatformV1ExplanationMetadata o) {
  buildCounterGoogleCloudAiplatformV1ExplanationMetadata++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadata < 3) {
    unittest.expect(
      o.featureAttributionsSchemaUri!,
      unittest.equals('foo'),
    );
    checkUnnamed82(o.inputs!);
    unittest.expect(
      o.latentSpaceSource!,
      unittest.equals('foo'),
    );
    checkUnnamed83(o.outputs!);
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadata--;
}

core.List<core.Object?> buildUnnamed84() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed84(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted31 = (o[0]) as core.Map;
  unittest.expect(casted31, unittest.hasLength(3));
  unittest.expect(
    casted31['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted31['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted31['string'],
    unittest.equals('foo'),
  );
  var casted32 = (o[1]) as core.Map;
  unittest.expect(casted32, unittest.hasLength(3));
  unittest.expect(
    casted32['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted32['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted32['string'],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed85() => [
      'foo',
      'foo',
    ];

void checkUnnamed85(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.Object?> buildUnnamed86() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed86(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted33 = (o[0]) as core.Map;
  unittest.expect(casted33, unittest.hasLength(3));
  unittest.expect(
    casted33['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted33['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted33['string'],
    unittest.equals('foo'),
  );
  var casted34 = (o[1]) as core.Map;
  unittest.expect(casted34, unittest.hasLength(3));
  unittest.expect(
    casted34['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted34['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted34['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadata =
    0;
api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadata
    buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadata() {
  final o = api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadata();
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadata++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadata < 3) {
    o.denseShapeTensorName = 'foo';
    o.encodedBaselines = buildUnnamed84();
    o.encodedTensorName = 'foo';
    o.encoding = 'foo';
    o.featureValueDomain =
        buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain();
    o.groupName = 'foo';
    o.indexFeatureMapping = buildUnnamed85();
    o.indicesTensorName = 'foo';
    o.inputBaselines = buildUnnamed86();
    o.inputTensorName = 'foo';
    o.modality = 'foo';
    o.visualization =
        buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization();
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadata(
    api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadata o) {
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadata++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadata < 3) {
    unittest.expect(
      o.denseShapeTensorName!,
      unittest.equals('foo'),
    );
    checkUnnamed84(o.encodedBaselines!);
    unittest.expect(
      o.encodedTensorName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.encoding!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain(
        o.featureValueDomain!);
    unittest.expect(
      o.groupName!,
      unittest.equals('foo'),
    );
    checkUnnamed85(o.indexFeatureMapping!);
    unittest.expect(
      o.indicesTensorName!,
      unittest.equals('foo'),
    );
    checkUnnamed86(o.inputBaselines!);
    unittest.expect(
      o.inputTensorName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modality!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization(
        o.visualization!);
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadata--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain =
    0;
api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain
    buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain() {
  final o = api
      .GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain();
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain <
      3) {
    o.maxValue = 42.0;
    o.minValue = 42.0;
    o.originalMean = 42.0;
    o.originalStddev = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain(
    api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain
        o) {
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain <
      3) {
    unittest.expect(
      o.maxValue!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.minValue!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.originalMean!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.originalStddev!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization =
    0;
api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization
    buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization() {
  final o = api
      .GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization();
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization <
      3) {
    o.clipPercentLowerbound = 42.0;
    o.clipPercentUpperbound = 42.0;
    o.colorMap = 'foo';
    o.overlayType = 'foo';
    o.polarity = 'foo';
    o.type = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization(
    api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization
        o) {
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization <
      3) {
    unittest.expect(
      o.clipPercentLowerbound!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.clipPercentUpperbound!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.colorMap!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.overlayType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.polarity!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.type!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization--;
}

core.int buildCounterGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata =
    0;
api.GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata
    buildGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata() {
  final o = api.GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata();
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata <
      3) {
    o.displayNameMappingKey = 'foo';
    o.indexDisplayNameMapping = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.outputTensorName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata(
    api.GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata o) {
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata <
      3) {
    unittest.expect(
      o.displayNameMappingKey!,
      unittest.equals('foo'),
    );
    var casted35 = (o.indexDisplayNameMapping!) as core.Map;
    unittest.expect(casted35, unittest.hasLength(3));
    unittest.expect(
      casted35['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted35['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted35['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.outputTensorName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata--;
}

core.Map<
        core.String,
        api
        .GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride>
    buildUnnamed87() => {
          'x':
              buildGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride(),
          'y':
              buildGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride(),
        };

void checkUnnamed87(
    core.Map<
            core.String,
            api
            .GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride(
      o['x']!);
  checkGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride(
      o['y']!);
}

core.int buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverride = 0;
api.GoogleCloudAiplatformV1ExplanationMetadataOverride
    buildGoogleCloudAiplatformV1ExplanationMetadataOverride() {
  final o = api.GoogleCloudAiplatformV1ExplanationMetadataOverride();
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverride++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverride < 3) {
    o.inputs = buildUnnamed87();
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverride--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationMetadataOverride(
    api.GoogleCloudAiplatformV1ExplanationMetadataOverride o) {
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverride++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverride < 3) {
    checkUnnamed87(o.inputs!);
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverride--;
}

core.List<core.Object?> buildUnnamed88() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed88(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted36 = (o[0]) as core.Map;
  unittest.expect(casted36, unittest.hasLength(3));
  unittest.expect(
    casted36['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted36['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted36['string'],
    unittest.equals('foo'),
  );
  var casted37 = (o[1]) as core.Map;
  unittest.expect(casted37, unittest.hasLength(3));
  unittest.expect(
    casted37['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted37['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted37['string'],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride =
    0;
api.GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride
    buildGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride() {
  final o = api
      .GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride();
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride <
      3) {
    o.inputBaselines = buildUnnamed88();
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride(
    api.GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride
        o) {
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride <
      3) {
    checkUnnamed88(o.inputBaselines!);
  }
  buildCounterGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride--;
}

core.List<core.Object?> buildUnnamed89() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed89(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted38 = (o[0]) as core.Map;
  unittest.expect(casted38, unittest.hasLength(3));
  unittest.expect(
    casted38['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted38['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted38['string'],
    unittest.equals('foo'),
  );
  var casted39 = (o[1]) as core.Map;
  unittest.expect(casted39, unittest.hasLength(3));
  unittest.expect(
    casted39['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted39['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted39['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ExplanationParameters = 0;
api.GoogleCloudAiplatformV1ExplanationParameters
    buildGoogleCloudAiplatformV1ExplanationParameters() {
  final o = api.GoogleCloudAiplatformV1ExplanationParameters();
  buildCounterGoogleCloudAiplatformV1ExplanationParameters++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationParameters < 3) {
    o.examples = buildGoogleCloudAiplatformV1Examples();
    o.integratedGradientsAttribution =
        buildGoogleCloudAiplatformV1IntegratedGradientsAttribution();
    o.outputIndices = buildUnnamed89();
    o.sampledShapleyAttribution =
        buildGoogleCloudAiplatformV1SampledShapleyAttribution();
    o.topK = 42;
    o.xraiAttribution = buildGoogleCloudAiplatformV1XraiAttribution();
  }
  buildCounterGoogleCloudAiplatformV1ExplanationParameters--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationParameters(
    api.GoogleCloudAiplatformV1ExplanationParameters o) {
  buildCounterGoogleCloudAiplatformV1ExplanationParameters++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationParameters < 3) {
    checkGoogleCloudAiplatformV1Examples(o.examples!);
    checkGoogleCloudAiplatformV1IntegratedGradientsAttribution(
        o.integratedGradientsAttribution!);
    checkUnnamed89(o.outputIndices!);
    checkGoogleCloudAiplatformV1SampledShapleyAttribution(
        o.sampledShapleyAttribution!);
    unittest.expect(
      o.topK!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1XraiAttribution(o.xraiAttribution!);
  }
  buildCounterGoogleCloudAiplatformV1ExplanationParameters--;
}

core.int buildCounterGoogleCloudAiplatformV1ExplanationSpec = 0;
api.GoogleCloudAiplatformV1ExplanationSpec
    buildGoogleCloudAiplatformV1ExplanationSpec() {
  final o = api.GoogleCloudAiplatformV1ExplanationSpec();
  buildCounterGoogleCloudAiplatformV1ExplanationSpec++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationSpec < 3) {
    o.metadata = buildGoogleCloudAiplatformV1ExplanationMetadata();
    o.parameters = buildGoogleCloudAiplatformV1ExplanationParameters();
  }
  buildCounterGoogleCloudAiplatformV1ExplanationSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationSpec(
    api.GoogleCloudAiplatformV1ExplanationSpec o) {
  buildCounterGoogleCloudAiplatformV1ExplanationSpec++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationSpec < 3) {
    checkGoogleCloudAiplatformV1ExplanationMetadata(o.metadata!);
    checkGoogleCloudAiplatformV1ExplanationParameters(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1ExplanationSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1ExplanationSpecOverride = 0;
api.GoogleCloudAiplatformV1ExplanationSpecOverride
    buildGoogleCloudAiplatformV1ExplanationSpecOverride() {
  final o = api.GoogleCloudAiplatformV1ExplanationSpecOverride();
  buildCounterGoogleCloudAiplatformV1ExplanationSpecOverride++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationSpecOverride < 3) {
    o.examplesOverride = buildGoogleCloudAiplatformV1ExamplesOverride();
    o.metadata = buildGoogleCloudAiplatformV1ExplanationMetadataOverride();
    o.parameters = buildGoogleCloudAiplatformV1ExplanationParameters();
  }
  buildCounterGoogleCloudAiplatformV1ExplanationSpecOverride--;
  return o;
}

void checkGoogleCloudAiplatformV1ExplanationSpecOverride(
    api.GoogleCloudAiplatformV1ExplanationSpecOverride o) {
  buildCounterGoogleCloudAiplatformV1ExplanationSpecOverride++;
  if (buildCounterGoogleCloudAiplatformV1ExplanationSpecOverride < 3) {
    checkGoogleCloudAiplatformV1ExamplesOverride(o.examplesOverride!);
    checkGoogleCloudAiplatformV1ExplanationMetadataOverride(o.metadata!);
    checkGoogleCloudAiplatformV1ExplanationParameters(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1ExplanationSpecOverride--;
}

core.int buildCounterGoogleCloudAiplatformV1ExportDataConfig = 0;
api.GoogleCloudAiplatformV1ExportDataConfig
    buildGoogleCloudAiplatformV1ExportDataConfig() {
  final o = api.GoogleCloudAiplatformV1ExportDataConfig();
  buildCounterGoogleCloudAiplatformV1ExportDataConfig++;
  if (buildCounterGoogleCloudAiplatformV1ExportDataConfig < 3) {
    o.annotationSchemaUri = 'foo';
    o.annotationsFilter = 'foo';
    o.exportUse = 'foo';
    o.filterSplit = buildGoogleCloudAiplatformV1ExportFilterSplit();
    o.fractionSplit = buildGoogleCloudAiplatformV1ExportFractionSplit();
    o.gcsDestination = buildGoogleCloudAiplatformV1GcsDestination();
    o.savedQueryId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ExportDataConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportDataConfig(
    api.GoogleCloudAiplatformV1ExportDataConfig o) {
  buildCounterGoogleCloudAiplatformV1ExportDataConfig++;
  if (buildCounterGoogleCloudAiplatformV1ExportDataConfig < 3) {
    unittest.expect(
      o.annotationSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.annotationsFilter!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.exportUse!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ExportFilterSplit(o.filterSplit!);
    checkGoogleCloudAiplatformV1ExportFractionSplit(o.fractionSplit!);
    checkGoogleCloudAiplatformV1GcsDestination(o.gcsDestination!);
    unittest.expect(
      o.savedQueryId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExportDataConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1ExportDataRequest = 0;
api.GoogleCloudAiplatformV1ExportDataRequest
    buildGoogleCloudAiplatformV1ExportDataRequest() {
  final o = api.GoogleCloudAiplatformV1ExportDataRequest();
  buildCounterGoogleCloudAiplatformV1ExportDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExportDataRequest < 3) {
    o.exportConfig = buildGoogleCloudAiplatformV1ExportDataConfig();
  }
  buildCounterGoogleCloudAiplatformV1ExportDataRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportDataRequest(
    api.GoogleCloudAiplatformV1ExportDataRequest o) {
  buildCounterGoogleCloudAiplatformV1ExportDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExportDataRequest < 3) {
    checkGoogleCloudAiplatformV1ExportDataConfig(o.exportConfig!);
  }
  buildCounterGoogleCloudAiplatformV1ExportDataRequest--;
}

core.List<api.GoogleCloudAiplatformV1DestinationFeatureSetting>
    buildUnnamed90() => [
          buildGoogleCloudAiplatformV1DestinationFeatureSetting(),
          buildGoogleCloudAiplatformV1DestinationFeatureSetting(),
        ];

void checkUnnamed90(
    core.List<api.GoogleCloudAiplatformV1DestinationFeatureSetting> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DestinationFeatureSetting(o[0]);
  checkGoogleCloudAiplatformV1DestinationFeatureSetting(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequest = 0;
api.GoogleCloudAiplatformV1ExportFeatureValuesRequest
    buildGoogleCloudAiplatformV1ExportFeatureValuesRequest() {
  final o = api.GoogleCloudAiplatformV1ExportFeatureValuesRequest();
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequest < 3) {
    o.destination = buildGoogleCloudAiplatformV1FeatureValueDestination();
    o.featureSelector = buildGoogleCloudAiplatformV1FeatureSelector();
    o.fullExport =
        buildGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport();
    o.settings = buildUnnamed90();
    o.snapshotExport =
        buildGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport();
  }
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportFeatureValuesRequest(
    api.GoogleCloudAiplatformV1ExportFeatureValuesRequest o) {
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequest < 3) {
    checkGoogleCloudAiplatformV1FeatureValueDestination(o.destination!);
    checkGoogleCloudAiplatformV1FeatureSelector(o.featureSelector!);
    checkGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport(
        o.fullExport!);
    checkUnnamed90(o.settings!);
    checkGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport(
        o.snapshotExport!);
  }
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport = 0;
api.GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport
    buildGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport() {
  final o = api.GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport();
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport++;
  if (buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport <
      3) {
    o.endTime = 'foo';
    o.startTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport(
    api.GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport o) {
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport++;
  if (buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport <
      3) {
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport =
    0;
api.GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport
    buildGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport() {
  final o =
      api.GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport();
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport++;
  if (buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport <
      3) {
    o.snapshotTime = 'foo';
    o.startTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport(
    api.GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport o) {
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport++;
  if (buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport <
      3) {
    unittest.expect(
      o.snapshotTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport--;
}

core.int buildCounterGoogleCloudAiplatformV1ExportFilterSplit = 0;
api.GoogleCloudAiplatformV1ExportFilterSplit
    buildGoogleCloudAiplatformV1ExportFilterSplit() {
  final o = api.GoogleCloudAiplatformV1ExportFilterSplit();
  buildCounterGoogleCloudAiplatformV1ExportFilterSplit++;
  if (buildCounterGoogleCloudAiplatformV1ExportFilterSplit < 3) {
    o.testFilter = 'foo';
    o.trainingFilter = 'foo';
    o.validationFilter = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ExportFilterSplit--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportFilterSplit(
    api.GoogleCloudAiplatformV1ExportFilterSplit o) {
  buildCounterGoogleCloudAiplatformV1ExportFilterSplit++;
  if (buildCounterGoogleCloudAiplatformV1ExportFilterSplit < 3) {
    unittest.expect(
      o.testFilter!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.trainingFilter!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.validationFilter!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExportFilterSplit--;
}

core.int buildCounterGoogleCloudAiplatformV1ExportFractionSplit = 0;
api.GoogleCloudAiplatformV1ExportFractionSplit
    buildGoogleCloudAiplatformV1ExportFractionSplit() {
  final o = api.GoogleCloudAiplatformV1ExportFractionSplit();
  buildCounterGoogleCloudAiplatformV1ExportFractionSplit++;
  if (buildCounterGoogleCloudAiplatformV1ExportFractionSplit < 3) {
    o.testFraction = 42.0;
    o.trainingFraction = 42.0;
    o.validationFraction = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1ExportFractionSplit--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportFractionSplit(
    api.GoogleCloudAiplatformV1ExportFractionSplit o) {
  buildCounterGoogleCloudAiplatformV1ExportFractionSplit++;
  if (buildCounterGoogleCloudAiplatformV1ExportFractionSplit < 3) {
    unittest.expect(
      o.testFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.trainingFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.validationFraction!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExportFractionSplit--;
}

core.int buildCounterGoogleCloudAiplatformV1ExportModelRequest = 0;
api.GoogleCloudAiplatformV1ExportModelRequest
    buildGoogleCloudAiplatformV1ExportModelRequest() {
  final o = api.GoogleCloudAiplatformV1ExportModelRequest();
  buildCounterGoogleCloudAiplatformV1ExportModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExportModelRequest < 3) {
    o.outputConfig =
        buildGoogleCloudAiplatformV1ExportModelRequestOutputConfig();
  }
  buildCounterGoogleCloudAiplatformV1ExportModelRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportModelRequest(
    api.GoogleCloudAiplatformV1ExportModelRequest o) {
  buildCounterGoogleCloudAiplatformV1ExportModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExportModelRequest < 3) {
    checkGoogleCloudAiplatformV1ExportModelRequestOutputConfig(o.outputConfig!);
  }
  buildCounterGoogleCloudAiplatformV1ExportModelRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1ExportModelRequestOutputConfig = 0;
api.GoogleCloudAiplatformV1ExportModelRequestOutputConfig
    buildGoogleCloudAiplatformV1ExportModelRequestOutputConfig() {
  final o = api.GoogleCloudAiplatformV1ExportModelRequestOutputConfig();
  buildCounterGoogleCloudAiplatformV1ExportModelRequestOutputConfig++;
  if (buildCounterGoogleCloudAiplatformV1ExportModelRequestOutputConfig < 3) {
    o.artifactDestination = buildGoogleCloudAiplatformV1GcsDestination();
    o.exportFormatId = 'foo';
    o.imageDestination =
        buildGoogleCloudAiplatformV1ContainerRegistryDestination();
  }
  buildCounterGoogleCloudAiplatformV1ExportModelRequestOutputConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportModelRequestOutputConfig(
    api.GoogleCloudAiplatformV1ExportModelRequestOutputConfig o) {
  buildCounterGoogleCloudAiplatformV1ExportModelRequestOutputConfig++;
  if (buildCounterGoogleCloudAiplatformV1ExportModelRequestOutputConfig < 3) {
    checkGoogleCloudAiplatformV1GcsDestination(o.artifactDestination!);
    unittest.expect(
      o.exportFormatId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ContainerRegistryDestination(
        o.imageDestination!);
  }
  buildCounterGoogleCloudAiplatformV1ExportModelRequestOutputConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest =
    0;
api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest
    buildGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest() {
  final o = api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest();
  buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest <
      3) {
    o.filter = 'foo';
    o.orderBy = 'foo';
    o.pageSize = 42;
    o.pageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest(
    api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest o) {
  buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest <
      3) {
    unittest.expect(
      o.filter!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.orderBy!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.pageSize!,
      unittest.equals(42),
    );
    unittest.expect(
      o.pageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest--;
}

core.List<api.GoogleCloudAiplatformV1TimeSeriesDataPoint> buildUnnamed91() => [
      buildGoogleCloudAiplatformV1TimeSeriesDataPoint(),
      buildGoogleCloudAiplatformV1TimeSeriesDataPoint(),
    ];

void checkUnnamed91(
    core.List<api.GoogleCloudAiplatformV1TimeSeriesDataPoint> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TimeSeriesDataPoint(o[0]);
  checkGoogleCloudAiplatformV1TimeSeriesDataPoint(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse =
    0;
api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse
    buildGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse() {
  final o =
      api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse();
  buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse <
      3) {
    o.nextPageToken = 'foo';
    o.timeSeriesDataPoints = buildUnnamed91();
  }
  buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse(
    api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse o) {
  buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse <
      3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed91(o.timeSeriesDataPoints!);
  }
  buildCounterGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse--;
}

core.Map<core.String, core.String> buildUnnamed92() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed92(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly>
    buildUnnamed93() => [
          buildGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly(),
          buildGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly(),
        ];

void checkUnnamed93(
    core.List<api.GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly(o[0]);
  checkGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1Feature = 0;
api.GoogleCloudAiplatformV1Feature buildGoogleCloudAiplatformV1Feature() {
  final o = api.GoogleCloudAiplatformV1Feature();
  buildCounterGoogleCloudAiplatformV1Feature++;
  if (buildCounterGoogleCloudAiplatformV1Feature < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.disableMonitoring = true;
    o.etag = 'foo';
    o.labels = buildUnnamed92();
    o.monitoringStatsAnomalies = buildUnnamed93();
    o.name = 'foo';
    o.pointOfContact = 'foo';
    o.updateTime = 'foo';
    o.valueType = 'foo';
    o.versionColumnName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Feature--;
  return o;
}

void checkGoogleCloudAiplatformV1Feature(api.GoogleCloudAiplatformV1Feature o) {
  buildCounterGoogleCloudAiplatformV1Feature++;
  if (buildCounterGoogleCloudAiplatformV1Feature < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(o.disableMonitoring!, unittest.isTrue);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed92(o.labels!);
    checkUnnamed93(o.monitoringStatsAnomalies!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.pointOfContact!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.valueType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.versionColumnName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Feature--;
}

core.Map<core.String, core.String> buildUnnamed94() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed94(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FeatureGroup = 0;
api.GoogleCloudAiplatformV1FeatureGroup
    buildGoogleCloudAiplatformV1FeatureGroup() {
  final o = api.GoogleCloudAiplatformV1FeatureGroup();
  buildCounterGoogleCloudAiplatformV1FeatureGroup++;
  if (buildCounterGoogleCloudAiplatformV1FeatureGroup < 3) {
    o.bigQuery = buildGoogleCloudAiplatformV1FeatureGroupBigQuery();
    o.createTime = 'foo';
    o.description = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed94();
    o.name = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureGroup--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureGroup(
    api.GoogleCloudAiplatformV1FeatureGroup o) {
  buildCounterGoogleCloudAiplatformV1FeatureGroup++;
  if (buildCounterGoogleCloudAiplatformV1FeatureGroup < 3) {
    checkGoogleCloudAiplatformV1FeatureGroupBigQuery(o.bigQuery!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed94(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureGroup--;
}

core.List<core.String> buildUnnamed95() => [
      'foo',
      'foo',
    ];

void checkUnnamed95(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FeatureGroupBigQuery = 0;
api.GoogleCloudAiplatformV1FeatureGroupBigQuery
    buildGoogleCloudAiplatformV1FeatureGroupBigQuery() {
  final o = api.GoogleCloudAiplatformV1FeatureGroupBigQuery();
  buildCounterGoogleCloudAiplatformV1FeatureGroupBigQuery++;
  if (buildCounterGoogleCloudAiplatformV1FeatureGroupBigQuery < 3) {
    o.bigQuerySource = buildGoogleCloudAiplatformV1BigQuerySource();
    o.entityIdColumns = buildUnnamed95();
  }
  buildCounterGoogleCloudAiplatformV1FeatureGroupBigQuery--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureGroupBigQuery(
    api.GoogleCloudAiplatformV1FeatureGroupBigQuery o) {
  buildCounterGoogleCloudAiplatformV1FeatureGroupBigQuery++;
  if (buildCounterGoogleCloudAiplatformV1FeatureGroupBigQuery < 3) {
    checkGoogleCloudAiplatformV1BigQuerySource(o.bigQuerySource!);
    checkUnnamed95(o.entityIdColumns!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureGroupBigQuery--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly = 0;
api.GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly
    buildGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly() {
  final o = api.GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly();
  buildCounterGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly++;
  if (buildCounterGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly < 3) {
    o.featureStatsAnomaly = buildGoogleCloudAiplatformV1FeatureStatsAnomaly();
    o.objective = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly(
    api.GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly o) {
  buildCounterGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly++;
  if (buildCounterGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly < 3) {
    checkGoogleCloudAiplatformV1FeatureStatsAnomaly(o.featureStatsAnomaly!);
    unittest.expect(
      o.objective!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly--;
}

core.List<api.GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature>
    buildUnnamed96() => [
          buildGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature(),
          buildGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature(),
        ];

void checkUnnamed96(
    core.List<api.GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature(o[0]);
  checkGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1FeatureNoiseSigma = 0;
api.GoogleCloudAiplatformV1FeatureNoiseSigma
    buildGoogleCloudAiplatformV1FeatureNoiseSigma() {
  final o = api.GoogleCloudAiplatformV1FeatureNoiseSigma();
  buildCounterGoogleCloudAiplatformV1FeatureNoiseSigma++;
  if (buildCounterGoogleCloudAiplatformV1FeatureNoiseSigma < 3) {
    o.noiseSigma = buildUnnamed96();
  }
  buildCounterGoogleCloudAiplatformV1FeatureNoiseSigma--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureNoiseSigma(
    api.GoogleCloudAiplatformV1FeatureNoiseSigma o) {
  buildCounterGoogleCloudAiplatformV1FeatureNoiseSigma++;
  if (buildCounterGoogleCloudAiplatformV1FeatureNoiseSigma < 3) {
    checkUnnamed96(o.noiseSigma!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureNoiseSigma--;
}

core.int
    buildCounterGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature =
    0;
api.GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature
    buildGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature() {
  final o = api.GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature();
  buildCounterGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature++;
  if (buildCounterGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature <
      3) {
    o.name = 'foo';
    o.sigma = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature(
    api.GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature o) {
  buildCounterGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature++;
  if (buildCounterGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature <
      3) {
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.sigma!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature--;
}

core.Map<core.String, core.String> buildUnnamed97() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed97(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FeatureOnlineStore = 0;
api.GoogleCloudAiplatformV1FeatureOnlineStore
    buildGoogleCloudAiplatformV1FeatureOnlineStore() {
  final o = api.GoogleCloudAiplatformV1FeatureOnlineStore();
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStore++;
  if (buildCounterGoogleCloudAiplatformV1FeatureOnlineStore < 3) {
    o.bigtable = buildGoogleCloudAiplatformV1FeatureOnlineStoreBigtable();
    o.createTime = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed97();
    o.name = 'foo';
    o.state = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStore--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureOnlineStore(
    api.GoogleCloudAiplatformV1FeatureOnlineStore o) {
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStore++;
  if (buildCounterGoogleCloudAiplatformV1FeatureOnlineStore < 3) {
    checkGoogleCloudAiplatformV1FeatureOnlineStoreBigtable(o.bigtable!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed97(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStore--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtable = 0;
api.GoogleCloudAiplatformV1FeatureOnlineStoreBigtable
    buildGoogleCloudAiplatformV1FeatureOnlineStoreBigtable() {
  final o = api.GoogleCloudAiplatformV1FeatureOnlineStoreBigtable();
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtable++;
  if (buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtable < 3) {
    o.autoScaling =
        buildGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling();
  }
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtable--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureOnlineStoreBigtable(
    api.GoogleCloudAiplatformV1FeatureOnlineStoreBigtable o) {
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtable++;
  if (buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtable < 3) {
    checkGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling(
        o.autoScaling!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtable--;
}

core.int
    buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling =
    0;
api.GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling
    buildGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling() {
  final o = api.GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling();
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling++;
  if (buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling <
      3) {
    o.cpuUtilizationTarget = 42;
    o.maxNodeCount = 42;
    o.minNodeCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling(
    api.GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling o) {
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling++;
  if (buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling <
      3) {
    unittest.expect(
      o.cpuUtilizationTarget!,
      unittest.equals(42),
    );
    unittest.expect(
      o.maxNodeCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.minNodeCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureSelector = 0;
api.GoogleCloudAiplatformV1FeatureSelector
    buildGoogleCloudAiplatformV1FeatureSelector() {
  final o = api.GoogleCloudAiplatformV1FeatureSelector();
  buildCounterGoogleCloudAiplatformV1FeatureSelector++;
  if (buildCounterGoogleCloudAiplatformV1FeatureSelector < 3) {
    o.idMatcher = buildGoogleCloudAiplatformV1IdMatcher();
  }
  buildCounterGoogleCloudAiplatformV1FeatureSelector--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureSelector(
    api.GoogleCloudAiplatformV1FeatureSelector o) {
  buildCounterGoogleCloudAiplatformV1FeatureSelector++;
  if (buildCounterGoogleCloudAiplatformV1FeatureSelector < 3) {
    checkGoogleCloudAiplatformV1IdMatcher(o.idMatcher!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureSelector--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureStatsAnomaly = 0;
api.GoogleCloudAiplatformV1FeatureStatsAnomaly
    buildGoogleCloudAiplatformV1FeatureStatsAnomaly() {
  final o = api.GoogleCloudAiplatformV1FeatureStatsAnomaly();
  buildCounterGoogleCloudAiplatformV1FeatureStatsAnomaly++;
  if (buildCounterGoogleCloudAiplatformV1FeatureStatsAnomaly < 3) {
    o.anomalyDetectionThreshold = 42.0;
    o.anomalyUri = 'foo';
    o.distributionDeviation = 42.0;
    o.endTime = 'foo';
    o.score = 42.0;
    o.startTime = 'foo';
    o.statsUri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureStatsAnomaly--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureStatsAnomaly(
    api.GoogleCloudAiplatformV1FeatureStatsAnomaly o) {
  buildCounterGoogleCloudAiplatformV1FeatureStatsAnomaly++;
  if (buildCounterGoogleCloudAiplatformV1FeatureStatsAnomaly < 3) {
    unittest.expect(
      o.anomalyDetectionThreshold!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.anomalyUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.distributionDeviation!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.score!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.statsUri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureStatsAnomaly--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureValue = 0;
api.GoogleCloudAiplatformV1FeatureValue
    buildGoogleCloudAiplatformV1FeatureValue() {
  final o = api.GoogleCloudAiplatformV1FeatureValue();
  buildCounterGoogleCloudAiplatformV1FeatureValue++;
  if (buildCounterGoogleCloudAiplatformV1FeatureValue < 3) {
    o.boolArrayValue = buildGoogleCloudAiplatformV1BoolArray();
    o.boolValue = true;
    o.bytesValue = 'foo';
    o.doubleArrayValue = buildGoogleCloudAiplatformV1DoubleArray();
    o.doubleValue = 42.0;
    o.int64ArrayValue = buildGoogleCloudAiplatformV1Int64Array();
    o.int64Value = 'foo';
    o.metadata = buildGoogleCloudAiplatformV1FeatureValueMetadata();
    o.stringArrayValue = buildGoogleCloudAiplatformV1StringArray();
    o.stringValue = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureValue--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureValue(
    api.GoogleCloudAiplatformV1FeatureValue o) {
  buildCounterGoogleCloudAiplatformV1FeatureValue++;
  if (buildCounterGoogleCloudAiplatformV1FeatureValue < 3) {
    checkGoogleCloudAiplatformV1BoolArray(o.boolArrayValue!);
    unittest.expect(o.boolValue!, unittest.isTrue);
    unittest.expect(
      o.bytesValue!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1DoubleArray(o.doubleArrayValue!);
    unittest.expect(
      o.doubleValue!,
      unittest.equals(42.0),
    );
    checkGoogleCloudAiplatformV1Int64Array(o.int64ArrayValue!);
    unittest.expect(
      o.int64Value!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FeatureValueMetadata(o.metadata!);
    checkGoogleCloudAiplatformV1StringArray(o.stringArrayValue!);
    unittest.expect(
      o.stringValue!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureValue--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureValueDestination = 0;
api.GoogleCloudAiplatformV1FeatureValueDestination
    buildGoogleCloudAiplatformV1FeatureValueDestination() {
  final o = api.GoogleCloudAiplatformV1FeatureValueDestination();
  buildCounterGoogleCloudAiplatformV1FeatureValueDestination++;
  if (buildCounterGoogleCloudAiplatformV1FeatureValueDestination < 3) {
    o.bigqueryDestination = buildGoogleCloudAiplatformV1BigQueryDestination();
    o.csvDestination = buildGoogleCloudAiplatformV1CsvDestination();
    o.tfrecordDestination = buildGoogleCloudAiplatformV1TFRecordDestination();
  }
  buildCounterGoogleCloudAiplatformV1FeatureValueDestination--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureValueDestination(
    api.GoogleCloudAiplatformV1FeatureValueDestination o) {
  buildCounterGoogleCloudAiplatformV1FeatureValueDestination++;
  if (buildCounterGoogleCloudAiplatformV1FeatureValueDestination < 3) {
    checkGoogleCloudAiplatformV1BigQueryDestination(o.bigqueryDestination!);
    checkGoogleCloudAiplatformV1CsvDestination(o.csvDestination!);
    checkGoogleCloudAiplatformV1TFRecordDestination(o.tfrecordDestination!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureValueDestination--;
}

core.List<api.GoogleCloudAiplatformV1FeatureValue> buildUnnamed98() => [
      buildGoogleCloudAiplatformV1FeatureValue(),
      buildGoogleCloudAiplatformV1FeatureValue(),
    ];

void checkUnnamed98(core.List<api.GoogleCloudAiplatformV1FeatureValue> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureValue(o[0]);
  checkGoogleCloudAiplatformV1FeatureValue(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1FeatureValueList = 0;
api.GoogleCloudAiplatformV1FeatureValueList
    buildGoogleCloudAiplatformV1FeatureValueList() {
  final o = api.GoogleCloudAiplatformV1FeatureValueList();
  buildCounterGoogleCloudAiplatformV1FeatureValueList++;
  if (buildCounterGoogleCloudAiplatformV1FeatureValueList < 3) {
    o.values = buildUnnamed98();
  }
  buildCounterGoogleCloudAiplatformV1FeatureValueList--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureValueList(
    api.GoogleCloudAiplatformV1FeatureValueList o) {
  buildCounterGoogleCloudAiplatformV1FeatureValueList++;
  if (buildCounterGoogleCloudAiplatformV1FeatureValueList < 3) {
    checkUnnamed98(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureValueList--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureValueMetadata = 0;
api.GoogleCloudAiplatformV1FeatureValueMetadata
    buildGoogleCloudAiplatformV1FeatureValueMetadata() {
  final o = api.GoogleCloudAiplatformV1FeatureValueMetadata();
  buildCounterGoogleCloudAiplatformV1FeatureValueMetadata++;
  if (buildCounterGoogleCloudAiplatformV1FeatureValueMetadata < 3) {
    o.generateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureValueMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureValueMetadata(
    api.GoogleCloudAiplatformV1FeatureValueMetadata o) {
  buildCounterGoogleCloudAiplatformV1FeatureValueMetadata++;
  if (buildCounterGoogleCloudAiplatformV1FeatureValueMetadata < 3) {
    unittest.expect(
      o.generateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureValueMetadata--;
}

core.Map<core.String, core.String> buildUnnamed99() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed99(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FeatureView = 0;
api.GoogleCloudAiplatformV1FeatureView
    buildGoogleCloudAiplatformV1FeatureView() {
  final o = api.GoogleCloudAiplatformV1FeatureView();
  buildCounterGoogleCloudAiplatformV1FeatureView++;
  if (buildCounterGoogleCloudAiplatformV1FeatureView < 3) {
    o.bigQuerySource = buildGoogleCloudAiplatformV1FeatureViewBigQuerySource();
    o.createTime = 'foo';
    o.etag = 'foo';
    o.featureRegistrySource =
        buildGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource();
    o.labels = buildUnnamed99();
    o.name = 'foo';
    o.syncConfig = buildGoogleCloudAiplatformV1FeatureViewSyncConfig();
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureView--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureView(
    api.GoogleCloudAiplatformV1FeatureView o) {
  buildCounterGoogleCloudAiplatformV1FeatureView++;
  if (buildCounterGoogleCloudAiplatformV1FeatureView < 3) {
    checkGoogleCloudAiplatformV1FeatureViewBigQuerySource(o.bigQuerySource!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource(
        o.featureRegistrySource!);
    checkUnnamed99(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FeatureViewSyncConfig(o.syncConfig!);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureView--;
}

core.List<core.String> buildUnnamed100() => [
      'foo',
      'foo',
    ];

void checkUnnamed100(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FeatureViewBigQuerySource = 0;
api.GoogleCloudAiplatformV1FeatureViewBigQuerySource
    buildGoogleCloudAiplatformV1FeatureViewBigQuerySource() {
  final o = api.GoogleCloudAiplatformV1FeatureViewBigQuerySource();
  buildCounterGoogleCloudAiplatformV1FeatureViewBigQuerySource++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewBigQuerySource < 3) {
    o.entityIdColumns = buildUnnamed100();
    o.uri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewBigQuerySource--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureViewBigQuerySource(
    api.GoogleCloudAiplatformV1FeatureViewBigQuerySource o) {
  buildCounterGoogleCloudAiplatformV1FeatureViewBigQuerySource++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewBigQuerySource < 3) {
    checkUnnamed100(o.entityIdColumns!);
    unittest.expect(
      o.uri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewBigQuerySource--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureViewDataKey = 0;
api.GoogleCloudAiplatformV1FeatureViewDataKey
    buildGoogleCloudAiplatformV1FeatureViewDataKey() {
  final o = api.GoogleCloudAiplatformV1FeatureViewDataKey();
  buildCounterGoogleCloudAiplatformV1FeatureViewDataKey++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewDataKey < 3) {
    o.compositeKey =
        buildGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey();
    o.key = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewDataKey--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureViewDataKey(
    api.GoogleCloudAiplatformV1FeatureViewDataKey o) {
  buildCounterGoogleCloudAiplatformV1FeatureViewDataKey++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewDataKey < 3) {
    checkGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey(o.compositeKey!);
    unittest.expect(
      o.key!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewDataKey--;
}

core.List<core.String> buildUnnamed101() => [
      'foo',
      'foo',
    ];

void checkUnnamed101(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey = 0;
api.GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey
    buildGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey() {
  final o = api.GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey();
  buildCounterGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey < 3) {
    o.parts = buildUnnamed101();
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey(
    api.GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey o) {
  buildCounterGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey < 3) {
    checkUnnamed101(o.parts!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey--;
}

core.List<
        api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup>
    buildUnnamed102() => [
          buildGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup(),
          buildGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup(),
        ];

void checkUnnamed102(
    core.List<
            api
            .GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup(
      o[0]);
  checkGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup(
      o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource =
    0;
api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource
    buildGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource() {
  final o = api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource();
  buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource < 3) {
    o.featureGroups = buildUnnamed102();
    o.projectNumber = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource(
    api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource o) {
  buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource < 3) {
    checkUnnamed102(o.featureGroups!);
    unittest.expect(
      o.projectNumber!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource--;
}

core.List<core.String> buildUnnamed103() => [
      'foo',
      'foo',
    ];

void checkUnnamed103(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup =
    0;
api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup
    buildGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup() {
  final o =
      api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup();
  buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup <
      3) {
    o.featureGroupId = 'foo';
    o.featureIds = buildUnnamed103();
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup(
    api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup o) {
  buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup <
      3) {
    unittest.expect(
      o.featureGroupId!,
      unittest.equals('foo'),
    );
    checkUnnamed103(o.featureIds!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureViewSync = 0;
api.GoogleCloudAiplatformV1FeatureViewSync
    buildGoogleCloudAiplatformV1FeatureViewSync() {
  final o = api.GoogleCloudAiplatformV1FeatureViewSync();
  buildCounterGoogleCloudAiplatformV1FeatureViewSync++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewSync < 3) {
    o.createTime = 'foo';
    o.finalStatus = buildGoogleRpcStatus();
    o.name = 'foo';
    o.runTime = buildGoogleTypeInterval();
    o.syncSummary = buildGoogleCloudAiplatformV1FeatureViewSyncSyncSummary();
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewSync--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureViewSync(
    api.GoogleCloudAiplatformV1FeatureViewSync o) {
  buildCounterGoogleCloudAiplatformV1FeatureViewSync++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewSync < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.finalStatus!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleTypeInterval(o.runTime!);
    checkGoogleCloudAiplatformV1FeatureViewSyncSyncSummary(o.syncSummary!);
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewSync--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureViewSyncConfig = 0;
api.GoogleCloudAiplatformV1FeatureViewSyncConfig
    buildGoogleCloudAiplatformV1FeatureViewSyncConfig() {
  final o = api.GoogleCloudAiplatformV1FeatureViewSyncConfig();
  buildCounterGoogleCloudAiplatformV1FeatureViewSyncConfig++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewSyncConfig < 3) {
    o.cron = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewSyncConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureViewSyncConfig(
    api.GoogleCloudAiplatformV1FeatureViewSyncConfig o) {
  buildCounterGoogleCloudAiplatformV1FeatureViewSyncConfig++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewSyncConfig < 3) {
    unittest.expect(
      o.cron!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewSyncConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1FeatureViewSyncSyncSummary = 0;
api.GoogleCloudAiplatformV1FeatureViewSyncSyncSummary
    buildGoogleCloudAiplatformV1FeatureViewSyncSyncSummary() {
  final o = api.GoogleCloudAiplatformV1FeatureViewSyncSyncSummary();
  buildCounterGoogleCloudAiplatformV1FeatureViewSyncSyncSummary++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewSyncSyncSummary < 3) {
    o.rowSynced = 'foo';
    o.totalSlot = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewSyncSyncSummary--;
  return o;
}

void checkGoogleCloudAiplatformV1FeatureViewSyncSyncSummary(
    api.GoogleCloudAiplatformV1FeatureViewSyncSyncSummary o) {
  buildCounterGoogleCloudAiplatformV1FeatureViewSyncSyncSummary++;
  if (buildCounterGoogleCloudAiplatformV1FeatureViewSyncSyncSummary < 3) {
    unittest.expect(
      o.rowSynced!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.totalSlot!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeatureViewSyncSyncSummary--;
}

core.Map<core.String, core.String> buildUnnamed104() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed104(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Featurestore = 0;
api.GoogleCloudAiplatformV1Featurestore
    buildGoogleCloudAiplatformV1Featurestore() {
  final o = api.GoogleCloudAiplatformV1Featurestore();
  buildCounterGoogleCloudAiplatformV1Featurestore++;
  if (buildCounterGoogleCloudAiplatformV1Featurestore < 3) {
    o.createTime = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.etag = 'foo';
    o.labels = buildUnnamed104();
    o.name = 'foo';
    o.onlineServingConfig =
        buildGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig();
    o.onlineStorageTtlDays = 42;
    o.state = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Featurestore--;
  return o;
}

void checkGoogleCloudAiplatformV1Featurestore(
    api.GoogleCloudAiplatformV1Featurestore o) {
  buildCounterGoogleCloudAiplatformV1Featurestore++;
  if (buildCounterGoogleCloudAiplatformV1Featurestore < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed104(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig(
        o.onlineServingConfig!);
    unittest.expect(
      o.onlineStorageTtlDays!,
      unittest.equals(42),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Featurestore--;
}

core.int buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfig = 0;
api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfig
    buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfig() {
  final o = api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfig();
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfig++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfig < 3) {
    o.categoricalThresholdConfig =
        buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig();
    o.importFeaturesAnalysis =
        buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis();
    o.numericalThresholdConfig =
        buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig();
    o.snapshotAnalysis =
        buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis();
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfig(
    api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfig o) {
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfig++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfig < 3) {
    checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig(
        o.categoricalThresholdConfig!);
    checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis(
        o.importFeaturesAnalysis!);
    checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig(
        o.numericalThresholdConfig!);
    checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis(
        o.snapshotAnalysis!);
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis =
    0;
api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis
    buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis() {
  final o = api
      .GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis();
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis <
      3) {
    o.anomalyDetectionBaseline = 'foo';
    o.state = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis--;
  return o;
}

void checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis(
    api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis
        o) {
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis <
      3) {
    unittest.expect(
      o.anomalyDetectionBaseline!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis--;
}

core.int
    buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis =
    0;
api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis
    buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis() {
  final o =
      api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis();
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis <
      3) {
    o.disabled = true;
    o.monitoringIntervalDays = 42;
    o.stalenessDays = 42;
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis--;
  return o;
}

void checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis(
    api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis o) {
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis <
      3) {
    unittest.expect(o.disabled!, unittest.isTrue);
    unittest.expect(
      o.monitoringIntervalDays!,
      unittest.equals(42),
    );
    unittest.expect(
      o.stalenessDays!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis--;
}

core.int
    buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig =
    0;
api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig
    buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig() {
  final o =
      api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig();
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig <
      3) {
    o.value = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig(
    api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig o) {
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig <
      3) {
    unittest.expect(
      o.value!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig = 0;
api.GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig
    buildGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig() {
  final o = api.GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig();
  buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig < 3) {
    o.fixedNodeCount = 42;
    o.scaling =
        buildGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling();
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig(
    api.GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig o) {
  buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig < 3) {
    unittest.expect(
      o.fixedNodeCount!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling(
        o.scaling!);
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling =
    0;
api.GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling
    buildGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling() {
  final o = api.GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling();
  buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling <
      3) {
    o.cpuUtilizationTarget = 42;
    o.maxNodeCount = 42;
    o.minNodeCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling--;
  return o;
}

void checkGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling(
    api.GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling o) {
  buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling++;
  if (buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling <
      3) {
    unittest.expect(
      o.cpuUtilizationTarget!,
      unittest.equals(42),
    );
    unittest.expect(
      o.maxNodeCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.minNodeCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling--;
}

core.int buildCounterGoogleCloudAiplatformV1FetchFeatureValuesRequest = 0;
api.GoogleCloudAiplatformV1FetchFeatureValuesRequest
    buildGoogleCloudAiplatformV1FetchFeatureValuesRequest() {
  final o = api.GoogleCloudAiplatformV1FetchFeatureValuesRequest();
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1FetchFeatureValuesRequest < 3) {
    o.dataFormat = 'foo';
    o.dataKey = buildGoogleCloudAiplatformV1FeatureViewDataKey();
  }
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1FetchFeatureValuesRequest(
    api.GoogleCloudAiplatformV1FetchFeatureValuesRequest o) {
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1FetchFeatureValuesRequest < 3) {
    unittest.expect(
      o.dataFormat!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FeatureViewDataKey(o.dataKey!);
  }
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesRequest--;
}

core.Map<core.String, core.Object?> buildUnnamed105() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed105(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted40 = (o['x']!) as core.Map;
  unittest.expect(casted40, unittest.hasLength(3));
  unittest.expect(
    casted40['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted40['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted40['string'],
    unittest.equals('foo'),
  );
  var casted41 = (o['y']!) as core.Map;
  unittest.expect(casted41, unittest.hasLength(3));
  unittest.expect(
    casted41['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted41['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted41['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponse = 0;
api.GoogleCloudAiplatformV1FetchFeatureValuesResponse
    buildGoogleCloudAiplatformV1FetchFeatureValuesResponse() {
  final o = api.GoogleCloudAiplatformV1FetchFeatureValuesResponse();
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponse++;
  if (buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponse < 3) {
    o.keyValues =
        buildGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList();
    o.protoStruct = buildUnnamed105();
  }
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1FetchFeatureValuesResponse(
    api.GoogleCloudAiplatformV1FetchFeatureValuesResponse o) {
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponse++;
  if (buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponse < 3) {
    checkGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList(
        o.keyValues!);
    checkUnnamed105(o.protoStruct!);
  }
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponse--;
}

core.List<
        api
        .GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair>
    buildUnnamed106() => [
          buildGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair(),
          buildGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair(),
        ];

void checkUnnamed106(
    core.List<
            api
            .GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair(
      o[0]);
  checkGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair(
      o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList =
    0;
api.GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList
    buildGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList() {
  final o = api
      .GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList();
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList++;
  if (buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList <
      3) {
    o.features = buildUnnamed106();
  }
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList--;
  return o;
}

void checkGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList(
    api.GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList
        o) {
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList++;
  if (buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList <
      3) {
    checkUnnamed106(o.features!);
  }
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList--;
}

core.int
    buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair =
    0;
api.GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair
    buildGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair() {
  final o = api
      .GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair();
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair++;
  if (buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair <
      3) {
    o.name = 'foo';
    o.value = buildGoogleCloudAiplatformV1FeatureValue();
  }
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair--;
  return o;
}

void checkGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair(
    api.GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair
        o) {
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair++;
  if (buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair <
      3) {
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FeatureValue(o.value!);
  }
  buildCounterGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair--;
}

core.int buildCounterGoogleCloudAiplatformV1FileData = 0;
api.GoogleCloudAiplatformV1FileData buildGoogleCloudAiplatformV1FileData() {
  final o = api.GoogleCloudAiplatformV1FileData();
  buildCounterGoogleCloudAiplatformV1FileData++;
  if (buildCounterGoogleCloudAiplatformV1FileData < 3) {
    o.fileUri = 'foo';
    o.mimeType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FileData--;
  return o;
}

void checkGoogleCloudAiplatformV1FileData(
    api.GoogleCloudAiplatformV1FileData o) {
  buildCounterGoogleCloudAiplatformV1FileData++;
  if (buildCounterGoogleCloudAiplatformV1FileData < 3) {
    unittest.expect(
      o.fileUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.mimeType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FileData--;
}

core.int buildCounterGoogleCloudAiplatformV1FilterSplit = 0;
api.GoogleCloudAiplatformV1FilterSplit
    buildGoogleCloudAiplatformV1FilterSplit() {
  final o = api.GoogleCloudAiplatformV1FilterSplit();
  buildCounterGoogleCloudAiplatformV1FilterSplit++;
  if (buildCounterGoogleCloudAiplatformV1FilterSplit < 3) {
    o.testFilter = 'foo';
    o.trainingFilter = 'foo';
    o.validationFilter = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FilterSplit--;
  return o;
}

void checkGoogleCloudAiplatformV1FilterSplit(
    api.GoogleCloudAiplatformV1FilterSplit o) {
  buildCounterGoogleCloudAiplatformV1FilterSplit++;
  if (buildCounterGoogleCloudAiplatformV1FilterSplit < 3) {
    unittest.expect(
      o.testFilter!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.trainingFilter!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.validationFilter!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FilterSplit--;
}

core.List<api.GoogleCloudAiplatformV1FindNeighborsRequestQuery>
    buildUnnamed107() => [
          buildGoogleCloudAiplatformV1FindNeighborsRequestQuery(),
          buildGoogleCloudAiplatformV1FindNeighborsRequestQuery(),
        ];

void checkUnnamed107(
    core.List<api.GoogleCloudAiplatformV1FindNeighborsRequestQuery> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FindNeighborsRequestQuery(o[0]);
  checkGoogleCloudAiplatformV1FindNeighborsRequestQuery(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1FindNeighborsRequest = 0;
api.GoogleCloudAiplatformV1FindNeighborsRequest
    buildGoogleCloudAiplatformV1FindNeighborsRequest() {
  final o = api.GoogleCloudAiplatformV1FindNeighborsRequest();
  buildCounterGoogleCloudAiplatformV1FindNeighborsRequest++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsRequest < 3) {
    o.deployedIndexId = 'foo';
    o.queries = buildUnnamed107();
    o.returnFullDatapoint = true;
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1FindNeighborsRequest(
    api.GoogleCloudAiplatformV1FindNeighborsRequest o) {
  buildCounterGoogleCloudAiplatformV1FindNeighborsRequest++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsRequest < 3) {
    unittest.expect(
      o.deployedIndexId!,
      unittest.equals('foo'),
    );
    checkUnnamed107(o.queries!);
    unittest.expect(o.returnFullDatapoint!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1FindNeighborsRequestQuery = 0;
api.GoogleCloudAiplatformV1FindNeighborsRequestQuery
    buildGoogleCloudAiplatformV1FindNeighborsRequestQuery() {
  final o = api.GoogleCloudAiplatformV1FindNeighborsRequestQuery();
  buildCounterGoogleCloudAiplatformV1FindNeighborsRequestQuery++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsRequestQuery < 3) {
    o.approximateNeighborCount = 42;
    o.datapoint = buildGoogleCloudAiplatformV1IndexDatapoint();
    o.fractionLeafNodesToSearchOverride = 42.0;
    o.neighborCount = 42;
    o.perCrowdingAttributeNeighborCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsRequestQuery--;
  return o;
}

void checkGoogleCloudAiplatformV1FindNeighborsRequestQuery(
    api.GoogleCloudAiplatformV1FindNeighborsRequestQuery o) {
  buildCounterGoogleCloudAiplatformV1FindNeighborsRequestQuery++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsRequestQuery < 3) {
    unittest.expect(
      o.approximateNeighborCount!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1IndexDatapoint(o.datapoint!);
    unittest.expect(
      o.fractionLeafNodesToSearchOverride!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.neighborCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.perCrowdingAttributeNeighborCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsRequestQuery--;
}

core.List<api.GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors>
    buildUnnamed108() => [
          buildGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors(),
          buildGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors(),
        ];

void checkUnnamed108(
    core.List<api.GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors(o[0]);
  checkGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1FindNeighborsResponse = 0;
api.GoogleCloudAiplatformV1FindNeighborsResponse
    buildGoogleCloudAiplatformV1FindNeighborsResponse() {
  final o = api.GoogleCloudAiplatformV1FindNeighborsResponse();
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponse++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsResponse < 3) {
    o.nearestNeighbors = buildUnnamed108();
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1FindNeighborsResponse(
    api.GoogleCloudAiplatformV1FindNeighborsResponse o) {
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponse++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsResponse < 3) {
    checkUnnamed108(o.nearestNeighbors!);
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponse--;
}

core.List<api.GoogleCloudAiplatformV1FindNeighborsResponseNeighbor>
    buildUnnamed109() => [
          buildGoogleCloudAiplatformV1FindNeighborsResponseNeighbor(),
          buildGoogleCloudAiplatformV1FindNeighborsResponseNeighbor(),
        ];

void checkUnnamed109(
    core.List<api.GoogleCloudAiplatformV1FindNeighborsResponseNeighbor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FindNeighborsResponseNeighbor(o[0]);
  checkGoogleCloudAiplatformV1FindNeighborsResponseNeighbor(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors =
    0;
api.GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors
    buildGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors() {
  final o = api.GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors();
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors <
      3) {
    o.id = 'foo';
    o.neighbors = buildUnnamed109();
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors--;
  return o;
}

void checkGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors(
    api.GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors o) {
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors <
      3) {
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
    checkUnnamed109(o.neighbors!);
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors--;
}

core.int buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNeighbor = 0;
api.GoogleCloudAiplatformV1FindNeighborsResponseNeighbor
    buildGoogleCloudAiplatformV1FindNeighborsResponseNeighbor() {
  final o = api.GoogleCloudAiplatformV1FindNeighborsResponseNeighbor();
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNeighbor++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNeighbor < 3) {
    o.datapoint = buildGoogleCloudAiplatformV1IndexDatapoint();
    o.distance = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNeighbor--;
  return o;
}

void checkGoogleCloudAiplatformV1FindNeighborsResponseNeighbor(
    api.GoogleCloudAiplatformV1FindNeighborsResponseNeighbor o) {
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNeighbor++;
  if (buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNeighbor < 3) {
    checkGoogleCloudAiplatformV1IndexDatapoint(o.datapoint!);
    unittest.expect(
      o.distance!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1FindNeighborsResponseNeighbor--;
}

core.int buildCounterGoogleCloudAiplatformV1FractionSplit = 0;
api.GoogleCloudAiplatformV1FractionSplit
    buildGoogleCloudAiplatformV1FractionSplit() {
  final o = api.GoogleCloudAiplatformV1FractionSplit();
  buildCounterGoogleCloudAiplatformV1FractionSplit++;
  if (buildCounterGoogleCloudAiplatformV1FractionSplit < 3) {
    o.testFraction = 42.0;
    o.trainingFraction = 42.0;
    o.validationFraction = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1FractionSplit--;
  return o;
}

void checkGoogleCloudAiplatformV1FractionSplit(
    api.GoogleCloudAiplatformV1FractionSplit o) {
  buildCounterGoogleCloudAiplatformV1FractionSplit++;
  if (buildCounterGoogleCloudAiplatformV1FractionSplit < 3) {
    unittest.expect(
      o.testFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.trainingFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.validationFraction!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1FractionSplit--;
}

core.Map<core.String, core.Object?> buildUnnamed110() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed110(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted42 = (o['x']!) as core.Map;
  unittest.expect(casted42, unittest.hasLength(3));
  unittest.expect(
    casted42['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted42['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted42['string'],
    unittest.equals('foo'),
  );
  var casted43 = (o['y']!) as core.Map;
  unittest.expect(casted43, unittest.hasLength(3));
  unittest.expect(
    casted43['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted43['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted43['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FunctionCall = 0;
api.GoogleCloudAiplatformV1FunctionCall
    buildGoogleCloudAiplatformV1FunctionCall() {
  final o = api.GoogleCloudAiplatformV1FunctionCall();
  buildCounterGoogleCloudAiplatformV1FunctionCall++;
  if (buildCounterGoogleCloudAiplatformV1FunctionCall < 3) {
    o.args = buildUnnamed110();
    o.name = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1FunctionCall--;
  return o;
}

void checkGoogleCloudAiplatformV1FunctionCall(
    api.GoogleCloudAiplatformV1FunctionCall o) {
  buildCounterGoogleCloudAiplatformV1FunctionCall++;
  if (buildCounterGoogleCloudAiplatformV1FunctionCall < 3) {
    checkUnnamed110(o.args!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1FunctionCall--;
}

core.int buildCounterGoogleCloudAiplatformV1FunctionDeclaration = 0;
api.GoogleCloudAiplatformV1FunctionDeclaration
    buildGoogleCloudAiplatformV1FunctionDeclaration() {
  final o = api.GoogleCloudAiplatformV1FunctionDeclaration();
  buildCounterGoogleCloudAiplatformV1FunctionDeclaration++;
  if (buildCounterGoogleCloudAiplatformV1FunctionDeclaration < 3) {
    o.description = 'foo';
    o.name = 'foo';
    o.parameters = buildGoogleCloudAiplatformV1Schema();
  }
  buildCounterGoogleCloudAiplatformV1FunctionDeclaration--;
  return o;
}

void checkGoogleCloudAiplatformV1FunctionDeclaration(
    api.GoogleCloudAiplatformV1FunctionDeclaration o) {
  buildCounterGoogleCloudAiplatformV1FunctionDeclaration++;
  if (buildCounterGoogleCloudAiplatformV1FunctionDeclaration < 3) {
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1Schema(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1FunctionDeclaration--;
}

core.Map<core.String, core.Object?> buildUnnamed111() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed111(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted44 = (o['x']!) as core.Map;
  unittest.expect(casted44, unittest.hasLength(3));
  unittest.expect(
    casted44['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted44['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted44['string'],
    unittest.equals('foo'),
  );
  var casted45 = (o['y']!) as core.Map;
  unittest.expect(casted45, unittest.hasLength(3));
  unittest.expect(
    casted45['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted45['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted45['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1FunctionResponse = 0;
api.GoogleCloudAiplatformV1FunctionResponse
    buildGoogleCloudAiplatformV1FunctionResponse() {
  final o = api.GoogleCloudAiplatformV1FunctionResponse();
  buildCounterGoogleCloudAiplatformV1FunctionResponse++;
  if (buildCounterGoogleCloudAiplatformV1FunctionResponse < 3) {
    o.name = 'foo';
    o.response = buildUnnamed111();
  }
  buildCounterGoogleCloudAiplatformV1FunctionResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1FunctionResponse(
    api.GoogleCloudAiplatformV1FunctionResponse o) {
  buildCounterGoogleCloudAiplatformV1FunctionResponse++;
  if (buildCounterGoogleCloudAiplatformV1FunctionResponse < 3) {
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed111(o.response!);
  }
  buildCounterGoogleCloudAiplatformV1FunctionResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1GcsDestination = 0;
api.GoogleCloudAiplatformV1GcsDestination
    buildGoogleCloudAiplatformV1GcsDestination() {
  final o = api.GoogleCloudAiplatformV1GcsDestination();
  buildCounterGoogleCloudAiplatformV1GcsDestination++;
  if (buildCounterGoogleCloudAiplatformV1GcsDestination < 3) {
    o.outputUriPrefix = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1GcsDestination--;
  return o;
}

void checkGoogleCloudAiplatformV1GcsDestination(
    api.GoogleCloudAiplatformV1GcsDestination o) {
  buildCounterGoogleCloudAiplatformV1GcsDestination++;
  if (buildCounterGoogleCloudAiplatformV1GcsDestination < 3) {
    unittest.expect(
      o.outputUriPrefix!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1GcsDestination--;
}

core.List<core.String> buildUnnamed112() => [
      'foo',
      'foo',
    ];

void checkUnnamed112(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1GcsSource = 0;
api.GoogleCloudAiplatformV1GcsSource buildGoogleCloudAiplatformV1GcsSource() {
  final o = api.GoogleCloudAiplatformV1GcsSource();
  buildCounterGoogleCloudAiplatformV1GcsSource++;
  if (buildCounterGoogleCloudAiplatformV1GcsSource < 3) {
    o.uris = buildUnnamed112();
  }
  buildCounterGoogleCloudAiplatformV1GcsSource--;
  return o;
}

void checkGoogleCloudAiplatformV1GcsSource(
    api.GoogleCloudAiplatformV1GcsSource o) {
  buildCounterGoogleCloudAiplatformV1GcsSource++;
  if (buildCounterGoogleCloudAiplatformV1GcsSource < 3) {
    checkUnnamed112(o.uris!);
  }
  buildCounterGoogleCloudAiplatformV1GcsSource--;
}

core.List<api.GoogleCloudAiplatformV1Content> buildUnnamed113() => [
      buildGoogleCloudAiplatformV1Content(),
      buildGoogleCloudAiplatformV1Content(),
    ];

void checkUnnamed113(core.List<api.GoogleCloudAiplatformV1Content> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Content(o[0]);
  checkGoogleCloudAiplatformV1Content(o[1]);
}

core.List<api.GoogleCloudAiplatformV1SafetySetting> buildUnnamed114() => [
      buildGoogleCloudAiplatformV1SafetySetting(),
      buildGoogleCloudAiplatformV1SafetySetting(),
    ];

void checkUnnamed114(core.List<api.GoogleCloudAiplatformV1SafetySetting> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1SafetySetting(o[0]);
  checkGoogleCloudAiplatformV1SafetySetting(o[1]);
}

core.List<api.GoogleCloudAiplatformV1Tool> buildUnnamed115() => [
      buildGoogleCloudAiplatformV1Tool(),
      buildGoogleCloudAiplatformV1Tool(),
    ];

void checkUnnamed115(core.List<api.GoogleCloudAiplatformV1Tool> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Tool(o[0]);
  checkGoogleCloudAiplatformV1Tool(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1GenerateContentRequest = 0;
api.GoogleCloudAiplatformV1GenerateContentRequest
    buildGoogleCloudAiplatformV1GenerateContentRequest() {
  final o = api.GoogleCloudAiplatformV1GenerateContentRequest();
  buildCounterGoogleCloudAiplatformV1GenerateContentRequest++;
  if (buildCounterGoogleCloudAiplatformV1GenerateContentRequest < 3) {
    o.contents = buildUnnamed113();
    o.generationConfig = buildGoogleCloudAiplatformV1GenerationConfig();
    o.safetySettings = buildUnnamed114();
    o.tools = buildUnnamed115();
  }
  buildCounterGoogleCloudAiplatformV1GenerateContentRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1GenerateContentRequest(
    api.GoogleCloudAiplatformV1GenerateContentRequest o) {
  buildCounterGoogleCloudAiplatformV1GenerateContentRequest++;
  if (buildCounterGoogleCloudAiplatformV1GenerateContentRequest < 3) {
    checkUnnamed113(o.contents!);
    checkGoogleCloudAiplatformV1GenerationConfig(o.generationConfig!);
    checkUnnamed114(o.safetySettings!);
    checkUnnamed115(o.tools!);
  }
  buildCounterGoogleCloudAiplatformV1GenerateContentRequest--;
}

core.List<api.GoogleCloudAiplatformV1Candidate> buildUnnamed116() => [
      buildGoogleCloudAiplatformV1Candidate(),
      buildGoogleCloudAiplatformV1Candidate(),
    ];

void checkUnnamed116(core.List<api.GoogleCloudAiplatformV1Candidate> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Candidate(o[0]);
  checkGoogleCloudAiplatformV1Candidate(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1GenerateContentResponse = 0;
api.GoogleCloudAiplatformV1GenerateContentResponse
    buildGoogleCloudAiplatformV1GenerateContentResponse() {
  final o = api.GoogleCloudAiplatformV1GenerateContentResponse();
  buildCounterGoogleCloudAiplatformV1GenerateContentResponse++;
  if (buildCounterGoogleCloudAiplatformV1GenerateContentResponse < 3) {
    o.candidates = buildUnnamed116();
    o.promptFeedback =
        buildGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback();
    o.usageMetadata =
        buildGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata();
  }
  buildCounterGoogleCloudAiplatformV1GenerateContentResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1GenerateContentResponse(
    api.GoogleCloudAiplatformV1GenerateContentResponse o) {
  buildCounterGoogleCloudAiplatformV1GenerateContentResponse++;
  if (buildCounterGoogleCloudAiplatformV1GenerateContentResponse < 3) {
    checkUnnamed116(o.candidates!);
    checkGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback(
        o.promptFeedback!);
    checkGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata(
        o.usageMetadata!);
  }
  buildCounterGoogleCloudAiplatformV1GenerateContentResponse--;
}

core.List<api.GoogleCloudAiplatformV1SafetyRating> buildUnnamed117() => [
      buildGoogleCloudAiplatformV1SafetyRating(),
      buildGoogleCloudAiplatformV1SafetyRating(),
    ];

void checkUnnamed117(core.List<api.GoogleCloudAiplatformV1SafetyRating> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1SafetyRating(o[0]);
  checkGoogleCloudAiplatformV1SafetyRating(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback =
    0;
api.GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback
    buildGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback() {
  final o = api.GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback();
  buildCounterGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback++;
  if (buildCounterGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback <
      3) {
    o.blockReason = 'foo';
    o.blockReasonMessage = 'foo';
    o.safetyRatings = buildUnnamed117();
  }
  buildCounterGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback--;
  return o;
}

void checkGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback(
    api.GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback o) {
  buildCounterGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback++;
  if (buildCounterGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback <
      3) {
    unittest.expect(
      o.blockReason!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.blockReasonMessage!,
      unittest.equals('foo'),
    );
    checkUnnamed117(o.safetyRatings!);
  }
  buildCounterGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback--;
}

core.int
    buildCounterGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata = 0;
api.GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata
    buildGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata() {
  final o = api.GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata();
  buildCounterGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata++;
  if (buildCounterGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata <
      3) {
    o.candidatesTokenCount = 42;
    o.promptTokenCount = 42;
    o.totalTokenCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata(
    api.GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata o) {
  buildCounterGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata++;
  if (buildCounterGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata <
      3) {
    unittest.expect(
      o.candidatesTokenCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.promptTokenCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.totalTokenCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata--;
}

core.List<core.String> buildUnnamed118() => [
      'foo',
      'foo',
    ];

void checkUnnamed118(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1GenerationConfig = 0;
api.GoogleCloudAiplatformV1GenerationConfig
    buildGoogleCloudAiplatformV1GenerationConfig() {
  final o = api.GoogleCloudAiplatformV1GenerationConfig();
  buildCounterGoogleCloudAiplatformV1GenerationConfig++;
  if (buildCounterGoogleCloudAiplatformV1GenerationConfig < 3) {
    o.candidateCount = 42;
    o.maxOutputTokens = 42;
    o.stopSequences = buildUnnamed118();
    o.temperature = 42.0;
    o.topK = 42.0;
    o.topP = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1GenerationConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1GenerationConfig(
    api.GoogleCloudAiplatformV1GenerationConfig o) {
  buildCounterGoogleCloudAiplatformV1GenerationConfig++;
  if (buildCounterGoogleCloudAiplatformV1GenerationConfig < 3) {
    unittest.expect(
      o.candidateCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.maxOutputTokens!,
      unittest.equals(42),
    );
    checkUnnamed118(o.stopSequences!);
    unittest.expect(
      o.temperature!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.topK!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.topP!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1GenerationConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1GenieSource = 0;
api.GoogleCloudAiplatformV1GenieSource
    buildGoogleCloudAiplatformV1GenieSource() {
  final o = api.GoogleCloudAiplatformV1GenieSource();
  buildCounterGoogleCloudAiplatformV1GenieSource++;
  if (buildCounterGoogleCloudAiplatformV1GenieSource < 3) {
    o.baseModelUri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1GenieSource--;
  return o;
}

void checkGoogleCloudAiplatformV1GenieSource(
    api.GoogleCloudAiplatformV1GenieSource o) {
  buildCounterGoogleCloudAiplatformV1GenieSource++;
  if (buildCounterGoogleCloudAiplatformV1GenieSource < 3) {
    unittest.expect(
      o.baseModelUri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1GenieSource--;
}

core.int buildCounterGoogleCloudAiplatformV1GroundingAttribution = 0;
api.GoogleCloudAiplatformV1GroundingAttribution
    buildGoogleCloudAiplatformV1GroundingAttribution() {
  final o = api.GoogleCloudAiplatformV1GroundingAttribution();
  buildCounterGoogleCloudAiplatformV1GroundingAttribution++;
  if (buildCounterGoogleCloudAiplatformV1GroundingAttribution < 3) {
    o.confidenceScore = 42.0;
    o.segment = buildGoogleCloudAiplatformV1Segment();
    o.web = buildGoogleCloudAiplatformV1GroundingAttributionWeb();
  }
  buildCounterGoogleCloudAiplatformV1GroundingAttribution--;
  return o;
}

void checkGoogleCloudAiplatformV1GroundingAttribution(
    api.GoogleCloudAiplatformV1GroundingAttribution o) {
  buildCounterGoogleCloudAiplatformV1GroundingAttribution++;
  if (buildCounterGoogleCloudAiplatformV1GroundingAttribution < 3) {
    unittest.expect(
      o.confidenceScore!,
      unittest.equals(42.0),
    );
    checkGoogleCloudAiplatformV1Segment(o.segment!);
    checkGoogleCloudAiplatformV1GroundingAttributionWeb(o.web!);
  }
  buildCounterGoogleCloudAiplatformV1GroundingAttribution--;
}

core.int buildCounterGoogleCloudAiplatformV1GroundingAttributionWeb = 0;
api.GoogleCloudAiplatformV1GroundingAttributionWeb
    buildGoogleCloudAiplatformV1GroundingAttributionWeb() {
  final o = api.GoogleCloudAiplatformV1GroundingAttributionWeb();
  buildCounterGoogleCloudAiplatformV1GroundingAttributionWeb++;
  if (buildCounterGoogleCloudAiplatformV1GroundingAttributionWeb < 3) {
    o.title = 'foo';
    o.uri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1GroundingAttributionWeb--;
  return o;
}

void checkGoogleCloudAiplatformV1GroundingAttributionWeb(
    api.GoogleCloudAiplatformV1GroundingAttributionWeb o) {
  buildCounterGoogleCloudAiplatformV1GroundingAttributionWeb++;
  if (buildCounterGoogleCloudAiplatformV1GroundingAttributionWeb < 3) {
    unittest.expect(
      o.title!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.uri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1GroundingAttributionWeb--;
}

core.List<api.GoogleCloudAiplatformV1GroundingAttribution> buildUnnamed119() =>
    [
      buildGoogleCloudAiplatformV1GroundingAttribution(),
      buildGoogleCloudAiplatformV1GroundingAttribution(),
    ];

void checkUnnamed119(
    core.List<api.GoogleCloudAiplatformV1GroundingAttribution> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1GroundingAttribution(o[0]);
  checkGoogleCloudAiplatformV1GroundingAttribution(o[1]);
}

core.List<core.String> buildUnnamed120() => [
      'foo',
      'foo',
    ];

void checkUnnamed120(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1GroundingMetadata = 0;
api.GoogleCloudAiplatformV1GroundingMetadata
    buildGoogleCloudAiplatformV1GroundingMetadata() {
  final o = api.GoogleCloudAiplatformV1GroundingMetadata();
  buildCounterGoogleCloudAiplatformV1GroundingMetadata++;
  if (buildCounterGoogleCloudAiplatformV1GroundingMetadata < 3) {
    o.groundingAttributions = buildUnnamed119();
    o.webSearchQueries = buildUnnamed120();
  }
  buildCounterGoogleCloudAiplatformV1GroundingMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1GroundingMetadata(
    api.GoogleCloudAiplatformV1GroundingMetadata o) {
  buildCounterGoogleCloudAiplatformV1GroundingMetadata++;
  if (buildCounterGoogleCloudAiplatformV1GroundingMetadata < 3) {
    checkUnnamed119(o.groundingAttributions!);
    checkUnnamed120(o.webSearchQueries!);
  }
  buildCounterGoogleCloudAiplatformV1GroundingMetadata--;
}

core.Map<core.String, core.String> buildUnnamed121() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed121(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1Trial> buildUnnamed122() => [
      buildGoogleCloudAiplatformV1Trial(),
      buildGoogleCloudAiplatformV1Trial(),
    ];

void checkUnnamed122(core.List<api.GoogleCloudAiplatformV1Trial> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Trial(o[0]);
  checkGoogleCloudAiplatformV1Trial(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1HyperparameterTuningJob = 0;
api.GoogleCloudAiplatformV1HyperparameterTuningJob
    buildGoogleCloudAiplatformV1HyperparameterTuningJob() {
  final o = api.GoogleCloudAiplatformV1HyperparameterTuningJob();
  buildCounterGoogleCloudAiplatformV1HyperparameterTuningJob++;
  if (buildCounterGoogleCloudAiplatformV1HyperparameterTuningJob < 3) {
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.endTime = 'foo';
    o.error = buildGoogleRpcStatus();
    o.labels = buildUnnamed121();
    o.maxFailedTrialCount = 42;
    o.maxTrialCount = 42;
    o.name = 'foo';
    o.parallelTrialCount = 42;
    o.startTime = 'foo';
    o.state = 'foo';
    o.studySpec = buildGoogleCloudAiplatformV1StudySpec();
    o.trialJobSpec = buildGoogleCloudAiplatformV1CustomJobSpec();
    o.trials = buildUnnamed122();
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1HyperparameterTuningJob--;
  return o;
}

void checkGoogleCloudAiplatformV1HyperparameterTuningJob(
    api.GoogleCloudAiplatformV1HyperparameterTuningJob o) {
  buildCounterGoogleCloudAiplatformV1HyperparameterTuningJob++;
  if (buildCounterGoogleCloudAiplatformV1HyperparameterTuningJob < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.error!);
    checkUnnamed121(o.labels!);
    unittest.expect(
      o.maxFailedTrialCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.maxTrialCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.parallelTrialCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1StudySpec(o.studySpec!);
    checkGoogleCloudAiplatformV1CustomJobSpec(o.trialJobSpec!);
    checkUnnamed122(o.trials!);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1HyperparameterTuningJob--;
}

core.List<core.String> buildUnnamed123() => [
      'foo',
      'foo',
    ];

void checkUnnamed123(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1IdMatcher = 0;
api.GoogleCloudAiplatformV1IdMatcher buildGoogleCloudAiplatformV1IdMatcher() {
  final o = api.GoogleCloudAiplatformV1IdMatcher();
  buildCounterGoogleCloudAiplatformV1IdMatcher++;
  if (buildCounterGoogleCloudAiplatformV1IdMatcher < 3) {
    o.ids = buildUnnamed123();
  }
  buildCounterGoogleCloudAiplatformV1IdMatcher--;
  return o;
}

void checkGoogleCloudAiplatformV1IdMatcher(
    api.GoogleCloudAiplatformV1IdMatcher o) {
  buildCounterGoogleCloudAiplatformV1IdMatcher++;
  if (buildCounterGoogleCloudAiplatformV1IdMatcher < 3) {
    checkUnnamed123(o.ids!);
  }
  buildCounterGoogleCloudAiplatformV1IdMatcher--;
}

core.Map<core.String, core.String> buildUnnamed124() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed124(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.String> buildUnnamed125() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed125(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ImportDataConfig = 0;
api.GoogleCloudAiplatformV1ImportDataConfig
    buildGoogleCloudAiplatformV1ImportDataConfig() {
  final o = api.GoogleCloudAiplatformV1ImportDataConfig();
  buildCounterGoogleCloudAiplatformV1ImportDataConfig++;
  if (buildCounterGoogleCloudAiplatformV1ImportDataConfig < 3) {
    o.annotationLabels = buildUnnamed124();
    o.dataItemLabels = buildUnnamed125();
    o.gcsSource = buildGoogleCloudAiplatformV1GcsSource();
    o.importSchemaUri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ImportDataConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ImportDataConfig(
    api.GoogleCloudAiplatformV1ImportDataConfig o) {
  buildCounterGoogleCloudAiplatformV1ImportDataConfig++;
  if (buildCounterGoogleCloudAiplatformV1ImportDataConfig < 3) {
    checkUnnamed124(o.annotationLabels!);
    checkUnnamed125(o.dataItemLabels!);
    checkGoogleCloudAiplatformV1GcsSource(o.gcsSource!);
    unittest.expect(
      o.importSchemaUri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ImportDataConfig--;
}

core.List<api.GoogleCloudAiplatformV1ImportDataConfig> buildUnnamed126() => [
      buildGoogleCloudAiplatformV1ImportDataConfig(),
      buildGoogleCloudAiplatformV1ImportDataConfig(),
    ];

void checkUnnamed126(core.List<api.GoogleCloudAiplatformV1ImportDataConfig> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ImportDataConfig(o[0]);
  checkGoogleCloudAiplatformV1ImportDataConfig(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ImportDataRequest = 0;
api.GoogleCloudAiplatformV1ImportDataRequest
    buildGoogleCloudAiplatformV1ImportDataRequest() {
  final o = api.GoogleCloudAiplatformV1ImportDataRequest();
  buildCounterGoogleCloudAiplatformV1ImportDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1ImportDataRequest < 3) {
    o.importConfigs = buildUnnamed126();
  }
  buildCounterGoogleCloudAiplatformV1ImportDataRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ImportDataRequest(
    api.GoogleCloudAiplatformV1ImportDataRequest o) {
  buildCounterGoogleCloudAiplatformV1ImportDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1ImportDataRequest < 3) {
    checkUnnamed126(o.importConfigs!);
  }
  buildCounterGoogleCloudAiplatformV1ImportDataRequest--;
}

core.List<api.GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec>
    buildUnnamed127() => [
          buildGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec(),
          buildGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec(),
        ];

void checkUnnamed127(
    core.List<api.GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec(o[0]);
  checkGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequest = 0;
api.GoogleCloudAiplatformV1ImportFeatureValuesRequest
    buildGoogleCloudAiplatformV1ImportFeatureValuesRequest() {
  final o = api.GoogleCloudAiplatformV1ImportFeatureValuesRequest();
  buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequest < 3) {
    o.avroSource = buildGoogleCloudAiplatformV1AvroSource();
    o.bigquerySource = buildGoogleCloudAiplatformV1BigQuerySource();
    o.csvSource = buildGoogleCloudAiplatformV1CsvSource();
    o.disableIngestionAnalysis = true;
    o.disableOnlineServing = true;
    o.entityIdField = 'foo';
    o.featureSpecs = buildUnnamed127();
    o.featureTime = 'foo';
    o.featureTimeField = 'foo';
    o.workerCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ImportFeatureValuesRequest(
    api.GoogleCloudAiplatformV1ImportFeatureValuesRequest o) {
  buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequest < 3) {
    checkGoogleCloudAiplatformV1AvroSource(o.avroSource!);
    checkGoogleCloudAiplatformV1BigQuerySource(o.bigquerySource!);
    checkGoogleCloudAiplatformV1CsvSource(o.csvSource!);
    unittest.expect(o.disableIngestionAnalysis!, unittest.isTrue);
    unittest.expect(o.disableOnlineServing!, unittest.isTrue);
    unittest.expect(
      o.entityIdField!,
      unittest.equals('foo'),
    );
    checkUnnamed127(o.featureSpecs!);
    unittest.expect(
      o.featureTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.featureTimeField!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.workerCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec =
    0;
api.GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec
    buildGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec() {
  final o = api.GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec();
  buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec++;
  if (buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec <
      3) {
    o.id = 'foo';
    o.sourceField = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec(
    api.GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec o) {
  buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec++;
  if (buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec <
      3) {
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.sourceField!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1ImportModelEvaluationRequest = 0;
api.GoogleCloudAiplatformV1ImportModelEvaluationRequest
    buildGoogleCloudAiplatformV1ImportModelEvaluationRequest() {
  final o = api.GoogleCloudAiplatformV1ImportModelEvaluationRequest();
  buildCounterGoogleCloudAiplatformV1ImportModelEvaluationRequest++;
  if (buildCounterGoogleCloudAiplatformV1ImportModelEvaluationRequest < 3) {
    o.modelEvaluation = buildGoogleCloudAiplatformV1ModelEvaluation();
  }
  buildCounterGoogleCloudAiplatformV1ImportModelEvaluationRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ImportModelEvaluationRequest(
    api.GoogleCloudAiplatformV1ImportModelEvaluationRequest o) {
  buildCounterGoogleCloudAiplatformV1ImportModelEvaluationRequest++;
  if (buildCounterGoogleCloudAiplatformV1ImportModelEvaluationRequest < 3) {
    checkGoogleCloudAiplatformV1ModelEvaluation(o.modelEvaluation!);
  }
  buildCounterGoogleCloudAiplatformV1ImportModelEvaluationRequest--;
}

core.List<api.GoogleCloudAiplatformV1DeployedIndexRef> buildUnnamed128() => [
      buildGoogleCloudAiplatformV1DeployedIndexRef(),
      buildGoogleCloudAiplatformV1DeployedIndexRef(),
    ];

void checkUnnamed128(core.List<api.GoogleCloudAiplatformV1DeployedIndexRef> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DeployedIndexRef(o[0]);
  checkGoogleCloudAiplatformV1DeployedIndexRef(o[1]);
}

core.Map<core.String, core.String> buildUnnamed129() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed129(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Index = 0;
api.GoogleCloudAiplatformV1Index buildGoogleCloudAiplatformV1Index() {
  final o = api.GoogleCloudAiplatformV1Index();
  buildCounterGoogleCloudAiplatformV1Index++;
  if (buildCounterGoogleCloudAiplatformV1Index < 3) {
    o.createTime = 'foo';
    o.deployedIndexes = buildUnnamed128();
    o.description = 'foo';
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.etag = 'foo';
    o.indexStats = buildGoogleCloudAiplatformV1IndexStats();
    o.indexUpdateMethod = 'foo';
    o.labels = buildUnnamed129();
    o.metadata = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.metadataSchemaUri = 'foo';
    o.name = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Index--;
  return o;
}

void checkGoogleCloudAiplatformV1Index(api.GoogleCloudAiplatformV1Index o) {
  buildCounterGoogleCloudAiplatformV1Index++;
  if (buildCounterGoogleCloudAiplatformV1Index < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkUnnamed128(o.deployedIndexes!);
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1IndexStats(o.indexStats!);
    unittest.expect(
      o.indexUpdateMethod!,
      unittest.equals('foo'),
    );
    checkUnnamed129(o.labels!);
    var casted46 = (o.metadata!) as core.Map;
    unittest.expect(casted46, unittest.hasLength(3));
    unittest.expect(
      casted46['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted46['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted46['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metadataSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Index--;
}

core.List<core.double> buildUnnamed130() => [
      42.0,
      42.0,
    ];

void checkUnnamed130(core.List<core.double> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42.0),
  );
  unittest.expect(
    o[1],
    unittest.equals(42.0),
  );
}

core.List<api.GoogleCloudAiplatformV1IndexDatapointNumericRestriction>
    buildUnnamed131() => [
          buildGoogleCloudAiplatformV1IndexDatapointNumericRestriction(),
          buildGoogleCloudAiplatformV1IndexDatapointNumericRestriction(),
        ];

void checkUnnamed131(
    core.List<api.GoogleCloudAiplatformV1IndexDatapointNumericRestriction> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1IndexDatapointNumericRestriction(o[0]);
  checkGoogleCloudAiplatformV1IndexDatapointNumericRestriction(o[1]);
}

core.List<api.GoogleCloudAiplatformV1IndexDatapointRestriction>
    buildUnnamed132() => [
          buildGoogleCloudAiplatformV1IndexDatapointRestriction(),
          buildGoogleCloudAiplatformV1IndexDatapointRestriction(),
        ];

void checkUnnamed132(
    core.List<api.GoogleCloudAiplatformV1IndexDatapointRestriction> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1IndexDatapointRestriction(o[0]);
  checkGoogleCloudAiplatformV1IndexDatapointRestriction(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1IndexDatapoint = 0;
api.GoogleCloudAiplatformV1IndexDatapoint
    buildGoogleCloudAiplatformV1IndexDatapoint() {
  final o = api.GoogleCloudAiplatformV1IndexDatapoint();
  buildCounterGoogleCloudAiplatformV1IndexDatapoint++;
  if (buildCounterGoogleCloudAiplatformV1IndexDatapoint < 3) {
    o.crowdingTag = buildGoogleCloudAiplatformV1IndexDatapointCrowdingTag();
    o.datapointId = 'foo';
    o.featureVector = buildUnnamed130();
    o.numericRestricts = buildUnnamed131();
    o.restricts = buildUnnamed132();
  }
  buildCounterGoogleCloudAiplatformV1IndexDatapoint--;
  return o;
}

void checkGoogleCloudAiplatformV1IndexDatapoint(
    api.GoogleCloudAiplatformV1IndexDatapoint o) {
  buildCounterGoogleCloudAiplatformV1IndexDatapoint++;
  if (buildCounterGoogleCloudAiplatformV1IndexDatapoint < 3) {
    checkGoogleCloudAiplatformV1IndexDatapointCrowdingTag(o.crowdingTag!);
    unittest.expect(
      o.datapointId!,
      unittest.equals('foo'),
    );
    checkUnnamed130(o.featureVector!);
    checkUnnamed131(o.numericRestricts!);
    checkUnnamed132(o.restricts!);
  }
  buildCounterGoogleCloudAiplatformV1IndexDatapoint--;
}

core.int buildCounterGoogleCloudAiplatformV1IndexDatapointCrowdingTag = 0;
api.GoogleCloudAiplatformV1IndexDatapointCrowdingTag
    buildGoogleCloudAiplatformV1IndexDatapointCrowdingTag() {
  final o = api.GoogleCloudAiplatformV1IndexDatapointCrowdingTag();
  buildCounterGoogleCloudAiplatformV1IndexDatapointCrowdingTag++;
  if (buildCounterGoogleCloudAiplatformV1IndexDatapointCrowdingTag < 3) {
    o.crowdingAttribute = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1IndexDatapointCrowdingTag--;
  return o;
}

void checkGoogleCloudAiplatformV1IndexDatapointCrowdingTag(
    api.GoogleCloudAiplatformV1IndexDatapointCrowdingTag o) {
  buildCounterGoogleCloudAiplatformV1IndexDatapointCrowdingTag++;
  if (buildCounterGoogleCloudAiplatformV1IndexDatapointCrowdingTag < 3) {
    unittest.expect(
      o.crowdingAttribute!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1IndexDatapointCrowdingTag--;
}

core.int buildCounterGoogleCloudAiplatformV1IndexDatapointNumericRestriction =
    0;
api.GoogleCloudAiplatformV1IndexDatapointNumericRestriction
    buildGoogleCloudAiplatformV1IndexDatapointNumericRestriction() {
  final o = api.GoogleCloudAiplatformV1IndexDatapointNumericRestriction();
  buildCounterGoogleCloudAiplatformV1IndexDatapointNumericRestriction++;
  if (buildCounterGoogleCloudAiplatformV1IndexDatapointNumericRestriction < 3) {
    o.namespace = 'foo';
    o.op = 'foo';
    o.valueDouble = 42.0;
    o.valueFloat = 42.0;
    o.valueInt = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1IndexDatapointNumericRestriction--;
  return o;
}

void checkGoogleCloudAiplatformV1IndexDatapointNumericRestriction(
    api.GoogleCloudAiplatformV1IndexDatapointNumericRestriction o) {
  buildCounterGoogleCloudAiplatformV1IndexDatapointNumericRestriction++;
  if (buildCounterGoogleCloudAiplatformV1IndexDatapointNumericRestriction < 3) {
    unittest.expect(
      o.namespace!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.op!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.valueDouble!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.valueFloat!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.valueInt!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1IndexDatapointNumericRestriction--;
}

core.List<core.String> buildUnnamed133() => [
      'foo',
      'foo',
    ];

void checkUnnamed133(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed134() => [
      'foo',
      'foo',
    ];

void checkUnnamed134(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1IndexDatapointRestriction = 0;
api.GoogleCloudAiplatformV1IndexDatapointRestriction
    buildGoogleCloudAiplatformV1IndexDatapointRestriction() {
  final o = api.GoogleCloudAiplatformV1IndexDatapointRestriction();
  buildCounterGoogleCloudAiplatformV1IndexDatapointRestriction++;
  if (buildCounterGoogleCloudAiplatformV1IndexDatapointRestriction < 3) {
    o.allowList = buildUnnamed133();
    o.denyList = buildUnnamed134();
    o.namespace = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1IndexDatapointRestriction--;
  return o;
}

void checkGoogleCloudAiplatformV1IndexDatapointRestriction(
    api.GoogleCloudAiplatformV1IndexDatapointRestriction o) {
  buildCounterGoogleCloudAiplatformV1IndexDatapointRestriction++;
  if (buildCounterGoogleCloudAiplatformV1IndexDatapointRestriction < 3) {
    checkUnnamed133(o.allowList!);
    checkUnnamed134(o.denyList!);
    unittest.expect(
      o.namespace!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1IndexDatapointRestriction--;
}

core.List<api.GoogleCloudAiplatformV1DeployedIndex> buildUnnamed135() => [
      buildGoogleCloudAiplatformV1DeployedIndex(),
      buildGoogleCloudAiplatformV1DeployedIndex(),
    ];

void checkUnnamed135(core.List<api.GoogleCloudAiplatformV1DeployedIndex> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DeployedIndex(o[0]);
  checkGoogleCloudAiplatformV1DeployedIndex(o[1]);
}

core.Map<core.String, core.String> buildUnnamed136() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed136(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1IndexEndpoint = 0;
api.GoogleCloudAiplatformV1IndexEndpoint
    buildGoogleCloudAiplatformV1IndexEndpoint() {
  final o = api.GoogleCloudAiplatformV1IndexEndpoint();
  buildCounterGoogleCloudAiplatformV1IndexEndpoint++;
  if (buildCounterGoogleCloudAiplatformV1IndexEndpoint < 3) {
    o.createTime = 'foo';
    o.deployedIndexes = buildUnnamed135();
    o.description = 'foo';
    o.displayName = 'foo';
    o.enablePrivateServiceConnect = true;
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.etag = 'foo';
    o.labels = buildUnnamed136();
    o.name = 'foo';
    o.network = 'foo';
    o.privateServiceConnectConfig =
        buildGoogleCloudAiplatformV1PrivateServiceConnectConfig();
    o.publicEndpointDomainName = 'foo';
    o.publicEndpointEnabled = true;
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1IndexEndpoint--;
  return o;
}

void checkGoogleCloudAiplatformV1IndexEndpoint(
    api.GoogleCloudAiplatformV1IndexEndpoint o) {
  buildCounterGoogleCloudAiplatformV1IndexEndpoint++;
  if (buildCounterGoogleCloudAiplatformV1IndexEndpoint < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkUnnamed135(o.deployedIndexes!);
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(o.enablePrivateServiceConnect!, unittest.isTrue);
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed136(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.network!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PrivateServiceConnectConfig(
        o.privateServiceConnectConfig!);
    unittest.expect(
      o.publicEndpointDomainName!,
      unittest.equals('foo'),
    );
    unittest.expect(o.publicEndpointEnabled!, unittest.isTrue);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1IndexEndpoint--;
}

core.List<api.GoogleCloudAiplatformV1PscAutomatedEndpoints> buildUnnamed137() =>
    [
      buildGoogleCloudAiplatformV1PscAutomatedEndpoints(),
      buildGoogleCloudAiplatformV1PscAutomatedEndpoints(),
    ];

void checkUnnamed137(
    core.List<api.GoogleCloudAiplatformV1PscAutomatedEndpoints> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PscAutomatedEndpoints(o[0]);
  checkGoogleCloudAiplatformV1PscAutomatedEndpoints(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1IndexPrivateEndpoints = 0;
api.GoogleCloudAiplatformV1IndexPrivateEndpoints
    buildGoogleCloudAiplatformV1IndexPrivateEndpoints() {
  final o = api.GoogleCloudAiplatformV1IndexPrivateEndpoints();
  buildCounterGoogleCloudAiplatformV1IndexPrivateEndpoints++;
  if (buildCounterGoogleCloudAiplatformV1IndexPrivateEndpoints < 3) {
    o.matchGrpcAddress = 'foo';
    o.pscAutomatedEndpoints = buildUnnamed137();
    o.serviceAttachment = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1IndexPrivateEndpoints--;
  return o;
}

void checkGoogleCloudAiplatformV1IndexPrivateEndpoints(
    api.GoogleCloudAiplatformV1IndexPrivateEndpoints o) {
  buildCounterGoogleCloudAiplatformV1IndexPrivateEndpoints++;
  if (buildCounterGoogleCloudAiplatformV1IndexPrivateEndpoints < 3) {
    unittest.expect(
      o.matchGrpcAddress!,
      unittest.equals('foo'),
    );
    checkUnnamed137(o.pscAutomatedEndpoints!);
    unittest.expect(
      o.serviceAttachment!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1IndexPrivateEndpoints--;
}

core.int buildCounterGoogleCloudAiplatformV1IndexStats = 0;
api.GoogleCloudAiplatformV1IndexStats buildGoogleCloudAiplatformV1IndexStats() {
  final o = api.GoogleCloudAiplatformV1IndexStats();
  buildCounterGoogleCloudAiplatformV1IndexStats++;
  if (buildCounterGoogleCloudAiplatformV1IndexStats < 3) {
    o.shardsCount = 42;
    o.vectorsCount = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1IndexStats--;
  return o;
}

void checkGoogleCloudAiplatformV1IndexStats(
    api.GoogleCloudAiplatformV1IndexStats o) {
  buildCounterGoogleCloudAiplatformV1IndexStats++;
  if (buildCounterGoogleCloudAiplatformV1IndexStats < 3) {
    unittest.expect(
      o.shardsCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.vectorsCount!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1IndexStats--;
}

core.int buildCounterGoogleCloudAiplatformV1InputDataConfig = 0;
api.GoogleCloudAiplatformV1InputDataConfig
    buildGoogleCloudAiplatformV1InputDataConfig() {
  final o = api.GoogleCloudAiplatformV1InputDataConfig();
  buildCounterGoogleCloudAiplatformV1InputDataConfig++;
  if (buildCounterGoogleCloudAiplatformV1InputDataConfig < 3) {
    o.annotationSchemaUri = 'foo';
    o.annotationsFilter = 'foo';
    o.bigqueryDestination = buildGoogleCloudAiplatformV1BigQueryDestination();
    o.datasetId = 'foo';
    o.filterSplit = buildGoogleCloudAiplatformV1FilterSplit();
    o.fractionSplit = buildGoogleCloudAiplatformV1FractionSplit();
    o.gcsDestination = buildGoogleCloudAiplatformV1GcsDestination();
    o.persistMlUseAssignment = true;
    o.predefinedSplit = buildGoogleCloudAiplatformV1PredefinedSplit();
    o.savedQueryId = 'foo';
    o.stratifiedSplit = buildGoogleCloudAiplatformV1StratifiedSplit();
    o.timestampSplit = buildGoogleCloudAiplatformV1TimestampSplit();
  }
  buildCounterGoogleCloudAiplatformV1InputDataConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1InputDataConfig(
    api.GoogleCloudAiplatformV1InputDataConfig o) {
  buildCounterGoogleCloudAiplatformV1InputDataConfig++;
  if (buildCounterGoogleCloudAiplatformV1InputDataConfig < 3) {
    unittest.expect(
      o.annotationSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.annotationsFilter!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1BigQueryDestination(o.bigqueryDestination!);
    unittest.expect(
      o.datasetId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FilterSplit(o.filterSplit!);
    checkGoogleCloudAiplatformV1FractionSplit(o.fractionSplit!);
    checkGoogleCloudAiplatformV1GcsDestination(o.gcsDestination!);
    unittest.expect(o.persistMlUseAssignment!, unittest.isTrue);
    checkGoogleCloudAiplatformV1PredefinedSplit(o.predefinedSplit!);
    unittest.expect(
      o.savedQueryId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1StratifiedSplit(o.stratifiedSplit!);
    checkGoogleCloudAiplatformV1TimestampSplit(o.timestampSplit!);
  }
  buildCounterGoogleCloudAiplatformV1InputDataConfig--;
}

core.List<core.String> buildUnnamed138() => [
      'foo',
      'foo',
    ];

void checkUnnamed138(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Int64Array = 0;
api.GoogleCloudAiplatformV1Int64Array buildGoogleCloudAiplatformV1Int64Array() {
  final o = api.GoogleCloudAiplatformV1Int64Array();
  buildCounterGoogleCloudAiplatformV1Int64Array++;
  if (buildCounterGoogleCloudAiplatformV1Int64Array < 3) {
    o.values = buildUnnamed138();
  }
  buildCounterGoogleCloudAiplatformV1Int64Array--;
  return o;
}

void checkGoogleCloudAiplatformV1Int64Array(
    api.GoogleCloudAiplatformV1Int64Array o) {
  buildCounterGoogleCloudAiplatformV1Int64Array++;
  if (buildCounterGoogleCloudAiplatformV1Int64Array < 3) {
    checkUnnamed138(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1Int64Array--;
}

core.int buildCounterGoogleCloudAiplatformV1IntegratedGradientsAttribution = 0;
api.GoogleCloudAiplatformV1IntegratedGradientsAttribution
    buildGoogleCloudAiplatformV1IntegratedGradientsAttribution() {
  final o = api.GoogleCloudAiplatformV1IntegratedGradientsAttribution();
  buildCounterGoogleCloudAiplatformV1IntegratedGradientsAttribution++;
  if (buildCounterGoogleCloudAiplatformV1IntegratedGradientsAttribution < 3) {
    o.blurBaselineConfig = buildGoogleCloudAiplatformV1BlurBaselineConfig();
    o.smoothGradConfig = buildGoogleCloudAiplatformV1SmoothGradConfig();
    o.stepCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1IntegratedGradientsAttribution--;
  return o;
}

void checkGoogleCloudAiplatformV1IntegratedGradientsAttribution(
    api.GoogleCloudAiplatformV1IntegratedGradientsAttribution o) {
  buildCounterGoogleCloudAiplatformV1IntegratedGradientsAttribution++;
  if (buildCounterGoogleCloudAiplatformV1IntegratedGradientsAttribution < 3) {
    checkGoogleCloudAiplatformV1BlurBaselineConfig(o.blurBaselineConfig!);
    checkGoogleCloudAiplatformV1SmoothGradConfig(o.smoothGradConfig!);
    unittest.expect(
      o.stepCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1IntegratedGradientsAttribution--;
}

core.int buildCounterGoogleCloudAiplatformV1LargeModelReference = 0;
api.GoogleCloudAiplatformV1LargeModelReference
    buildGoogleCloudAiplatformV1LargeModelReference() {
  final o = api.GoogleCloudAiplatformV1LargeModelReference();
  buildCounterGoogleCloudAiplatformV1LargeModelReference++;
  if (buildCounterGoogleCloudAiplatformV1LargeModelReference < 3) {
    o.name = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1LargeModelReference--;
  return o;
}

void checkGoogleCloudAiplatformV1LargeModelReference(
    api.GoogleCloudAiplatformV1LargeModelReference o) {
  buildCounterGoogleCloudAiplatformV1LargeModelReference++;
  if (buildCounterGoogleCloudAiplatformV1LargeModelReference < 3) {
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1LargeModelReference--;
}

core.List<api.GoogleCloudAiplatformV1Artifact> buildUnnamed139() => [
      buildGoogleCloudAiplatformV1Artifact(),
      buildGoogleCloudAiplatformV1Artifact(),
    ];

void checkUnnamed139(core.List<api.GoogleCloudAiplatformV1Artifact> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Artifact(o[0]);
  checkGoogleCloudAiplatformV1Artifact(o[1]);
}

core.List<api.GoogleCloudAiplatformV1Event> buildUnnamed140() => [
      buildGoogleCloudAiplatformV1Event(),
      buildGoogleCloudAiplatformV1Event(),
    ];

void checkUnnamed140(core.List<api.GoogleCloudAiplatformV1Event> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Event(o[0]);
  checkGoogleCloudAiplatformV1Event(o[1]);
}

core.List<api.GoogleCloudAiplatformV1Execution> buildUnnamed141() => [
      buildGoogleCloudAiplatformV1Execution(),
      buildGoogleCloudAiplatformV1Execution(),
    ];

void checkUnnamed141(core.List<api.GoogleCloudAiplatformV1Execution> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Execution(o[0]);
  checkGoogleCloudAiplatformV1Execution(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1LineageSubgraph = 0;
api.GoogleCloudAiplatformV1LineageSubgraph
    buildGoogleCloudAiplatformV1LineageSubgraph() {
  final o = api.GoogleCloudAiplatformV1LineageSubgraph();
  buildCounterGoogleCloudAiplatformV1LineageSubgraph++;
  if (buildCounterGoogleCloudAiplatformV1LineageSubgraph < 3) {
    o.artifacts = buildUnnamed139();
    o.events = buildUnnamed140();
    o.executions = buildUnnamed141();
  }
  buildCounterGoogleCloudAiplatformV1LineageSubgraph--;
  return o;
}

void checkGoogleCloudAiplatformV1LineageSubgraph(
    api.GoogleCloudAiplatformV1LineageSubgraph o) {
  buildCounterGoogleCloudAiplatformV1LineageSubgraph++;
  if (buildCounterGoogleCloudAiplatformV1LineageSubgraph < 3) {
    checkUnnamed139(o.artifacts!);
    checkUnnamed140(o.events!);
    checkUnnamed141(o.executions!);
  }
  buildCounterGoogleCloudAiplatformV1LineageSubgraph--;
}

core.List<api.GoogleCloudAiplatformV1Annotation> buildUnnamed142() => [
      buildGoogleCloudAiplatformV1Annotation(),
      buildGoogleCloudAiplatformV1Annotation(),
    ];

void checkUnnamed142(core.List<api.GoogleCloudAiplatformV1Annotation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Annotation(o[0]);
  checkGoogleCloudAiplatformV1Annotation(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListAnnotationsResponse = 0;
api.GoogleCloudAiplatformV1ListAnnotationsResponse
    buildGoogleCloudAiplatformV1ListAnnotationsResponse() {
  final o = api.GoogleCloudAiplatformV1ListAnnotationsResponse();
  buildCounterGoogleCloudAiplatformV1ListAnnotationsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListAnnotationsResponse < 3) {
    o.annotations = buildUnnamed142();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListAnnotationsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListAnnotationsResponse(
    api.GoogleCloudAiplatformV1ListAnnotationsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListAnnotationsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListAnnotationsResponse < 3) {
    checkUnnamed142(o.annotations!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListAnnotationsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Artifact> buildUnnamed143() => [
      buildGoogleCloudAiplatformV1Artifact(),
      buildGoogleCloudAiplatformV1Artifact(),
    ];

void checkUnnamed143(core.List<api.GoogleCloudAiplatformV1Artifact> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Artifact(o[0]);
  checkGoogleCloudAiplatformV1Artifact(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListArtifactsResponse = 0;
api.GoogleCloudAiplatformV1ListArtifactsResponse
    buildGoogleCloudAiplatformV1ListArtifactsResponse() {
  final o = api.GoogleCloudAiplatformV1ListArtifactsResponse();
  buildCounterGoogleCloudAiplatformV1ListArtifactsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListArtifactsResponse < 3) {
    o.artifacts = buildUnnamed143();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListArtifactsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListArtifactsResponse(
    api.GoogleCloudAiplatformV1ListArtifactsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListArtifactsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListArtifactsResponse < 3) {
    checkUnnamed143(o.artifacts!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListArtifactsResponse--;
}

core.List<api.GoogleCloudAiplatformV1BatchPredictionJob> buildUnnamed144() => [
      buildGoogleCloudAiplatformV1BatchPredictionJob(),
      buildGoogleCloudAiplatformV1BatchPredictionJob(),
    ];

void checkUnnamed144(
    core.List<api.GoogleCloudAiplatformV1BatchPredictionJob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1BatchPredictionJob(o[0]);
  checkGoogleCloudAiplatformV1BatchPredictionJob(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListBatchPredictionJobsResponse = 0;
api.GoogleCloudAiplatformV1ListBatchPredictionJobsResponse
    buildGoogleCloudAiplatformV1ListBatchPredictionJobsResponse() {
  final o = api.GoogleCloudAiplatformV1ListBatchPredictionJobsResponse();
  buildCounterGoogleCloudAiplatformV1ListBatchPredictionJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListBatchPredictionJobsResponse < 3) {
    o.batchPredictionJobs = buildUnnamed144();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListBatchPredictionJobsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListBatchPredictionJobsResponse(
    api.GoogleCloudAiplatformV1ListBatchPredictionJobsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListBatchPredictionJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListBatchPredictionJobsResponse < 3) {
    checkUnnamed144(o.batchPredictionJobs!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListBatchPredictionJobsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Context> buildUnnamed145() => [
      buildGoogleCloudAiplatformV1Context(),
      buildGoogleCloudAiplatformV1Context(),
    ];

void checkUnnamed145(core.List<api.GoogleCloudAiplatformV1Context> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Context(o[0]);
  checkGoogleCloudAiplatformV1Context(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListContextsResponse = 0;
api.GoogleCloudAiplatformV1ListContextsResponse
    buildGoogleCloudAiplatformV1ListContextsResponse() {
  final o = api.GoogleCloudAiplatformV1ListContextsResponse();
  buildCounterGoogleCloudAiplatformV1ListContextsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListContextsResponse < 3) {
    o.contexts = buildUnnamed145();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListContextsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListContextsResponse(
    api.GoogleCloudAiplatformV1ListContextsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListContextsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListContextsResponse < 3) {
    checkUnnamed145(o.contexts!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListContextsResponse--;
}

core.List<api.GoogleCloudAiplatformV1CustomJob> buildUnnamed146() => [
      buildGoogleCloudAiplatformV1CustomJob(),
      buildGoogleCloudAiplatformV1CustomJob(),
    ];

void checkUnnamed146(core.List<api.GoogleCloudAiplatformV1CustomJob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1CustomJob(o[0]);
  checkGoogleCloudAiplatformV1CustomJob(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListCustomJobsResponse = 0;
api.GoogleCloudAiplatformV1ListCustomJobsResponse
    buildGoogleCloudAiplatformV1ListCustomJobsResponse() {
  final o = api.GoogleCloudAiplatformV1ListCustomJobsResponse();
  buildCounterGoogleCloudAiplatformV1ListCustomJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListCustomJobsResponse < 3) {
    o.customJobs = buildUnnamed146();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListCustomJobsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListCustomJobsResponse(
    api.GoogleCloudAiplatformV1ListCustomJobsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListCustomJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListCustomJobsResponse < 3) {
    checkUnnamed146(o.customJobs!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListCustomJobsResponse--;
}

core.List<api.GoogleCloudAiplatformV1DataItem> buildUnnamed147() => [
      buildGoogleCloudAiplatformV1DataItem(),
      buildGoogleCloudAiplatformV1DataItem(),
    ];

void checkUnnamed147(core.List<api.GoogleCloudAiplatformV1DataItem> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DataItem(o[0]);
  checkGoogleCloudAiplatformV1DataItem(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListDataItemsResponse = 0;
api.GoogleCloudAiplatformV1ListDataItemsResponse
    buildGoogleCloudAiplatformV1ListDataItemsResponse() {
  final o = api.GoogleCloudAiplatformV1ListDataItemsResponse();
  buildCounterGoogleCloudAiplatformV1ListDataItemsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDataItemsResponse < 3) {
    o.dataItems = buildUnnamed147();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListDataItemsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListDataItemsResponse(
    api.GoogleCloudAiplatformV1ListDataItemsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListDataItemsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDataItemsResponse < 3) {
    checkUnnamed147(o.dataItems!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListDataItemsResponse--;
}

core.List<api.GoogleCloudAiplatformV1DataLabelingJob> buildUnnamed148() => [
      buildGoogleCloudAiplatformV1DataLabelingJob(),
      buildGoogleCloudAiplatformV1DataLabelingJob(),
    ];

void checkUnnamed148(core.List<api.GoogleCloudAiplatformV1DataLabelingJob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DataLabelingJob(o[0]);
  checkGoogleCloudAiplatformV1DataLabelingJob(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListDataLabelingJobsResponse = 0;
api.GoogleCloudAiplatformV1ListDataLabelingJobsResponse
    buildGoogleCloudAiplatformV1ListDataLabelingJobsResponse() {
  final o = api.GoogleCloudAiplatformV1ListDataLabelingJobsResponse();
  buildCounterGoogleCloudAiplatformV1ListDataLabelingJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDataLabelingJobsResponse < 3) {
    o.dataLabelingJobs = buildUnnamed148();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListDataLabelingJobsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListDataLabelingJobsResponse(
    api.GoogleCloudAiplatformV1ListDataLabelingJobsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListDataLabelingJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDataLabelingJobsResponse < 3) {
    checkUnnamed148(o.dataLabelingJobs!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListDataLabelingJobsResponse--;
}

core.List<api.GoogleCloudAiplatformV1DatasetVersion> buildUnnamed149() => [
      buildGoogleCloudAiplatformV1DatasetVersion(),
      buildGoogleCloudAiplatformV1DatasetVersion(),
    ];

void checkUnnamed149(core.List<api.GoogleCloudAiplatformV1DatasetVersion> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DatasetVersion(o[0]);
  checkGoogleCloudAiplatformV1DatasetVersion(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListDatasetVersionsResponse = 0;
api.GoogleCloudAiplatformV1ListDatasetVersionsResponse
    buildGoogleCloudAiplatformV1ListDatasetVersionsResponse() {
  final o = api.GoogleCloudAiplatformV1ListDatasetVersionsResponse();
  buildCounterGoogleCloudAiplatformV1ListDatasetVersionsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDatasetVersionsResponse < 3) {
    o.datasetVersions = buildUnnamed149();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListDatasetVersionsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListDatasetVersionsResponse(
    api.GoogleCloudAiplatformV1ListDatasetVersionsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListDatasetVersionsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDatasetVersionsResponse < 3) {
    checkUnnamed149(o.datasetVersions!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListDatasetVersionsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Dataset> buildUnnamed150() => [
      buildGoogleCloudAiplatformV1Dataset(),
      buildGoogleCloudAiplatformV1Dataset(),
    ];

void checkUnnamed150(core.List<api.GoogleCloudAiplatformV1Dataset> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Dataset(o[0]);
  checkGoogleCloudAiplatformV1Dataset(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListDatasetsResponse = 0;
api.GoogleCloudAiplatformV1ListDatasetsResponse
    buildGoogleCloudAiplatformV1ListDatasetsResponse() {
  final o = api.GoogleCloudAiplatformV1ListDatasetsResponse();
  buildCounterGoogleCloudAiplatformV1ListDatasetsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDatasetsResponse < 3) {
    o.datasets = buildUnnamed150();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListDatasetsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListDatasetsResponse(
    api.GoogleCloudAiplatformV1ListDatasetsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListDatasetsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDatasetsResponse < 3) {
    checkUnnamed150(o.datasets!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListDatasetsResponse--;
}

core.List<api.GoogleCloudAiplatformV1DeploymentResourcePool>
    buildUnnamed151() => [
          buildGoogleCloudAiplatformV1DeploymentResourcePool(),
          buildGoogleCloudAiplatformV1DeploymentResourcePool(),
        ];

void checkUnnamed151(
    core.List<api.GoogleCloudAiplatformV1DeploymentResourcePool> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DeploymentResourcePool(o[0]);
  checkGoogleCloudAiplatformV1DeploymentResourcePool(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse = 0;
api.GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse
    buildGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse() {
  final o = api.GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse();
  buildCounterGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse <
      3) {
    o.deploymentResourcePools = buildUnnamed151();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse(
    api.GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse <
      3) {
    checkUnnamed151(o.deploymentResourcePools!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Endpoint> buildUnnamed152() => [
      buildGoogleCloudAiplatformV1Endpoint(),
      buildGoogleCloudAiplatformV1Endpoint(),
    ];

void checkUnnamed152(core.List<api.GoogleCloudAiplatformV1Endpoint> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Endpoint(o[0]);
  checkGoogleCloudAiplatformV1Endpoint(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListEndpointsResponse = 0;
api.GoogleCloudAiplatformV1ListEndpointsResponse
    buildGoogleCloudAiplatformV1ListEndpointsResponse() {
  final o = api.GoogleCloudAiplatformV1ListEndpointsResponse();
  buildCounterGoogleCloudAiplatformV1ListEndpointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListEndpointsResponse < 3) {
    o.endpoints = buildUnnamed152();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListEndpointsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListEndpointsResponse(
    api.GoogleCloudAiplatformV1ListEndpointsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListEndpointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListEndpointsResponse < 3) {
    checkUnnamed152(o.endpoints!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListEndpointsResponse--;
}

core.List<api.GoogleCloudAiplatformV1EntityType> buildUnnamed153() => [
      buildGoogleCloudAiplatformV1EntityType(),
      buildGoogleCloudAiplatformV1EntityType(),
    ];

void checkUnnamed153(core.List<api.GoogleCloudAiplatformV1EntityType> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1EntityType(o[0]);
  checkGoogleCloudAiplatformV1EntityType(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListEntityTypesResponse = 0;
api.GoogleCloudAiplatformV1ListEntityTypesResponse
    buildGoogleCloudAiplatformV1ListEntityTypesResponse() {
  final o = api.GoogleCloudAiplatformV1ListEntityTypesResponse();
  buildCounterGoogleCloudAiplatformV1ListEntityTypesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListEntityTypesResponse < 3) {
    o.entityTypes = buildUnnamed153();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListEntityTypesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListEntityTypesResponse(
    api.GoogleCloudAiplatformV1ListEntityTypesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListEntityTypesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListEntityTypesResponse < 3) {
    checkUnnamed153(o.entityTypes!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListEntityTypesResponse--;
}

core.List<api.GoogleCloudAiplatformV1Execution> buildUnnamed154() => [
      buildGoogleCloudAiplatformV1Execution(),
      buildGoogleCloudAiplatformV1Execution(),
    ];

void checkUnnamed154(core.List<api.GoogleCloudAiplatformV1Execution> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Execution(o[0]);
  checkGoogleCloudAiplatformV1Execution(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListExecutionsResponse = 0;
api.GoogleCloudAiplatformV1ListExecutionsResponse
    buildGoogleCloudAiplatformV1ListExecutionsResponse() {
  final o = api.GoogleCloudAiplatformV1ListExecutionsResponse();
  buildCounterGoogleCloudAiplatformV1ListExecutionsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListExecutionsResponse < 3) {
    o.executions = buildUnnamed154();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListExecutionsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListExecutionsResponse(
    api.GoogleCloudAiplatformV1ListExecutionsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListExecutionsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListExecutionsResponse < 3) {
    checkUnnamed154(o.executions!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListExecutionsResponse--;
}

core.List<api.GoogleCloudAiplatformV1FeatureGroup> buildUnnamed155() => [
      buildGoogleCloudAiplatformV1FeatureGroup(),
      buildGoogleCloudAiplatformV1FeatureGroup(),
    ];

void checkUnnamed155(core.List<api.GoogleCloudAiplatformV1FeatureGroup> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureGroup(o[0]);
  checkGoogleCloudAiplatformV1FeatureGroup(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListFeatureGroupsResponse = 0;
api.GoogleCloudAiplatformV1ListFeatureGroupsResponse
    buildGoogleCloudAiplatformV1ListFeatureGroupsResponse() {
  final o = api.GoogleCloudAiplatformV1ListFeatureGroupsResponse();
  buildCounterGoogleCloudAiplatformV1ListFeatureGroupsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeatureGroupsResponse < 3) {
    o.featureGroups = buildUnnamed155();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListFeatureGroupsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListFeatureGroupsResponse(
    api.GoogleCloudAiplatformV1ListFeatureGroupsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListFeatureGroupsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeatureGroupsResponse < 3) {
    checkUnnamed155(o.featureGroups!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListFeatureGroupsResponse--;
}

core.List<api.GoogleCloudAiplatformV1FeatureOnlineStore> buildUnnamed156() => [
      buildGoogleCloudAiplatformV1FeatureOnlineStore(),
      buildGoogleCloudAiplatformV1FeatureOnlineStore(),
    ];

void checkUnnamed156(
    core.List<api.GoogleCloudAiplatformV1FeatureOnlineStore> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureOnlineStore(o[0]);
  checkGoogleCloudAiplatformV1FeatureOnlineStore(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse = 0;
api.GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse
    buildGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse() {
  final o = api.GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse();
  buildCounterGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse < 3) {
    o.featureOnlineStores = buildUnnamed156();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse(
    api.GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse o) {
  buildCounterGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse < 3) {
    checkUnnamed156(o.featureOnlineStores!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse--;
}

core.List<api.GoogleCloudAiplatformV1FeatureViewSync> buildUnnamed157() => [
      buildGoogleCloudAiplatformV1FeatureViewSync(),
      buildGoogleCloudAiplatformV1FeatureViewSync(),
    ];

void checkUnnamed157(core.List<api.GoogleCloudAiplatformV1FeatureViewSync> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureViewSync(o[0]);
  checkGoogleCloudAiplatformV1FeatureViewSync(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListFeatureViewSyncsResponse = 0;
api.GoogleCloudAiplatformV1ListFeatureViewSyncsResponse
    buildGoogleCloudAiplatformV1ListFeatureViewSyncsResponse() {
  final o = api.GoogleCloudAiplatformV1ListFeatureViewSyncsResponse();
  buildCounterGoogleCloudAiplatformV1ListFeatureViewSyncsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeatureViewSyncsResponse < 3) {
    o.featureViewSyncs = buildUnnamed157();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListFeatureViewSyncsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListFeatureViewSyncsResponse(
    api.GoogleCloudAiplatformV1ListFeatureViewSyncsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListFeatureViewSyncsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeatureViewSyncsResponse < 3) {
    checkUnnamed157(o.featureViewSyncs!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListFeatureViewSyncsResponse--;
}

core.List<api.GoogleCloudAiplatformV1FeatureView> buildUnnamed158() => [
      buildGoogleCloudAiplatformV1FeatureView(),
      buildGoogleCloudAiplatformV1FeatureView(),
    ];

void checkUnnamed158(core.List<api.GoogleCloudAiplatformV1FeatureView> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureView(o[0]);
  checkGoogleCloudAiplatformV1FeatureView(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListFeatureViewsResponse = 0;
api.GoogleCloudAiplatformV1ListFeatureViewsResponse
    buildGoogleCloudAiplatformV1ListFeatureViewsResponse() {
  final o = api.GoogleCloudAiplatformV1ListFeatureViewsResponse();
  buildCounterGoogleCloudAiplatformV1ListFeatureViewsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeatureViewsResponse < 3) {
    o.featureViews = buildUnnamed158();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListFeatureViewsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListFeatureViewsResponse(
    api.GoogleCloudAiplatformV1ListFeatureViewsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListFeatureViewsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeatureViewsResponse < 3) {
    checkUnnamed158(o.featureViews!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListFeatureViewsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Feature> buildUnnamed159() => [
      buildGoogleCloudAiplatformV1Feature(),
      buildGoogleCloudAiplatformV1Feature(),
    ];

void checkUnnamed159(core.List<api.GoogleCloudAiplatformV1Feature> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Feature(o[0]);
  checkGoogleCloudAiplatformV1Feature(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListFeaturesResponse = 0;
api.GoogleCloudAiplatformV1ListFeaturesResponse
    buildGoogleCloudAiplatformV1ListFeaturesResponse() {
  final o = api.GoogleCloudAiplatformV1ListFeaturesResponse();
  buildCounterGoogleCloudAiplatformV1ListFeaturesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeaturesResponse < 3) {
    o.features = buildUnnamed159();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListFeaturesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListFeaturesResponse(
    api.GoogleCloudAiplatformV1ListFeaturesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListFeaturesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeaturesResponse < 3) {
    checkUnnamed159(o.features!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListFeaturesResponse--;
}

core.List<api.GoogleCloudAiplatformV1Featurestore> buildUnnamed160() => [
      buildGoogleCloudAiplatformV1Featurestore(),
      buildGoogleCloudAiplatformV1Featurestore(),
    ];

void checkUnnamed160(core.List<api.GoogleCloudAiplatformV1Featurestore> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Featurestore(o[0]);
  checkGoogleCloudAiplatformV1Featurestore(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListFeaturestoresResponse = 0;
api.GoogleCloudAiplatformV1ListFeaturestoresResponse
    buildGoogleCloudAiplatformV1ListFeaturestoresResponse() {
  final o = api.GoogleCloudAiplatformV1ListFeaturestoresResponse();
  buildCounterGoogleCloudAiplatformV1ListFeaturestoresResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeaturestoresResponse < 3) {
    o.featurestores = buildUnnamed160();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListFeaturestoresResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListFeaturestoresResponse(
    api.GoogleCloudAiplatformV1ListFeaturestoresResponse o) {
  buildCounterGoogleCloudAiplatformV1ListFeaturestoresResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListFeaturestoresResponse < 3) {
    checkUnnamed160(o.featurestores!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListFeaturestoresResponse--;
}

core.List<api.GoogleCloudAiplatformV1HyperparameterTuningJob>
    buildUnnamed161() => [
          buildGoogleCloudAiplatformV1HyperparameterTuningJob(),
          buildGoogleCloudAiplatformV1HyperparameterTuningJob(),
        ];

void checkUnnamed161(
    core.List<api.GoogleCloudAiplatformV1HyperparameterTuningJob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1HyperparameterTuningJob(o[0]);
  checkGoogleCloudAiplatformV1HyperparameterTuningJob(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse = 0;
api.GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse
    buildGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse() {
  final o = api.GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse();
  buildCounterGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse <
      3) {
    o.hyperparameterTuningJobs = buildUnnamed161();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse(
    api.GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse <
      3) {
    checkUnnamed161(o.hyperparameterTuningJobs!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse--;
}

core.List<api.GoogleCloudAiplatformV1IndexEndpoint> buildUnnamed162() => [
      buildGoogleCloudAiplatformV1IndexEndpoint(),
      buildGoogleCloudAiplatformV1IndexEndpoint(),
    ];

void checkUnnamed162(core.List<api.GoogleCloudAiplatformV1IndexEndpoint> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1IndexEndpoint(o[0]);
  checkGoogleCloudAiplatformV1IndexEndpoint(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListIndexEndpointsResponse = 0;
api.GoogleCloudAiplatformV1ListIndexEndpointsResponse
    buildGoogleCloudAiplatformV1ListIndexEndpointsResponse() {
  final o = api.GoogleCloudAiplatformV1ListIndexEndpointsResponse();
  buildCounterGoogleCloudAiplatformV1ListIndexEndpointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListIndexEndpointsResponse < 3) {
    o.indexEndpoints = buildUnnamed162();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListIndexEndpointsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListIndexEndpointsResponse(
    api.GoogleCloudAiplatformV1ListIndexEndpointsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListIndexEndpointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListIndexEndpointsResponse < 3) {
    checkUnnamed162(o.indexEndpoints!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListIndexEndpointsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Index> buildUnnamed163() => [
      buildGoogleCloudAiplatformV1Index(),
      buildGoogleCloudAiplatformV1Index(),
    ];

void checkUnnamed163(core.List<api.GoogleCloudAiplatformV1Index> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Index(o[0]);
  checkGoogleCloudAiplatformV1Index(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListIndexesResponse = 0;
api.GoogleCloudAiplatformV1ListIndexesResponse
    buildGoogleCloudAiplatformV1ListIndexesResponse() {
  final o = api.GoogleCloudAiplatformV1ListIndexesResponse();
  buildCounterGoogleCloudAiplatformV1ListIndexesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListIndexesResponse < 3) {
    o.indexes = buildUnnamed163();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListIndexesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListIndexesResponse(
    api.GoogleCloudAiplatformV1ListIndexesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListIndexesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListIndexesResponse < 3) {
    checkUnnamed163(o.indexes!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListIndexesResponse--;
}

core.List<api.GoogleCloudAiplatformV1MetadataSchema> buildUnnamed164() => [
      buildGoogleCloudAiplatformV1MetadataSchema(),
      buildGoogleCloudAiplatformV1MetadataSchema(),
    ];

void checkUnnamed164(core.List<api.GoogleCloudAiplatformV1MetadataSchema> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1MetadataSchema(o[0]);
  checkGoogleCloudAiplatformV1MetadataSchema(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListMetadataSchemasResponse = 0;
api.GoogleCloudAiplatformV1ListMetadataSchemasResponse
    buildGoogleCloudAiplatformV1ListMetadataSchemasResponse() {
  final o = api.GoogleCloudAiplatformV1ListMetadataSchemasResponse();
  buildCounterGoogleCloudAiplatformV1ListMetadataSchemasResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListMetadataSchemasResponse < 3) {
    o.metadataSchemas = buildUnnamed164();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListMetadataSchemasResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListMetadataSchemasResponse(
    api.GoogleCloudAiplatformV1ListMetadataSchemasResponse o) {
  buildCounterGoogleCloudAiplatformV1ListMetadataSchemasResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListMetadataSchemasResponse < 3) {
    checkUnnamed164(o.metadataSchemas!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListMetadataSchemasResponse--;
}

core.List<api.GoogleCloudAiplatformV1MetadataStore> buildUnnamed165() => [
      buildGoogleCloudAiplatformV1MetadataStore(),
      buildGoogleCloudAiplatformV1MetadataStore(),
    ];

void checkUnnamed165(core.List<api.GoogleCloudAiplatformV1MetadataStore> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1MetadataStore(o[0]);
  checkGoogleCloudAiplatformV1MetadataStore(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListMetadataStoresResponse = 0;
api.GoogleCloudAiplatformV1ListMetadataStoresResponse
    buildGoogleCloudAiplatformV1ListMetadataStoresResponse() {
  final o = api.GoogleCloudAiplatformV1ListMetadataStoresResponse();
  buildCounterGoogleCloudAiplatformV1ListMetadataStoresResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListMetadataStoresResponse < 3) {
    o.metadataStores = buildUnnamed165();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListMetadataStoresResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListMetadataStoresResponse(
    api.GoogleCloudAiplatformV1ListMetadataStoresResponse o) {
  buildCounterGoogleCloudAiplatformV1ListMetadataStoresResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListMetadataStoresResponse < 3) {
    checkUnnamed165(o.metadataStores!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListMetadataStoresResponse--;
}

core.List<api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob>
    buildUnnamed166() => [
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(),
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(),
        ];

void checkUnnamed166(
    core.List<api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(o[0]);
  checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse =
    0;
api.GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse
    buildGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse() {
  final o =
      api.GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse();
  buildCounterGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse <
      3) {
    o.modelDeploymentMonitoringJobs = buildUnnamed166();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse(
    api.GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse <
      3) {
    checkUnnamed166(o.modelDeploymentMonitoringJobs!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse--;
}

core.List<api.GoogleCloudAiplatformV1ModelEvaluationSlice> buildUnnamed167() =>
    [
      buildGoogleCloudAiplatformV1ModelEvaluationSlice(),
      buildGoogleCloudAiplatformV1ModelEvaluationSlice(),
    ];

void checkUnnamed167(
    core.List<api.GoogleCloudAiplatformV1ModelEvaluationSlice> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelEvaluationSlice(o[0]);
  checkGoogleCloudAiplatformV1ModelEvaluationSlice(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse =
    0;
api.GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse
    buildGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse() {
  final o = api.GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse();
  buildCounterGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse <
      3) {
    o.modelEvaluationSlices = buildUnnamed167();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse(
    api.GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse <
      3) {
    checkUnnamed167(o.modelEvaluationSlices!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse--;
}

core.List<api.GoogleCloudAiplatformV1ModelEvaluation> buildUnnamed168() => [
      buildGoogleCloudAiplatformV1ModelEvaluation(),
      buildGoogleCloudAiplatformV1ModelEvaluation(),
    ];

void checkUnnamed168(core.List<api.GoogleCloudAiplatformV1ModelEvaluation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelEvaluation(o[0]);
  checkGoogleCloudAiplatformV1ModelEvaluation(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListModelEvaluationsResponse = 0;
api.GoogleCloudAiplatformV1ListModelEvaluationsResponse
    buildGoogleCloudAiplatformV1ListModelEvaluationsResponse() {
  final o = api.GoogleCloudAiplatformV1ListModelEvaluationsResponse();
  buildCounterGoogleCloudAiplatformV1ListModelEvaluationsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelEvaluationsResponse < 3) {
    o.modelEvaluations = buildUnnamed168();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListModelEvaluationsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListModelEvaluationsResponse(
    api.GoogleCloudAiplatformV1ListModelEvaluationsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListModelEvaluationsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelEvaluationsResponse < 3) {
    checkUnnamed168(o.modelEvaluations!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListModelEvaluationsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Model> buildUnnamed169() => [
      buildGoogleCloudAiplatformV1Model(),
      buildGoogleCloudAiplatformV1Model(),
    ];

void checkUnnamed169(core.List<api.GoogleCloudAiplatformV1Model> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Model(o[0]);
  checkGoogleCloudAiplatformV1Model(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListModelVersionsResponse = 0;
api.GoogleCloudAiplatformV1ListModelVersionsResponse
    buildGoogleCloudAiplatformV1ListModelVersionsResponse() {
  final o = api.GoogleCloudAiplatformV1ListModelVersionsResponse();
  buildCounterGoogleCloudAiplatformV1ListModelVersionsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelVersionsResponse < 3) {
    o.models = buildUnnamed169();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListModelVersionsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListModelVersionsResponse(
    api.GoogleCloudAiplatformV1ListModelVersionsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListModelVersionsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelVersionsResponse < 3) {
    checkUnnamed169(o.models!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListModelVersionsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Model> buildUnnamed170() => [
      buildGoogleCloudAiplatformV1Model(),
      buildGoogleCloudAiplatformV1Model(),
    ];

void checkUnnamed170(core.List<api.GoogleCloudAiplatformV1Model> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Model(o[0]);
  checkGoogleCloudAiplatformV1Model(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListModelsResponse = 0;
api.GoogleCloudAiplatformV1ListModelsResponse
    buildGoogleCloudAiplatformV1ListModelsResponse() {
  final o = api.GoogleCloudAiplatformV1ListModelsResponse();
  buildCounterGoogleCloudAiplatformV1ListModelsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelsResponse < 3) {
    o.models = buildUnnamed170();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListModelsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListModelsResponse(
    api.GoogleCloudAiplatformV1ListModelsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListModelsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListModelsResponse < 3) {
    checkUnnamed170(o.models!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListModelsResponse--;
}

core.List<api.GoogleCloudAiplatformV1NasJob> buildUnnamed171() => [
      buildGoogleCloudAiplatformV1NasJob(),
      buildGoogleCloudAiplatformV1NasJob(),
    ];

void checkUnnamed171(core.List<api.GoogleCloudAiplatformV1NasJob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NasJob(o[0]);
  checkGoogleCloudAiplatformV1NasJob(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListNasJobsResponse = 0;
api.GoogleCloudAiplatformV1ListNasJobsResponse
    buildGoogleCloudAiplatformV1ListNasJobsResponse() {
  final o = api.GoogleCloudAiplatformV1ListNasJobsResponse();
  buildCounterGoogleCloudAiplatformV1ListNasJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListNasJobsResponse < 3) {
    o.nasJobs = buildUnnamed171();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListNasJobsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListNasJobsResponse(
    api.GoogleCloudAiplatformV1ListNasJobsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListNasJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListNasJobsResponse < 3) {
    checkUnnamed171(o.nasJobs!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListNasJobsResponse--;
}

core.List<api.GoogleCloudAiplatformV1NasTrialDetail> buildUnnamed172() => [
      buildGoogleCloudAiplatformV1NasTrialDetail(),
      buildGoogleCloudAiplatformV1NasTrialDetail(),
    ];

void checkUnnamed172(core.List<api.GoogleCloudAiplatformV1NasTrialDetail> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NasTrialDetail(o[0]);
  checkGoogleCloudAiplatformV1NasTrialDetail(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListNasTrialDetailsResponse = 0;
api.GoogleCloudAiplatformV1ListNasTrialDetailsResponse
    buildGoogleCloudAiplatformV1ListNasTrialDetailsResponse() {
  final o = api.GoogleCloudAiplatformV1ListNasTrialDetailsResponse();
  buildCounterGoogleCloudAiplatformV1ListNasTrialDetailsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListNasTrialDetailsResponse < 3) {
    o.nasTrialDetails = buildUnnamed172();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ListNasTrialDetailsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListNasTrialDetailsResponse(
    api.GoogleCloudAiplatformV1ListNasTrialDetailsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListNasTrialDetailsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListNasTrialDetailsResponse < 3) {
    checkUnnamed172(o.nasTrialDetails!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ListNasTrialDetailsResponse--;
}

core.List<api.GoogleCloudAiplatformV1NotebookRuntimeTemplate>
    buildUnnamed173() => [
          buildGoogleCloudAiplatformV1NotebookRuntimeTemplate(),
          buildGoogleCloudAiplatformV1NotebookRuntimeTemplate(),
        ];

void checkUnnamed173(
    core.List<api.GoogleCloudAiplatformV1NotebookRuntimeTemplate> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NotebookRuntimeTemplate(o[0]);
  checkGoogleCloudAiplatformV1NotebookRuntimeTemplate(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse = 0;
api.GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse
    buildGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse() {
  final o = api.GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse();
  buildCounterGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse <
      3) {
    o.nextPageToken = 'foo';
    o.notebookRuntimeTemplates = buildUnnamed173();
  }
  buildCounterGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse(
    api.GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse <
      3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed173(o.notebookRuntimeTemplates!);
  }
  buildCounterGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse--;
}

core.List<api.GoogleCloudAiplatformV1NotebookRuntime> buildUnnamed174() => [
      buildGoogleCloudAiplatformV1NotebookRuntime(),
      buildGoogleCloudAiplatformV1NotebookRuntime(),
    ];

void checkUnnamed174(core.List<api.GoogleCloudAiplatformV1NotebookRuntime> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NotebookRuntime(o[0]);
  checkGoogleCloudAiplatformV1NotebookRuntime(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListNotebookRuntimesResponse = 0;
api.GoogleCloudAiplatformV1ListNotebookRuntimesResponse
    buildGoogleCloudAiplatformV1ListNotebookRuntimesResponse() {
  final o = api.GoogleCloudAiplatformV1ListNotebookRuntimesResponse();
  buildCounterGoogleCloudAiplatformV1ListNotebookRuntimesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListNotebookRuntimesResponse < 3) {
    o.nextPageToken = 'foo';
    o.notebookRuntimes = buildUnnamed174();
  }
  buildCounterGoogleCloudAiplatformV1ListNotebookRuntimesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListNotebookRuntimesResponse(
    api.GoogleCloudAiplatformV1ListNotebookRuntimesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListNotebookRuntimesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListNotebookRuntimesResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed174(o.notebookRuntimes!);
  }
  buildCounterGoogleCloudAiplatformV1ListNotebookRuntimesResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1ListOptimalTrialsRequest = 0;
api.GoogleCloudAiplatformV1ListOptimalTrialsRequest
    buildGoogleCloudAiplatformV1ListOptimalTrialsRequest() {
  final o = api.GoogleCloudAiplatformV1ListOptimalTrialsRequest();
  buildCounterGoogleCloudAiplatformV1ListOptimalTrialsRequest++;
  if (buildCounterGoogleCloudAiplatformV1ListOptimalTrialsRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1ListOptimalTrialsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ListOptimalTrialsRequest(
    api.GoogleCloudAiplatformV1ListOptimalTrialsRequest o) {
  buildCounterGoogleCloudAiplatformV1ListOptimalTrialsRequest++;
  if (buildCounterGoogleCloudAiplatformV1ListOptimalTrialsRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1ListOptimalTrialsRequest--;
}

core.List<api.GoogleCloudAiplatformV1Trial> buildUnnamed175() => [
      buildGoogleCloudAiplatformV1Trial(),
      buildGoogleCloudAiplatformV1Trial(),
    ];

void checkUnnamed175(core.List<api.GoogleCloudAiplatformV1Trial> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Trial(o[0]);
  checkGoogleCloudAiplatformV1Trial(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListOptimalTrialsResponse = 0;
api.GoogleCloudAiplatformV1ListOptimalTrialsResponse
    buildGoogleCloudAiplatformV1ListOptimalTrialsResponse() {
  final o = api.GoogleCloudAiplatformV1ListOptimalTrialsResponse();
  buildCounterGoogleCloudAiplatformV1ListOptimalTrialsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListOptimalTrialsResponse < 3) {
    o.optimalTrials = buildUnnamed175();
  }
  buildCounterGoogleCloudAiplatformV1ListOptimalTrialsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListOptimalTrialsResponse(
    api.GoogleCloudAiplatformV1ListOptimalTrialsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListOptimalTrialsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListOptimalTrialsResponse < 3) {
    checkUnnamed175(o.optimalTrials!);
  }
  buildCounterGoogleCloudAiplatformV1ListOptimalTrialsResponse--;
}

core.List<api.GoogleCloudAiplatformV1PipelineJob> buildUnnamed176() => [
      buildGoogleCloudAiplatformV1PipelineJob(),
      buildGoogleCloudAiplatformV1PipelineJob(),
    ];

void checkUnnamed176(core.List<api.GoogleCloudAiplatformV1PipelineJob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PipelineJob(o[0]);
  checkGoogleCloudAiplatformV1PipelineJob(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListPipelineJobsResponse = 0;
api.GoogleCloudAiplatformV1ListPipelineJobsResponse
    buildGoogleCloudAiplatformV1ListPipelineJobsResponse() {
  final o = api.GoogleCloudAiplatformV1ListPipelineJobsResponse();
  buildCounterGoogleCloudAiplatformV1ListPipelineJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListPipelineJobsResponse < 3) {
    o.nextPageToken = 'foo';
    o.pipelineJobs = buildUnnamed176();
  }
  buildCounterGoogleCloudAiplatformV1ListPipelineJobsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListPipelineJobsResponse(
    api.GoogleCloudAiplatformV1ListPipelineJobsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListPipelineJobsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListPipelineJobsResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed176(o.pipelineJobs!);
  }
  buildCounterGoogleCloudAiplatformV1ListPipelineJobsResponse--;
}

core.List<api.GoogleCloudAiplatformV1SavedQuery> buildUnnamed177() => [
      buildGoogleCloudAiplatformV1SavedQuery(),
      buildGoogleCloudAiplatformV1SavedQuery(),
    ];

void checkUnnamed177(core.List<api.GoogleCloudAiplatformV1SavedQuery> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1SavedQuery(o[0]);
  checkGoogleCloudAiplatformV1SavedQuery(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListSavedQueriesResponse = 0;
api.GoogleCloudAiplatformV1ListSavedQueriesResponse
    buildGoogleCloudAiplatformV1ListSavedQueriesResponse() {
  final o = api.GoogleCloudAiplatformV1ListSavedQueriesResponse();
  buildCounterGoogleCloudAiplatformV1ListSavedQueriesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListSavedQueriesResponse < 3) {
    o.nextPageToken = 'foo';
    o.savedQueries = buildUnnamed177();
  }
  buildCounterGoogleCloudAiplatformV1ListSavedQueriesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListSavedQueriesResponse(
    api.GoogleCloudAiplatformV1ListSavedQueriesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListSavedQueriesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListSavedQueriesResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed177(o.savedQueries!);
  }
  buildCounterGoogleCloudAiplatformV1ListSavedQueriesResponse--;
}

core.List<api.GoogleCloudAiplatformV1Schedule> buildUnnamed178() => [
      buildGoogleCloudAiplatformV1Schedule(),
      buildGoogleCloudAiplatformV1Schedule(),
    ];

void checkUnnamed178(core.List<api.GoogleCloudAiplatformV1Schedule> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Schedule(o[0]);
  checkGoogleCloudAiplatformV1Schedule(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListSchedulesResponse = 0;
api.GoogleCloudAiplatformV1ListSchedulesResponse
    buildGoogleCloudAiplatformV1ListSchedulesResponse() {
  final o = api.GoogleCloudAiplatformV1ListSchedulesResponse();
  buildCounterGoogleCloudAiplatformV1ListSchedulesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListSchedulesResponse < 3) {
    o.nextPageToken = 'foo';
    o.schedules = buildUnnamed178();
  }
  buildCounterGoogleCloudAiplatformV1ListSchedulesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListSchedulesResponse(
    api.GoogleCloudAiplatformV1ListSchedulesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListSchedulesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListSchedulesResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed178(o.schedules!);
  }
  buildCounterGoogleCloudAiplatformV1ListSchedulesResponse--;
}

core.List<api.GoogleCloudAiplatformV1SpecialistPool> buildUnnamed179() => [
      buildGoogleCloudAiplatformV1SpecialistPool(),
      buildGoogleCloudAiplatformV1SpecialistPool(),
    ];

void checkUnnamed179(core.List<api.GoogleCloudAiplatformV1SpecialistPool> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1SpecialistPool(o[0]);
  checkGoogleCloudAiplatformV1SpecialistPool(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListSpecialistPoolsResponse = 0;
api.GoogleCloudAiplatformV1ListSpecialistPoolsResponse
    buildGoogleCloudAiplatformV1ListSpecialistPoolsResponse() {
  final o = api.GoogleCloudAiplatformV1ListSpecialistPoolsResponse();
  buildCounterGoogleCloudAiplatformV1ListSpecialistPoolsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListSpecialistPoolsResponse < 3) {
    o.nextPageToken = 'foo';
    o.specialistPools = buildUnnamed179();
  }
  buildCounterGoogleCloudAiplatformV1ListSpecialistPoolsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListSpecialistPoolsResponse(
    api.GoogleCloudAiplatformV1ListSpecialistPoolsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListSpecialistPoolsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListSpecialistPoolsResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed179(o.specialistPools!);
  }
  buildCounterGoogleCloudAiplatformV1ListSpecialistPoolsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Study> buildUnnamed180() => [
      buildGoogleCloudAiplatformV1Study(),
      buildGoogleCloudAiplatformV1Study(),
    ];

void checkUnnamed180(core.List<api.GoogleCloudAiplatformV1Study> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Study(o[0]);
  checkGoogleCloudAiplatformV1Study(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListStudiesResponse = 0;
api.GoogleCloudAiplatformV1ListStudiesResponse
    buildGoogleCloudAiplatformV1ListStudiesResponse() {
  final o = api.GoogleCloudAiplatformV1ListStudiesResponse();
  buildCounterGoogleCloudAiplatformV1ListStudiesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListStudiesResponse < 3) {
    o.nextPageToken = 'foo';
    o.studies = buildUnnamed180();
  }
  buildCounterGoogleCloudAiplatformV1ListStudiesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListStudiesResponse(
    api.GoogleCloudAiplatformV1ListStudiesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListStudiesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListStudiesResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed180(o.studies!);
  }
  buildCounterGoogleCloudAiplatformV1ListStudiesResponse--;
}

core.List<api.GoogleCloudAiplatformV1TensorboardExperiment> buildUnnamed181() =>
    [
      buildGoogleCloudAiplatformV1TensorboardExperiment(),
      buildGoogleCloudAiplatformV1TensorboardExperiment(),
    ];

void checkUnnamed181(
    core.List<api.GoogleCloudAiplatformV1TensorboardExperiment> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TensorboardExperiment(o[0]);
  checkGoogleCloudAiplatformV1TensorboardExperiment(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListTensorboardExperimentsResponse =
    0;
api.GoogleCloudAiplatformV1ListTensorboardExperimentsResponse
    buildGoogleCloudAiplatformV1ListTensorboardExperimentsResponse() {
  final o = api.GoogleCloudAiplatformV1ListTensorboardExperimentsResponse();
  buildCounterGoogleCloudAiplatformV1ListTensorboardExperimentsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTensorboardExperimentsResponse <
      3) {
    o.nextPageToken = 'foo';
    o.tensorboardExperiments = buildUnnamed181();
  }
  buildCounterGoogleCloudAiplatformV1ListTensorboardExperimentsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListTensorboardExperimentsResponse(
    api.GoogleCloudAiplatformV1ListTensorboardExperimentsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListTensorboardExperimentsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTensorboardExperimentsResponse <
      3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed181(o.tensorboardExperiments!);
  }
  buildCounterGoogleCloudAiplatformV1ListTensorboardExperimentsResponse--;
}

core.List<api.GoogleCloudAiplatformV1TensorboardRun> buildUnnamed182() => [
      buildGoogleCloudAiplatformV1TensorboardRun(),
      buildGoogleCloudAiplatformV1TensorboardRun(),
    ];

void checkUnnamed182(core.List<api.GoogleCloudAiplatformV1TensorboardRun> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TensorboardRun(o[0]);
  checkGoogleCloudAiplatformV1TensorboardRun(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListTensorboardRunsResponse = 0;
api.GoogleCloudAiplatformV1ListTensorboardRunsResponse
    buildGoogleCloudAiplatformV1ListTensorboardRunsResponse() {
  final o = api.GoogleCloudAiplatformV1ListTensorboardRunsResponse();
  buildCounterGoogleCloudAiplatformV1ListTensorboardRunsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTensorboardRunsResponse < 3) {
    o.nextPageToken = 'foo';
    o.tensorboardRuns = buildUnnamed182();
  }
  buildCounterGoogleCloudAiplatformV1ListTensorboardRunsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListTensorboardRunsResponse(
    api.GoogleCloudAiplatformV1ListTensorboardRunsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListTensorboardRunsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTensorboardRunsResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed182(o.tensorboardRuns!);
  }
  buildCounterGoogleCloudAiplatformV1ListTensorboardRunsResponse--;
}

core.List<api.GoogleCloudAiplatformV1TensorboardTimeSeries> buildUnnamed183() =>
    [
      buildGoogleCloudAiplatformV1TensorboardTimeSeries(),
      buildGoogleCloudAiplatformV1TensorboardTimeSeries(),
    ];

void checkUnnamed183(
    core.List<api.GoogleCloudAiplatformV1TensorboardTimeSeries> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TensorboardTimeSeries(o[0]);
  checkGoogleCloudAiplatformV1TensorboardTimeSeries(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse =
    0;
api.GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse
    buildGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse() {
  final o = api.GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse();
  buildCounterGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse <
      3) {
    o.nextPageToken = 'foo';
    o.tensorboardTimeSeries = buildUnnamed183();
  }
  buildCounterGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse(
    api.GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse <
      3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed183(o.tensorboardTimeSeries!);
  }
  buildCounterGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse--;
}

core.List<api.GoogleCloudAiplatformV1Tensorboard> buildUnnamed184() => [
      buildGoogleCloudAiplatformV1Tensorboard(),
      buildGoogleCloudAiplatformV1Tensorboard(),
    ];

void checkUnnamed184(core.List<api.GoogleCloudAiplatformV1Tensorboard> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Tensorboard(o[0]);
  checkGoogleCloudAiplatformV1Tensorboard(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListTensorboardsResponse = 0;
api.GoogleCloudAiplatformV1ListTensorboardsResponse
    buildGoogleCloudAiplatformV1ListTensorboardsResponse() {
  final o = api.GoogleCloudAiplatformV1ListTensorboardsResponse();
  buildCounterGoogleCloudAiplatformV1ListTensorboardsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTensorboardsResponse < 3) {
    o.nextPageToken = 'foo';
    o.tensorboards = buildUnnamed184();
  }
  buildCounterGoogleCloudAiplatformV1ListTensorboardsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListTensorboardsResponse(
    api.GoogleCloudAiplatformV1ListTensorboardsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListTensorboardsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTensorboardsResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed184(o.tensorboards!);
  }
  buildCounterGoogleCloudAiplatformV1ListTensorboardsResponse--;
}

core.List<api.GoogleCloudAiplatformV1TrainingPipeline> buildUnnamed185() => [
      buildGoogleCloudAiplatformV1TrainingPipeline(),
      buildGoogleCloudAiplatformV1TrainingPipeline(),
    ];

void checkUnnamed185(core.List<api.GoogleCloudAiplatformV1TrainingPipeline> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TrainingPipeline(o[0]);
  checkGoogleCloudAiplatformV1TrainingPipeline(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListTrainingPipelinesResponse = 0;
api.GoogleCloudAiplatformV1ListTrainingPipelinesResponse
    buildGoogleCloudAiplatformV1ListTrainingPipelinesResponse() {
  final o = api.GoogleCloudAiplatformV1ListTrainingPipelinesResponse();
  buildCounterGoogleCloudAiplatformV1ListTrainingPipelinesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTrainingPipelinesResponse < 3) {
    o.nextPageToken = 'foo';
    o.trainingPipelines = buildUnnamed185();
  }
  buildCounterGoogleCloudAiplatformV1ListTrainingPipelinesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListTrainingPipelinesResponse(
    api.GoogleCloudAiplatformV1ListTrainingPipelinesResponse o) {
  buildCounterGoogleCloudAiplatformV1ListTrainingPipelinesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTrainingPipelinesResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed185(o.trainingPipelines!);
  }
  buildCounterGoogleCloudAiplatformV1ListTrainingPipelinesResponse--;
}

core.List<api.GoogleCloudAiplatformV1Trial> buildUnnamed186() => [
      buildGoogleCloudAiplatformV1Trial(),
      buildGoogleCloudAiplatformV1Trial(),
    ];

void checkUnnamed186(core.List<api.GoogleCloudAiplatformV1Trial> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Trial(o[0]);
  checkGoogleCloudAiplatformV1Trial(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ListTrialsResponse = 0;
api.GoogleCloudAiplatformV1ListTrialsResponse
    buildGoogleCloudAiplatformV1ListTrialsResponse() {
  final o = api.GoogleCloudAiplatformV1ListTrialsResponse();
  buildCounterGoogleCloudAiplatformV1ListTrialsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTrialsResponse < 3) {
    o.nextPageToken = 'foo';
    o.trials = buildUnnamed186();
  }
  buildCounterGoogleCloudAiplatformV1ListTrialsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ListTrialsResponse(
    api.GoogleCloudAiplatformV1ListTrialsResponse o) {
  buildCounterGoogleCloudAiplatformV1ListTrialsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ListTrialsResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed186(o.trials!);
  }
  buildCounterGoogleCloudAiplatformV1ListTrialsResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1LookupStudyRequest = 0;
api.GoogleCloudAiplatformV1LookupStudyRequest
    buildGoogleCloudAiplatformV1LookupStudyRequest() {
  final o = api.GoogleCloudAiplatformV1LookupStudyRequest();
  buildCounterGoogleCloudAiplatformV1LookupStudyRequest++;
  if (buildCounterGoogleCloudAiplatformV1LookupStudyRequest < 3) {
    o.displayName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1LookupStudyRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1LookupStudyRequest(
    api.GoogleCloudAiplatformV1LookupStudyRequest o) {
  buildCounterGoogleCloudAiplatformV1LookupStudyRequest++;
  if (buildCounterGoogleCloudAiplatformV1LookupStudyRequest < 3) {
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1LookupStudyRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1MachineSpec = 0;
api.GoogleCloudAiplatformV1MachineSpec
    buildGoogleCloudAiplatformV1MachineSpec() {
  final o = api.GoogleCloudAiplatformV1MachineSpec();
  buildCounterGoogleCloudAiplatformV1MachineSpec++;
  if (buildCounterGoogleCloudAiplatformV1MachineSpec < 3) {
    o.acceleratorCount = 42;
    o.acceleratorType = 'foo';
    o.machineType = 'foo';
    o.tpuTopology = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MachineSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1MachineSpec(
    api.GoogleCloudAiplatformV1MachineSpec o) {
  buildCounterGoogleCloudAiplatformV1MachineSpec++;
  if (buildCounterGoogleCloudAiplatformV1MachineSpec < 3) {
    unittest.expect(
      o.acceleratorCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.acceleratorType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.machineType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.tpuTopology!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MachineSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1ManualBatchTuningParameters = 0;
api.GoogleCloudAiplatformV1ManualBatchTuningParameters
    buildGoogleCloudAiplatformV1ManualBatchTuningParameters() {
  final o = api.GoogleCloudAiplatformV1ManualBatchTuningParameters();
  buildCounterGoogleCloudAiplatformV1ManualBatchTuningParameters++;
  if (buildCounterGoogleCloudAiplatformV1ManualBatchTuningParameters < 3) {
    o.batchSize = 42;
  }
  buildCounterGoogleCloudAiplatformV1ManualBatchTuningParameters--;
  return o;
}

void checkGoogleCloudAiplatformV1ManualBatchTuningParameters(
    api.GoogleCloudAiplatformV1ManualBatchTuningParameters o) {
  buildCounterGoogleCloudAiplatformV1ManualBatchTuningParameters++;
  if (buildCounterGoogleCloudAiplatformV1ManualBatchTuningParameters < 3) {
    unittest.expect(
      o.batchSize!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1ManualBatchTuningParameters--;
}

core.List<api.GoogleCloudAiplatformV1MeasurementMetric> buildUnnamed187() => [
      buildGoogleCloudAiplatformV1MeasurementMetric(),
      buildGoogleCloudAiplatformV1MeasurementMetric(),
    ];

void checkUnnamed187(
    core.List<api.GoogleCloudAiplatformV1MeasurementMetric> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1MeasurementMetric(o[0]);
  checkGoogleCloudAiplatformV1MeasurementMetric(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1Measurement = 0;
api.GoogleCloudAiplatformV1Measurement
    buildGoogleCloudAiplatformV1Measurement() {
  final o = api.GoogleCloudAiplatformV1Measurement();
  buildCounterGoogleCloudAiplatformV1Measurement++;
  if (buildCounterGoogleCloudAiplatformV1Measurement < 3) {
    o.elapsedDuration = 'foo';
    o.metrics = buildUnnamed187();
    o.stepCount = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Measurement--;
  return o;
}

void checkGoogleCloudAiplatformV1Measurement(
    api.GoogleCloudAiplatformV1Measurement o) {
  buildCounterGoogleCloudAiplatformV1Measurement++;
  if (buildCounterGoogleCloudAiplatformV1Measurement < 3) {
    unittest.expect(
      o.elapsedDuration!,
      unittest.equals('foo'),
    );
    checkUnnamed187(o.metrics!);
    unittest.expect(
      o.stepCount!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Measurement--;
}

core.int buildCounterGoogleCloudAiplatformV1MeasurementMetric = 0;
api.GoogleCloudAiplatformV1MeasurementMetric
    buildGoogleCloudAiplatformV1MeasurementMetric() {
  final o = api.GoogleCloudAiplatformV1MeasurementMetric();
  buildCounterGoogleCloudAiplatformV1MeasurementMetric++;
  if (buildCounterGoogleCloudAiplatformV1MeasurementMetric < 3) {
    o.metricId = 'foo';
    o.value = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1MeasurementMetric--;
  return o;
}

void checkGoogleCloudAiplatformV1MeasurementMetric(
    api.GoogleCloudAiplatformV1MeasurementMetric o) {
  buildCounterGoogleCloudAiplatformV1MeasurementMetric++;
  if (buildCounterGoogleCloudAiplatformV1MeasurementMetric < 3) {
    unittest.expect(
      o.metricId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.value!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1MeasurementMetric--;
}

core.List<core.String> buildUnnamed188() => [
      'foo',
      'foo',
    ];

void checkUnnamed188(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1MergeVersionAliasesRequest = 0;
api.GoogleCloudAiplatformV1MergeVersionAliasesRequest
    buildGoogleCloudAiplatformV1MergeVersionAliasesRequest() {
  final o = api.GoogleCloudAiplatformV1MergeVersionAliasesRequest();
  buildCounterGoogleCloudAiplatformV1MergeVersionAliasesRequest++;
  if (buildCounterGoogleCloudAiplatformV1MergeVersionAliasesRequest < 3) {
    o.versionAliases = buildUnnamed188();
  }
  buildCounterGoogleCloudAiplatformV1MergeVersionAliasesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1MergeVersionAliasesRequest(
    api.GoogleCloudAiplatformV1MergeVersionAliasesRequest o) {
  buildCounterGoogleCloudAiplatformV1MergeVersionAliasesRequest++;
  if (buildCounterGoogleCloudAiplatformV1MergeVersionAliasesRequest < 3) {
    checkUnnamed188(o.versionAliases!);
  }
  buildCounterGoogleCloudAiplatformV1MergeVersionAliasesRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1MetadataSchema = 0;
api.GoogleCloudAiplatformV1MetadataSchema
    buildGoogleCloudAiplatformV1MetadataSchema() {
  final o = api.GoogleCloudAiplatformV1MetadataSchema();
  buildCounterGoogleCloudAiplatformV1MetadataSchema++;
  if (buildCounterGoogleCloudAiplatformV1MetadataSchema < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.name = 'foo';
    o.schema = 'foo';
    o.schemaType = 'foo';
    o.schemaVersion = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MetadataSchema--;
  return o;
}

void checkGoogleCloudAiplatformV1MetadataSchema(
    api.GoogleCloudAiplatformV1MetadataSchema o) {
  buildCounterGoogleCloudAiplatformV1MetadataSchema++;
  if (buildCounterGoogleCloudAiplatformV1MetadataSchema < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.schema!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.schemaType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.schemaVersion!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MetadataSchema--;
}

core.int buildCounterGoogleCloudAiplatformV1MetadataStore = 0;
api.GoogleCloudAiplatformV1MetadataStore
    buildGoogleCloudAiplatformV1MetadataStore() {
  final o = api.GoogleCloudAiplatformV1MetadataStore();
  buildCounterGoogleCloudAiplatformV1MetadataStore++;
  if (buildCounterGoogleCloudAiplatformV1MetadataStore < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.name = 'foo';
    o.state = buildGoogleCloudAiplatformV1MetadataStoreMetadataStoreState();
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MetadataStore--;
  return o;
}

void checkGoogleCloudAiplatformV1MetadataStore(
    api.GoogleCloudAiplatformV1MetadataStore o) {
  buildCounterGoogleCloudAiplatformV1MetadataStore++;
  if (buildCounterGoogleCloudAiplatformV1MetadataStore < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1MetadataStoreMetadataStoreState(o.state!);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MetadataStore--;
}

core.int buildCounterGoogleCloudAiplatformV1MetadataStoreMetadataStoreState = 0;
api.GoogleCloudAiplatformV1MetadataStoreMetadataStoreState
    buildGoogleCloudAiplatformV1MetadataStoreMetadataStoreState() {
  final o = api.GoogleCloudAiplatformV1MetadataStoreMetadataStoreState();
  buildCounterGoogleCloudAiplatformV1MetadataStoreMetadataStoreState++;
  if (buildCounterGoogleCloudAiplatformV1MetadataStoreMetadataStoreState < 3) {
    o.diskUtilizationBytes = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MetadataStoreMetadataStoreState--;
  return o;
}

void checkGoogleCloudAiplatformV1MetadataStoreMetadataStoreState(
    api.GoogleCloudAiplatformV1MetadataStoreMetadataStoreState o) {
  buildCounterGoogleCloudAiplatformV1MetadataStoreMetadataStoreState++;
  if (buildCounterGoogleCloudAiplatformV1MetadataStoreMetadataStoreState < 3) {
    unittest.expect(
      o.diskUtilizationBytes!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MetadataStoreMetadataStoreState--;
}

core.int buildCounterGoogleCloudAiplatformV1MigratableResource = 0;
api.GoogleCloudAiplatformV1MigratableResource
    buildGoogleCloudAiplatformV1MigratableResource() {
  final o = api.GoogleCloudAiplatformV1MigratableResource();
  buildCounterGoogleCloudAiplatformV1MigratableResource++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResource < 3) {
    o.automlDataset =
        buildGoogleCloudAiplatformV1MigratableResourceAutomlDataset();
    o.automlModel = buildGoogleCloudAiplatformV1MigratableResourceAutomlModel();
    o.dataLabelingDataset =
        buildGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset();
    o.lastMigrateTime = 'foo';
    o.lastUpdateTime = 'foo';
    o.mlEngineModelVersion =
        buildGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion();
  }
  buildCounterGoogleCloudAiplatformV1MigratableResource--;
  return o;
}

void checkGoogleCloudAiplatformV1MigratableResource(
    api.GoogleCloudAiplatformV1MigratableResource o) {
  buildCounterGoogleCloudAiplatformV1MigratableResource++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResource < 3) {
    checkGoogleCloudAiplatformV1MigratableResourceAutomlDataset(
        o.automlDataset!);
    checkGoogleCloudAiplatformV1MigratableResourceAutomlModel(o.automlModel!);
    checkGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset(
        o.dataLabelingDataset!);
    unittest.expect(
      o.lastMigrateTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.lastUpdateTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion(
        o.mlEngineModelVersion!);
  }
  buildCounterGoogleCloudAiplatformV1MigratableResource--;
}

core.int buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlDataset = 0;
api.GoogleCloudAiplatformV1MigratableResourceAutomlDataset
    buildGoogleCloudAiplatformV1MigratableResourceAutomlDataset() {
  final o = api.GoogleCloudAiplatformV1MigratableResourceAutomlDataset();
  buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlDataset++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlDataset < 3) {
    o.dataset = 'foo';
    o.datasetDisplayName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlDataset--;
  return o;
}

void checkGoogleCloudAiplatformV1MigratableResourceAutomlDataset(
    api.GoogleCloudAiplatformV1MigratableResourceAutomlDataset o) {
  buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlDataset++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlDataset < 3) {
    unittest.expect(
      o.dataset!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.datasetDisplayName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlDataset--;
}

core.int buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlModel = 0;
api.GoogleCloudAiplatformV1MigratableResourceAutomlModel
    buildGoogleCloudAiplatformV1MigratableResourceAutomlModel() {
  final o = api.GoogleCloudAiplatformV1MigratableResourceAutomlModel();
  buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlModel++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlModel < 3) {
    o.model = 'foo';
    o.modelDisplayName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlModel--;
  return o;
}

void checkGoogleCloudAiplatformV1MigratableResourceAutomlModel(
    api.GoogleCloudAiplatformV1MigratableResourceAutomlModel o) {
  buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlModel++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlModel < 3) {
    unittest.expect(
      o.model!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modelDisplayName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceAutomlModel--;
}

core.List<
        api
        .GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset>
    buildUnnamed189() => [
          buildGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset(),
          buildGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset(),
        ];

void checkUnnamed189(
    core.List<
            api
            .GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset(
      o[0]);
  checkGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset(
      o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset =
    0;
api.GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset
    buildGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset() {
  final o = api.GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset();
  buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset <
      3) {
    o.dataLabelingAnnotatedDatasets = buildUnnamed189();
    o.dataset = 'foo';
    o.datasetDisplayName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset--;
  return o;
}

void checkGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset(
    api.GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset o) {
  buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset <
      3) {
    checkUnnamed189(o.dataLabelingAnnotatedDatasets!);
    unittest.expect(
      o.dataset!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.datasetDisplayName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset--;
}

core.int
    buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset =
    0;
api.GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset
    buildGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset() {
  final o = api
      .GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset();
  buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset <
      3) {
    o.annotatedDataset = 'foo';
    o.annotatedDatasetDisplayName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset--;
  return o;
}

void checkGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset(
    api.GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset
        o) {
  buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset <
      3) {
    unittest.expect(
      o.annotatedDataset!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.annotatedDatasetDisplayName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset--;
}

core.int
    buildCounterGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion =
    0;
api.GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion
    buildGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion() {
  final o = api.GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion();
  buildCounterGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion <
      3) {
    o.endpoint = 'foo';
    o.version = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion--;
  return o;
}

void checkGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion(
    api.GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion o) {
  buildCounterGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion++;
  if (buildCounterGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion <
      3) {
    unittest.expect(
      o.endpoint!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.version!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion--;
}

core.int buildCounterGoogleCloudAiplatformV1MigrateResourceRequest = 0;
api.GoogleCloudAiplatformV1MigrateResourceRequest
    buildGoogleCloudAiplatformV1MigrateResourceRequest() {
  final o = api.GoogleCloudAiplatformV1MigrateResourceRequest();
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequest++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequest < 3) {
    o.migrateAutomlDatasetConfig =
        buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig();
    o.migrateAutomlModelConfig =
        buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig();
    o.migrateDataLabelingDatasetConfig =
        buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig();
    o.migrateMlEngineModelVersionConfig =
        buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig();
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1MigrateResourceRequest(
    api.GoogleCloudAiplatformV1MigrateResourceRequest o) {
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequest++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequest < 3) {
    checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig(
        o.migrateAutomlDatasetConfig!);
    checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig(
        o.migrateAutomlModelConfig!);
    checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig(
        o.migrateDataLabelingDatasetConfig!);
    checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig(
        o.migrateMlEngineModelVersionConfig!);
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig =
    0;
api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig
    buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig() {
  final o = api
      .GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig();
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig <
      3) {
    o.dataset = 'foo';
    o.datasetDisplayName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig(
    api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig
        o) {
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig <
      3) {
    unittest.expect(
      o.dataset!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.datasetDisplayName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig =
    0;
api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig
    buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig() {
  final o = api
      .GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig();
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig <
      3) {
    o.model = 'foo';
    o.modelDisplayName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig(
    api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig
        o) {
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig <
      3) {
    unittest.expect(
      o.model!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modelDisplayName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig--;
}

core.List<
        api
        .GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig>
    buildUnnamed190() => [
          buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig(),
          buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig(),
        ];

void checkUnnamed190(
    core.List<
            api
            .GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig(
      o[0]);
  checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig(
      o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig =
    0;
api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig
    buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig() {
  final o = api
      .GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig();
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig <
      3) {
    o.dataset = 'foo';
    o.datasetDisplayName = 'foo';
    o.migrateDataLabelingAnnotatedDatasetConfigs = buildUnnamed190();
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig(
    api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig
        o) {
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig <
      3) {
    unittest.expect(
      o.dataset!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.datasetDisplayName!,
      unittest.equals('foo'),
    );
    checkUnnamed190(o.migrateDataLabelingAnnotatedDatasetConfigs!);
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig =
    0;
api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig
    buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig() {
  final o = api
      .GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig();
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig <
      3) {
    o.annotatedDataset = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig(
    api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig
        o) {
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig <
      3) {
    unittest.expect(
      o.annotatedDataset!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig =
    0;
api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig
    buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig() {
  final o = api
      .GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig();
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig <
      3) {
    o.endpoint = 'foo';
    o.modelDisplayName = 'foo';
    o.modelVersion = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig(
    api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig
        o) {
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig++;
  if (buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig <
      3) {
    unittest.expect(
      o.endpoint!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modelDisplayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modelVersion!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig--;
}

core.List<api.GoogleCloudAiplatformV1DeployedModelRef> buildUnnamed191() => [
      buildGoogleCloudAiplatformV1DeployedModelRef(),
      buildGoogleCloudAiplatformV1DeployedModelRef(),
    ];

void checkUnnamed191(core.List<api.GoogleCloudAiplatformV1DeployedModelRef> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DeployedModelRef(o[0]);
  checkGoogleCloudAiplatformV1DeployedModelRef(o[1]);
}

core.Map<core.String, core.String> buildUnnamed192() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed192(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed193() => [
      'foo',
      'foo',
    ];

void checkUnnamed193(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1ModelExportFormat> buildUnnamed194() => [
      buildGoogleCloudAiplatformV1ModelExportFormat(),
      buildGoogleCloudAiplatformV1ModelExportFormat(),
    ];

void checkUnnamed194(
    core.List<api.GoogleCloudAiplatformV1ModelExportFormat> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelExportFormat(o[0]);
  checkGoogleCloudAiplatformV1ModelExportFormat(o[1]);
}

core.List<core.String> buildUnnamed195() => [
      'foo',
      'foo',
    ];

void checkUnnamed195(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed196() => [
      'foo',
      'foo',
    ];

void checkUnnamed196(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed197() => [
      'foo',
      'foo',
    ];

void checkUnnamed197(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Model = 0;
api.GoogleCloudAiplatformV1Model buildGoogleCloudAiplatformV1Model() {
  final o = api.GoogleCloudAiplatformV1Model();
  buildCounterGoogleCloudAiplatformV1Model++;
  if (buildCounterGoogleCloudAiplatformV1Model < 3) {
    o.artifactUri = 'foo';
    o.baseModelSource = buildGoogleCloudAiplatformV1ModelBaseModelSource();
    o.containerSpec = buildGoogleCloudAiplatformV1ModelContainerSpec();
    o.createTime = 'foo';
    o.dataStats = buildGoogleCloudAiplatformV1ModelDataStats();
    o.deployedModels = buildUnnamed191();
    o.description = 'foo';
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.etag = 'foo';
    o.explanationSpec = buildGoogleCloudAiplatformV1ExplanationSpec();
    o.labels = buildUnnamed192();
    o.metadata = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.metadataArtifact = 'foo';
    o.metadataSchemaUri = 'foo';
    o.modelSourceInfo = buildGoogleCloudAiplatformV1ModelSourceInfo();
    o.name = 'foo';
    o.originalModelInfo = buildGoogleCloudAiplatformV1ModelOriginalModelInfo();
    o.pipelineJob = 'foo';
    o.predictSchemata = buildGoogleCloudAiplatformV1PredictSchemata();
    o.supportedDeploymentResourcesTypes = buildUnnamed193();
    o.supportedExportFormats = buildUnnamed194();
    o.supportedInputStorageFormats = buildUnnamed195();
    o.supportedOutputStorageFormats = buildUnnamed196();
    o.trainingPipeline = 'foo';
    o.updateTime = 'foo';
    o.versionAliases = buildUnnamed197();
    o.versionCreateTime = 'foo';
    o.versionDescription = 'foo';
    o.versionId = 'foo';
    o.versionUpdateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Model--;
  return o;
}

void checkGoogleCloudAiplatformV1Model(api.GoogleCloudAiplatformV1Model o) {
  buildCounterGoogleCloudAiplatformV1Model++;
  if (buildCounterGoogleCloudAiplatformV1Model < 3) {
    unittest.expect(
      o.artifactUri!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelBaseModelSource(o.baseModelSource!);
    checkGoogleCloudAiplatformV1ModelContainerSpec(o.containerSpec!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelDataStats(o.dataStats!);
    checkUnnamed191(o.deployedModels!);
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ExplanationSpec(o.explanationSpec!);
    checkUnnamed192(o.labels!);
    var casted47 = (o.metadata!) as core.Map;
    unittest.expect(casted47, unittest.hasLength(3));
    unittest.expect(
      casted47['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted47['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted47['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metadataArtifact!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metadataSchemaUri!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelSourceInfo(o.modelSourceInfo!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelOriginalModelInfo(o.originalModelInfo!);
    unittest.expect(
      o.pipelineJob!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PredictSchemata(o.predictSchemata!);
    checkUnnamed193(o.supportedDeploymentResourcesTypes!);
    checkUnnamed194(o.supportedExportFormats!);
    checkUnnamed195(o.supportedInputStorageFormats!);
    checkUnnamed196(o.supportedOutputStorageFormats!);
    unittest.expect(
      o.trainingPipeline!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
    checkUnnamed197(o.versionAliases!);
    unittest.expect(
      o.versionCreateTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.versionDescription!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.versionId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.versionUpdateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Model--;
}

core.int buildCounterGoogleCloudAiplatformV1ModelBaseModelSource = 0;
api.GoogleCloudAiplatformV1ModelBaseModelSource
    buildGoogleCloudAiplatformV1ModelBaseModelSource() {
  final o = api.GoogleCloudAiplatformV1ModelBaseModelSource();
  buildCounterGoogleCloudAiplatformV1ModelBaseModelSource++;
  if (buildCounterGoogleCloudAiplatformV1ModelBaseModelSource < 3) {
    o.genieSource = buildGoogleCloudAiplatformV1GenieSource();
    o.modelGardenSource = buildGoogleCloudAiplatformV1ModelGardenSource();
  }
  buildCounterGoogleCloudAiplatformV1ModelBaseModelSource--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelBaseModelSource(
    api.GoogleCloudAiplatformV1ModelBaseModelSource o) {
  buildCounterGoogleCloudAiplatformV1ModelBaseModelSource++;
  if (buildCounterGoogleCloudAiplatformV1ModelBaseModelSource < 3) {
    checkGoogleCloudAiplatformV1GenieSource(o.genieSource!);
    checkGoogleCloudAiplatformV1ModelGardenSource(o.modelGardenSource!);
  }
  buildCounterGoogleCloudAiplatformV1ModelBaseModelSource--;
}

core.List<core.String> buildUnnamed198() => [
      'foo',
      'foo',
    ];

void checkUnnamed198(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed199() => [
      'foo',
      'foo',
    ];

void checkUnnamed199(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1EnvVar> buildUnnamed200() => [
      buildGoogleCloudAiplatformV1EnvVar(),
      buildGoogleCloudAiplatformV1EnvVar(),
    ];

void checkUnnamed200(core.List<api.GoogleCloudAiplatformV1EnvVar> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1EnvVar(o[0]);
  checkGoogleCloudAiplatformV1EnvVar(o[1]);
}

core.List<api.GoogleCloudAiplatformV1Port> buildUnnamed201() => [
      buildGoogleCloudAiplatformV1Port(),
      buildGoogleCloudAiplatformV1Port(),
    ];

void checkUnnamed201(core.List<api.GoogleCloudAiplatformV1Port> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Port(o[0]);
  checkGoogleCloudAiplatformV1Port(o[1]);
}

core.List<api.GoogleCloudAiplatformV1Port> buildUnnamed202() => [
      buildGoogleCloudAiplatformV1Port(),
      buildGoogleCloudAiplatformV1Port(),
    ];

void checkUnnamed202(core.List<api.GoogleCloudAiplatformV1Port> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Port(o[0]);
  checkGoogleCloudAiplatformV1Port(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ModelContainerSpec = 0;
api.GoogleCloudAiplatformV1ModelContainerSpec
    buildGoogleCloudAiplatformV1ModelContainerSpec() {
  final o = api.GoogleCloudAiplatformV1ModelContainerSpec();
  buildCounterGoogleCloudAiplatformV1ModelContainerSpec++;
  if (buildCounterGoogleCloudAiplatformV1ModelContainerSpec < 3) {
    o.args = buildUnnamed198();
    o.command = buildUnnamed199();
    o.deploymentTimeout = 'foo';
    o.env = buildUnnamed200();
    o.grpcPorts = buildUnnamed201();
    o.healthProbe = buildGoogleCloudAiplatformV1Probe();
    o.healthRoute = 'foo';
    o.imageUri = 'foo';
    o.ports = buildUnnamed202();
    o.predictRoute = 'foo';
    o.sharedMemorySizeMb = 'foo';
    o.startupProbe = buildGoogleCloudAiplatformV1Probe();
  }
  buildCounterGoogleCloudAiplatformV1ModelContainerSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelContainerSpec(
    api.GoogleCloudAiplatformV1ModelContainerSpec o) {
  buildCounterGoogleCloudAiplatformV1ModelContainerSpec++;
  if (buildCounterGoogleCloudAiplatformV1ModelContainerSpec < 3) {
    checkUnnamed198(o.args!);
    checkUnnamed199(o.command!);
    unittest.expect(
      o.deploymentTimeout!,
      unittest.equals('foo'),
    );
    checkUnnamed200(o.env!);
    checkUnnamed201(o.grpcPorts!);
    checkGoogleCloudAiplatformV1Probe(o.healthProbe!);
    unittest.expect(
      o.healthRoute!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.imageUri!,
      unittest.equals('foo'),
    );
    checkUnnamed202(o.ports!);
    unittest.expect(
      o.predictRoute!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.sharedMemorySizeMb!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1Probe(o.startupProbe!);
  }
  buildCounterGoogleCloudAiplatformV1ModelContainerSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1ModelDataStats = 0;
api.GoogleCloudAiplatformV1ModelDataStats
    buildGoogleCloudAiplatformV1ModelDataStats() {
  final o = api.GoogleCloudAiplatformV1ModelDataStats();
  buildCounterGoogleCloudAiplatformV1ModelDataStats++;
  if (buildCounterGoogleCloudAiplatformV1ModelDataStats < 3) {
    o.testAnnotationsCount = 'foo';
    o.testDataItemsCount = 'foo';
    o.trainingAnnotationsCount = 'foo';
    o.trainingDataItemsCount = 'foo';
    o.validationAnnotationsCount = 'foo';
    o.validationDataItemsCount = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelDataStats--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelDataStats(
    api.GoogleCloudAiplatformV1ModelDataStats o) {
  buildCounterGoogleCloudAiplatformV1ModelDataStats++;
  if (buildCounterGoogleCloudAiplatformV1ModelDataStats < 3) {
    unittest.expect(
      o.testAnnotationsCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.testDataItemsCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.trainingAnnotationsCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.trainingDataItemsCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.validationAnnotationsCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.validationDataItemsCount!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelDataStats--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable =
    0;
api.GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable
    buildGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable() {
  final o = api.GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable();
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable <
      3) {
    o.bigqueryTablePath = 'foo';
    o.logSource = 'foo';
    o.logType = 'foo';
    o.requestResponseLoggingSchemaVersion = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable(
    api.GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable o) {
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable <
      3) {
    unittest.expect(
      o.bigqueryTablePath!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.logSource!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.logType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.requestResponseLoggingSchemaVersion!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable--;
}

core.List<api.GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable>
    buildUnnamed203() => [
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable(),
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable(),
        ];

void checkUnnamed203(
    core.List<api.GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable(o[0]);
  checkGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable(o[1]);
}

core.Map<core.String, core.String> buildUnnamed204() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed204(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig>
    buildUnnamed205() => [
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig(),
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig(),
        ];

void checkUnnamed205(
    core.List<
            api.GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig(o[0]);
  checkGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJob = 0;
api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob
    buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJob() {
  final o = api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob();
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJob++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJob < 3) {
    o.analysisInstanceSchemaUri = 'foo';
    o.bigqueryTables = buildUnnamed203();
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.enableMonitoringPipelineLogs = true;
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.endpoint = 'foo';
    o.error = buildGoogleRpcStatus();
    o.labels = buildUnnamed204();
    o.latestMonitoringPipelineMetadata =
        buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata();
    o.logTtl = 'foo';
    o.loggingSamplingStrategy = buildGoogleCloudAiplatformV1SamplingStrategy();
    o.modelDeploymentMonitoringObjectiveConfigs = buildUnnamed205();
    o.modelDeploymentMonitoringScheduleConfig =
        buildGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig();
    o.modelMonitoringAlertConfig =
        buildGoogleCloudAiplatformV1ModelMonitoringAlertConfig();
    o.name = 'foo';
    o.nextScheduleTime = 'foo';
    o.predictInstanceSchemaUri = 'foo';
    o.samplePredictInstance = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.scheduleState = 'foo';
    o.state = 'foo';
    o.statsAnomaliesBaseDirectory =
        buildGoogleCloudAiplatformV1GcsDestination();
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJob--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(
    api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob o) {
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJob++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJob < 3) {
    unittest.expect(
      o.analysisInstanceSchemaUri!,
      unittest.equals('foo'),
    );
    checkUnnamed203(o.bigqueryTables!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(o.enableMonitoringPipelineLogs!, unittest.isTrue);
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.endpoint!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.error!);
    checkUnnamed204(o.labels!);
    checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata(
        o.latestMonitoringPipelineMetadata!);
    unittest.expect(
      o.logTtl!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1SamplingStrategy(o.loggingSamplingStrategy!);
    checkUnnamed205(o.modelDeploymentMonitoringObjectiveConfigs!);
    checkGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig(
        o.modelDeploymentMonitoringScheduleConfig!);
    checkGoogleCloudAiplatformV1ModelMonitoringAlertConfig(
        o.modelMonitoringAlertConfig!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.nextScheduleTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.predictInstanceSchemaUri!,
      unittest.equals('foo'),
    );
    var casted48 = (o.samplePredictInstance!) as core.Map;
    unittest.expect(casted48, unittest.hasLength(3));
    unittest.expect(
      casted48['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted48['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted48['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.scheduleState!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1GcsDestination(o.statsAnomaliesBaseDirectory!);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJob--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata =
    0;
api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata
    buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata() {
  final o = api
      .GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata();
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata <
      3) {
    o.runTime = 'foo';
    o.status = buildGoogleRpcStatus();
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata(
    api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata
        o) {
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata <
      3) {
    unittest.expect(
      o.runTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.status!);
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig =
    0;
api.GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig
    buildGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig() {
  final o =
      api.GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig();
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig <
      3) {
    o.deployedModelId = 'foo';
    o.objectiveConfig =
        buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig();
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig(
    api.GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig o) {
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig <
      3) {
    unittest.expect(
      o.deployedModelId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig(
        o.objectiveConfig!);
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig =
    0;
api.GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig
    buildGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig() {
  final o =
      api.GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig();
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig <
      3) {
    o.monitorInterval = 'foo';
    o.monitorWindow = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig(
    api.GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig o) {
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig <
      3) {
    unittest.expect(
      o.monitorInterval!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.monitorWindow!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig--;
}

core.List<
        api
        .GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec>
    buildUnnamed206() => [
          buildGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec(),
          buildGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec(),
        ];

void checkUnnamed206(
    core.List<
            api
            .GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec(
      o[0]);
  checkGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec(
      o[1]);
}

core.List<core.String> buildUnnamed207() => [
      'foo',
      'foo',
    ];

void checkUnnamed207(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ModelEvaluation = 0;
api.GoogleCloudAiplatformV1ModelEvaluation
    buildGoogleCloudAiplatformV1ModelEvaluation() {
  final o = api.GoogleCloudAiplatformV1ModelEvaluation();
  buildCounterGoogleCloudAiplatformV1ModelEvaluation++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluation < 3) {
    o.annotationSchemaUri = 'foo';
    o.createTime = 'foo';
    o.dataItemSchemaUri = 'foo';
    o.displayName = 'foo';
    o.explanationSpecs = buildUnnamed206();
    o.metadata = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.metrics = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.metricsSchemaUri = 'foo';
    o.modelExplanation = buildGoogleCloudAiplatformV1ModelExplanation();
    o.name = 'foo';
    o.sliceDimensions = buildUnnamed207();
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluation--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelEvaluation(
    api.GoogleCloudAiplatformV1ModelEvaluation o) {
  buildCounterGoogleCloudAiplatformV1ModelEvaluation++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluation < 3) {
    unittest.expect(
      o.annotationSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.dataItemSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkUnnamed206(o.explanationSpecs!);
    var casted49 = (o.metadata!) as core.Map;
    unittest.expect(casted49, unittest.hasLength(3));
    unittest.expect(
      casted49['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted49['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted49['string'],
      unittest.equals('foo'),
    );
    var casted50 = (o.metrics!) as core.Map;
    unittest.expect(casted50, unittest.hasLength(3));
    unittest.expect(
      casted50['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted50['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted50['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metricsSchemaUri!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelExplanation(o.modelExplanation!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed207(o.sliceDimensions!);
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluation--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec =
    0;
api.GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec
    buildGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec() {
  final o = api
      .GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec();
  buildCounterGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec <
      3) {
    o.explanationSpec = buildGoogleCloudAiplatformV1ExplanationSpec();
    o.explanationType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec(
    api.GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec
        o) {
  buildCounterGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec <
      3) {
    checkGoogleCloudAiplatformV1ExplanationSpec(o.explanationSpec!);
    unittest.expect(
      o.explanationType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1ModelEvaluationSlice = 0;
api.GoogleCloudAiplatformV1ModelEvaluationSlice
    buildGoogleCloudAiplatformV1ModelEvaluationSlice() {
  final o = api.GoogleCloudAiplatformV1ModelEvaluationSlice();
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSlice++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSlice < 3) {
    o.createTime = 'foo';
    o.metrics = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.metricsSchemaUri = 'foo';
    o.modelExplanation = buildGoogleCloudAiplatformV1ModelExplanation();
    o.name = 'foo';
    o.slice = buildGoogleCloudAiplatformV1ModelEvaluationSliceSlice();
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSlice--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelEvaluationSlice(
    api.GoogleCloudAiplatformV1ModelEvaluationSlice o) {
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSlice++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSlice < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    var casted51 = (o.metrics!) as core.Map;
    unittest.expect(casted51, unittest.hasLength(3));
    unittest.expect(
      casted51['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted51['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted51['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metricsSchemaUri!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelExplanation(o.modelExplanation!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelEvaluationSliceSlice(o.slice!);
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSlice--;
}

core.int buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSlice = 0;
api.GoogleCloudAiplatformV1ModelEvaluationSliceSlice
    buildGoogleCloudAiplatformV1ModelEvaluationSliceSlice() {
  final o = api.GoogleCloudAiplatformV1ModelEvaluationSliceSlice();
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSlice++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSlice < 3) {
    o.dimension = 'foo';
    o.sliceSpec =
        buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec();
    o.value = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSlice--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelEvaluationSliceSlice(
    api.GoogleCloudAiplatformV1ModelEvaluationSliceSlice o) {
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSlice++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSlice < 3) {
    unittest.expect(
      o.dimension!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec(
        o.sliceSpec!);
    unittest.expect(
      o.value!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSlice--;
}

core.Map<
        core.String,
        api
        .GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig>
    buildUnnamed208() => {
          'x':
              buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig(),
          'y':
              buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig(),
        };

void checkUnnamed208(
    core.Map<
            core.String,
            api
            .GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig(
      o['x']!);
  checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig(
      o['y']!);
}

core.int buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec =
    0;
api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec
    buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec() {
  final o = api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec();
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec <
      3) {
    o.configs = buildUnnamed208();
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec(
    api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec o) {
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec <
      3) {
    checkUnnamed208(o.configs!);
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange =
    0;
api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange
    buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange() {
  final o =
      api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange();
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange <
      3) {
    o.high = 42.0;
    o.low = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange(
    api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange o) {
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange <
      3) {
    unittest.expect(
      o.high!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.low!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig =
    0;
api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig
    buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig() {
  final o = api
      .GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig();
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig <
      3) {
    o.allValues = true;
    o.range =
        buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange();
    o.value =
        buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue();
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig(
    api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig
        o) {
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig <
      3) {
    unittest.expect(o.allValues!, unittest.isTrue);
    checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange(
        o.range!);
    checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue(
        o.value!);
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue =
    0;
api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue
    buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue() {
  final o =
      api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue();
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue <
      3) {
    o.floatValue = 42.0;
    o.stringValue = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue(
    api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue o) {
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue++;
  if (buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue <
      3) {
    unittest.expect(
      o.floatValue!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.stringValue!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue--;
}

core.List<api.GoogleCloudAiplatformV1Attribution> buildUnnamed209() => [
      buildGoogleCloudAiplatformV1Attribution(),
      buildGoogleCloudAiplatformV1Attribution(),
    ];

void checkUnnamed209(core.List<api.GoogleCloudAiplatformV1Attribution> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Attribution(o[0]);
  checkGoogleCloudAiplatformV1Attribution(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ModelExplanation = 0;
api.GoogleCloudAiplatformV1ModelExplanation
    buildGoogleCloudAiplatformV1ModelExplanation() {
  final o = api.GoogleCloudAiplatformV1ModelExplanation();
  buildCounterGoogleCloudAiplatformV1ModelExplanation++;
  if (buildCounterGoogleCloudAiplatformV1ModelExplanation < 3) {
    o.meanAttributions = buildUnnamed209();
  }
  buildCounterGoogleCloudAiplatformV1ModelExplanation--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelExplanation(
    api.GoogleCloudAiplatformV1ModelExplanation o) {
  buildCounterGoogleCloudAiplatformV1ModelExplanation++;
  if (buildCounterGoogleCloudAiplatformV1ModelExplanation < 3) {
    checkUnnamed209(o.meanAttributions!);
  }
  buildCounterGoogleCloudAiplatformV1ModelExplanation--;
}

core.List<core.String> buildUnnamed210() => [
      'foo',
      'foo',
    ];

void checkUnnamed210(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ModelExportFormat = 0;
api.GoogleCloudAiplatformV1ModelExportFormat
    buildGoogleCloudAiplatformV1ModelExportFormat() {
  final o = api.GoogleCloudAiplatformV1ModelExportFormat();
  buildCounterGoogleCloudAiplatformV1ModelExportFormat++;
  if (buildCounterGoogleCloudAiplatformV1ModelExportFormat < 3) {
    o.exportableContents = buildUnnamed210();
    o.id = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelExportFormat--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelExportFormat(
    api.GoogleCloudAiplatformV1ModelExportFormat o) {
  buildCounterGoogleCloudAiplatformV1ModelExportFormat++;
  if (buildCounterGoogleCloudAiplatformV1ModelExportFormat < 3) {
    checkUnnamed210(o.exportableContents!);
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelExportFormat--;
}

core.int buildCounterGoogleCloudAiplatformV1ModelGardenSource = 0;
api.GoogleCloudAiplatformV1ModelGardenSource
    buildGoogleCloudAiplatformV1ModelGardenSource() {
  final o = api.GoogleCloudAiplatformV1ModelGardenSource();
  buildCounterGoogleCloudAiplatformV1ModelGardenSource++;
  if (buildCounterGoogleCloudAiplatformV1ModelGardenSource < 3) {
    o.publicModelName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelGardenSource--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelGardenSource(
    api.GoogleCloudAiplatformV1ModelGardenSource o) {
  buildCounterGoogleCloudAiplatformV1ModelGardenSource++;
  if (buildCounterGoogleCloudAiplatformV1ModelGardenSource < 3) {
    unittest.expect(
      o.publicModelName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelGardenSource--;
}

core.List<core.String> buildUnnamed211() => [
      'foo',
      'foo',
    ];

void checkUnnamed211(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfig = 0;
api.GoogleCloudAiplatformV1ModelMonitoringAlertConfig
    buildGoogleCloudAiplatformV1ModelMonitoringAlertConfig() {
  final o = api.GoogleCloudAiplatformV1ModelMonitoringAlertConfig();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfig < 3) {
    o.emailAlertConfig =
        buildGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig();
    o.enableLogging = true;
    o.notificationChannels = buildUnnamed211();
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringAlertConfig(
    api.GoogleCloudAiplatformV1ModelMonitoringAlertConfig o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfig < 3) {
    checkGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig(
        o.emailAlertConfig!);
    unittest.expect(o.enableLogging!, unittest.isTrue);
    checkUnnamed211(o.notificationChannels!);
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfig--;
}

core.List<core.String> buildUnnamed212() => [
      'foo',
      'foo',
    ];

void checkUnnamed212(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig =
    0;
api.GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig
    buildGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig() {
  final o =
      api.GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig <
      3) {
    o.userEmails = buildUnnamed212();
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig(
    api.GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig <
      3) {
    checkUnnamed212(o.userEmails!);
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig = 0;
api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig
    buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig() {
  final o = api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig < 3) {
    o.explanationConfig =
        buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig();
    o.predictionDriftDetectionConfig =
        buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig();
    o.trainingDataset =
        buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset();
    o.trainingPredictionSkewDetectionConfig =
        buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig();
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig(
    api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig < 3) {
    checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig(
        o.explanationConfig!);
    checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig(
        o.predictionDriftDetectionConfig!);
    checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset(
        o.trainingDataset!);
    checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig(
        o.trainingPredictionSkewDetectionConfig!);
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig =
    0;
api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig
    buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig() {
  final o = api
      .GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig <
      3) {
    o.enableFeatureAttributes = true;
    o.explanationBaseline =
        buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline();
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig(
    api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig
        o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig <
      3) {
    unittest.expect(o.enableFeatureAttributes!, unittest.isTrue);
    checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline(
        o.explanationBaseline!);
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline =
    0;
api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline
    buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline() {
  final o = api
      .GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline <
      3) {
    o.bigquery = buildGoogleCloudAiplatformV1BigQueryDestination();
    o.gcs = buildGoogleCloudAiplatformV1GcsDestination();
    o.predictionFormat = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline(
    api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline
        o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline <
      3) {
    checkGoogleCloudAiplatformV1BigQueryDestination(o.bigquery!);
    checkGoogleCloudAiplatformV1GcsDestination(o.gcs!);
    unittest.expect(
      o.predictionFormat!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline--;
}

core.Map<core.String, api.GoogleCloudAiplatformV1ThresholdConfig>
    buildUnnamed213() => {
          'x': buildGoogleCloudAiplatformV1ThresholdConfig(),
          'y': buildGoogleCloudAiplatformV1ThresholdConfig(),
        };

void checkUnnamed213(
    core.Map<core.String, api.GoogleCloudAiplatformV1ThresholdConfig> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ThresholdConfig(o['x']!);
  checkGoogleCloudAiplatformV1ThresholdConfig(o['y']!);
}

core.Map<core.String, api.GoogleCloudAiplatformV1ThresholdConfig>
    buildUnnamed214() => {
          'x': buildGoogleCloudAiplatformV1ThresholdConfig(),
          'y': buildGoogleCloudAiplatformV1ThresholdConfig(),
        };

void checkUnnamed214(
    core.Map<core.String, api.GoogleCloudAiplatformV1ThresholdConfig> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ThresholdConfig(o['x']!);
  checkGoogleCloudAiplatformV1ThresholdConfig(o['y']!);
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig =
    0;
api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig
    buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig() {
  final o = api
      .GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig <
      3) {
    o.attributionScoreDriftThresholds = buildUnnamed213();
    o.defaultDriftThreshold = buildGoogleCloudAiplatformV1ThresholdConfig();
    o.driftThresholds = buildUnnamed214();
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig(
    api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig
        o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig <
      3) {
    checkUnnamed213(o.attributionScoreDriftThresholds!);
    checkGoogleCloudAiplatformV1ThresholdConfig(o.defaultDriftThreshold!);
    checkUnnamed214(o.driftThresholds!);
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset =
    0;
api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset
    buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset() {
  final o = api
      .GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset <
      3) {
    o.bigquerySource = buildGoogleCloudAiplatformV1BigQuerySource();
    o.dataFormat = 'foo';
    o.dataset = 'foo';
    o.gcsSource = buildGoogleCloudAiplatformV1GcsSource();
    o.loggingSamplingStrategy = buildGoogleCloudAiplatformV1SamplingStrategy();
    o.targetField = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset(
    api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset
        o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset <
      3) {
    checkGoogleCloudAiplatformV1BigQuerySource(o.bigquerySource!);
    unittest.expect(
      o.dataFormat!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.dataset!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1GcsSource(o.gcsSource!);
    checkGoogleCloudAiplatformV1SamplingStrategy(o.loggingSamplingStrategy!);
    unittest.expect(
      o.targetField!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset--;
}

core.Map<core.String, api.GoogleCloudAiplatformV1ThresholdConfig>
    buildUnnamed215() => {
          'x': buildGoogleCloudAiplatformV1ThresholdConfig(),
          'y': buildGoogleCloudAiplatformV1ThresholdConfig(),
        };

void checkUnnamed215(
    core.Map<core.String, api.GoogleCloudAiplatformV1ThresholdConfig> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ThresholdConfig(o['x']!);
  checkGoogleCloudAiplatformV1ThresholdConfig(o['y']!);
}

core.Map<core.String, api.GoogleCloudAiplatformV1ThresholdConfig>
    buildUnnamed216() => {
          'x': buildGoogleCloudAiplatformV1ThresholdConfig(),
          'y': buildGoogleCloudAiplatformV1ThresholdConfig(),
        };

void checkUnnamed216(
    core.Map<core.String, api.GoogleCloudAiplatformV1ThresholdConfig> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ThresholdConfig(o['x']!);
  checkGoogleCloudAiplatformV1ThresholdConfig(o['y']!);
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig =
    0;
api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig
    buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig() {
  final o = api
      .GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig <
      3) {
    o.attributionScoreSkewThresholds = buildUnnamed215();
    o.defaultSkewThreshold = buildGoogleCloudAiplatformV1ThresholdConfig();
    o.skewThresholds = buildUnnamed216();
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig(
    api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig
        o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig <
      3) {
    checkUnnamed215(o.attributionScoreSkewThresholds!);
    checkGoogleCloudAiplatformV1ThresholdConfig(o.defaultSkewThreshold!);
    checkUnnamed216(o.skewThresholds!);
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig--;
}

core.List<
        api
        .GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies>
    buildUnnamed217() => [
          buildGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies(),
          buildGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies(),
        ];

void checkUnnamed217(
    core.List<
            api
            .GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies(
      o[0]);
  checkGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies(
      o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies = 0;
api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies
    buildGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies() {
  final o = api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies < 3) {
    o.anomalyCount = 42;
    o.deployedModelId = 'foo';
    o.featureStats = buildUnnamed217();
    o.objective = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies(
    api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies < 3) {
    unittest.expect(
      o.anomalyCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.deployedModelId!,
      unittest.equals('foo'),
    );
    checkUnnamed217(o.featureStats!);
    unittest.expect(
      o.objective!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies--;
}

core.List<api.GoogleCloudAiplatformV1FeatureStatsAnomaly> buildUnnamed218() => [
      buildGoogleCloudAiplatformV1FeatureStatsAnomaly(),
      buildGoogleCloudAiplatformV1FeatureStatsAnomaly(),
    ];

void checkUnnamed218(
    core.List<api.GoogleCloudAiplatformV1FeatureStatsAnomaly> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureStatsAnomaly(o[0]);
  checkGoogleCloudAiplatformV1FeatureStatsAnomaly(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies =
    0;
api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies
    buildGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies() {
  final o = api
      .GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies();
  buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies <
      3) {
    o.featureDisplayName = 'foo';
    o.predictionStats = buildUnnamed218();
    o.threshold = buildGoogleCloudAiplatformV1ThresholdConfig();
    o.trainingStats = buildGoogleCloudAiplatformV1FeatureStatsAnomaly();
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies(
    api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies
        o) {
  buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies++;
  if (buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies <
      3) {
    unittest.expect(
      o.featureDisplayName!,
      unittest.equals('foo'),
    );
    checkUnnamed218(o.predictionStats!);
    checkGoogleCloudAiplatformV1ThresholdConfig(o.threshold!);
    checkGoogleCloudAiplatformV1FeatureStatsAnomaly(o.trainingStats!);
  }
  buildCounterGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies--;
}

core.int buildCounterGoogleCloudAiplatformV1ModelOriginalModelInfo = 0;
api.GoogleCloudAiplatformV1ModelOriginalModelInfo
    buildGoogleCloudAiplatformV1ModelOriginalModelInfo() {
  final o = api.GoogleCloudAiplatformV1ModelOriginalModelInfo();
  buildCounterGoogleCloudAiplatformV1ModelOriginalModelInfo++;
  if (buildCounterGoogleCloudAiplatformV1ModelOriginalModelInfo < 3) {
    o.model = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelOriginalModelInfo--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelOriginalModelInfo(
    api.GoogleCloudAiplatformV1ModelOriginalModelInfo o) {
  buildCounterGoogleCloudAiplatformV1ModelOriginalModelInfo++;
  if (buildCounterGoogleCloudAiplatformV1ModelOriginalModelInfo < 3) {
    unittest.expect(
      o.model!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelOriginalModelInfo--;
}

core.int buildCounterGoogleCloudAiplatformV1ModelSourceInfo = 0;
api.GoogleCloudAiplatformV1ModelSourceInfo
    buildGoogleCloudAiplatformV1ModelSourceInfo() {
  final o = api.GoogleCloudAiplatformV1ModelSourceInfo();
  buildCounterGoogleCloudAiplatformV1ModelSourceInfo++;
  if (buildCounterGoogleCloudAiplatformV1ModelSourceInfo < 3) {
    o.copy = true;
    o.sourceType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ModelSourceInfo--;
  return o;
}

void checkGoogleCloudAiplatformV1ModelSourceInfo(
    api.GoogleCloudAiplatformV1ModelSourceInfo o) {
  buildCounterGoogleCloudAiplatformV1ModelSourceInfo++;
  if (buildCounterGoogleCloudAiplatformV1ModelSourceInfo < 3) {
    unittest.expect(o.copy!, unittest.isTrue);
    unittest.expect(
      o.sourceType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ModelSourceInfo--;
}

core.int buildCounterGoogleCloudAiplatformV1MutateDeployedModelRequest = 0;
api.GoogleCloudAiplatformV1MutateDeployedModelRequest
    buildGoogleCloudAiplatformV1MutateDeployedModelRequest() {
  final o = api.GoogleCloudAiplatformV1MutateDeployedModelRequest();
  buildCounterGoogleCloudAiplatformV1MutateDeployedModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1MutateDeployedModelRequest < 3) {
    o.deployedModel = buildGoogleCloudAiplatformV1DeployedModel();
    o.updateMask = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1MutateDeployedModelRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1MutateDeployedModelRequest(
    api.GoogleCloudAiplatformV1MutateDeployedModelRequest o) {
  buildCounterGoogleCloudAiplatformV1MutateDeployedModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1MutateDeployedModelRequest < 3) {
    checkGoogleCloudAiplatformV1DeployedModel(o.deployedModel!);
    unittest.expect(
      o.updateMask!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1MutateDeployedModelRequest--;
}

core.Map<core.String, core.String> buildUnnamed219() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed219(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1NasJob = 0;
api.GoogleCloudAiplatformV1NasJob buildGoogleCloudAiplatformV1NasJob() {
  final o = api.GoogleCloudAiplatformV1NasJob();
  buildCounterGoogleCloudAiplatformV1NasJob++;
  if (buildCounterGoogleCloudAiplatformV1NasJob < 3) {
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.enableRestrictedImageTraining = true;
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.endTime = 'foo';
    o.error = buildGoogleRpcStatus();
    o.labels = buildUnnamed219();
    o.name = 'foo';
    o.nasJobOutput = buildGoogleCloudAiplatformV1NasJobOutput();
    o.nasJobSpec = buildGoogleCloudAiplatformV1NasJobSpec();
    o.startTime = 'foo';
    o.state = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NasJob--;
  return o;
}

void checkGoogleCloudAiplatformV1NasJob(api.GoogleCloudAiplatformV1NasJob o) {
  buildCounterGoogleCloudAiplatformV1NasJob++;
  if (buildCounterGoogleCloudAiplatformV1NasJob < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(o.enableRestrictedImageTraining!, unittest.isTrue);
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.error!);
    checkUnnamed219(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1NasJobOutput(o.nasJobOutput!);
    checkGoogleCloudAiplatformV1NasJobSpec(o.nasJobSpec!);
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NasJob--;
}

core.int buildCounterGoogleCloudAiplatformV1NasJobOutput = 0;
api.GoogleCloudAiplatformV1NasJobOutput
    buildGoogleCloudAiplatformV1NasJobOutput() {
  final o = api.GoogleCloudAiplatformV1NasJobOutput();
  buildCounterGoogleCloudAiplatformV1NasJobOutput++;
  if (buildCounterGoogleCloudAiplatformV1NasJobOutput < 3) {
    o.multiTrialJobOutput =
        buildGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput();
  }
  buildCounterGoogleCloudAiplatformV1NasJobOutput--;
  return o;
}

void checkGoogleCloudAiplatformV1NasJobOutput(
    api.GoogleCloudAiplatformV1NasJobOutput o) {
  buildCounterGoogleCloudAiplatformV1NasJobOutput++;
  if (buildCounterGoogleCloudAiplatformV1NasJobOutput < 3) {
    checkGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput(
        o.multiTrialJobOutput!);
  }
  buildCounterGoogleCloudAiplatformV1NasJobOutput--;
}

core.List<api.GoogleCloudAiplatformV1NasTrial> buildUnnamed220() => [
      buildGoogleCloudAiplatformV1NasTrial(),
      buildGoogleCloudAiplatformV1NasTrial(),
    ];

void checkUnnamed220(core.List<api.GoogleCloudAiplatformV1NasTrial> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NasTrial(o[0]);
  checkGoogleCloudAiplatformV1NasTrial(o[1]);
}

core.List<api.GoogleCloudAiplatformV1NasTrial> buildUnnamed221() => [
      buildGoogleCloudAiplatformV1NasTrial(),
      buildGoogleCloudAiplatformV1NasTrial(),
    ];

void checkUnnamed221(core.List<api.GoogleCloudAiplatformV1NasTrial> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NasTrial(o[0]);
  checkGoogleCloudAiplatformV1NasTrial(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput = 0;
api.GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput
    buildGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput() {
  final o = api.GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput();
  buildCounterGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput++;
  if (buildCounterGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput < 3) {
    o.searchTrials = buildUnnamed220();
    o.trainTrials = buildUnnamed221();
  }
  buildCounterGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput--;
  return o;
}

void checkGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput(
    api.GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput o) {
  buildCounterGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput++;
  if (buildCounterGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput < 3) {
    checkUnnamed220(o.searchTrials!);
    checkUnnamed221(o.trainTrials!);
  }
  buildCounterGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput--;
}

core.int buildCounterGoogleCloudAiplatformV1NasJobSpec = 0;
api.GoogleCloudAiplatformV1NasJobSpec buildGoogleCloudAiplatformV1NasJobSpec() {
  final o = api.GoogleCloudAiplatformV1NasJobSpec();
  buildCounterGoogleCloudAiplatformV1NasJobSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpec < 3) {
    o.multiTrialAlgorithmSpec =
        buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec();
    o.resumeNasJobId = 'foo';
    o.searchSpaceSpec = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1NasJobSpec(
    api.GoogleCloudAiplatformV1NasJobSpec o) {
  buildCounterGoogleCloudAiplatformV1NasJobSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpec < 3) {
    checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec(
        o.multiTrialAlgorithmSpec!);
    unittest.expect(
      o.resumeNasJobId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.searchSpaceSpec!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec =
    0;
api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec
    buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec() {
  final o = api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec();
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec <
      3) {
    o.metric =
        buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec();
    o.multiTrialAlgorithm = 'foo';
    o.searchTrialSpec =
        buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec();
    o.trainTrialSpec =
        buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec();
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec(
    api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec o) {
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec <
      3) {
    checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec(
        o.metric!);
    unittest.expect(
      o.multiTrialAlgorithm!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec(
        o.searchTrialSpec!);
    checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec(
        o.trainTrialSpec!);
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec =
    0;
api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec
    buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec() {
  final o =
      api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec();
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec <
      3) {
    o.goal = 'foo';
    o.metricId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec(
    api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec o) {
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec <
      3) {
    unittest.expect(
      o.goal!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metricId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec =
    0;
api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec
    buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec() {
  final o = api
      .GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec();
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec <
      3) {
    o.maxFailedTrialCount = 42;
    o.maxParallelTrialCount = 42;
    o.maxTrialCount = 42;
    o.searchTrialJobSpec = buildGoogleCloudAiplatformV1CustomJobSpec();
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec(
    api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec
        o) {
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec <
      3) {
    unittest.expect(
      o.maxFailedTrialCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.maxParallelTrialCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.maxTrialCount!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1CustomJobSpec(o.searchTrialJobSpec!);
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec =
    0;
api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec
    buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec() {
  final o = api
      .GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec();
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec <
      3) {
    o.frequency = 42;
    o.maxParallelTrialCount = 42;
    o.trainTrialJobSpec = buildGoogleCloudAiplatformV1CustomJobSpec();
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec(
    api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec
        o) {
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec++;
  if (buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec <
      3) {
    unittest.expect(
      o.frequency!,
      unittest.equals(42),
    );
    unittest.expect(
      o.maxParallelTrialCount!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1CustomJobSpec(o.trainTrialJobSpec!);
  }
  buildCounterGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1NasTrial = 0;
api.GoogleCloudAiplatformV1NasTrial buildGoogleCloudAiplatformV1NasTrial() {
  final o = api.GoogleCloudAiplatformV1NasTrial();
  buildCounterGoogleCloudAiplatformV1NasTrial++;
  if (buildCounterGoogleCloudAiplatformV1NasTrial < 3) {
    o.endTime = 'foo';
    o.finalMeasurement = buildGoogleCloudAiplatformV1Measurement();
    o.id = 'foo';
    o.startTime = 'foo';
    o.state = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NasTrial--;
  return o;
}

void checkGoogleCloudAiplatformV1NasTrial(
    api.GoogleCloudAiplatformV1NasTrial o) {
  buildCounterGoogleCloudAiplatformV1NasTrial++;
  if (buildCounterGoogleCloudAiplatformV1NasTrial < 3) {
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1Measurement(o.finalMeasurement!);
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NasTrial--;
}

core.int buildCounterGoogleCloudAiplatformV1NasTrialDetail = 0;
api.GoogleCloudAiplatformV1NasTrialDetail
    buildGoogleCloudAiplatformV1NasTrialDetail() {
  final o = api.GoogleCloudAiplatformV1NasTrialDetail();
  buildCounterGoogleCloudAiplatformV1NasTrialDetail++;
  if (buildCounterGoogleCloudAiplatformV1NasTrialDetail < 3) {
    o.name = 'foo';
    o.parameters = 'foo';
    o.searchTrial = buildGoogleCloudAiplatformV1NasTrial();
    o.trainTrial = buildGoogleCloudAiplatformV1NasTrial();
  }
  buildCounterGoogleCloudAiplatformV1NasTrialDetail--;
  return o;
}

void checkGoogleCloudAiplatformV1NasTrialDetail(
    api.GoogleCloudAiplatformV1NasTrialDetail o) {
  buildCounterGoogleCloudAiplatformV1NasTrialDetail++;
  if (buildCounterGoogleCloudAiplatformV1NasTrialDetail < 3) {
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.parameters!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1NasTrial(o.searchTrial!);
    checkGoogleCloudAiplatformV1NasTrial(o.trainTrial!);
  }
  buildCounterGoogleCloudAiplatformV1NasTrialDetail--;
}

core.List<api.GoogleCloudAiplatformV1NearestNeighborQueryStringFilter>
    buildUnnamed222() => [
          buildGoogleCloudAiplatformV1NearestNeighborQueryStringFilter(),
          buildGoogleCloudAiplatformV1NearestNeighborQueryStringFilter(),
        ];

void checkUnnamed222(
    core.List<api.GoogleCloudAiplatformV1NearestNeighborQueryStringFilter> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NearestNeighborQueryStringFilter(o[0]);
  checkGoogleCloudAiplatformV1NearestNeighborQueryStringFilter(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1NearestNeighborQuery = 0;
api.GoogleCloudAiplatformV1NearestNeighborQuery
    buildGoogleCloudAiplatformV1NearestNeighborQuery() {
  final o = api.GoogleCloudAiplatformV1NearestNeighborQuery();
  buildCounterGoogleCloudAiplatformV1NearestNeighborQuery++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborQuery < 3) {
    o.embedding = buildGoogleCloudAiplatformV1NearestNeighborQueryEmbedding();
    o.entityId = 'foo';
    o.neighborCount = 42;
    o.parameters = buildGoogleCloudAiplatformV1NearestNeighborQueryParameters();
    o.perCrowdingAttributeNeighborCount = 42;
    o.stringFilters = buildUnnamed222();
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborQuery--;
  return o;
}

void checkGoogleCloudAiplatformV1NearestNeighborQuery(
    api.GoogleCloudAiplatformV1NearestNeighborQuery o) {
  buildCounterGoogleCloudAiplatformV1NearestNeighborQuery++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborQuery < 3) {
    checkGoogleCloudAiplatformV1NearestNeighborQueryEmbedding(o.embedding!);
    unittest.expect(
      o.entityId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.neighborCount!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1NearestNeighborQueryParameters(o.parameters!);
    unittest.expect(
      o.perCrowdingAttributeNeighborCount!,
      unittest.equals(42),
    );
    checkUnnamed222(o.stringFilters!);
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborQuery--;
}

core.List<core.double> buildUnnamed223() => [
      42.0,
      42.0,
    ];

void checkUnnamed223(core.List<core.double> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42.0),
  );
  unittest.expect(
    o[1],
    unittest.equals(42.0),
  );
}

core.int buildCounterGoogleCloudAiplatformV1NearestNeighborQueryEmbedding = 0;
api.GoogleCloudAiplatformV1NearestNeighborQueryEmbedding
    buildGoogleCloudAiplatformV1NearestNeighborQueryEmbedding() {
  final o = api.GoogleCloudAiplatformV1NearestNeighborQueryEmbedding();
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryEmbedding++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborQueryEmbedding < 3) {
    o.value = buildUnnamed223();
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryEmbedding--;
  return o;
}

void checkGoogleCloudAiplatformV1NearestNeighborQueryEmbedding(
    api.GoogleCloudAiplatformV1NearestNeighborQueryEmbedding o) {
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryEmbedding++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborQueryEmbedding < 3) {
    checkUnnamed223(o.value!);
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryEmbedding--;
}

core.int buildCounterGoogleCloudAiplatformV1NearestNeighborQueryParameters = 0;
api.GoogleCloudAiplatformV1NearestNeighborQueryParameters
    buildGoogleCloudAiplatformV1NearestNeighborQueryParameters() {
  final o = api.GoogleCloudAiplatformV1NearestNeighborQueryParameters();
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryParameters++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborQueryParameters < 3) {
    o.approximateNeighborCandidates = 42;
    o.leafNodesSearchFraction = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryParameters--;
  return o;
}

void checkGoogleCloudAiplatformV1NearestNeighborQueryParameters(
    api.GoogleCloudAiplatformV1NearestNeighborQueryParameters o) {
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryParameters++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborQueryParameters < 3) {
    unittest.expect(
      o.approximateNeighborCandidates!,
      unittest.equals(42),
    );
    unittest.expect(
      o.leafNodesSearchFraction!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryParameters--;
}

core.List<core.String> buildUnnamed224() => [
      'foo',
      'foo',
    ];

void checkUnnamed224(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed225() => [
      'foo',
      'foo',
    ];

void checkUnnamed225(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1NearestNeighborQueryStringFilter =
    0;
api.GoogleCloudAiplatformV1NearestNeighborQueryStringFilter
    buildGoogleCloudAiplatformV1NearestNeighborQueryStringFilter() {
  final o = api.GoogleCloudAiplatformV1NearestNeighborQueryStringFilter();
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryStringFilter++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborQueryStringFilter < 3) {
    o.allowTokens = buildUnnamed224();
    o.denyTokens = buildUnnamed225();
    o.name = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryStringFilter--;
  return o;
}

void checkGoogleCloudAiplatformV1NearestNeighborQueryStringFilter(
    api.GoogleCloudAiplatformV1NearestNeighborQueryStringFilter o) {
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryStringFilter++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborQueryStringFilter < 3) {
    checkUnnamed224(o.allowTokens!);
    checkUnnamed225(o.denyTokens!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborQueryStringFilter--;
}

core.List<api.GoogleCloudAiplatformV1NearestNeighborsNeighbor>
    buildUnnamed226() => [
          buildGoogleCloudAiplatformV1NearestNeighborsNeighbor(),
          buildGoogleCloudAiplatformV1NearestNeighborsNeighbor(),
        ];

void checkUnnamed226(
    core.List<api.GoogleCloudAiplatformV1NearestNeighborsNeighbor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NearestNeighborsNeighbor(o[0]);
  checkGoogleCloudAiplatformV1NearestNeighborsNeighbor(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1NearestNeighbors = 0;
api.GoogleCloudAiplatformV1NearestNeighbors
    buildGoogleCloudAiplatformV1NearestNeighbors() {
  final o = api.GoogleCloudAiplatformV1NearestNeighbors();
  buildCounterGoogleCloudAiplatformV1NearestNeighbors++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighbors < 3) {
    o.neighbors = buildUnnamed226();
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighbors--;
  return o;
}

void checkGoogleCloudAiplatformV1NearestNeighbors(
    api.GoogleCloudAiplatformV1NearestNeighbors o) {
  buildCounterGoogleCloudAiplatformV1NearestNeighbors++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighbors < 3) {
    checkUnnamed226(o.neighbors!);
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighbors--;
}

core.int buildCounterGoogleCloudAiplatformV1NearestNeighborsNeighbor = 0;
api.GoogleCloudAiplatformV1NearestNeighborsNeighbor
    buildGoogleCloudAiplatformV1NearestNeighborsNeighbor() {
  final o = api.GoogleCloudAiplatformV1NearestNeighborsNeighbor();
  buildCounterGoogleCloudAiplatformV1NearestNeighborsNeighbor++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborsNeighbor < 3) {
    o.distance = 42.0;
    o.entityId = 'foo';
    o.entityKeyValues =
        buildGoogleCloudAiplatformV1FetchFeatureValuesResponse();
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborsNeighbor--;
  return o;
}

void checkGoogleCloudAiplatformV1NearestNeighborsNeighbor(
    api.GoogleCloudAiplatformV1NearestNeighborsNeighbor o) {
  buildCounterGoogleCloudAiplatformV1NearestNeighborsNeighbor++;
  if (buildCounterGoogleCloudAiplatformV1NearestNeighborsNeighbor < 3) {
    unittest.expect(
      o.distance!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.entityId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FetchFeatureValuesResponse(o.entityKeyValues!);
  }
  buildCounterGoogleCloudAiplatformV1NearestNeighborsNeighbor--;
}

core.int buildCounterGoogleCloudAiplatformV1Neighbor = 0;
api.GoogleCloudAiplatformV1Neighbor buildGoogleCloudAiplatformV1Neighbor() {
  final o = api.GoogleCloudAiplatformV1Neighbor();
  buildCounterGoogleCloudAiplatformV1Neighbor++;
  if (buildCounterGoogleCloudAiplatformV1Neighbor < 3) {
    o.neighborDistance = 42.0;
    o.neighborId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Neighbor--;
  return o;
}

void checkGoogleCloudAiplatformV1Neighbor(
    api.GoogleCloudAiplatformV1Neighbor o) {
  buildCounterGoogleCloudAiplatformV1Neighbor++;
  if (buildCounterGoogleCloudAiplatformV1Neighbor < 3) {
    unittest.expect(
      o.neighborDistance!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.neighborId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Neighbor--;
}

core.int buildCounterGoogleCloudAiplatformV1NetworkSpec = 0;
api.GoogleCloudAiplatformV1NetworkSpec
    buildGoogleCloudAiplatformV1NetworkSpec() {
  final o = api.GoogleCloudAiplatformV1NetworkSpec();
  buildCounterGoogleCloudAiplatformV1NetworkSpec++;
  if (buildCounterGoogleCloudAiplatformV1NetworkSpec < 3) {
    o.enableInternetAccess = true;
    o.network = 'foo';
    o.subnetwork = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NetworkSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1NetworkSpec(
    api.GoogleCloudAiplatformV1NetworkSpec o) {
  buildCounterGoogleCloudAiplatformV1NetworkSpec++;
  if (buildCounterGoogleCloudAiplatformV1NetworkSpec < 3) {
    unittest.expect(o.enableInternetAccess!, unittest.isTrue);
    unittest.expect(
      o.network!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.subnetwork!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NetworkSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1NfsMount = 0;
api.GoogleCloudAiplatformV1NfsMount buildGoogleCloudAiplatformV1NfsMount() {
  final o = api.GoogleCloudAiplatformV1NfsMount();
  buildCounterGoogleCloudAiplatformV1NfsMount++;
  if (buildCounterGoogleCloudAiplatformV1NfsMount < 3) {
    o.mountPoint = 'foo';
    o.path = 'foo';
    o.server = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NfsMount--;
  return o;
}

void checkGoogleCloudAiplatformV1NfsMount(
    api.GoogleCloudAiplatformV1NfsMount o) {
  buildCounterGoogleCloudAiplatformV1NfsMount++;
  if (buildCounterGoogleCloudAiplatformV1NfsMount < 3) {
    unittest.expect(
      o.mountPoint!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.path!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.server!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NfsMount--;
}

core.int buildCounterGoogleCloudAiplatformV1NotebookEucConfig = 0;
api.GoogleCloudAiplatformV1NotebookEucConfig
    buildGoogleCloudAiplatformV1NotebookEucConfig() {
  final o = api.GoogleCloudAiplatformV1NotebookEucConfig();
  buildCounterGoogleCloudAiplatformV1NotebookEucConfig++;
  if (buildCounterGoogleCloudAiplatformV1NotebookEucConfig < 3) {
    o.bypassActasCheck = true;
    o.eucDisabled = true;
  }
  buildCounterGoogleCloudAiplatformV1NotebookEucConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1NotebookEucConfig(
    api.GoogleCloudAiplatformV1NotebookEucConfig o) {
  buildCounterGoogleCloudAiplatformV1NotebookEucConfig++;
  if (buildCounterGoogleCloudAiplatformV1NotebookEucConfig < 3) {
    unittest.expect(o.bypassActasCheck!, unittest.isTrue);
    unittest.expect(o.eucDisabled!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1NotebookEucConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1NotebookIdleShutdownConfig = 0;
api.GoogleCloudAiplatformV1NotebookIdleShutdownConfig
    buildGoogleCloudAiplatformV1NotebookIdleShutdownConfig() {
  final o = api.GoogleCloudAiplatformV1NotebookIdleShutdownConfig();
  buildCounterGoogleCloudAiplatformV1NotebookIdleShutdownConfig++;
  if (buildCounterGoogleCloudAiplatformV1NotebookIdleShutdownConfig < 3) {
    o.idleShutdownDisabled = true;
    o.idleTimeout = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NotebookIdleShutdownConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1NotebookIdleShutdownConfig(
    api.GoogleCloudAiplatformV1NotebookIdleShutdownConfig o) {
  buildCounterGoogleCloudAiplatformV1NotebookIdleShutdownConfig++;
  if (buildCounterGoogleCloudAiplatformV1NotebookIdleShutdownConfig < 3) {
    unittest.expect(o.idleShutdownDisabled!, unittest.isTrue);
    unittest.expect(
      o.idleTimeout!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NotebookIdleShutdownConfig--;
}

core.List<core.String> buildUnnamed227() => [
      'foo',
      'foo',
    ];

void checkUnnamed227(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1NotebookReservationAffinity = 0;
api.GoogleCloudAiplatformV1NotebookReservationAffinity
    buildGoogleCloudAiplatformV1NotebookReservationAffinity() {
  final o = api.GoogleCloudAiplatformV1NotebookReservationAffinity();
  buildCounterGoogleCloudAiplatformV1NotebookReservationAffinity++;
  if (buildCounterGoogleCloudAiplatformV1NotebookReservationAffinity < 3) {
    o.consumeReservationType = 'foo';
    o.key = 'foo';
    o.values = buildUnnamed227();
  }
  buildCounterGoogleCloudAiplatformV1NotebookReservationAffinity--;
  return o;
}

void checkGoogleCloudAiplatformV1NotebookReservationAffinity(
    api.GoogleCloudAiplatformV1NotebookReservationAffinity o) {
  buildCounterGoogleCloudAiplatformV1NotebookReservationAffinity++;
  if (buildCounterGoogleCloudAiplatformV1NotebookReservationAffinity < 3) {
    unittest.expect(
      o.consumeReservationType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.key!,
      unittest.equals('foo'),
    );
    checkUnnamed227(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1NotebookReservationAffinity--;
}

core.Map<core.String, core.String> buildUnnamed228() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed228(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed229() => [
      'foo',
      'foo',
    ];

void checkUnnamed229(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1NotebookRuntime = 0;
api.GoogleCloudAiplatformV1NotebookRuntime
    buildGoogleCloudAiplatformV1NotebookRuntime() {
  final o = api.GoogleCloudAiplatformV1NotebookRuntime();
  buildCounterGoogleCloudAiplatformV1NotebookRuntime++;
  if (buildCounterGoogleCloudAiplatformV1NotebookRuntime < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.expirationTime = 'foo';
    o.healthState = 'foo';
    o.isUpgradable = true;
    o.labels = buildUnnamed228();
    o.name = 'foo';
    o.networkTags = buildUnnamed229();
    o.notebookRuntimeTemplateRef =
        buildGoogleCloudAiplatformV1NotebookRuntimeTemplateRef();
    o.notebookRuntimeType = 'foo';
    o.proxyUri = 'foo';
    o.reservationAffinity =
        buildGoogleCloudAiplatformV1NotebookReservationAffinity();
    o.runtimeState = 'foo';
    o.runtimeUser = 'foo';
    o.serviceAccount = 'foo';
    o.updateTime = 'foo';
    o.version = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NotebookRuntime--;
  return o;
}

void checkGoogleCloudAiplatformV1NotebookRuntime(
    api.GoogleCloudAiplatformV1NotebookRuntime o) {
  buildCounterGoogleCloudAiplatformV1NotebookRuntime++;
  if (buildCounterGoogleCloudAiplatformV1NotebookRuntime < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.expirationTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.healthState!,
      unittest.equals('foo'),
    );
    unittest.expect(o.isUpgradable!, unittest.isTrue);
    checkUnnamed228(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed229(o.networkTags!);
    checkGoogleCloudAiplatformV1NotebookRuntimeTemplateRef(
        o.notebookRuntimeTemplateRef!);
    unittest.expect(
      o.notebookRuntimeType!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.proxyUri!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1NotebookReservationAffinity(
        o.reservationAffinity!);
    unittest.expect(
      o.runtimeState!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.runtimeUser!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.serviceAccount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.version!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NotebookRuntime--;
}

core.Map<core.String, core.String> buildUnnamed230() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed230(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed231() => [
      'foo',
      'foo',
    ];

void checkUnnamed231(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplate = 0;
api.GoogleCloudAiplatformV1NotebookRuntimeTemplate
    buildGoogleCloudAiplatformV1NotebookRuntimeTemplate() {
  final o = api.GoogleCloudAiplatformV1NotebookRuntimeTemplate();
  buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplate++;
  if (buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplate < 3) {
    o.createTime = 'foo';
    o.dataPersistentDiskSpec = buildGoogleCloudAiplatformV1PersistentDiskSpec();
    o.description = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.eucConfig = buildGoogleCloudAiplatformV1NotebookEucConfig();
    o.idleShutdownConfig =
        buildGoogleCloudAiplatformV1NotebookIdleShutdownConfig();
    o.isDefault = true;
    o.labels = buildUnnamed230();
    o.machineSpec = buildGoogleCloudAiplatformV1MachineSpec();
    o.name = 'foo';
    o.networkSpec = buildGoogleCloudAiplatformV1NetworkSpec();
    o.networkTags = buildUnnamed231();
    o.notebookRuntimeType = 'foo';
    o.reservationAffinity =
        buildGoogleCloudAiplatformV1NotebookReservationAffinity();
    o.serviceAccount = 'foo';
    o.shieldedVmConfig = buildGoogleCloudAiplatformV1ShieldedVmConfig();
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplate--;
  return o;
}

void checkGoogleCloudAiplatformV1NotebookRuntimeTemplate(
    api.GoogleCloudAiplatformV1NotebookRuntimeTemplate o) {
  buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplate++;
  if (buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplate < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PersistentDiskSpec(o.dataPersistentDiskSpec!);
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1NotebookEucConfig(o.eucConfig!);
    checkGoogleCloudAiplatformV1NotebookIdleShutdownConfig(
        o.idleShutdownConfig!);
    unittest.expect(o.isDefault!, unittest.isTrue);
    checkUnnamed230(o.labels!);
    checkGoogleCloudAiplatformV1MachineSpec(o.machineSpec!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1NetworkSpec(o.networkSpec!);
    checkUnnamed231(o.networkTags!);
    unittest.expect(
      o.notebookRuntimeType!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1NotebookReservationAffinity(
        o.reservationAffinity!);
    unittest.expect(
      o.serviceAccount!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ShieldedVmConfig(o.shieldedVmConfig!);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplate--;
}

core.int buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplateRef = 0;
api.GoogleCloudAiplatformV1NotebookRuntimeTemplateRef
    buildGoogleCloudAiplatformV1NotebookRuntimeTemplateRef() {
  final o = api.GoogleCloudAiplatformV1NotebookRuntimeTemplateRef();
  buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplateRef++;
  if (buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplateRef < 3) {
    o.notebookRuntimeTemplate = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplateRef--;
  return o;
}

void checkGoogleCloudAiplatformV1NotebookRuntimeTemplateRef(
    api.GoogleCloudAiplatformV1NotebookRuntimeTemplateRef o) {
  buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplateRef++;
  if (buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplateRef < 3) {
    unittest.expect(
      o.notebookRuntimeTemplate!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1NotebookRuntimeTemplateRef--;
}

core.int buildCounterGoogleCloudAiplatformV1Part = 0;
api.GoogleCloudAiplatformV1Part buildGoogleCloudAiplatformV1Part() {
  final o = api.GoogleCloudAiplatformV1Part();
  buildCounterGoogleCloudAiplatformV1Part++;
  if (buildCounterGoogleCloudAiplatformV1Part < 3) {
    o.fileData = buildGoogleCloudAiplatformV1FileData();
    o.functionCall = buildGoogleCloudAiplatformV1FunctionCall();
    o.functionResponse = buildGoogleCloudAiplatformV1FunctionResponse();
    o.inlineData = buildGoogleCloudAiplatformV1Blob();
    o.text = 'foo';
    o.videoMetadata = buildGoogleCloudAiplatformV1VideoMetadata();
  }
  buildCounterGoogleCloudAiplatformV1Part--;
  return o;
}

void checkGoogleCloudAiplatformV1Part(api.GoogleCloudAiplatformV1Part o) {
  buildCounterGoogleCloudAiplatformV1Part++;
  if (buildCounterGoogleCloudAiplatformV1Part < 3) {
    checkGoogleCloudAiplatformV1FileData(o.fileData!);
    checkGoogleCloudAiplatformV1FunctionCall(o.functionCall!);
    checkGoogleCloudAiplatformV1FunctionResponse(o.functionResponse!);
    checkGoogleCloudAiplatformV1Blob(o.inlineData!);
    unittest.expect(
      o.text!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1VideoMetadata(o.videoMetadata!);
  }
  buildCounterGoogleCloudAiplatformV1Part--;
}

core.int
    buildCounterGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest =
    0;
api.GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest
    buildGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest() {
  final o =
      api.GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest();
  buildCounterGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest <
      3) {}
  buildCounterGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest(
    api.GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest o) {
  buildCounterGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest <
      3) {}
  buildCounterGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1PauseScheduleRequest = 0;
api.GoogleCloudAiplatformV1PauseScheduleRequest
    buildGoogleCloudAiplatformV1PauseScheduleRequest() {
  final o = api.GoogleCloudAiplatformV1PauseScheduleRequest();
  buildCounterGoogleCloudAiplatformV1PauseScheduleRequest++;
  if (buildCounterGoogleCloudAiplatformV1PauseScheduleRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1PauseScheduleRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1PauseScheduleRequest(
    api.GoogleCloudAiplatformV1PauseScheduleRequest o) {
  buildCounterGoogleCloudAiplatformV1PauseScheduleRequest++;
  if (buildCounterGoogleCloudAiplatformV1PauseScheduleRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1PauseScheduleRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1PersistentDiskSpec = 0;
api.GoogleCloudAiplatformV1PersistentDiskSpec
    buildGoogleCloudAiplatformV1PersistentDiskSpec() {
  final o = api.GoogleCloudAiplatformV1PersistentDiskSpec();
  buildCounterGoogleCloudAiplatformV1PersistentDiskSpec++;
  if (buildCounterGoogleCloudAiplatformV1PersistentDiskSpec < 3) {
    o.diskSizeGb = 'foo';
    o.diskType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PersistentDiskSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1PersistentDiskSpec(
    api.GoogleCloudAiplatformV1PersistentDiskSpec o) {
  buildCounterGoogleCloudAiplatformV1PersistentDiskSpec++;
  if (buildCounterGoogleCloudAiplatformV1PersistentDiskSpec < 3) {
    unittest.expect(
      o.diskSizeGb!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.diskType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PersistentDiskSpec--;
}

core.Map<core.String, core.String> buildUnnamed232() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed232(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.Object?> buildUnnamed233() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed233(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted52 = (o['x']!) as core.Map;
  unittest.expect(casted52, unittest.hasLength(3));
  unittest.expect(
    casted52['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted52['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted52['string'],
    unittest.equals('foo'),
  );
  var casted53 = (o['y']!) as core.Map;
  unittest.expect(casted53, unittest.hasLength(3));
  unittest.expect(
    casted53['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted53['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted53['string'],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed234() => [
      'foo',
      'foo',
    ];

void checkUnnamed234(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1PipelineJob = 0;
api.GoogleCloudAiplatformV1PipelineJob
    buildGoogleCloudAiplatformV1PipelineJob() {
  final o = api.GoogleCloudAiplatformV1PipelineJob();
  buildCounterGoogleCloudAiplatformV1PipelineJob++;
  if (buildCounterGoogleCloudAiplatformV1PipelineJob < 3) {
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.endTime = 'foo';
    o.error = buildGoogleRpcStatus();
    o.jobDetail = buildGoogleCloudAiplatformV1PipelineJobDetail();
    o.labels = buildUnnamed232();
    o.name = 'foo';
    o.network = 'foo';
    o.pipelineSpec = buildUnnamed233();
    o.reservedIpRanges = buildUnnamed234();
    o.runtimeConfig = buildGoogleCloudAiplatformV1PipelineJobRuntimeConfig();
    o.scheduleName = 'foo';
    o.serviceAccount = 'foo';
    o.startTime = 'foo';
    o.state = 'foo';
    o.templateMetadata = buildGoogleCloudAiplatformV1PipelineTemplateMetadata();
    o.templateUri = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PipelineJob--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineJob(
    api.GoogleCloudAiplatformV1PipelineJob o) {
  buildCounterGoogleCloudAiplatformV1PipelineJob++;
  if (buildCounterGoogleCloudAiplatformV1PipelineJob < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.error!);
    checkGoogleCloudAiplatformV1PipelineJobDetail(o.jobDetail!);
    checkUnnamed232(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.network!,
      unittest.equals('foo'),
    );
    checkUnnamed233(o.pipelineSpec!);
    checkUnnamed234(o.reservedIpRanges!);
    checkGoogleCloudAiplatformV1PipelineJobRuntimeConfig(o.runtimeConfig!);
    unittest.expect(
      o.scheduleName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.serviceAccount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PipelineTemplateMetadata(o.templateMetadata!);
    unittest.expect(
      o.templateUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PipelineJob--;
}

core.List<api.GoogleCloudAiplatformV1PipelineTaskDetail> buildUnnamed235() => [
      buildGoogleCloudAiplatformV1PipelineTaskDetail(),
      buildGoogleCloudAiplatformV1PipelineTaskDetail(),
    ];

void checkUnnamed235(
    core.List<api.GoogleCloudAiplatformV1PipelineTaskDetail> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PipelineTaskDetail(o[0]);
  checkGoogleCloudAiplatformV1PipelineTaskDetail(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1PipelineJobDetail = 0;
api.GoogleCloudAiplatformV1PipelineJobDetail
    buildGoogleCloudAiplatformV1PipelineJobDetail() {
  final o = api.GoogleCloudAiplatformV1PipelineJobDetail();
  buildCounterGoogleCloudAiplatformV1PipelineJobDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineJobDetail < 3) {
    o.pipelineContext = buildGoogleCloudAiplatformV1Context();
    o.pipelineRunContext = buildGoogleCloudAiplatformV1Context();
    o.taskDetails = buildUnnamed235();
  }
  buildCounterGoogleCloudAiplatformV1PipelineJobDetail--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineJobDetail(
    api.GoogleCloudAiplatformV1PipelineJobDetail o) {
  buildCounterGoogleCloudAiplatformV1PipelineJobDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineJobDetail < 3) {
    checkGoogleCloudAiplatformV1Context(o.pipelineContext!);
    checkGoogleCloudAiplatformV1Context(o.pipelineRunContext!);
    checkUnnamed235(o.taskDetails!);
  }
  buildCounterGoogleCloudAiplatformV1PipelineJobDetail--;
}

core.Map<core.String,
        api.GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact>
    buildUnnamed236() => {
          'x':
              buildGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact(),
          'y':
              buildGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact(),
        };

void checkUnnamed236(
    core.Map<core.String,
            api.GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact(o['x']!);
  checkGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact(o['y']!);
}

core.Map<core.String, core.Object?> buildUnnamed237() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed237(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted54 = (o['x']!) as core.Map;
  unittest.expect(casted54, unittest.hasLength(3));
  unittest.expect(
    casted54['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted54['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted54['string'],
    unittest.equals('foo'),
  );
  var casted55 = (o['y']!) as core.Map;
  unittest.expect(casted55, unittest.hasLength(3));
  unittest.expect(
    casted55['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted55['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted55['string'],
    unittest.equals('foo'),
  );
}

core.Map<core.String, api.GoogleCloudAiplatformV1Value> buildUnnamed238() => {
      'x': buildGoogleCloudAiplatformV1Value(),
      'y': buildGoogleCloudAiplatformV1Value(),
    };

void checkUnnamed238(
    core.Map<core.String, api.GoogleCloudAiplatformV1Value> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Value(o['x']!);
  checkGoogleCloudAiplatformV1Value(o['y']!);
}

core.int buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfig = 0;
api.GoogleCloudAiplatformV1PipelineJobRuntimeConfig
    buildGoogleCloudAiplatformV1PipelineJobRuntimeConfig() {
  final o = api.GoogleCloudAiplatformV1PipelineJobRuntimeConfig();
  buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfig++;
  if (buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfig < 3) {
    o.failurePolicy = 'foo';
    o.gcsOutputDirectory = 'foo';
    o.inputArtifacts = buildUnnamed236();
    o.parameterValues = buildUnnamed237();
    o.parameters = buildUnnamed238();
  }
  buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineJobRuntimeConfig(
    api.GoogleCloudAiplatformV1PipelineJobRuntimeConfig o) {
  buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfig++;
  if (buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfig < 3) {
    unittest.expect(
      o.failurePolicy!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.gcsOutputDirectory!,
      unittest.equals('foo'),
    );
    checkUnnamed236(o.inputArtifacts!);
    checkUnnamed237(o.parameterValues!);
    checkUnnamed238(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfig--;
}

core.int
    buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact =
    0;
api.GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact
    buildGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact() {
  final o = api.GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact();
  buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact++;
  if (buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact <
      3) {
    o.artifactId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact(
    api.GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact o) {
  buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact++;
  if (buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact <
      3) {
    unittest.expect(
      o.artifactId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact--;
}

core.Map<core.String, api.GoogleCloudAiplatformV1PipelineTaskDetailArtifactList>
    buildUnnamed239() => {
          'x': buildGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(),
          'y': buildGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(),
        };

void checkUnnamed239(
    core.Map<core.String,
            api.GoogleCloudAiplatformV1PipelineTaskDetailArtifactList>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(o['x']!);
  checkGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(o['y']!);
}

core.Map<core.String, api.GoogleCloudAiplatformV1PipelineTaskDetailArtifactList>
    buildUnnamed240() => {
          'x': buildGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(),
          'y': buildGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(),
        };

void checkUnnamed240(
    core.Map<core.String,
            api.GoogleCloudAiplatformV1PipelineTaskDetailArtifactList>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(o['x']!);
  checkGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(o['y']!);
}

core.List<api.GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus>
    buildUnnamed241() => [
          buildGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus(),
          buildGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus(),
        ];

void checkUnnamed241(
    core.List<api.GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus(o[0]);
  checkGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1PipelineTaskDetail = 0;
api.GoogleCloudAiplatformV1PipelineTaskDetail
    buildGoogleCloudAiplatformV1PipelineTaskDetail() {
  final o = api.GoogleCloudAiplatformV1PipelineTaskDetail();
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskDetail < 3) {
    o.createTime = 'foo';
    o.endTime = 'foo';
    o.error = buildGoogleRpcStatus();
    o.execution = buildGoogleCloudAiplatformV1Execution();
    o.executorDetail = buildGoogleCloudAiplatformV1PipelineTaskExecutorDetail();
    o.inputs = buildUnnamed239();
    o.outputs = buildUnnamed240();
    o.parentTaskId = 'foo';
    o.pipelineTaskStatus = buildUnnamed241();
    o.startTime = 'foo';
    o.state = 'foo';
    o.taskId = 'foo';
    o.taskName = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetail--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineTaskDetail(
    api.GoogleCloudAiplatformV1PipelineTaskDetail o) {
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskDetail < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.error!);
    checkGoogleCloudAiplatformV1Execution(o.execution!);
    checkGoogleCloudAiplatformV1PipelineTaskExecutorDetail(o.executorDetail!);
    checkUnnamed239(o.inputs!);
    checkUnnamed240(o.outputs!);
    unittest.expect(
      o.parentTaskId!,
      unittest.equals('foo'),
    );
    checkUnnamed241(o.pipelineTaskStatus!);
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.taskId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.taskName!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetail--;
}

core.List<api.GoogleCloudAiplatformV1Artifact> buildUnnamed242() => [
      buildGoogleCloudAiplatformV1Artifact(),
      buildGoogleCloudAiplatformV1Artifact(),
    ];

void checkUnnamed242(core.List<api.GoogleCloudAiplatformV1Artifact> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Artifact(o[0]);
  checkGoogleCloudAiplatformV1Artifact(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1PipelineTaskDetailArtifactList = 0;
api.GoogleCloudAiplatformV1PipelineTaskDetailArtifactList
    buildGoogleCloudAiplatformV1PipelineTaskDetailArtifactList() {
  final o = api.GoogleCloudAiplatformV1PipelineTaskDetailArtifactList();
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetailArtifactList++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskDetailArtifactList < 3) {
    o.artifacts = buildUnnamed242();
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetailArtifactList--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(
    api.GoogleCloudAiplatformV1PipelineTaskDetailArtifactList o) {
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetailArtifactList++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskDetailArtifactList < 3) {
    checkUnnamed242(o.artifacts!);
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetailArtifactList--;
}

core.int
    buildCounterGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus = 0;
api.GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus
    buildGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus() {
  final o = api.GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus();
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus <
      3) {
    o.error = buildGoogleRpcStatus();
    o.state = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus(
    api.GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus o) {
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus <
      3) {
    checkGoogleRpcStatus(o.error!);
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus--;
}

core.int buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetail = 0;
api.GoogleCloudAiplatformV1PipelineTaskExecutorDetail
    buildGoogleCloudAiplatformV1PipelineTaskExecutorDetail() {
  final o = api.GoogleCloudAiplatformV1PipelineTaskExecutorDetail();
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetail < 3) {
    o.containerDetail =
        buildGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail();
    o.customJobDetail =
        buildGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail();
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetail--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineTaskExecutorDetail(
    api.GoogleCloudAiplatformV1PipelineTaskExecutorDetail o) {
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetail < 3) {
    checkGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail(
        o.containerDetail!);
    checkGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail(
        o.customJobDetail!);
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetail--;
}

core.List<core.String> buildUnnamed243() => [
      'foo',
      'foo',
    ];

void checkUnnamed243(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed244() => [
      'foo',
      'foo',
    ];

void checkUnnamed244(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail =
    0;
api.GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail
    buildGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail() {
  final o =
      api.GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail();
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail <
      3) {
    o.failedMainJobs = buildUnnamed243();
    o.failedPreCachingCheckJobs = buildUnnamed244();
    o.mainJob = 'foo';
    o.preCachingCheckJob = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail(
    api.GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail o) {
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail <
      3) {
    checkUnnamed243(o.failedMainJobs!);
    checkUnnamed244(o.failedPreCachingCheckJobs!);
    unittest.expect(
      o.mainJob!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.preCachingCheckJob!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail--;
}

core.List<core.String> buildUnnamed245() => [
      'foo',
      'foo',
    ];

void checkUnnamed245(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail =
    0;
api.GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail
    buildGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail() {
  final o =
      api.GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail();
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail <
      3) {
    o.failedJobs = buildUnnamed245();
    o.job = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail(
    api.GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail o) {
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail <
      3) {
    checkUnnamed245(o.failedJobs!);
    unittest.expect(
      o.job!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail--;
}

core.int buildCounterGoogleCloudAiplatformV1PipelineTemplateMetadata = 0;
api.GoogleCloudAiplatformV1PipelineTemplateMetadata
    buildGoogleCloudAiplatformV1PipelineTemplateMetadata() {
  final o = api.GoogleCloudAiplatformV1PipelineTemplateMetadata();
  buildCounterGoogleCloudAiplatformV1PipelineTemplateMetadata++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTemplateMetadata < 3) {
    o.version = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PipelineTemplateMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1PipelineTemplateMetadata(
    api.GoogleCloudAiplatformV1PipelineTemplateMetadata o) {
  buildCounterGoogleCloudAiplatformV1PipelineTemplateMetadata++;
  if (buildCounterGoogleCloudAiplatformV1PipelineTemplateMetadata < 3) {
    unittest.expect(
      o.version!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PipelineTemplateMetadata--;
}

core.int buildCounterGoogleCloudAiplatformV1Port = 0;
api.GoogleCloudAiplatformV1Port buildGoogleCloudAiplatformV1Port() {
  final o = api.GoogleCloudAiplatformV1Port();
  buildCounterGoogleCloudAiplatformV1Port++;
  if (buildCounterGoogleCloudAiplatformV1Port < 3) {
    o.containerPort = 42;
  }
  buildCounterGoogleCloudAiplatformV1Port--;
  return o;
}

void checkGoogleCloudAiplatformV1Port(api.GoogleCloudAiplatformV1Port o) {
  buildCounterGoogleCloudAiplatformV1Port++;
  if (buildCounterGoogleCloudAiplatformV1Port < 3) {
    unittest.expect(
      o.containerPort!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1Port--;
}

core.int buildCounterGoogleCloudAiplatformV1PredefinedSplit = 0;
api.GoogleCloudAiplatformV1PredefinedSplit
    buildGoogleCloudAiplatformV1PredefinedSplit() {
  final o = api.GoogleCloudAiplatformV1PredefinedSplit();
  buildCounterGoogleCloudAiplatformV1PredefinedSplit++;
  if (buildCounterGoogleCloudAiplatformV1PredefinedSplit < 3) {
    o.key = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PredefinedSplit--;
  return o;
}

void checkGoogleCloudAiplatformV1PredefinedSplit(
    api.GoogleCloudAiplatformV1PredefinedSplit o) {
  buildCounterGoogleCloudAiplatformV1PredefinedSplit++;
  if (buildCounterGoogleCloudAiplatformV1PredefinedSplit < 3) {
    unittest.expect(
      o.key!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PredefinedSplit--;
}

core.List<core.Object?> buildUnnamed246() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed246(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted56 = (o[0]) as core.Map;
  unittest.expect(casted56, unittest.hasLength(3));
  unittest.expect(
    casted56['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted56['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted56['string'],
    unittest.equals('foo'),
  );
  var casted57 = (o[1]) as core.Map;
  unittest.expect(casted57, unittest.hasLength(3));
  unittest.expect(
    casted57['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted57['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted57['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1PredictRequest = 0;
api.GoogleCloudAiplatformV1PredictRequest
    buildGoogleCloudAiplatformV1PredictRequest() {
  final o = api.GoogleCloudAiplatformV1PredictRequest();
  buildCounterGoogleCloudAiplatformV1PredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1PredictRequest < 3) {
    o.instances = buildUnnamed246();
    o.parameters = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
  }
  buildCounterGoogleCloudAiplatformV1PredictRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1PredictRequest(
    api.GoogleCloudAiplatformV1PredictRequest o) {
  buildCounterGoogleCloudAiplatformV1PredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1PredictRequest < 3) {
    checkUnnamed246(o.instances!);
    var casted58 = (o.parameters!) as core.Map;
    unittest.expect(casted58, unittest.hasLength(3));
    unittest.expect(
      casted58['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted58['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted58['string'],
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PredictRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig = 0;
api.GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig
    buildGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig() {
  final o = api.GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig();
  buildCounterGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig++;
  if (buildCounterGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig <
      3) {
    o.bigqueryDestination = buildGoogleCloudAiplatformV1BigQueryDestination();
    o.enabled = true;
    o.samplingRate = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig(
    api.GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig o) {
  buildCounterGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig++;
  if (buildCounterGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig <
      3) {
    checkGoogleCloudAiplatformV1BigQueryDestination(o.bigqueryDestination!);
    unittest.expect(o.enabled!, unittest.isTrue);
    unittest.expect(
      o.samplingRate!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig--;
}

core.List<core.Object?> buildUnnamed247() => [
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    ];

void checkUnnamed247(core.List<core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted59 = (o[0]) as core.Map;
  unittest.expect(casted59, unittest.hasLength(3));
  unittest.expect(
    casted59['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted59['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted59['string'],
    unittest.equals('foo'),
  );
  var casted60 = (o[1]) as core.Map;
  unittest.expect(casted60, unittest.hasLength(3));
  unittest.expect(
    casted60['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted60['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted60['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1PredictResponse = 0;
api.GoogleCloudAiplatformV1PredictResponse
    buildGoogleCloudAiplatformV1PredictResponse() {
  final o = api.GoogleCloudAiplatformV1PredictResponse();
  buildCounterGoogleCloudAiplatformV1PredictResponse++;
  if (buildCounterGoogleCloudAiplatformV1PredictResponse < 3) {
    o.deployedModelId = 'foo';
    o.metadata = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.model = 'foo';
    o.modelDisplayName = 'foo';
    o.modelVersionId = 'foo';
    o.predictions = buildUnnamed247();
  }
  buildCounterGoogleCloudAiplatformV1PredictResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1PredictResponse(
    api.GoogleCloudAiplatformV1PredictResponse o) {
  buildCounterGoogleCloudAiplatformV1PredictResponse++;
  if (buildCounterGoogleCloudAiplatformV1PredictResponse < 3) {
    unittest.expect(
      o.deployedModelId!,
      unittest.equals('foo'),
    );
    var casted61 = (o.metadata!) as core.Map;
    unittest.expect(casted61, unittest.hasLength(3));
    unittest.expect(
      casted61['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted61['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted61['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.model!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modelDisplayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.modelVersionId!,
      unittest.equals('foo'),
    );
    checkUnnamed247(o.predictions!);
  }
  buildCounterGoogleCloudAiplatformV1PredictResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1PredictSchemata = 0;
api.GoogleCloudAiplatformV1PredictSchemata
    buildGoogleCloudAiplatformV1PredictSchemata() {
  final o = api.GoogleCloudAiplatformV1PredictSchemata();
  buildCounterGoogleCloudAiplatformV1PredictSchemata++;
  if (buildCounterGoogleCloudAiplatformV1PredictSchemata < 3) {
    o.instanceSchemaUri = 'foo';
    o.parametersSchemaUri = 'foo';
    o.predictionSchemaUri = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PredictSchemata--;
  return o;
}

void checkGoogleCloudAiplatformV1PredictSchemata(
    api.GoogleCloudAiplatformV1PredictSchemata o) {
  buildCounterGoogleCloudAiplatformV1PredictSchemata++;
  if (buildCounterGoogleCloudAiplatformV1PredictSchemata < 3) {
    unittest.expect(
      o.instanceSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.parametersSchemaUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.predictionSchemaUri!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PredictSchemata--;
}

core.int buildCounterGoogleCloudAiplatformV1Presets = 0;
api.GoogleCloudAiplatformV1Presets buildGoogleCloudAiplatformV1Presets() {
  final o = api.GoogleCloudAiplatformV1Presets();
  buildCounterGoogleCloudAiplatformV1Presets++;
  if (buildCounterGoogleCloudAiplatformV1Presets < 3) {
    o.modality = 'foo';
    o.query = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Presets--;
  return o;
}

void checkGoogleCloudAiplatformV1Presets(api.GoogleCloudAiplatformV1Presets o) {
  buildCounterGoogleCloudAiplatformV1Presets++;
  if (buildCounterGoogleCloudAiplatformV1Presets < 3) {
    unittest.expect(
      o.modality!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.query!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Presets--;
}

core.int buildCounterGoogleCloudAiplatformV1PrivateEndpoints = 0;
api.GoogleCloudAiplatformV1PrivateEndpoints
    buildGoogleCloudAiplatformV1PrivateEndpoints() {
  final o = api.GoogleCloudAiplatformV1PrivateEndpoints();
  buildCounterGoogleCloudAiplatformV1PrivateEndpoints++;
  if (buildCounterGoogleCloudAiplatformV1PrivateEndpoints < 3) {
    o.explainHttpUri = 'foo';
    o.healthHttpUri = 'foo';
    o.predictHttpUri = 'foo';
    o.serviceAttachment = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PrivateEndpoints--;
  return o;
}

void checkGoogleCloudAiplatformV1PrivateEndpoints(
    api.GoogleCloudAiplatformV1PrivateEndpoints o) {
  buildCounterGoogleCloudAiplatformV1PrivateEndpoints++;
  if (buildCounterGoogleCloudAiplatformV1PrivateEndpoints < 3) {
    unittest.expect(
      o.explainHttpUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.healthHttpUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.predictHttpUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.serviceAttachment!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PrivateEndpoints--;
}

core.List<core.String> buildUnnamed248() => [
      'foo',
      'foo',
    ];

void checkUnnamed248(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1PrivateServiceConnectConfig = 0;
api.GoogleCloudAiplatformV1PrivateServiceConnectConfig
    buildGoogleCloudAiplatformV1PrivateServiceConnectConfig() {
  final o = api.GoogleCloudAiplatformV1PrivateServiceConnectConfig();
  buildCounterGoogleCloudAiplatformV1PrivateServiceConnectConfig++;
  if (buildCounterGoogleCloudAiplatformV1PrivateServiceConnectConfig < 3) {
    o.enablePrivateServiceConnect = true;
    o.projectAllowlist = buildUnnamed248();
  }
  buildCounterGoogleCloudAiplatformV1PrivateServiceConnectConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1PrivateServiceConnectConfig(
    api.GoogleCloudAiplatformV1PrivateServiceConnectConfig o) {
  buildCounterGoogleCloudAiplatformV1PrivateServiceConnectConfig++;
  if (buildCounterGoogleCloudAiplatformV1PrivateServiceConnectConfig < 3) {
    unittest.expect(o.enablePrivateServiceConnect!, unittest.isTrue);
    checkUnnamed248(o.projectAllowlist!);
  }
  buildCounterGoogleCloudAiplatformV1PrivateServiceConnectConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1Probe = 0;
api.GoogleCloudAiplatformV1Probe buildGoogleCloudAiplatformV1Probe() {
  final o = api.GoogleCloudAiplatformV1Probe();
  buildCounterGoogleCloudAiplatformV1Probe++;
  if (buildCounterGoogleCloudAiplatformV1Probe < 3) {
    o.exec = buildGoogleCloudAiplatformV1ProbeExecAction();
    o.periodSeconds = 42;
    o.timeoutSeconds = 42;
  }
  buildCounterGoogleCloudAiplatformV1Probe--;
  return o;
}

void checkGoogleCloudAiplatformV1Probe(api.GoogleCloudAiplatformV1Probe o) {
  buildCounterGoogleCloudAiplatformV1Probe++;
  if (buildCounterGoogleCloudAiplatformV1Probe < 3) {
    checkGoogleCloudAiplatformV1ProbeExecAction(o.exec!);
    unittest.expect(
      o.periodSeconds!,
      unittest.equals(42),
    );
    unittest.expect(
      o.timeoutSeconds!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1Probe--;
}

core.List<core.String> buildUnnamed249() => [
      'foo',
      'foo',
    ];

void checkUnnamed249(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ProbeExecAction = 0;
api.GoogleCloudAiplatformV1ProbeExecAction
    buildGoogleCloudAiplatformV1ProbeExecAction() {
  final o = api.GoogleCloudAiplatformV1ProbeExecAction();
  buildCounterGoogleCloudAiplatformV1ProbeExecAction++;
  if (buildCounterGoogleCloudAiplatformV1ProbeExecAction < 3) {
    o.command = buildUnnamed249();
  }
  buildCounterGoogleCloudAiplatformV1ProbeExecAction--;
  return o;
}

void checkGoogleCloudAiplatformV1ProbeExecAction(
    api.GoogleCloudAiplatformV1ProbeExecAction o) {
  buildCounterGoogleCloudAiplatformV1ProbeExecAction++;
  if (buildCounterGoogleCloudAiplatformV1ProbeExecAction < 3) {
    checkUnnamed249(o.command!);
  }
  buildCounterGoogleCloudAiplatformV1ProbeExecAction--;
}

core.int buildCounterGoogleCloudAiplatformV1PscAutomatedEndpoints = 0;
api.GoogleCloudAiplatformV1PscAutomatedEndpoints
    buildGoogleCloudAiplatformV1PscAutomatedEndpoints() {
  final o = api.GoogleCloudAiplatformV1PscAutomatedEndpoints();
  buildCounterGoogleCloudAiplatformV1PscAutomatedEndpoints++;
  if (buildCounterGoogleCloudAiplatformV1PscAutomatedEndpoints < 3) {
    o.matchAddress = 'foo';
    o.network = 'foo';
    o.projectId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PscAutomatedEndpoints--;
  return o;
}

void checkGoogleCloudAiplatformV1PscAutomatedEndpoints(
    api.GoogleCloudAiplatformV1PscAutomatedEndpoints o) {
  buildCounterGoogleCloudAiplatformV1PscAutomatedEndpoints++;
  if (buildCounterGoogleCloudAiplatformV1PscAutomatedEndpoints < 3) {
    unittest.expect(
      o.matchAddress!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.network!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.projectId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PscAutomatedEndpoints--;
}

core.List<core.String> buildUnnamed250() => [
      'foo',
      'foo',
    ];

void checkUnnamed250(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1PublisherModel = 0;
api.GoogleCloudAiplatformV1PublisherModel
    buildGoogleCloudAiplatformV1PublisherModel() {
  final o = api.GoogleCloudAiplatformV1PublisherModel();
  buildCounterGoogleCloudAiplatformV1PublisherModel++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModel < 3) {
    o.frameworks = buildUnnamed250();
    o.launchStage = 'foo';
    o.name = 'foo';
    o.openSourceCategory = 'foo';
    o.predictSchemata = buildGoogleCloudAiplatformV1PredictSchemata();
    o.publisherModelTemplate = 'foo';
    o.supportedActions =
        buildGoogleCloudAiplatformV1PublisherModelCallToAction();
    o.versionId = 'foo';
    o.versionState = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PublisherModel--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModel(
    api.GoogleCloudAiplatformV1PublisherModel o) {
  buildCounterGoogleCloudAiplatformV1PublisherModel++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModel < 3) {
    checkUnnamed250(o.frameworks!);
    unittest.expect(
      o.launchStage!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.openSourceCategory!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PredictSchemata(o.predictSchemata!);
    unittest.expect(
      o.publisherModelTemplate!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1PublisherModelCallToAction(o.supportedActions!);
    unittest.expect(
      o.versionId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.versionState!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PublisherModel--;
}

core.int buildCounterGoogleCloudAiplatformV1PublisherModelCallToAction = 0;
api.GoogleCloudAiplatformV1PublisherModelCallToAction
    buildGoogleCloudAiplatformV1PublisherModelCallToAction() {
  final o = api.GoogleCloudAiplatformV1PublisherModelCallToAction();
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToAction++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToAction < 3) {
    o.createApplication =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
    o.deploy = buildGoogleCloudAiplatformV1PublisherModelCallToActionDeploy();
    o.deployGke =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke();
    o.openEvaluationPipeline =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
    o.openFineTuningPipeline =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
    o.openFineTuningPipelines =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines();
    o.openGenerationAiStudio =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
    o.openGenie =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
    o.openNotebook =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
    o.openNotebooks =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks();
    o.openPromptTuningPipeline =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
    o.requestAccess =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
    o.viewRestApi =
        buildGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi();
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToAction--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelCallToAction(
    api.GoogleCloudAiplatformV1PublisherModelCallToAction o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToAction++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToAction < 3) {
    checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
        o.createApplication!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionDeploy(o.deploy!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke(
        o.deployGke!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
        o.openEvaluationPipeline!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
        o.openFineTuningPipeline!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines(
        o.openFineTuningPipelines!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
        o.openGenerationAiStudio!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
        o.openGenie!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
        o.openNotebook!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks(
        o.openNotebooks!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
        o.openPromptTuningPipeline!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
        o.requestAccess!);
    checkGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi(
        o.viewRestApi!);
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToAction--;
}

core.int buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeploy =
    0;
api.GoogleCloudAiplatformV1PublisherModelCallToActionDeploy
    buildGoogleCloudAiplatformV1PublisherModelCallToActionDeploy() {
  final o = api.GoogleCloudAiplatformV1PublisherModelCallToActionDeploy();
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeploy++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeploy < 3) {
    o.artifactUri = 'foo';
    o.automaticResources = buildGoogleCloudAiplatformV1AutomaticResources();
    o.containerSpec = buildGoogleCloudAiplatformV1ModelContainerSpec();
    o.dedicatedResources = buildGoogleCloudAiplatformV1DedicatedResources();
    o.largeModelReference = buildGoogleCloudAiplatformV1LargeModelReference();
    o.modelDisplayName = 'foo';
    o.publicArtifactUri = 'foo';
    o.sharedResources = 'foo';
    o.title = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeploy--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelCallToActionDeploy(
    api.GoogleCloudAiplatformV1PublisherModelCallToActionDeploy o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeploy++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeploy < 3) {
    unittest.expect(
      o.artifactUri!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1AutomaticResources(o.automaticResources!);
    checkGoogleCloudAiplatformV1ModelContainerSpec(o.containerSpec!);
    checkGoogleCloudAiplatformV1DedicatedResources(o.dedicatedResources!);
    checkGoogleCloudAiplatformV1LargeModelReference(o.largeModelReference!);
    unittest.expect(
      o.modelDisplayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.publicArtifactUri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.sharedResources!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.title!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeploy--;
}

core.List<core.String> buildUnnamed251() => [
      'foo',
      'foo',
    ];

void checkUnnamed251(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke = 0;
api.GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke
    buildGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke() {
  final o = api.GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke();
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke <
      3) {
    o.gkeYamlConfigs = buildUnnamed251();
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke(
    api.GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke <
      3) {
    checkUnnamed251(o.gkeYamlConfigs!);
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke--;
}

core.List<
        api
        .GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences>
    buildUnnamed252() => [
          buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(),
          buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(),
        ];

void checkUnnamed252(
    core.List<
            api
            .GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
      o[0]);
  checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
      o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines =
    0;
api.GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines
    buildGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines() {
  final o = api
      .GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines();
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines <
      3) {
    o.fineTuningPipelines = buildUnnamed252();
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines(
    api.GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines
        o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines <
      3) {
    checkUnnamed252(o.fineTuningPipelines!);
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines--;
}

core.List<
        api
        .GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences>
    buildUnnamed253() => [
          buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(),
          buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(),
        ];

void checkUnnamed253(
    core.List<
            api
            .GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
      o[0]);
  checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
      o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks =
    0;
api.GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks
    buildGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks() {
  final o =
      api.GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks();
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks <
      3) {
    o.notebooks = buildUnnamed253();
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks(
    api.GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks <
      3) {
    checkUnnamed253(o.notebooks!);
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks--;
}

core.Map<core.String,
        api.GoogleCloudAiplatformV1PublisherModelResourceReference>
    buildUnnamed254() => {
          'x': buildGoogleCloudAiplatformV1PublisherModelResourceReference(),
          'y': buildGoogleCloudAiplatformV1PublisherModelResourceReference(),
        };

void checkUnnamed254(
    core.Map<core.String,
            api.GoogleCloudAiplatformV1PublisherModelResourceReference>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PublisherModelResourceReference(o['x']!);
  checkGoogleCloudAiplatformV1PublisherModelResourceReference(o['y']!);
}

core.int
    buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences =
    0;
api.GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
    buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences() {
  final o = api
      .GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences <
      3) {
    o.references = buildUnnamed254();
    o.resourceDescription = 'foo';
    o.resourceTitle = 'foo';
    o.resourceUseCase = 'foo';
    o.title = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
    api.GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
        o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences <
      3) {
    checkUnnamed254(o.references!);
    unittest.expect(
      o.resourceDescription!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.resourceTitle!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.resourceUseCase!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.title!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences--;
}

core.List<api.GoogleCloudAiplatformV1PublisherModelDocumentation>
    buildUnnamed255() => [
          buildGoogleCloudAiplatformV1PublisherModelDocumentation(),
          buildGoogleCloudAiplatformV1PublisherModelDocumentation(),
        ];

void checkUnnamed255(
    core.List<api.GoogleCloudAiplatformV1PublisherModelDocumentation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1PublisherModelDocumentation(o[0]);
  checkGoogleCloudAiplatformV1PublisherModelDocumentation(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi =
    0;
api.GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi
    buildGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi() {
  final o = api.GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi();
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi <
      3) {
    o.documentations = buildUnnamed255();
    o.title = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi(
    api.GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi <
      3) {
    checkUnnamed255(o.documentations!);
    unittest.expect(
      o.title!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi--;
}

core.int buildCounterGoogleCloudAiplatformV1PublisherModelDocumentation = 0;
api.GoogleCloudAiplatformV1PublisherModelDocumentation
    buildGoogleCloudAiplatformV1PublisherModelDocumentation() {
  final o = api.GoogleCloudAiplatformV1PublisherModelDocumentation();
  buildCounterGoogleCloudAiplatformV1PublisherModelDocumentation++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelDocumentation < 3) {
    o.content = 'foo';
    o.title = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelDocumentation--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelDocumentation(
    api.GoogleCloudAiplatformV1PublisherModelDocumentation o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelDocumentation++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelDocumentation < 3) {
    unittest.expect(
      o.content!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.title!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelDocumentation--;
}

core.int buildCounterGoogleCloudAiplatformV1PublisherModelResourceReference = 0;
api.GoogleCloudAiplatformV1PublisherModelResourceReference
    buildGoogleCloudAiplatformV1PublisherModelResourceReference() {
  final o = api.GoogleCloudAiplatformV1PublisherModelResourceReference();
  buildCounterGoogleCloudAiplatformV1PublisherModelResourceReference++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelResourceReference < 3) {
    o.description = 'foo';
    o.resourceName = 'foo';
    o.uri = 'foo';
    o.useCase = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelResourceReference--;
  return o;
}

void checkGoogleCloudAiplatformV1PublisherModelResourceReference(
    api.GoogleCloudAiplatformV1PublisherModelResourceReference o) {
  buildCounterGoogleCloudAiplatformV1PublisherModelResourceReference++;
  if (buildCounterGoogleCloudAiplatformV1PublisherModelResourceReference < 3) {
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.resourceName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.uri!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.useCase!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PublisherModelResourceReference--;
}

core.int buildCounterGoogleCloudAiplatformV1PurgeArtifactsRequest = 0;
api.GoogleCloudAiplatformV1PurgeArtifactsRequest
    buildGoogleCloudAiplatformV1PurgeArtifactsRequest() {
  final o = api.GoogleCloudAiplatformV1PurgeArtifactsRequest();
  buildCounterGoogleCloudAiplatformV1PurgeArtifactsRequest++;
  if (buildCounterGoogleCloudAiplatformV1PurgeArtifactsRequest < 3) {
    o.filter = 'foo';
    o.force = true;
  }
  buildCounterGoogleCloudAiplatformV1PurgeArtifactsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1PurgeArtifactsRequest(
    api.GoogleCloudAiplatformV1PurgeArtifactsRequest o) {
  buildCounterGoogleCloudAiplatformV1PurgeArtifactsRequest++;
  if (buildCounterGoogleCloudAiplatformV1PurgeArtifactsRequest < 3) {
    unittest.expect(
      o.filter!,
      unittest.equals('foo'),
    );
    unittest.expect(o.force!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1PurgeArtifactsRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1PurgeContextsRequest = 0;
api.GoogleCloudAiplatformV1PurgeContextsRequest
    buildGoogleCloudAiplatformV1PurgeContextsRequest() {
  final o = api.GoogleCloudAiplatformV1PurgeContextsRequest();
  buildCounterGoogleCloudAiplatformV1PurgeContextsRequest++;
  if (buildCounterGoogleCloudAiplatformV1PurgeContextsRequest < 3) {
    o.filter = 'foo';
    o.force = true;
  }
  buildCounterGoogleCloudAiplatformV1PurgeContextsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1PurgeContextsRequest(
    api.GoogleCloudAiplatformV1PurgeContextsRequest o) {
  buildCounterGoogleCloudAiplatformV1PurgeContextsRequest++;
  if (buildCounterGoogleCloudAiplatformV1PurgeContextsRequest < 3) {
    unittest.expect(
      o.filter!,
      unittest.equals('foo'),
    );
    unittest.expect(o.force!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1PurgeContextsRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1PurgeExecutionsRequest = 0;
api.GoogleCloudAiplatformV1PurgeExecutionsRequest
    buildGoogleCloudAiplatformV1PurgeExecutionsRequest() {
  final o = api.GoogleCloudAiplatformV1PurgeExecutionsRequest();
  buildCounterGoogleCloudAiplatformV1PurgeExecutionsRequest++;
  if (buildCounterGoogleCloudAiplatformV1PurgeExecutionsRequest < 3) {
    o.filter = 'foo';
    o.force = true;
  }
  buildCounterGoogleCloudAiplatformV1PurgeExecutionsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1PurgeExecutionsRequest(
    api.GoogleCloudAiplatformV1PurgeExecutionsRequest o) {
  buildCounterGoogleCloudAiplatformV1PurgeExecutionsRequest++;
  if (buildCounterGoogleCloudAiplatformV1PurgeExecutionsRequest < 3) {
    unittest.expect(
      o.filter!,
      unittest.equals('foo'),
    );
    unittest.expect(o.force!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1PurgeExecutionsRequest--;
}

core.List<core.String> buildUnnamed256() => [
      'foo',
      'foo',
    ];

void checkUnnamed256(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<api.GoogleCloudAiplatformV1EnvVar> buildUnnamed257() => [
      buildGoogleCloudAiplatformV1EnvVar(),
      buildGoogleCloudAiplatformV1EnvVar(),
    ];

void checkUnnamed257(core.List<api.GoogleCloudAiplatformV1EnvVar> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1EnvVar(o[0]);
  checkGoogleCloudAiplatformV1EnvVar(o[1]);
}

core.List<core.String> buildUnnamed258() => [
      'foo',
      'foo',
    ];

void checkUnnamed258(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1PythonPackageSpec = 0;
api.GoogleCloudAiplatformV1PythonPackageSpec
    buildGoogleCloudAiplatformV1PythonPackageSpec() {
  final o = api.GoogleCloudAiplatformV1PythonPackageSpec();
  buildCounterGoogleCloudAiplatformV1PythonPackageSpec++;
  if (buildCounterGoogleCloudAiplatformV1PythonPackageSpec < 3) {
    o.args = buildUnnamed256();
    o.env = buildUnnamed257();
    o.executorImageUri = 'foo';
    o.packageUris = buildUnnamed258();
    o.pythonModule = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1PythonPackageSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1PythonPackageSpec(
    api.GoogleCloudAiplatformV1PythonPackageSpec o) {
  buildCounterGoogleCloudAiplatformV1PythonPackageSpec++;
  if (buildCounterGoogleCloudAiplatformV1PythonPackageSpec < 3) {
    checkUnnamed256(o.args!);
    checkUnnamed257(o.env!);
    unittest.expect(
      o.executorImageUri!,
      unittest.equals('foo'),
    );
    checkUnnamed258(o.packageUris!);
    unittest.expect(
      o.pythonModule!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1PythonPackageSpec--;
}

core.List<api.GoogleCloudAiplatformV1DeployedModelRef> buildUnnamed259() => [
      buildGoogleCloudAiplatformV1DeployedModelRef(),
      buildGoogleCloudAiplatformV1DeployedModelRef(),
    ];

void checkUnnamed259(core.List<api.GoogleCloudAiplatformV1DeployedModelRef> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DeployedModelRef(o[0]);
  checkGoogleCloudAiplatformV1DeployedModelRef(o[1]);
}

core.List<api.GoogleCloudAiplatformV1DeployedModel> buildUnnamed260() => [
      buildGoogleCloudAiplatformV1DeployedModel(),
      buildGoogleCloudAiplatformV1DeployedModel(),
    ];

void checkUnnamed260(core.List<api.GoogleCloudAiplatformV1DeployedModel> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DeployedModel(o[0]);
  checkGoogleCloudAiplatformV1DeployedModel(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1QueryDeployedModelsResponse = 0;
api.GoogleCloudAiplatformV1QueryDeployedModelsResponse
    buildGoogleCloudAiplatformV1QueryDeployedModelsResponse() {
  final o = api.GoogleCloudAiplatformV1QueryDeployedModelsResponse();
  buildCounterGoogleCloudAiplatformV1QueryDeployedModelsResponse++;
  if (buildCounterGoogleCloudAiplatformV1QueryDeployedModelsResponse < 3) {
    o.deployedModelRefs = buildUnnamed259();
    o.deployedModels = buildUnnamed260();
    o.nextPageToken = 'foo';
    o.totalDeployedModelCount = 42;
    o.totalEndpointCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1QueryDeployedModelsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1QueryDeployedModelsResponse(
    api.GoogleCloudAiplatformV1QueryDeployedModelsResponse o) {
  buildCounterGoogleCloudAiplatformV1QueryDeployedModelsResponse++;
  if (buildCounterGoogleCloudAiplatformV1QueryDeployedModelsResponse < 3) {
    checkUnnamed259(o.deployedModelRefs!);
    checkUnnamed260(o.deployedModels!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.totalDeployedModelCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.totalEndpointCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1QueryDeployedModelsResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1RawPredictRequest = 0;
api.GoogleCloudAiplatformV1RawPredictRequest
    buildGoogleCloudAiplatformV1RawPredictRequest() {
  final o = api.GoogleCloudAiplatformV1RawPredictRequest();
  buildCounterGoogleCloudAiplatformV1RawPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1RawPredictRequest < 3) {
    o.httpBody = buildGoogleApiHttpBody();
  }
  buildCounterGoogleCloudAiplatformV1RawPredictRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1RawPredictRequest(
    api.GoogleCloudAiplatformV1RawPredictRequest o) {
  buildCounterGoogleCloudAiplatformV1RawPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1RawPredictRequest < 3) {
    checkGoogleApiHttpBody(o.httpBody!);
  }
  buildCounterGoogleCloudAiplatformV1RawPredictRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1ReadFeatureValuesRequest = 0;
api.GoogleCloudAiplatformV1ReadFeatureValuesRequest
    buildGoogleCloudAiplatformV1ReadFeatureValuesRequest() {
  final o = api.GoogleCloudAiplatformV1ReadFeatureValuesRequest();
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesRequest < 3) {
    o.entityId = 'foo';
    o.featureSelector = buildGoogleCloudAiplatformV1FeatureSelector();
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadFeatureValuesRequest(
    api.GoogleCloudAiplatformV1ReadFeatureValuesRequest o) {
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesRequest < 3) {
    unittest.expect(
      o.entityId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1FeatureSelector(o.featureSelector!);
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponse = 0;
api.GoogleCloudAiplatformV1ReadFeatureValuesResponse
    buildGoogleCloudAiplatformV1ReadFeatureValuesResponse() {
  final o = api.GoogleCloudAiplatformV1ReadFeatureValuesResponse();
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponse < 3) {
    o.entityView =
        buildGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView();
    o.header = buildGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader();
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadFeatureValuesResponse(
    api.GoogleCloudAiplatformV1ReadFeatureValuesResponse o) {
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponse < 3) {
    checkGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView(
        o.entityView!);
    checkGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader(o.header!);
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponse--;
}

core.List<api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData>
    buildUnnamed261() => [
          buildGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData(),
          buildGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData(),
        ];

void checkUnnamed261(
    core.List<
            api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData(o[0]);
  checkGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView = 0;
api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView
    buildGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView() {
  final o = api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView();
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView <
      3) {
    o.data = buildUnnamed261();
    o.entityId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView(
    api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView o) {
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView <
      3) {
    checkUnnamed261(o.data!);
    unittest.expect(
      o.entityId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData =
    0;
api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData
    buildGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData() {
  final o =
      api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData();
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData <
      3) {
    o.value = buildGoogleCloudAiplatformV1FeatureValue();
    o.values = buildGoogleCloudAiplatformV1FeatureValueList();
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData(
    api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData o) {
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData <
      3) {
    checkGoogleCloudAiplatformV1FeatureValue(o.value!);
    checkGoogleCloudAiplatformV1FeatureValueList(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor =
    0;
api.GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor
    buildGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor() {
  final o =
      api.GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor();
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor <
      3) {
    o.id = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor(
    api.GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor o) {
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor <
      3) {
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor--;
}

core.List<api.GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor>
    buildUnnamed262() => [
          buildGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor(),
          buildGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor(),
        ];

void checkUnnamed262(
    core.List<
            api
            .GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor(o[0]);
  checkGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader = 0;
api.GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader
    buildGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader() {
  final o = api.GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader();
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader < 3) {
    o.entityType = 'foo';
    o.featureDescriptors = buildUnnamed262();
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader(
    api.GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader o) {
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader++;
  if (buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader < 3) {
    unittest.expect(
      o.entityType!,
      unittest.equals('foo'),
    );
    checkUnnamed262(o.featureDescriptors!);
  }
  buildCounterGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader--;
}

core.List<core.String> buildUnnamed263() => [
      'foo',
      'foo',
    ];

void checkUnnamed263(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsRequest = 0;
api.GoogleCloudAiplatformV1ReadIndexDatapointsRequest
    buildGoogleCloudAiplatformV1ReadIndexDatapointsRequest() {
  final o = api.GoogleCloudAiplatformV1ReadIndexDatapointsRequest();
  buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsRequest++;
  if (buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsRequest < 3) {
    o.deployedIndexId = 'foo';
    o.ids = buildUnnamed263();
  }
  buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadIndexDatapointsRequest(
    api.GoogleCloudAiplatformV1ReadIndexDatapointsRequest o) {
  buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsRequest++;
  if (buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsRequest < 3) {
    unittest.expect(
      o.deployedIndexId!,
      unittest.equals('foo'),
    );
    checkUnnamed263(o.ids!);
  }
  buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsRequest--;
}

core.List<api.GoogleCloudAiplatformV1IndexDatapoint> buildUnnamed264() => [
      buildGoogleCloudAiplatformV1IndexDatapoint(),
      buildGoogleCloudAiplatformV1IndexDatapoint(),
    ];

void checkUnnamed264(core.List<api.GoogleCloudAiplatformV1IndexDatapoint> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1IndexDatapoint(o[0]);
  checkGoogleCloudAiplatformV1IndexDatapoint(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsResponse = 0;
api.GoogleCloudAiplatformV1ReadIndexDatapointsResponse
    buildGoogleCloudAiplatformV1ReadIndexDatapointsResponse() {
  final o = api.GoogleCloudAiplatformV1ReadIndexDatapointsResponse();
  buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsResponse < 3) {
    o.datapoints = buildUnnamed264();
  }
  buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadIndexDatapointsResponse(
    api.GoogleCloudAiplatformV1ReadIndexDatapointsResponse o) {
  buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsResponse < 3) {
    checkUnnamed264(o.datapoints!);
  }
  buildCounterGoogleCloudAiplatformV1ReadIndexDatapointsResponse--;
}

core.List<api.GoogleCloudAiplatformV1TensorboardBlob> buildUnnamed265() => [
      buildGoogleCloudAiplatformV1TensorboardBlob(),
      buildGoogleCloudAiplatformV1TensorboardBlob(),
    ];

void checkUnnamed265(core.List<api.GoogleCloudAiplatformV1TensorboardBlob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TensorboardBlob(o[0]);
  checkGoogleCloudAiplatformV1TensorboardBlob(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse = 0;
api.GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse
    buildGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse() {
  final o = api.GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse();
  buildCounterGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse < 3) {
    o.blobs = buildUnnamed265();
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse(
    api.GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse o) {
  buildCounterGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse < 3) {
    checkUnnamed265(o.blobs!);
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1ReadTensorboardSizeResponse = 0;
api.GoogleCloudAiplatformV1ReadTensorboardSizeResponse
    buildGoogleCloudAiplatformV1ReadTensorboardSizeResponse() {
  final o = api.GoogleCloudAiplatformV1ReadTensorboardSizeResponse();
  buildCounterGoogleCloudAiplatformV1ReadTensorboardSizeResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardSizeResponse < 3) {
    o.storageSizeByte = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardSizeResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadTensorboardSizeResponse(
    api.GoogleCloudAiplatformV1ReadTensorboardSizeResponse o) {
  buildCounterGoogleCloudAiplatformV1ReadTensorboardSizeResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardSizeResponse < 3) {
    unittest.expect(
      o.storageSizeByte!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardSizeResponse--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse =
    0;
api.GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse
    buildGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse() {
  final o = api.GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse();
  buildCounterGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse <
      3) {
    o.timeSeriesData = buildGoogleCloudAiplatformV1TimeSeriesData();
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse(
    api.GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse o) {
  buildCounterGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse <
      3) {
    checkGoogleCloudAiplatformV1TimeSeriesData(o.timeSeriesData!);
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse--;
}

core.Map<
        core.String,
        api
        .GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData>
    buildUnnamed266() => {
          'x':
              buildGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData(),
          'y':
              buildGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData(),
        };

void checkUnnamed266(
    core.Map<
            core.String,
            api
            .GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData(
      o['x']!);
  checkGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData(
      o['y']!);
}

core.int buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponse = 0;
api.GoogleCloudAiplatformV1ReadTensorboardUsageResponse
    buildGoogleCloudAiplatformV1ReadTensorboardUsageResponse() {
  final o = api.GoogleCloudAiplatformV1ReadTensorboardUsageResponse();
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponse < 3) {
    o.monthlyUsageData = buildUnnamed266();
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadTensorboardUsageResponse(
    api.GoogleCloudAiplatformV1ReadTensorboardUsageResponse o) {
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponse++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponse < 3) {
    checkUnnamed266(o.monthlyUsageData!);
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponse--;
}

core.List<
        api.GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData>
    buildUnnamed267() => [
          buildGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData(),
          buildGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData(),
        ];

void checkUnnamed267(
    core.List<
            api
            .GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData(
      o[0]);
  checkGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData(
      o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData =
    0;
api.GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData
    buildGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData() {
  final o = api
      .GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData();
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData <
      3) {
    o.userUsageData = buildUnnamed267();
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData(
    api.GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData
        o) {
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData <
      3) {
    checkUnnamed267(o.userUsageData!);
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData =
    0;
api.GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData
    buildGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData() {
  final o =
      api.GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData();
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData <
      3) {
    o.username = 'foo';
    o.viewCount = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData--;
  return o;
}

void checkGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData(
    api.GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData o) {
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData++;
  if (buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData <
      3) {
    unittest.expect(
      o.username!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.viewCount!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData--;
}

core.List<core.String> buildUnnamed268() => [
      'foo',
      'foo',
    ];

void checkUnnamed268(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1RemoveContextChildrenRequest = 0;
api.GoogleCloudAiplatformV1RemoveContextChildrenRequest
    buildGoogleCloudAiplatformV1RemoveContextChildrenRequest() {
  final o = api.GoogleCloudAiplatformV1RemoveContextChildrenRequest();
  buildCounterGoogleCloudAiplatformV1RemoveContextChildrenRequest++;
  if (buildCounterGoogleCloudAiplatformV1RemoveContextChildrenRequest < 3) {
    o.childContexts = buildUnnamed268();
  }
  buildCounterGoogleCloudAiplatformV1RemoveContextChildrenRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1RemoveContextChildrenRequest(
    api.GoogleCloudAiplatformV1RemoveContextChildrenRequest o) {
  buildCounterGoogleCloudAiplatformV1RemoveContextChildrenRequest++;
  if (buildCounterGoogleCloudAiplatformV1RemoveContextChildrenRequest < 3) {
    checkUnnamed268(o.childContexts!);
  }
  buildCounterGoogleCloudAiplatformV1RemoveContextChildrenRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1RemoveContextChildrenResponse = 0;
api.GoogleCloudAiplatformV1RemoveContextChildrenResponse
    buildGoogleCloudAiplatformV1RemoveContextChildrenResponse() {
  final o = api.GoogleCloudAiplatformV1RemoveContextChildrenResponse();
  buildCounterGoogleCloudAiplatformV1RemoveContextChildrenResponse++;
  if (buildCounterGoogleCloudAiplatformV1RemoveContextChildrenResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1RemoveContextChildrenResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1RemoveContextChildrenResponse(
    api.GoogleCloudAiplatformV1RemoveContextChildrenResponse o) {
  buildCounterGoogleCloudAiplatformV1RemoveContextChildrenResponse++;
  if (buildCounterGoogleCloudAiplatformV1RemoveContextChildrenResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1RemoveContextChildrenResponse--;
}

core.List<core.String> buildUnnamed269() => [
      'foo',
      'foo',
    ];

void checkUnnamed269(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1RemoveDatapointsRequest = 0;
api.GoogleCloudAiplatformV1RemoveDatapointsRequest
    buildGoogleCloudAiplatformV1RemoveDatapointsRequest() {
  final o = api.GoogleCloudAiplatformV1RemoveDatapointsRequest();
  buildCounterGoogleCloudAiplatformV1RemoveDatapointsRequest++;
  if (buildCounterGoogleCloudAiplatformV1RemoveDatapointsRequest < 3) {
    o.datapointIds = buildUnnamed269();
  }
  buildCounterGoogleCloudAiplatformV1RemoveDatapointsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1RemoveDatapointsRequest(
    api.GoogleCloudAiplatformV1RemoveDatapointsRequest o) {
  buildCounterGoogleCloudAiplatformV1RemoveDatapointsRequest++;
  if (buildCounterGoogleCloudAiplatformV1RemoveDatapointsRequest < 3) {
    checkUnnamed269(o.datapointIds!);
  }
  buildCounterGoogleCloudAiplatformV1RemoveDatapointsRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1RemoveDatapointsResponse = 0;
api.GoogleCloudAiplatformV1RemoveDatapointsResponse
    buildGoogleCloudAiplatformV1RemoveDatapointsResponse() {
  final o = api.GoogleCloudAiplatformV1RemoveDatapointsResponse();
  buildCounterGoogleCloudAiplatformV1RemoveDatapointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1RemoveDatapointsResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1RemoveDatapointsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1RemoveDatapointsResponse(
    api.GoogleCloudAiplatformV1RemoveDatapointsResponse o) {
  buildCounterGoogleCloudAiplatformV1RemoveDatapointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1RemoveDatapointsResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1RemoveDatapointsResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1ResourcesConsumed = 0;
api.GoogleCloudAiplatformV1ResourcesConsumed
    buildGoogleCloudAiplatformV1ResourcesConsumed() {
  final o = api.GoogleCloudAiplatformV1ResourcesConsumed();
  buildCounterGoogleCloudAiplatformV1ResourcesConsumed++;
  if (buildCounterGoogleCloudAiplatformV1ResourcesConsumed < 3) {
    o.replicaHours = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1ResourcesConsumed--;
  return o;
}

void checkGoogleCloudAiplatformV1ResourcesConsumed(
    api.GoogleCloudAiplatformV1ResourcesConsumed o) {
  buildCounterGoogleCloudAiplatformV1ResourcesConsumed++;
  if (buildCounterGoogleCloudAiplatformV1ResourcesConsumed < 3) {
    unittest.expect(
      o.replicaHours!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1ResourcesConsumed--;
}

core.int
    buildCounterGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest =
    0;
api.GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest
    buildGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest() {
  final o =
      api.GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest();
  buildCounterGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest <
      3) {}
  buildCounterGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest(
    api.GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest o) {
  buildCounterGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest++;
  if (buildCounterGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest <
      3) {}
  buildCounterGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1ResumeScheduleRequest = 0;
api.GoogleCloudAiplatformV1ResumeScheduleRequest
    buildGoogleCloudAiplatformV1ResumeScheduleRequest() {
  final o = api.GoogleCloudAiplatformV1ResumeScheduleRequest();
  buildCounterGoogleCloudAiplatformV1ResumeScheduleRequest++;
  if (buildCounterGoogleCloudAiplatformV1ResumeScheduleRequest < 3) {
    o.catchUp = true;
  }
  buildCounterGoogleCloudAiplatformV1ResumeScheduleRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1ResumeScheduleRequest(
    api.GoogleCloudAiplatformV1ResumeScheduleRequest o) {
  buildCounterGoogleCloudAiplatformV1ResumeScheduleRequest++;
  if (buildCounterGoogleCloudAiplatformV1ResumeScheduleRequest < 3) {
    unittest.expect(o.catchUp!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1ResumeScheduleRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1SafetyRating = 0;
api.GoogleCloudAiplatformV1SafetyRating
    buildGoogleCloudAiplatformV1SafetyRating() {
  final o = api.GoogleCloudAiplatformV1SafetyRating();
  buildCounterGoogleCloudAiplatformV1SafetyRating++;
  if (buildCounterGoogleCloudAiplatformV1SafetyRating < 3) {
    o.blocked = true;
    o.category = 'foo';
    o.probability = 'foo';
    o.probabilityScore = 42.0;
    o.severity = 'foo';
    o.severityScore = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1SafetyRating--;
  return o;
}

void checkGoogleCloudAiplatformV1SafetyRating(
    api.GoogleCloudAiplatformV1SafetyRating o) {
  buildCounterGoogleCloudAiplatformV1SafetyRating++;
  if (buildCounterGoogleCloudAiplatformV1SafetyRating < 3) {
    unittest.expect(o.blocked!, unittest.isTrue);
    unittest.expect(
      o.category!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.probability!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.probabilityScore!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.severity!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.severityScore!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1SafetyRating--;
}

core.int buildCounterGoogleCloudAiplatformV1SafetySetting = 0;
api.GoogleCloudAiplatformV1SafetySetting
    buildGoogleCloudAiplatformV1SafetySetting() {
  final o = api.GoogleCloudAiplatformV1SafetySetting();
  buildCounterGoogleCloudAiplatformV1SafetySetting++;
  if (buildCounterGoogleCloudAiplatformV1SafetySetting < 3) {
    o.category = 'foo';
    o.threshold = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SafetySetting--;
  return o;
}

void checkGoogleCloudAiplatformV1SafetySetting(
    api.GoogleCloudAiplatformV1SafetySetting o) {
  buildCounterGoogleCloudAiplatformV1SafetySetting++;
  if (buildCounterGoogleCloudAiplatformV1SafetySetting < 3) {
    unittest.expect(
      o.category!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.threshold!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SafetySetting--;
}

core.int buildCounterGoogleCloudAiplatformV1SampleConfig = 0;
api.GoogleCloudAiplatformV1SampleConfig
    buildGoogleCloudAiplatformV1SampleConfig() {
  final o = api.GoogleCloudAiplatformV1SampleConfig();
  buildCounterGoogleCloudAiplatformV1SampleConfig++;
  if (buildCounterGoogleCloudAiplatformV1SampleConfig < 3) {
    o.followingBatchSamplePercentage = 42;
    o.initialBatchSamplePercentage = 42;
    o.sampleStrategy = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SampleConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1SampleConfig(
    api.GoogleCloudAiplatformV1SampleConfig o) {
  buildCounterGoogleCloudAiplatformV1SampleConfig++;
  if (buildCounterGoogleCloudAiplatformV1SampleConfig < 3) {
    unittest.expect(
      o.followingBatchSamplePercentage!,
      unittest.equals(42),
    );
    unittest.expect(
      o.initialBatchSamplePercentage!,
      unittest.equals(42),
    );
    unittest.expect(
      o.sampleStrategy!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SampleConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1SampledShapleyAttribution = 0;
api.GoogleCloudAiplatformV1SampledShapleyAttribution
    buildGoogleCloudAiplatformV1SampledShapleyAttribution() {
  final o = api.GoogleCloudAiplatformV1SampledShapleyAttribution();
  buildCounterGoogleCloudAiplatformV1SampledShapleyAttribution++;
  if (buildCounterGoogleCloudAiplatformV1SampledShapleyAttribution < 3) {
    o.pathCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1SampledShapleyAttribution--;
  return o;
}

void checkGoogleCloudAiplatformV1SampledShapleyAttribution(
    api.GoogleCloudAiplatformV1SampledShapleyAttribution o) {
  buildCounterGoogleCloudAiplatformV1SampledShapleyAttribution++;
  if (buildCounterGoogleCloudAiplatformV1SampledShapleyAttribution < 3) {
    unittest.expect(
      o.pathCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1SampledShapleyAttribution--;
}

core.int buildCounterGoogleCloudAiplatformV1SamplingStrategy = 0;
api.GoogleCloudAiplatformV1SamplingStrategy
    buildGoogleCloudAiplatformV1SamplingStrategy() {
  final o = api.GoogleCloudAiplatformV1SamplingStrategy();
  buildCounterGoogleCloudAiplatformV1SamplingStrategy++;
  if (buildCounterGoogleCloudAiplatformV1SamplingStrategy < 3) {
    o.randomSampleConfig =
        buildGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig();
  }
  buildCounterGoogleCloudAiplatformV1SamplingStrategy--;
  return o;
}

void checkGoogleCloudAiplatformV1SamplingStrategy(
    api.GoogleCloudAiplatformV1SamplingStrategy o) {
  buildCounterGoogleCloudAiplatformV1SamplingStrategy++;
  if (buildCounterGoogleCloudAiplatformV1SamplingStrategy < 3) {
    checkGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig(
        o.randomSampleConfig!);
  }
  buildCounterGoogleCloudAiplatformV1SamplingStrategy--;
}

core.int buildCounterGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig =
    0;
api.GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig
    buildGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig() {
  final o = api.GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig();
  buildCounterGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig++;
  if (buildCounterGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig <
      3) {
    o.sampleRate = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig(
    api.GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig o) {
  buildCounterGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig++;
  if (buildCounterGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig <
      3) {
    unittest.expect(
      o.sampleRate!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1SavedQuery = 0;
api.GoogleCloudAiplatformV1SavedQuery buildGoogleCloudAiplatformV1SavedQuery() {
  final o = api.GoogleCloudAiplatformV1SavedQuery();
  buildCounterGoogleCloudAiplatformV1SavedQuery++;
  if (buildCounterGoogleCloudAiplatformV1SavedQuery < 3) {
    o.annotationFilter = 'foo';
    o.annotationSpecCount = 42;
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.metadata = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.name = 'foo';
    o.problemType = 'foo';
    o.supportAutomlTraining = true;
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SavedQuery--;
  return o;
}

void checkGoogleCloudAiplatformV1SavedQuery(
    api.GoogleCloudAiplatformV1SavedQuery o) {
  buildCounterGoogleCloudAiplatformV1SavedQuery++;
  if (buildCounterGoogleCloudAiplatformV1SavedQuery < 3) {
    unittest.expect(
      o.annotationFilter!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.annotationSpecCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    var casted62 = (o.metadata!) as core.Map;
    unittest.expect(casted62, unittest.hasLength(3));
    unittest.expect(
      casted62['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted62['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted62['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.problemType!,
      unittest.equals('foo'),
    );
    unittest.expect(o.supportAutomlTraining!, unittest.isTrue);
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SavedQuery--;
}

core.int buildCounterGoogleCloudAiplatformV1Scalar = 0;
api.GoogleCloudAiplatformV1Scalar buildGoogleCloudAiplatformV1Scalar() {
  final o = api.GoogleCloudAiplatformV1Scalar();
  buildCounterGoogleCloudAiplatformV1Scalar++;
  if (buildCounterGoogleCloudAiplatformV1Scalar < 3) {
    o.value = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1Scalar--;
  return o;
}

void checkGoogleCloudAiplatformV1Scalar(api.GoogleCloudAiplatformV1Scalar o) {
  buildCounterGoogleCloudAiplatformV1Scalar++;
  if (buildCounterGoogleCloudAiplatformV1Scalar < 3) {
    unittest.expect(
      o.value!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1Scalar--;
}

core.int buildCounterGoogleCloudAiplatformV1Schedule = 0;
api.GoogleCloudAiplatformV1Schedule buildGoogleCloudAiplatformV1Schedule() {
  final o = api.GoogleCloudAiplatformV1Schedule();
  buildCounterGoogleCloudAiplatformV1Schedule++;
  if (buildCounterGoogleCloudAiplatformV1Schedule < 3) {
    o.allowQueueing = true;
    o.catchUp = true;
    o.createPipelineJobRequest =
        buildGoogleCloudAiplatformV1CreatePipelineJobRequest();
    o.createTime = 'foo';
    o.cron = 'foo';
    o.displayName = 'foo';
    o.endTime = 'foo';
    o.lastPauseTime = 'foo';
    o.lastResumeTime = 'foo';
    o.lastScheduledRunResponse =
        buildGoogleCloudAiplatformV1ScheduleRunResponse();
    o.maxConcurrentRunCount = 'foo';
    o.maxRunCount = 'foo';
    o.name = 'foo';
    o.nextRunTime = 'foo';
    o.startTime = 'foo';
    o.startedRunCount = 'foo';
    o.state = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Schedule--;
  return o;
}

void checkGoogleCloudAiplatformV1Schedule(
    api.GoogleCloudAiplatformV1Schedule o) {
  buildCounterGoogleCloudAiplatformV1Schedule++;
  if (buildCounterGoogleCloudAiplatformV1Schedule < 3) {
    unittest.expect(o.allowQueueing!, unittest.isTrue);
    unittest.expect(o.catchUp!, unittest.isTrue);
    checkGoogleCloudAiplatformV1CreatePipelineJobRequest(
        o.createPipelineJobRequest!);
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.cron!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.lastPauseTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.lastResumeTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ScheduleRunResponse(
        o.lastScheduledRunResponse!);
    unittest.expect(
      o.maxConcurrentRunCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.maxRunCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.nextRunTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startedRunCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Schedule--;
}

core.int buildCounterGoogleCloudAiplatformV1ScheduleRunResponse = 0;
api.GoogleCloudAiplatformV1ScheduleRunResponse
    buildGoogleCloudAiplatformV1ScheduleRunResponse() {
  final o = api.GoogleCloudAiplatformV1ScheduleRunResponse();
  buildCounterGoogleCloudAiplatformV1ScheduleRunResponse++;
  if (buildCounterGoogleCloudAiplatformV1ScheduleRunResponse < 3) {
    o.runResponse = 'foo';
    o.scheduledRunTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1ScheduleRunResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1ScheduleRunResponse(
    api.GoogleCloudAiplatformV1ScheduleRunResponse o) {
  buildCounterGoogleCloudAiplatformV1ScheduleRunResponse++;
  if (buildCounterGoogleCloudAiplatformV1ScheduleRunResponse < 3) {
    unittest.expect(
      o.runResponse!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.scheduledRunTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1ScheduleRunResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1Scheduling = 0;
api.GoogleCloudAiplatformV1Scheduling buildGoogleCloudAiplatformV1Scheduling() {
  final o = api.GoogleCloudAiplatformV1Scheduling();
  buildCounterGoogleCloudAiplatformV1Scheduling++;
  if (buildCounterGoogleCloudAiplatformV1Scheduling < 3) {
    o.disableRetries = true;
    o.restartJobOnWorkerRestart = true;
    o.timeout = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Scheduling--;
  return o;
}

void checkGoogleCloudAiplatformV1Scheduling(
    api.GoogleCloudAiplatformV1Scheduling o) {
  buildCounterGoogleCloudAiplatformV1Scheduling++;
  if (buildCounterGoogleCloudAiplatformV1Scheduling < 3) {
    unittest.expect(o.disableRetries!, unittest.isTrue);
    unittest.expect(o.restartJobOnWorkerRestart!, unittest.isTrue);
    unittest.expect(
      o.timeout!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Scheduling--;
}

core.List<core.String> buildUnnamed270() => [
      'foo',
      'foo',
    ];

void checkUnnamed270(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.Map<core.String, api.GoogleCloudAiplatformV1Schema> buildUnnamed271() => {
      'x': buildGoogleCloudAiplatformV1Schema(),
      'y': buildGoogleCloudAiplatformV1Schema(),
    };

void checkUnnamed271(
    core.Map<core.String, api.GoogleCloudAiplatformV1Schema> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Schema(o['x']!);
  checkGoogleCloudAiplatformV1Schema(o['y']!);
}

core.List<core.String> buildUnnamed272() => [
      'foo',
      'foo',
    ];

void checkUnnamed272(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Schema = 0;
api.GoogleCloudAiplatformV1Schema buildGoogleCloudAiplatformV1Schema() {
  final o = api.GoogleCloudAiplatformV1Schema();
  buildCounterGoogleCloudAiplatformV1Schema++;
  if (buildCounterGoogleCloudAiplatformV1Schema < 3) {
    o.description = 'foo';
    o.enum_ = buildUnnamed270();
    o.example = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.format = 'foo';
    o.items = buildGoogleCloudAiplatformV1Schema();
    o.nullable = true;
    o.properties = buildUnnamed271();
    o.required = buildUnnamed272();
    o.type = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Schema--;
  return o;
}

void checkGoogleCloudAiplatformV1Schema(api.GoogleCloudAiplatformV1Schema o) {
  buildCounterGoogleCloudAiplatformV1Schema++;
  if (buildCounterGoogleCloudAiplatformV1Schema < 3) {
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    checkUnnamed270(o.enum_!);
    var casted63 = (o.example!) as core.Map;
    unittest.expect(casted63, unittest.hasLength(3));
    unittest.expect(
      casted63['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted63['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted63['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.format!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1Schema(o.items!);
    unittest.expect(o.nullable!, unittest.isTrue);
    checkUnnamed271(o.properties!);
    checkUnnamed272(o.required!);
    unittest.expect(
      o.type!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Schema--;
}

core.List<api.GoogleCloudAiplatformV1DataItemView> buildUnnamed273() => [
      buildGoogleCloudAiplatformV1DataItemView(),
      buildGoogleCloudAiplatformV1DataItemView(),
    ];

void checkUnnamed273(core.List<api.GoogleCloudAiplatformV1DataItemView> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1DataItemView(o[0]);
  checkGoogleCloudAiplatformV1DataItemView(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1SearchDataItemsResponse = 0;
api.GoogleCloudAiplatformV1SearchDataItemsResponse
    buildGoogleCloudAiplatformV1SearchDataItemsResponse() {
  final o = api.GoogleCloudAiplatformV1SearchDataItemsResponse();
  buildCounterGoogleCloudAiplatformV1SearchDataItemsResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchDataItemsResponse < 3) {
    o.dataItemViews = buildUnnamed273();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SearchDataItemsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchDataItemsResponse(
    api.GoogleCloudAiplatformV1SearchDataItemsResponse o) {
  buildCounterGoogleCloudAiplatformV1SearchDataItemsResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchDataItemsResponse < 3) {
    checkUnnamed273(o.dataItemViews!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SearchDataItemsResponse--;
}

core.List<api.GoogleCloudAiplatformV1Feature> buildUnnamed274() => [
      buildGoogleCloudAiplatformV1Feature(),
      buildGoogleCloudAiplatformV1Feature(),
    ];

void checkUnnamed274(core.List<api.GoogleCloudAiplatformV1Feature> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Feature(o[0]);
  checkGoogleCloudAiplatformV1Feature(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1SearchFeaturesResponse = 0;
api.GoogleCloudAiplatformV1SearchFeaturesResponse
    buildGoogleCloudAiplatformV1SearchFeaturesResponse() {
  final o = api.GoogleCloudAiplatformV1SearchFeaturesResponse();
  buildCounterGoogleCloudAiplatformV1SearchFeaturesResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchFeaturesResponse < 3) {
    o.features = buildUnnamed274();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SearchFeaturesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchFeaturesResponse(
    api.GoogleCloudAiplatformV1SearchFeaturesResponse o) {
  buildCounterGoogleCloudAiplatformV1SearchFeaturesResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchFeaturesResponse < 3) {
    checkUnnamed274(o.features!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SearchFeaturesResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesRequest =
    0;
api.GoogleCloudAiplatformV1SearchMigratableResourcesRequest
    buildGoogleCloudAiplatformV1SearchMigratableResourcesRequest() {
  final o = api.GoogleCloudAiplatformV1SearchMigratableResourcesRequest();
  buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesRequest++;
  if (buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesRequest < 3) {
    o.filter = 'foo';
    o.pageSize = 42;
    o.pageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchMigratableResourcesRequest(
    api.GoogleCloudAiplatformV1SearchMigratableResourcesRequest o) {
  buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesRequest++;
  if (buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesRequest < 3) {
    unittest.expect(
      o.filter!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.pageSize!,
      unittest.equals(42),
    );
    unittest.expect(
      o.pageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesRequest--;
}

core.List<api.GoogleCloudAiplatformV1MigratableResource> buildUnnamed275() => [
      buildGoogleCloudAiplatformV1MigratableResource(),
      buildGoogleCloudAiplatformV1MigratableResource(),
    ];

void checkUnnamed275(
    core.List<api.GoogleCloudAiplatformV1MigratableResource> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1MigratableResource(o[0]);
  checkGoogleCloudAiplatformV1MigratableResource(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesResponse =
    0;
api.GoogleCloudAiplatformV1SearchMigratableResourcesResponse
    buildGoogleCloudAiplatformV1SearchMigratableResourcesResponse() {
  final o = api.GoogleCloudAiplatformV1SearchMigratableResourcesResponse();
  buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesResponse <
      3) {
    o.migratableResources = buildUnnamed275();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchMigratableResourcesResponse(
    api.GoogleCloudAiplatformV1SearchMigratableResourcesResponse o) {
  buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesResponse <
      3) {
    checkUnnamed275(o.migratableResources!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SearchMigratableResourcesResponse--;
}

core.List<
        api
        .GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective>
    buildUnnamed276() => [
          buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective(),
          buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective(),
        ];

void checkUnnamed276(
    core.List<
            api
            .GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective(
      o[0]);
  checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective(
      o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest =
    0;
api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest
    buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest() {
  final o = api
      .GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest();
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest++;
  if (buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest <
      3) {
    o.deployedModelId = 'foo';
    o.endTime = 'foo';
    o.featureDisplayName = 'foo';
    o.objectives = buildUnnamed276();
    o.pageSize = 42;
    o.pageToken = 'foo';
    o.startTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest(
    api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest
        o) {
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest++;
  if (buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest <
      3) {
    unittest.expect(
      o.deployedModelId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.featureDisplayName!,
      unittest.equals('foo'),
    );
    checkUnnamed276(o.objectives!);
    unittest.expect(
      o.pageSize!,
      unittest.equals(42),
    );
    unittest.expect(
      o.pageToken!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective =
    0;
api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective
    buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective() {
  final o = api
      .GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective();
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective++;
  if (buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective <
      3) {
    o.topFeatureCount = 42;
    o.type = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective(
    api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective
        o) {
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective++;
  if (buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective <
      3) {
    unittest.expect(
      o.topFeatureCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.type!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective--;
}

core.List<api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies>
    buildUnnamed277() => [
          buildGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies(),
          buildGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies(),
        ];

void checkUnnamed277(
    core.List<api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies(o[0]);
  checkGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse =
    0;
api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse
    buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse() {
  final o = api
      .GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse();
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse <
      3) {
    o.monitoringStats = buildUnnamed277();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse(
    api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse
        o) {
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse <
      3) {
    checkUnnamed277(o.monitoringStats!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesRequest = 0;
api.GoogleCloudAiplatformV1SearchNearestEntitiesRequest
    buildGoogleCloudAiplatformV1SearchNearestEntitiesRequest() {
  final o = api.GoogleCloudAiplatformV1SearchNearestEntitiesRequest();
  buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesRequest++;
  if (buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesRequest < 3) {
    o.query = buildGoogleCloudAiplatformV1NearestNeighborQuery();
    o.returnFullEntity = true;
  }
  buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchNearestEntitiesRequest(
    api.GoogleCloudAiplatformV1SearchNearestEntitiesRequest o) {
  buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesRequest++;
  if (buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesRequest < 3) {
    checkGoogleCloudAiplatformV1NearestNeighborQuery(o.query!);
    unittest.expect(o.returnFullEntity!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesResponse = 0;
api.GoogleCloudAiplatformV1SearchNearestEntitiesResponse
    buildGoogleCloudAiplatformV1SearchNearestEntitiesResponse() {
  final o = api.GoogleCloudAiplatformV1SearchNearestEntitiesResponse();
  buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesResponse < 3) {
    o.nearestNeighbors = buildGoogleCloudAiplatformV1NearestNeighbors();
  }
  buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1SearchNearestEntitiesResponse(
    api.GoogleCloudAiplatformV1SearchNearestEntitiesResponse o) {
  buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesResponse++;
  if (buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesResponse < 3) {
    checkGoogleCloudAiplatformV1NearestNeighbors(o.nearestNeighbors!);
  }
  buildCounterGoogleCloudAiplatformV1SearchNearestEntitiesResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1Segment = 0;
api.GoogleCloudAiplatformV1Segment buildGoogleCloudAiplatformV1Segment() {
  final o = api.GoogleCloudAiplatformV1Segment();
  buildCounterGoogleCloudAiplatformV1Segment++;
  if (buildCounterGoogleCloudAiplatformV1Segment < 3) {
    o.endIndex = 42;
    o.partIndex = 42;
    o.startIndex = 42;
  }
  buildCounterGoogleCloudAiplatformV1Segment--;
  return o;
}

void checkGoogleCloudAiplatformV1Segment(api.GoogleCloudAiplatformV1Segment o) {
  buildCounterGoogleCloudAiplatformV1Segment++;
  if (buildCounterGoogleCloudAiplatformV1Segment < 3) {
    unittest.expect(
      o.endIndex!,
      unittest.equals(42),
    );
    unittest.expect(
      o.partIndex!,
      unittest.equals(42),
    );
    unittest.expect(
      o.startIndex!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1Segment--;
}

core.int buildCounterGoogleCloudAiplatformV1ShieldedVmConfig = 0;
api.GoogleCloudAiplatformV1ShieldedVmConfig
    buildGoogleCloudAiplatformV1ShieldedVmConfig() {
  final o = api.GoogleCloudAiplatformV1ShieldedVmConfig();
  buildCounterGoogleCloudAiplatformV1ShieldedVmConfig++;
  if (buildCounterGoogleCloudAiplatformV1ShieldedVmConfig < 3) {
    o.enableSecureBoot = true;
  }
  buildCounterGoogleCloudAiplatformV1ShieldedVmConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ShieldedVmConfig(
    api.GoogleCloudAiplatformV1ShieldedVmConfig o) {
  buildCounterGoogleCloudAiplatformV1ShieldedVmConfig++;
  if (buildCounterGoogleCloudAiplatformV1ShieldedVmConfig < 3) {
    unittest.expect(o.enableSecureBoot!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1ShieldedVmConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1SmoothGradConfig = 0;
api.GoogleCloudAiplatformV1SmoothGradConfig
    buildGoogleCloudAiplatformV1SmoothGradConfig() {
  final o = api.GoogleCloudAiplatformV1SmoothGradConfig();
  buildCounterGoogleCloudAiplatformV1SmoothGradConfig++;
  if (buildCounterGoogleCloudAiplatformV1SmoothGradConfig < 3) {
    o.featureNoiseSigma = buildGoogleCloudAiplatformV1FeatureNoiseSigma();
    o.noiseSigma = 42.0;
    o.noisySampleCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1SmoothGradConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1SmoothGradConfig(
    api.GoogleCloudAiplatformV1SmoothGradConfig o) {
  buildCounterGoogleCloudAiplatformV1SmoothGradConfig++;
  if (buildCounterGoogleCloudAiplatformV1SmoothGradConfig < 3) {
    checkGoogleCloudAiplatformV1FeatureNoiseSigma(o.featureNoiseSigma!);
    unittest.expect(
      o.noiseSigma!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.noisySampleCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1SmoothGradConfig--;
}

core.List<core.String> buildUnnamed278() => [
      'foo',
      'foo',
    ];

void checkUnnamed278(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed279() => [
      'foo',
      'foo',
    ];

void checkUnnamed279(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed280() => [
      'foo',
      'foo',
    ];

void checkUnnamed280(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1SpecialistPool = 0;
api.GoogleCloudAiplatformV1SpecialistPool
    buildGoogleCloudAiplatformV1SpecialistPool() {
  final o = api.GoogleCloudAiplatformV1SpecialistPool();
  buildCounterGoogleCloudAiplatformV1SpecialistPool++;
  if (buildCounterGoogleCloudAiplatformV1SpecialistPool < 3) {
    o.displayName = 'foo';
    o.name = 'foo';
    o.pendingDataLabelingJobs = buildUnnamed278();
    o.specialistManagerEmails = buildUnnamed279();
    o.specialistManagersCount = 42;
    o.specialistWorkerEmails = buildUnnamed280();
  }
  buildCounterGoogleCloudAiplatformV1SpecialistPool--;
  return o;
}

void checkGoogleCloudAiplatformV1SpecialistPool(
    api.GoogleCloudAiplatformV1SpecialistPool o) {
  buildCounterGoogleCloudAiplatformV1SpecialistPool++;
  if (buildCounterGoogleCloudAiplatformV1SpecialistPool < 3) {
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed278(o.pendingDataLabelingJobs!);
    checkUnnamed279(o.specialistManagerEmails!);
    unittest.expect(
      o.specialistManagersCount!,
      unittest.equals(42),
    );
    checkUnnamed280(o.specialistWorkerEmails!);
  }
  buildCounterGoogleCloudAiplatformV1SpecialistPool--;
}

core.int buildCounterGoogleCloudAiplatformV1StartNotebookRuntimeRequest = 0;
api.GoogleCloudAiplatformV1StartNotebookRuntimeRequest
    buildGoogleCloudAiplatformV1StartNotebookRuntimeRequest() {
  final o = api.GoogleCloudAiplatformV1StartNotebookRuntimeRequest();
  buildCounterGoogleCloudAiplatformV1StartNotebookRuntimeRequest++;
  if (buildCounterGoogleCloudAiplatformV1StartNotebookRuntimeRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1StartNotebookRuntimeRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1StartNotebookRuntimeRequest(
    api.GoogleCloudAiplatformV1StartNotebookRuntimeRequest o) {
  buildCounterGoogleCloudAiplatformV1StartNotebookRuntimeRequest++;
  if (buildCounterGoogleCloudAiplatformV1StartNotebookRuntimeRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1StartNotebookRuntimeRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1StopTrialRequest = 0;
api.GoogleCloudAiplatformV1StopTrialRequest
    buildGoogleCloudAiplatformV1StopTrialRequest() {
  final o = api.GoogleCloudAiplatformV1StopTrialRequest();
  buildCounterGoogleCloudAiplatformV1StopTrialRequest++;
  if (buildCounterGoogleCloudAiplatformV1StopTrialRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1StopTrialRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1StopTrialRequest(
    api.GoogleCloudAiplatformV1StopTrialRequest o) {
  buildCounterGoogleCloudAiplatformV1StopTrialRequest++;
  if (buildCounterGoogleCloudAiplatformV1StopTrialRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1StopTrialRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1StratifiedSplit = 0;
api.GoogleCloudAiplatformV1StratifiedSplit
    buildGoogleCloudAiplatformV1StratifiedSplit() {
  final o = api.GoogleCloudAiplatformV1StratifiedSplit();
  buildCounterGoogleCloudAiplatformV1StratifiedSplit++;
  if (buildCounterGoogleCloudAiplatformV1StratifiedSplit < 3) {
    o.key = 'foo';
    o.testFraction = 42.0;
    o.trainingFraction = 42.0;
    o.validationFraction = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1StratifiedSplit--;
  return o;
}

void checkGoogleCloudAiplatformV1StratifiedSplit(
    api.GoogleCloudAiplatformV1StratifiedSplit o) {
  buildCounterGoogleCloudAiplatformV1StratifiedSplit++;
  if (buildCounterGoogleCloudAiplatformV1StratifiedSplit < 3) {
    unittest.expect(
      o.key!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.testFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.trainingFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.validationFraction!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1StratifiedSplit--;
}

core.int buildCounterGoogleCloudAiplatformV1StreamRawPredictRequest = 0;
api.GoogleCloudAiplatformV1StreamRawPredictRequest
    buildGoogleCloudAiplatformV1StreamRawPredictRequest() {
  final o = api.GoogleCloudAiplatformV1StreamRawPredictRequest();
  buildCounterGoogleCloudAiplatformV1StreamRawPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1StreamRawPredictRequest < 3) {
    o.httpBody = buildGoogleApiHttpBody();
  }
  buildCounterGoogleCloudAiplatformV1StreamRawPredictRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1StreamRawPredictRequest(
    api.GoogleCloudAiplatformV1StreamRawPredictRequest o) {
  buildCounterGoogleCloudAiplatformV1StreamRawPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1StreamRawPredictRequest < 3) {
    checkGoogleApiHttpBody(o.httpBody!);
  }
  buildCounterGoogleCloudAiplatformV1StreamRawPredictRequest--;
}

core.List<api.GoogleCloudAiplatformV1Tensor> buildUnnamed281() => [
      buildGoogleCloudAiplatformV1Tensor(),
      buildGoogleCloudAiplatformV1Tensor(),
    ];

void checkUnnamed281(core.List<api.GoogleCloudAiplatformV1Tensor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Tensor(o[0]);
  checkGoogleCloudAiplatformV1Tensor(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1StreamingPredictRequest = 0;
api.GoogleCloudAiplatformV1StreamingPredictRequest
    buildGoogleCloudAiplatformV1StreamingPredictRequest() {
  final o = api.GoogleCloudAiplatformV1StreamingPredictRequest();
  buildCounterGoogleCloudAiplatformV1StreamingPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1StreamingPredictRequest < 3) {
    o.inputs = buildUnnamed281();
    o.parameters = buildGoogleCloudAiplatformV1Tensor();
  }
  buildCounterGoogleCloudAiplatformV1StreamingPredictRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1StreamingPredictRequest(
    api.GoogleCloudAiplatformV1StreamingPredictRequest o) {
  buildCounterGoogleCloudAiplatformV1StreamingPredictRequest++;
  if (buildCounterGoogleCloudAiplatformV1StreamingPredictRequest < 3) {
    checkUnnamed281(o.inputs!);
    checkGoogleCloudAiplatformV1Tensor(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1StreamingPredictRequest--;
}

core.List<api.GoogleCloudAiplatformV1Tensor> buildUnnamed282() => [
      buildGoogleCloudAiplatformV1Tensor(),
      buildGoogleCloudAiplatformV1Tensor(),
    ];

void checkUnnamed282(core.List<api.GoogleCloudAiplatformV1Tensor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Tensor(o[0]);
  checkGoogleCloudAiplatformV1Tensor(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1StreamingPredictResponse = 0;
api.GoogleCloudAiplatformV1StreamingPredictResponse
    buildGoogleCloudAiplatformV1StreamingPredictResponse() {
  final o = api.GoogleCloudAiplatformV1StreamingPredictResponse();
  buildCounterGoogleCloudAiplatformV1StreamingPredictResponse++;
  if (buildCounterGoogleCloudAiplatformV1StreamingPredictResponse < 3) {
    o.outputs = buildUnnamed282();
    o.parameters = buildGoogleCloudAiplatformV1Tensor();
  }
  buildCounterGoogleCloudAiplatformV1StreamingPredictResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1StreamingPredictResponse(
    api.GoogleCloudAiplatformV1StreamingPredictResponse o) {
  buildCounterGoogleCloudAiplatformV1StreamingPredictResponse++;
  if (buildCounterGoogleCloudAiplatformV1StreamingPredictResponse < 3) {
    checkUnnamed282(o.outputs!);
    checkGoogleCloudAiplatformV1Tensor(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1StreamingPredictResponse--;
}

core.List<core.String> buildUnnamed283() => [
      'foo',
      'foo',
    ];

void checkUnnamed283(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest =
    0;
api.GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest
    buildGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest() {
  final o = api.GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest();
  buildCounterGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest <
      3) {
    o.entityIds = buildUnnamed283();
    o.featureSelector = buildGoogleCloudAiplatformV1FeatureSelector();
  }
  buildCounterGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest(
    api.GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest o) {
  buildCounterGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest <
      3) {
    checkUnnamed283(o.entityIds!);
    checkGoogleCloudAiplatformV1FeatureSelector(o.featureSelector!);
  }
  buildCounterGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest--;
}

core.List<core.String> buildUnnamed284() => [
      'foo',
      'foo',
    ];

void checkUnnamed284(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1StringArray = 0;
api.GoogleCloudAiplatformV1StringArray
    buildGoogleCloudAiplatformV1StringArray() {
  final o = api.GoogleCloudAiplatformV1StringArray();
  buildCounterGoogleCloudAiplatformV1StringArray++;
  if (buildCounterGoogleCloudAiplatformV1StringArray < 3) {
    o.values = buildUnnamed284();
  }
  buildCounterGoogleCloudAiplatformV1StringArray--;
  return o;
}

void checkGoogleCloudAiplatformV1StringArray(
    api.GoogleCloudAiplatformV1StringArray o) {
  buildCounterGoogleCloudAiplatformV1StringArray++;
  if (buildCounterGoogleCloudAiplatformV1StringArray < 3) {
    checkUnnamed284(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1StringArray--;
}

core.int buildCounterGoogleCloudAiplatformV1Study = 0;
api.GoogleCloudAiplatformV1Study buildGoogleCloudAiplatformV1Study() {
  final o = api.GoogleCloudAiplatformV1Study();
  buildCounterGoogleCloudAiplatformV1Study++;
  if (buildCounterGoogleCloudAiplatformV1Study < 3) {
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.inactiveReason = 'foo';
    o.name = 'foo';
    o.state = 'foo';
    o.studySpec = buildGoogleCloudAiplatformV1StudySpec();
  }
  buildCounterGoogleCloudAiplatformV1Study--;
  return o;
}

void checkGoogleCloudAiplatformV1Study(api.GoogleCloudAiplatformV1Study o) {
  buildCounterGoogleCloudAiplatformV1Study++;
  if (buildCounterGoogleCloudAiplatformV1Study < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.inactiveReason!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1StudySpec(o.studySpec!);
  }
  buildCounterGoogleCloudAiplatformV1Study--;
}

core.List<api.GoogleCloudAiplatformV1StudySpecMetricSpec> buildUnnamed285() => [
      buildGoogleCloudAiplatformV1StudySpecMetricSpec(),
      buildGoogleCloudAiplatformV1StudySpecMetricSpec(),
    ];

void checkUnnamed285(
    core.List<api.GoogleCloudAiplatformV1StudySpecMetricSpec> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1StudySpecMetricSpec(o[0]);
  checkGoogleCloudAiplatformV1StudySpecMetricSpec(o[1]);
}

core.List<api.GoogleCloudAiplatformV1StudySpecParameterSpec>
    buildUnnamed286() => [
          buildGoogleCloudAiplatformV1StudySpecParameterSpec(),
          buildGoogleCloudAiplatformV1StudySpecParameterSpec(),
        ];

void checkUnnamed286(
    core.List<api.GoogleCloudAiplatformV1StudySpecParameterSpec> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1StudySpecParameterSpec(o[0]);
  checkGoogleCloudAiplatformV1StudySpecParameterSpec(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1StudySpec = 0;
api.GoogleCloudAiplatformV1StudySpec buildGoogleCloudAiplatformV1StudySpec() {
  final o = api.GoogleCloudAiplatformV1StudySpec();
  buildCounterGoogleCloudAiplatformV1StudySpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpec < 3) {
    o.algorithm = 'foo';
    o.convexAutomatedStoppingSpec =
        buildGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec();
    o.decayCurveStoppingSpec =
        buildGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec();
    o.measurementSelectionType = 'foo';
    o.medianAutomatedStoppingSpec =
        buildGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec();
    o.metrics = buildUnnamed285();
    o.observationNoise = 'foo';
    o.parameters = buildUnnamed286();
    o.studyStoppingConfig =
        buildGoogleCloudAiplatformV1StudySpecStudyStoppingConfig();
  }
  buildCounterGoogleCloudAiplatformV1StudySpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpec(
    api.GoogleCloudAiplatformV1StudySpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpec < 3) {
    unittest.expect(
      o.algorithm!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec(
        o.convexAutomatedStoppingSpec!);
    checkGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec(
        o.decayCurveStoppingSpec!);
    unittest.expect(
      o.measurementSelectionType!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec(
        o.medianAutomatedStoppingSpec!);
    checkUnnamed285(o.metrics!);
    unittest.expect(
      o.observationNoise!,
      unittest.equals('foo'),
    );
    checkUnnamed286(o.parameters!);
    checkGoogleCloudAiplatformV1StudySpecStudyStoppingConfig(
        o.studyStoppingConfig!);
  }
  buildCounterGoogleCloudAiplatformV1StudySpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec = 0;
api.GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec
    buildGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec() {
  final o = api.GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec <
      3) {
    o.learningRateParameterName = 'foo';
    o.maxStepCount = 'foo';
    o.minMeasurementCount = 'foo';
    o.minStepCount = 'foo';
    o.updateAllStoppedTrials = true;
    o.useElapsedDuration = true;
  }
  buildCounterGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec(
    api.GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec <
      3) {
    unittest.expect(
      o.learningRateParameterName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.maxStepCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.minMeasurementCount!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.minStepCount!,
      unittest.equals('foo'),
    );
    unittest.expect(o.updateAllStoppedTrials!, unittest.isTrue);
    unittest.expect(o.useElapsedDuration!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec =
    0;
api.GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec
    buildGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec() {
  final o =
      api.GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec <
      3) {
    o.useElapsedDuration = true;
  }
  buildCounterGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec(
    api.GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec <
      3) {
    unittest.expect(o.useElapsedDuration!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec = 0;
api.GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec
    buildGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec() {
  final o = api.GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec <
      3) {
    o.useElapsedDuration = true;
  }
  buildCounterGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec(
    api.GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec <
      3) {
    unittest.expect(o.useElapsedDuration!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1StudySpecMetricSpec = 0;
api.GoogleCloudAiplatformV1StudySpecMetricSpec
    buildGoogleCloudAiplatformV1StudySpecMetricSpec() {
  final o = api.GoogleCloudAiplatformV1StudySpecMetricSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecMetricSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecMetricSpec < 3) {
    o.goal = 'foo';
    o.metricId = 'foo';
    o.safetyConfig =
        buildGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig();
  }
  buildCounterGoogleCloudAiplatformV1StudySpecMetricSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecMetricSpec(
    api.GoogleCloudAiplatformV1StudySpecMetricSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecMetricSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecMetricSpec < 3) {
    unittest.expect(
      o.goal!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.metricId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig(
        o.safetyConfig!);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecMetricSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig =
    0;
api.GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig
    buildGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig() {
  final o = api.GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig();
  buildCounterGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig <
      3) {
    o.desiredMinSafeTrialsFraction = 42.0;
    o.safetyThreshold = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig(
    api.GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig o) {
  buildCounterGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig <
      3) {
    unittest.expect(
      o.desiredMinSafeTrialsFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.safetyThreshold!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig--;
}

core.List<
        api
        .GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec>
    buildUnnamed287() => [
          buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec(),
          buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec(),
        ];

void checkUnnamed287(
    core.List<
            api
            .GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec>
        o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec(
      o[0]);
  checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec(
      o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1StudySpecParameterSpec = 0;
api.GoogleCloudAiplatformV1StudySpecParameterSpec
    buildGoogleCloudAiplatformV1StudySpecParameterSpec() {
  final o = api.GoogleCloudAiplatformV1StudySpecParameterSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpec < 3) {
    o.categoricalValueSpec =
        buildGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec();
    o.conditionalParameterSpecs = buildUnnamed287();
    o.discreteValueSpec =
        buildGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec();
    o.doubleValueSpec =
        buildGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec();
    o.integerValueSpec =
        buildGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec();
    o.parameterId = 'foo';
    o.scaleType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpec(
    api.GoogleCloudAiplatformV1StudySpecParameterSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpec < 3) {
    checkGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec(
        o.categoricalValueSpec!);
    checkUnnamed287(o.conditionalParameterSpecs!);
    checkGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec(
        o.discreteValueSpec!);
    checkGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec(
        o.doubleValueSpec!);
    checkGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec(
        o.integerValueSpec!);
    unittest.expect(
      o.parameterId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.scaleType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpec--;
}

core.List<core.String> buildUnnamed288() => [
      'foo',
      'foo',
    ];

void checkUnnamed288(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec =
    0;
api.GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec
    buildGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec() {
  final o =
      api.GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec <
      3) {
    o.defaultValue = 'foo';
    o.values = buildUnnamed288();
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec(
    api.GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec <
      3) {
    unittest.expect(
      o.defaultValue!,
      unittest.equals('foo'),
    );
    checkUnnamed288(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec =
    0;
api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec
    buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec() {
  final o = api
      .GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec <
      3) {
    o.parameterSpec = buildGoogleCloudAiplatformV1StudySpecParameterSpec();
    o.parentCategoricalValues =
        buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition();
    o.parentDiscreteValues =
        buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition();
    o.parentIntValues =
        buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition();
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec(
    api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec
        o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec <
      3) {
    checkGoogleCloudAiplatformV1StudySpecParameterSpec(o.parameterSpec!);
    checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition(
        o.parentCategoricalValues!);
    checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition(
        o.parentDiscreteValues!);
    checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition(
        o.parentIntValues!);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec--;
}

core.List<core.String> buildUnnamed289() => [
      'foo',
      'foo',
    ];

void checkUnnamed289(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition =
    0;
api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition
    buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition() {
  final o = api
      .GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition <
      3) {
    o.values = buildUnnamed289();
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition(
    api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition
        o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition <
      3) {
    checkUnnamed289(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition--;
}

core.List<core.double> buildUnnamed290() => [
      42.0,
      42.0,
    ];

void checkUnnamed290(core.List<core.double> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42.0),
  );
  unittest.expect(
    o[1],
    unittest.equals(42.0),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition =
    0;
api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition
    buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition() {
  final o = api
      .GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition <
      3) {
    o.values = buildUnnamed290();
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition(
    api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition
        o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition <
      3) {
    checkUnnamed290(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition--;
}

core.List<core.String> buildUnnamed291() => [
      'foo',
      'foo',
    ];

void checkUnnamed291(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition =
    0;
api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition
    buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition() {
  final o = api
      .GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition <
      3) {
    o.values = buildUnnamed291();
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition(
    api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition
        o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition <
      3) {
    checkUnnamed291(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition--;
}

core.List<core.double> buildUnnamed292() => [
      42.0,
      42.0,
    ];

void checkUnnamed292(core.List<core.double> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42.0),
  );
  unittest.expect(
    o[1],
    unittest.equals(42.0),
  );
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec =
    0;
api.GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec
    buildGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec() {
  final o =
      api.GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec <
      3) {
    o.defaultValue = 42.0;
    o.values = buildUnnamed292();
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec(
    api.GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec <
      3) {
    unittest.expect(
      o.defaultValue!,
      unittest.equals(42.0),
    );
    checkUnnamed292(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec =
    0;
api.GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec
    buildGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec() {
  final o = api.GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec <
      3) {
    o.defaultValue = 42.0;
    o.maxValue = 42.0;
    o.minValue = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec(
    api.GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec <
      3) {
    unittest.expect(
      o.defaultValue!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.maxValue!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.minValue!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec--;
}

core.int
    buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec =
    0;
api.GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec
    buildGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec() {
  final o = api.GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec();
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec <
      3) {
    o.defaultValue = 'foo';
    o.maxValue = 'foo';
    o.minValue = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec(
    api.GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec o) {
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec <
      3) {
    unittest.expect(
      o.defaultValue!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.maxValue!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.minValue!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec--;
}

core.int buildCounterGoogleCloudAiplatformV1StudySpecStudyStoppingConfig = 0;
api.GoogleCloudAiplatformV1StudySpecStudyStoppingConfig
    buildGoogleCloudAiplatformV1StudySpecStudyStoppingConfig() {
  final o = api.GoogleCloudAiplatformV1StudySpecStudyStoppingConfig();
  buildCounterGoogleCloudAiplatformV1StudySpecStudyStoppingConfig++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecStudyStoppingConfig < 3) {
    o.maxDurationNoProgress = 'foo';
    o.maxNumTrials = 42;
    o.maxNumTrialsNoProgress = 42;
    o.maximumRuntimeConstraint =
        buildGoogleCloudAiplatformV1StudyTimeConstraint();
    o.minNumTrials = 42;
    o.minimumRuntimeConstraint =
        buildGoogleCloudAiplatformV1StudyTimeConstraint();
    o.shouldStopAsap = true;
  }
  buildCounterGoogleCloudAiplatformV1StudySpecStudyStoppingConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1StudySpecStudyStoppingConfig(
    api.GoogleCloudAiplatformV1StudySpecStudyStoppingConfig o) {
  buildCounterGoogleCloudAiplatformV1StudySpecStudyStoppingConfig++;
  if (buildCounterGoogleCloudAiplatformV1StudySpecStudyStoppingConfig < 3) {
    unittest.expect(
      o.maxDurationNoProgress!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.maxNumTrials!,
      unittest.equals(42),
    );
    unittest.expect(
      o.maxNumTrialsNoProgress!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1StudyTimeConstraint(
        o.maximumRuntimeConstraint!);
    unittest.expect(
      o.minNumTrials!,
      unittest.equals(42),
    );
    checkGoogleCloudAiplatformV1StudyTimeConstraint(
        o.minimumRuntimeConstraint!);
    unittest.expect(o.shouldStopAsap!, unittest.isTrue);
  }
  buildCounterGoogleCloudAiplatformV1StudySpecStudyStoppingConfig--;
}

core.int buildCounterGoogleCloudAiplatformV1StudyTimeConstraint = 0;
api.GoogleCloudAiplatformV1StudyTimeConstraint
    buildGoogleCloudAiplatformV1StudyTimeConstraint() {
  final o = api.GoogleCloudAiplatformV1StudyTimeConstraint();
  buildCounterGoogleCloudAiplatformV1StudyTimeConstraint++;
  if (buildCounterGoogleCloudAiplatformV1StudyTimeConstraint < 3) {
    o.endTime = 'foo';
    o.maxDuration = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1StudyTimeConstraint--;
  return o;
}

void checkGoogleCloudAiplatformV1StudyTimeConstraint(
    api.GoogleCloudAiplatformV1StudyTimeConstraint o) {
  buildCounterGoogleCloudAiplatformV1StudyTimeConstraint++;
  if (buildCounterGoogleCloudAiplatformV1StudyTimeConstraint < 3) {
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.maxDuration!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1StudyTimeConstraint--;
}

core.List<api.GoogleCloudAiplatformV1TrialContext> buildUnnamed293() => [
      buildGoogleCloudAiplatformV1TrialContext(),
      buildGoogleCloudAiplatformV1TrialContext(),
    ];

void checkUnnamed293(core.List<api.GoogleCloudAiplatformV1TrialContext> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TrialContext(o[0]);
  checkGoogleCloudAiplatformV1TrialContext(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1SuggestTrialsRequest = 0;
api.GoogleCloudAiplatformV1SuggestTrialsRequest
    buildGoogleCloudAiplatformV1SuggestTrialsRequest() {
  final o = api.GoogleCloudAiplatformV1SuggestTrialsRequest();
  buildCounterGoogleCloudAiplatformV1SuggestTrialsRequest++;
  if (buildCounterGoogleCloudAiplatformV1SuggestTrialsRequest < 3) {
    o.clientId = 'foo';
    o.contexts = buildUnnamed293();
    o.suggestionCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1SuggestTrialsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1SuggestTrialsRequest(
    api.GoogleCloudAiplatformV1SuggestTrialsRequest o) {
  buildCounterGoogleCloudAiplatformV1SuggestTrialsRequest++;
  if (buildCounterGoogleCloudAiplatformV1SuggestTrialsRequest < 3) {
    unittest.expect(
      o.clientId!,
      unittest.equals('foo'),
    );
    checkUnnamed293(o.contexts!);
    unittest.expect(
      o.suggestionCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1SuggestTrialsRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1SyncFeatureViewRequest = 0;
api.GoogleCloudAiplatformV1SyncFeatureViewRequest
    buildGoogleCloudAiplatformV1SyncFeatureViewRequest() {
  final o = api.GoogleCloudAiplatformV1SyncFeatureViewRequest();
  buildCounterGoogleCloudAiplatformV1SyncFeatureViewRequest++;
  if (buildCounterGoogleCloudAiplatformV1SyncFeatureViewRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1SyncFeatureViewRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1SyncFeatureViewRequest(
    api.GoogleCloudAiplatformV1SyncFeatureViewRequest o) {
  buildCounterGoogleCloudAiplatformV1SyncFeatureViewRequest++;
  if (buildCounterGoogleCloudAiplatformV1SyncFeatureViewRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1SyncFeatureViewRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1SyncFeatureViewResponse = 0;
api.GoogleCloudAiplatformV1SyncFeatureViewResponse
    buildGoogleCloudAiplatformV1SyncFeatureViewResponse() {
  final o = api.GoogleCloudAiplatformV1SyncFeatureViewResponse();
  buildCounterGoogleCloudAiplatformV1SyncFeatureViewResponse++;
  if (buildCounterGoogleCloudAiplatformV1SyncFeatureViewResponse < 3) {
    o.featureViewSync = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1SyncFeatureViewResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1SyncFeatureViewResponse(
    api.GoogleCloudAiplatformV1SyncFeatureViewResponse o) {
  buildCounterGoogleCloudAiplatformV1SyncFeatureViewResponse++;
  if (buildCounterGoogleCloudAiplatformV1SyncFeatureViewResponse < 3) {
    unittest.expect(
      o.featureViewSync!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1SyncFeatureViewResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1TFRecordDestination = 0;
api.GoogleCloudAiplatformV1TFRecordDestination
    buildGoogleCloudAiplatformV1TFRecordDestination() {
  final o = api.GoogleCloudAiplatformV1TFRecordDestination();
  buildCounterGoogleCloudAiplatformV1TFRecordDestination++;
  if (buildCounterGoogleCloudAiplatformV1TFRecordDestination < 3) {
    o.gcsDestination = buildGoogleCloudAiplatformV1GcsDestination();
  }
  buildCounterGoogleCloudAiplatformV1TFRecordDestination--;
  return o;
}

void checkGoogleCloudAiplatformV1TFRecordDestination(
    api.GoogleCloudAiplatformV1TFRecordDestination o) {
  buildCounterGoogleCloudAiplatformV1TFRecordDestination++;
  if (buildCounterGoogleCloudAiplatformV1TFRecordDestination < 3) {
    checkGoogleCloudAiplatformV1GcsDestination(o.gcsDestination!);
  }
  buildCounterGoogleCloudAiplatformV1TFRecordDestination--;
}

core.List<core.bool> buildUnnamed294() => [
      true,
      true,
    ];

void checkUnnamed294(core.List<core.bool> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(o[0], unittest.isTrue);
  unittest.expect(o[1], unittest.isTrue);
}

core.List<core.String> buildUnnamed295() => [
      'foo',
      'foo',
    ];

void checkUnnamed295(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.double> buildUnnamed296() => [
      42.0,
      42.0,
    ];

void checkUnnamed296(core.List<core.double> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42.0),
  );
  unittest.expect(
    o[1],
    unittest.equals(42.0),
  );
}

core.List<core.double> buildUnnamed297() => [
      42.0,
      42.0,
    ];

void checkUnnamed297(core.List<core.double> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42.0),
  );
  unittest.expect(
    o[1],
    unittest.equals(42.0),
  );
}

core.List<core.String> buildUnnamed298() => [
      'foo',
      'foo',
    ];

void checkUnnamed298(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.int> buildUnnamed299() => [
      42,
      42,
    ];

void checkUnnamed299(core.List<core.int> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42),
  );
  unittest.expect(
    o[1],
    unittest.equals(42),
  );
}

core.List<api.GoogleCloudAiplatformV1Tensor> buildUnnamed300() => [
      buildGoogleCloudAiplatformV1Tensor(),
      buildGoogleCloudAiplatformV1Tensor(),
    ];

void checkUnnamed300(core.List<api.GoogleCloudAiplatformV1Tensor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Tensor(o[0]);
  checkGoogleCloudAiplatformV1Tensor(o[1]);
}

core.List<core.String> buildUnnamed301() => [
      'foo',
      'foo',
    ];

void checkUnnamed301(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed302() => [
      'foo',
      'foo',
    ];

void checkUnnamed302(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.Map<core.String, api.GoogleCloudAiplatformV1Tensor> buildUnnamed303() => {
      'x': buildGoogleCloudAiplatformV1Tensor(),
      'y': buildGoogleCloudAiplatformV1Tensor(),
    };

void checkUnnamed303(
    core.Map<core.String, api.GoogleCloudAiplatformV1Tensor> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Tensor(o['x']!);
  checkGoogleCloudAiplatformV1Tensor(o['y']!);
}

core.List<core.String> buildUnnamed304() => [
      'foo',
      'foo',
    ];

void checkUnnamed304(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.int> buildUnnamed305() => [
      42,
      42,
    ];

void checkUnnamed305(core.List<core.int> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals(42),
  );
  unittest.expect(
    o[1],
    unittest.equals(42),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Tensor = 0;
api.GoogleCloudAiplatformV1Tensor buildGoogleCloudAiplatformV1Tensor() {
  final o = api.GoogleCloudAiplatformV1Tensor();
  buildCounterGoogleCloudAiplatformV1Tensor++;
  if (buildCounterGoogleCloudAiplatformV1Tensor < 3) {
    o.boolVal = buildUnnamed294();
    o.bytesVal = buildUnnamed295();
    o.doubleVal = buildUnnamed296();
    o.dtype = 'foo';
    o.floatVal = buildUnnamed297();
    o.int64Val = buildUnnamed298();
    o.intVal = buildUnnamed299();
    o.listVal = buildUnnamed300();
    o.shape = buildUnnamed301();
    o.stringVal = buildUnnamed302();
    o.structVal = buildUnnamed303();
    o.tensorVal = 'foo';
    o.uint64Val = buildUnnamed304();
    o.uintVal = buildUnnamed305();
  }
  buildCounterGoogleCloudAiplatformV1Tensor--;
  return o;
}

void checkGoogleCloudAiplatformV1Tensor(api.GoogleCloudAiplatformV1Tensor o) {
  buildCounterGoogleCloudAiplatformV1Tensor++;
  if (buildCounterGoogleCloudAiplatformV1Tensor < 3) {
    checkUnnamed294(o.boolVal!);
    checkUnnamed295(o.bytesVal!);
    checkUnnamed296(o.doubleVal!);
    unittest.expect(
      o.dtype!,
      unittest.equals('foo'),
    );
    checkUnnamed297(o.floatVal!);
    checkUnnamed298(o.int64Val!);
    checkUnnamed299(o.intVal!);
    checkUnnamed300(o.listVal!);
    checkUnnamed301(o.shape!);
    checkUnnamed302(o.stringVal!);
    checkUnnamed303(o.structVal!);
    unittest.expect(
      o.tensorVal!,
      unittest.equals('foo'),
    );
    checkUnnamed304(o.uint64Val!);
    checkUnnamed305(o.uintVal!);
  }
  buildCounterGoogleCloudAiplatformV1Tensor--;
}

core.Map<core.String, core.String> buildUnnamed306() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed306(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Tensorboard = 0;
api.GoogleCloudAiplatformV1Tensorboard
    buildGoogleCloudAiplatformV1Tensorboard() {
  final o = api.GoogleCloudAiplatformV1Tensorboard();
  buildCounterGoogleCloudAiplatformV1Tensorboard++;
  if (buildCounterGoogleCloudAiplatformV1Tensorboard < 3) {
    o.blobStoragePathPrefix = 'foo';
    o.createTime = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.etag = 'foo';
    o.isDefault = true;
    o.labels = buildUnnamed306();
    o.name = 'foo';
    o.runCount = 42;
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Tensorboard--;
  return o;
}

void checkGoogleCloudAiplatformV1Tensorboard(
    api.GoogleCloudAiplatformV1Tensorboard o) {
  buildCounterGoogleCloudAiplatformV1Tensorboard++;
  if (buildCounterGoogleCloudAiplatformV1Tensorboard < 3) {
    unittest.expect(
      o.blobStoragePathPrefix!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    unittest.expect(o.isDefault!, unittest.isTrue);
    checkUnnamed306(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.runCount!,
      unittest.equals(42),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Tensorboard--;
}

core.int buildCounterGoogleCloudAiplatformV1TensorboardBlob = 0;
api.GoogleCloudAiplatformV1TensorboardBlob
    buildGoogleCloudAiplatformV1TensorboardBlob() {
  final o = api.GoogleCloudAiplatformV1TensorboardBlob();
  buildCounterGoogleCloudAiplatformV1TensorboardBlob++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardBlob < 3) {
    o.data = 'foo';
    o.id = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1TensorboardBlob--;
  return o;
}

void checkGoogleCloudAiplatformV1TensorboardBlob(
    api.GoogleCloudAiplatformV1TensorboardBlob o) {
  buildCounterGoogleCloudAiplatformV1TensorboardBlob++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardBlob < 3) {
    unittest.expect(
      o.data!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TensorboardBlob--;
}

core.List<api.GoogleCloudAiplatformV1TensorboardBlob> buildUnnamed307() => [
      buildGoogleCloudAiplatformV1TensorboardBlob(),
      buildGoogleCloudAiplatformV1TensorboardBlob(),
    ];

void checkUnnamed307(core.List<api.GoogleCloudAiplatformV1TensorboardBlob> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TensorboardBlob(o[0]);
  checkGoogleCloudAiplatformV1TensorboardBlob(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1TensorboardBlobSequence = 0;
api.GoogleCloudAiplatformV1TensorboardBlobSequence
    buildGoogleCloudAiplatformV1TensorboardBlobSequence() {
  final o = api.GoogleCloudAiplatformV1TensorboardBlobSequence();
  buildCounterGoogleCloudAiplatformV1TensorboardBlobSequence++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardBlobSequence < 3) {
    o.values = buildUnnamed307();
  }
  buildCounterGoogleCloudAiplatformV1TensorboardBlobSequence--;
  return o;
}

void checkGoogleCloudAiplatformV1TensorboardBlobSequence(
    api.GoogleCloudAiplatformV1TensorboardBlobSequence o) {
  buildCounterGoogleCloudAiplatformV1TensorboardBlobSequence++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardBlobSequence < 3) {
    checkUnnamed307(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1TensorboardBlobSequence--;
}

core.Map<core.String, core.String> buildUnnamed308() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed308(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1TensorboardExperiment = 0;
api.GoogleCloudAiplatformV1TensorboardExperiment
    buildGoogleCloudAiplatformV1TensorboardExperiment() {
  final o = api.GoogleCloudAiplatformV1TensorboardExperiment();
  buildCounterGoogleCloudAiplatformV1TensorboardExperiment++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardExperiment < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed308();
    o.name = 'foo';
    o.source = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1TensorboardExperiment--;
  return o;
}

void checkGoogleCloudAiplatformV1TensorboardExperiment(
    api.GoogleCloudAiplatformV1TensorboardExperiment o) {
  buildCounterGoogleCloudAiplatformV1TensorboardExperiment++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardExperiment < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed308(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.source!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TensorboardExperiment--;
}

core.Map<core.String, core.String> buildUnnamed309() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed309(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1TensorboardRun = 0;
api.GoogleCloudAiplatformV1TensorboardRun
    buildGoogleCloudAiplatformV1TensorboardRun() {
  final o = api.GoogleCloudAiplatformV1TensorboardRun();
  buildCounterGoogleCloudAiplatformV1TensorboardRun++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardRun < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.labels = buildUnnamed309();
    o.name = 'foo';
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1TensorboardRun--;
  return o;
}

void checkGoogleCloudAiplatformV1TensorboardRun(
    api.GoogleCloudAiplatformV1TensorboardRun o) {
  buildCounterGoogleCloudAiplatformV1TensorboardRun++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardRun < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkUnnamed309(o.labels!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TensorboardRun--;
}

core.int buildCounterGoogleCloudAiplatformV1TensorboardTensor = 0;
api.GoogleCloudAiplatformV1TensorboardTensor
    buildGoogleCloudAiplatformV1TensorboardTensor() {
  final o = api.GoogleCloudAiplatformV1TensorboardTensor();
  buildCounterGoogleCloudAiplatformV1TensorboardTensor++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardTensor < 3) {
    o.value = 'foo';
    o.versionNumber = 42;
  }
  buildCounterGoogleCloudAiplatformV1TensorboardTensor--;
  return o;
}

void checkGoogleCloudAiplatformV1TensorboardTensor(
    api.GoogleCloudAiplatformV1TensorboardTensor o) {
  buildCounterGoogleCloudAiplatformV1TensorboardTensor++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardTensor < 3) {
    unittest.expect(
      o.value!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.versionNumber!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1TensorboardTensor--;
}

core.int buildCounterGoogleCloudAiplatformV1TensorboardTimeSeries = 0;
api.GoogleCloudAiplatformV1TensorboardTimeSeries
    buildGoogleCloudAiplatformV1TensorboardTimeSeries() {
  final o = api.GoogleCloudAiplatformV1TensorboardTimeSeries();
  buildCounterGoogleCloudAiplatformV1TensorboardTimeSeries++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardTimeSeries < 3) {
    o.createTime = 'foo';
    o.description = 'foo';
    o.displayName = 'foo';
    o.etag = 'foo';
    o.metadata = buildGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata();
    o.name = 'foo';
    o.pluginData = 'foo';
    o.pluginName = 'foo';
    o.updateTime = 'foo';
    o.valueType = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1TensorboardTimeSeries--;
  return o;
}

void checkGoogleCloudAiplatformV1TensorboardTimeSeries(
    api.GoogleCloudAiplatformV1TensorboardTimeSeries o) {
  buildCounterGoogleCloudAiplatformV1TensorboardTimeSeries++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardTimeSeries < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata(o.metadata!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.pluginData!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.pluginName!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.valueType!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TensorboardTimeSeries--;
}

core.int buildCounterGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata = 0;
api.GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata
    buildGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata() {
  final o = api.GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata();
  buildCounterGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata < 3) {
    o.maxBlobSequenceLength = 'foo';
    o.maxStep = 'foo';
    o.maxWallTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata(
    api.GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata o) {
  buildCounterGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata++;
  if (buildCounterGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata < 3) {
    unittest.expect(
      o.maxBlobSequenceLength!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.maxStep!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.maxWallTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata--;
}

core.int buildCounterGoogleCloudAiplatformV1ThresholdConfig = 0;
api.GoogleCloudAiplatformV1ThresholdConfig
    buildGoogleCloudAiplatformV1ThresholdConfig() {
  final o = api.GoogleCloudAiplatformV1ThresholdConfig();
  buildCounterGoogleCloudAiplatformV1ThresholdConfig++;
  if (buildCounterGoogleCloudAiplatformV1ThresholdConfig < 3) {
    o.value = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1ThresholdConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1ThresholdConfig(
    api.GoogleCloudAiplatformV1ThresholdConfig o) {
  buildCounterGoogleCloudAiplatformV1ThresholdConfig++;
  if (buildCounterGoogleCloudAiplatformV1ThresholdConfig < 3) {
    unittest.expect(
      o.value!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1ThresholdConfig--;
}

core.List<api.GoogleCloudAiplatformV1TimeSeriesDataPoint> buildUnnamed310() => [
      buildGoogleCloudAiplatformV1TimeSeriesDataPoint(),
      buildGoogleCloudAiplatformV1TimeSeriesDataPoint(),
    ];

void checkUnnamed310(
    core.List<api.GoogleCloudAiplatformV1TimeSeriesDataPoint> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TimeSeriesDataPoint(o[0]);
  checkGoogleCloudAiplatformV1TimeSeriesDataPoint(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1TimeSeriesData = 0;
api.GoogleCloudAiplatformV1TimeSeriesData
    buildGoogleCloudAiplatformV1TimeSeriesData() {
  final o = api.GoogleCloudAiplatformV1TimeSeriesData();
  buildCounterGoogleCloudAiplatformV1TimeSeriesData++;
  if (buildCounterGoogleCloudAiplatformV1TimeSeriesData < 3) {
    o.tensorboardTimeSeriesId = 'foo';
    o.valueType = 'foo';
    o.values = buildUnnamed310();
  }
  buildCounterGoogleCloudAiplatformV1TimeSeriesData--;
  return o;
}

void checkGoogleCloudAiplatformV1TimeSeriesData(
    api.GoogleCloudAiplatformV1TimeSeriesData o) {
  buildCounterGoogleCloudAiplatformV1TimeSeriesData++;
  if (buildCounterGoogleCloudAiplatformV1TimeSeriesData < 3) {
    unittest.expect(
      o.tensorboardTimeSeriesId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.valueType!,
      unittest.equals('foo'),
    );
    checkUnnamed310(o.values!);
  }
  buildCounterGoogleCloudAiplatformV1TimeSeriesData--;
}

core.int buildCounterGoogleCloudAiplatformV1TimeSeriesDataPoint = 0;
api.GoogleCloudAiplatformV1TimeSeriesDataPoint
    buildGoogleCloudAiplatformV1TimeSeriesDataPoint() {
  final o = api.GoogleCloudAiplatformV1TimeSeriesDataPoint();
  buildCounterGoogleCloudAiplatformV1TimeSeriesDataPoint++;
  if (buildCounterGoogleCloudAiplatformV1TimeSeriesDataPoint < 3) {
    o.blobs = buildGoogleCloudAiplatformV1TensorboardBlobSequence();
    o.scalar = buildGoogleCloudAiplatformV1Scalar();
    o.step = 'foo';
    o.tensor = buildGoogleCloudAiplatformV1TensorboardTensor();
    o.wallTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1TimeSeriesDataPoint--;
  return o;
}

void checkGoogleCloudAiplatformV1TimeSeriesDataPoint(
    api.GoogleCloudAiplatformV1TimeSeriesDataPoint o) {
  buildCounterGoogleCloudAiplatformV1TimeSeriesDataPoint++;
  if (buildCounterGoogleCloudAiplatformV1TimeSeriesDataPoint < 3) {
    checkGoogleCloudAiplatformV1TensorboardBlobSequence(o.blobs!);
    checkGoogleCloudAiplatformV1Scalar(o.scalar!);
    unittest.expect(
      o.step!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1TensorboardTensor(o.tensor!);
    unittest.expect(
      o.wallTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TimeSeriesDataPoint--;
}

core.int buildCounterGoogleCloudAiplatformV1TimestampSplit = 0;
api.GoogleCloudAiplatformV1TimestampSplit
    buildGoogleCloudAiplatformV1TimestampSplit() {
  final o = api.GoogleCloudAiplatformV1TimestampSplit();
  buildCounterGoogleCloudAiplatformV1TimestampSplit++;
  if (buildCounterGoogleCloudAiplatformV1TimestampSplit < 3) {
    o.key = 'foo';
    o.testFraction = 42.0;
    o.trainingFraction = 42.0;
    o.validationFraction = 42.0;
  }
  buildCounterGoogleCloudAiplatformV1TimestampSplit--;
  return o;
}

void checkGoogleCloudAiplatformV1TimestampSplit(
    api.GoogleCloudAiplatformV1TimestampSplit o) {
  buildCounterGoogleCloudAiplatformV1TimestampSplit++;
  if (buildCounterGoogleCloudAiplatformV1TimestampSplit < 3) {
    unittest.expect(
      o.key!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.testFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.trainingFraction!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.validationFraction!,
      unittest.equals(42.0),
    );
  }
  buildCounterGoogleCloudAiplatformV1TimestampSplit--;
}

core.List<core.String> buildUnnamed311() => [
      'foo',
      'foo',
    ];

void checkUnnamed311(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed312() => [
      'foo',
      'foo',
    ];

void checkUnnamed312(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1TokensInfo = 0;
api.GoogleCloudAiplatformV1TokensInfo buildGoogleCloudAiplatformV1TokensInfo() {
  final o = api.GoogleCloudAiplatformV1TokensInfo();
  buildCounterGoogleCloudAiplatformV1TokensInfo++;
  if (buildCounterGoogleCloudAiplatformV1TokensInfo < 3) {
    o.tokenIds = buildUnnamed311();
    o.tokens = buildUnnamed312();
  }
  buildCounterGoogleCloudAiplatformV1TokensInfo--;
  return o;
}

void checkGoogleCloudAiplatformV1TokensInfo(
    api.GoogleCloudAiplatformV1TokensInfo o) {
  buildCounterGoogleCloudAiplatformV1TokensInfo++;
  if (buildCounterGoogleCloudAiplatformV1TokensInfo < 3) {
    checkUnnamed311(o.tokenIds!);
    checkUnnamed312(o.tokens!);
  }
  buildCounterGoogleCloudAiplatformV1TokensInfo--;
}

core.List<api.GoogleCloudAiplatformV1FunctionDeclaration> buildUnnamed313() => [
      buildGoogleCloudAiplatformV1FunctionDeclaration(),
      buildGoogleCloudAiplatformV1FunctionDeclaration(),
    ];

void checkUnnamed313(
    core.List<api.GoogleCloudAiplatformV1FunctionDeclaration> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FunctionDeclaration(o[0]);
  checkGoogleCloudAiplatformV1FunctionDeclaration(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1Tool = 0;
api.GoogleCloudAiplatformV1Tool buildGoogleCloudAiplatformV1Tool() {
  final o = api.GoogleCloudAiplatformV1Tool();
  buildCounterGoogleCloudAiplatformV1Tool++;
  if (buildCounterGoogleCloudAiplatformV1Tool < 3) {
    o.functionDeclarations = buildUnnamed313();
  }
  buildCounterGoogleCloudAiplatformV1Tool--;
  return o;
}

void checkGoogleCloudAiplatformV1Tool(api.GoogleCloudAiplatformV1Tool o) {
  buildCounterGoogleCloudAiplatformV1Tool++;
  if (buildCounterGoogleCloudAiplatformV1Tool < 3) {
    checkUnnamed313(o.functionDeclarations!);
  }
  buildCounterGoogleCloudAiplatformV1Tool--;
}

core.int buildCounterGoogleCloudAiplatformV1TrainingConfig = 0;
api.GoogleCloudAiplatformV1TrainingConfig
    buildGoogleCloudAiplatformV1TrainingConfig() {
  final o = api.GoogleCloudAiplatformV1TrainingConfig();
  buildCounterGoogleCloudAiplatformV1TrainingConfig++;
  if (buildCounterGoogleCloudAiplatformV1TrainingConfig < 3) {
    o.timeoutTrainingMilliHours = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1TrainingConfig--;
  return o;
}

void checkGoogleCloudAiplatformV1TrainingConfig(
    api.GoogleCloudAiplatformV1TrainingConfig o) {
  buildCounterGoogleCloudAiplatformV1TrainingConfig++;
  if (buildCounterGoogleCloudAiplatformV1TrainingConfig < 3) {
    unittest.expect(
      o.timeoutTrainingMilliHours!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TrainingConfig--;
}

core.Map<core.String, core.String> buildUnnamed314() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed314(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1TrainingPipeline = 0;
api.GoogleCloudAiplatformV1TrainingPipeline
    buildGoogleCloudAiplatformV1TrainingPipeline() {
  final o = api.GoogleCloudAiplatformV1TrainingPipeline();
  buildCounterGoogleCloudAiplatformV1TrainingPipeline++;
  if (buildCounterGoogleCloudAiplatformV1TrainingPipeline < 3) {
    o.createTime = 'foo';
    o.displayName = 'foo';
    o.encryptionSpec = buildGoogleCloudAiplatformV1EncryptionSpec();
    o.endTime = 'foo';
    o.error = buildGoogleRpcStatus();
    o.inputDataConfig = buildGoogleCloudAiplatformV1InputDataConfig();
    o.labels = buildUnnamed314();
    o.modelId = 'foo';
    o.modelToUpload = buildGoogleCloudAiplatformV1Model();
    o.name = 'foo';
    o.parentModel = 'foo';
    o.startTime = 'foo';
    o.state = 'foo';
    o.trainingTaskDefinition = 'foo';
    o.trainingTaskInputs = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.trainingTaskMetadata = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
    o.updateTime = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1TrainingPipeline--;
  return o;
}

void checkGoogleCloudAiplatformV1TrainingPipeline(
    api.GoogleCloudAiplatformV1TrainingPipeline o) {
  buildCounterGoogleCloudAiplatformV1TrainingPipeline++;
  if (buildCounterGoogleCloudAiplatformV1TrainingPipeline < 3) {
    unittest.expect(
      o.createTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1EncryptionSpec(o.encryptionSpec!);
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleRpcStatus(o.error!);
    checkGoogleCloudAiplatformV1InputDataConfig(o.inputDataConfig!);
    checkUnnamed314(o.labels!);
    unittest.expect(
      o.modelId!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1Model(o.modelToUpload!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.parentModel!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.trainingTaskDefinition!,
      unittest.equals('foo'),
    );
    var casted64 = (o.trainingTaskInputs!) as core.Map;
    unittest.expect(casted64, unittest.hasLength(3));
    unittest.expect(
      casted64['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted64['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted64['string'],
      unittest.equals('foo'),
    );
    var casted65 = (o.trainingTaskMetadata!) as core.Map;
    unittest.expect(casted65, unittest.hasLength(3));
    unittest.expect(
      casted65['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted65['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted65['string'],
      unittest.equals('foo'),
    );
    unittest.expect(
      o.updateTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TrainingPipeline--;
}

core.List<api.GoogleCloudAiplatformV1Measurement> buildUnnamed315() => [
      buildGoogleCloudAiplatformV1Measurement(),
      buildGoogleCloudAiplatformV1Measurement(),
    ];

void checkUnnamed315(core.List<api.GoogleCloudAiplatformV1Measurement> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1Measurement(o[0]);
  checkGoogleCloudAiplatformV1Measurement(o[1]);
}

core.List<api.GoogleCloudAiplatformV1TrialParameter> buildUnnamed316() => [
      buildGoogleCloudAiplatformV1TrialParameter(),
      buildGoogleCloudAiplatformV1TrialParameter(),
    ];

void checkUnnamed316(core.List<api.GoogleCloudAiplatformV1TrialParameter> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TrialParameter(o[0]);
  checkGoogleCloudAiplatformV1TrialParameter(o[1]);
}

core.Map<core.String, core.String> buildUnnamed317() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed317(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudAiplatformV1Trial = 0;
api.GoogleCloudAiplatformV1Trial buildGoogleCloudAiplatformV1Trial() {
  final o = api.GoogleCloudAiplatformV1Trial();
  buildCounterGoogleCloudAiplatformV1Trial++;
  if (buildCounterGoogleCloudAiplatformV1Trial < 3) {
    o.clientId = 'foo';
    o.customJob = 'foo';
    o.endTime = 'foo';
    o.finalMeasurement = buildGoogleCloudAiplatformV1Measurement();
    o.id = 'foo';
    o.infeasibleReason = 'foo';
    o.measurements = buildUnnamed315();
    o.name = 'foo';
    o.parameters = buildUnnamed316();
    o.startTime = 'foo';
    o.state = 'foo';
    o.webAccessUris = buildUnnamed317();
  }
  buildCounterGoogleCloudAiplatformV1Trial--;
  return o;
}

void checkGoogleCloudAiplatformV1Trial(api.GoogleCloudAiplatformV1Trial o) {
  buildCounterGoogleCloudAiplatformV1Trial++;
  if (buildCounterGoogleCloudAiplatformV1Trial < 3) {
    unittest.expect(
      o.clientId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.customJob!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1Measurement(o.finalMeasurement!);
    unittest.expect(
      o.id!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.infeasibleReason!,
      unittest.equals('foo'),
    );
    checkUnnamed315(o.measurements!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed316(o.parameters!);
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.state!,
      unittest.equals('foo'),
    );
    checkUnnamed317(o.webAccessUris!);
  }
  buildCounterGoogleCloudAiplatformV1Trial--;
}

core.List<api.GoogleCloudAiplatformV1TrialParameter> buildUnnamed318() => [
      buildGoogleCloudAiplatformV1TrialParameter(),
      buildGoogleCloudAiplatformV1TrialParameter(),
    ];

void checkUnnamed318(core.List<api.GoogleCloudAiplatformV1TrialParameter> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TrialParameter(o[0]);
  checkGoogleCloudAiplatformV1TrialParameter(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1TrialContext = 0;
api.GoogleCloudAiplatformV1TrialContext
    buildGoogleCloudAiplatformV1TrialContext() {
  final o = api.GoogleCloudAiplatformV1TrialContext();
  buildCounterGoogleCloudAiplatformV1TrialContext++;
  if (buildCounterGoogleCloudAiplatformV1TrialContext < 3) {
    o.description = 'foo';
    o.parameters = buildUnnamed318();
  }
  buildCounterGoogleCloudAiplatformV1TrialContext--;
  return o;
}

void checkGoogleCloudAiplatformV1TrialContext(
    api.GoogleCloudAiplatformV1TrialContext o) {
  buildCounterGoogleCloudAiplatformV1TrialContext++;
  if (buildCounterGoogleCloudAiplatformV1TrialContext < 3) {
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    checkUnnamed318(o.parameters!);
  }
  buildCounterGoogleCloudAiplatformV1TrialContext--;
}

core.int buildCounterGoogleCloudAiplatformV1TrialParameter = 0;
api.GoogleCloudAiplatformV1TrialParameter
    buildGoogleCloudAiplatformV1TrialParameter() {
  final o = api.GoogleCloudAiplatformV1TrialParameter();
  buildCounterGoogleCloudAiplatformV1TrialParameter++;
  if (buildCounterGoogleCloudAiplatformV1TrialParameter < 3) {
    o.parameterId = 'foo';
    o.value = {
      'list': [1, 2, 3],
      'bool': true,
      'string': 'foo'
    };
  }
  buildCounterGoogleCloudAiplatformV1TrialParameter--;
  return o;
}

void checkGoogleCloudAiplatformV1TrialParameter(
    api.GoogleCloudAiplatformV1TrialParameter o) {
  buildCounterGoogleCloudAiplatformV1TrialParameter++;
  if (buildCounterGoogleCloudAiplatformV1TrialParameter < 3) {
    unittest.expect(
      o.parameterId!,
      unittest.equals('foo'),
    );
    var casted66 = (o.value!) as core.Map;
    unittest.expect(casted66, unittest.hasLength(3));
    unittest.expect(
      casted66['list'],
      unittest.equals([1, 2, 3]),
    );
    unittest.expect(
      casted66['bool'],
      unittest.equals(true),
    );
    unittest.expect(
      casted66['string'],
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1TrialParameter--;
}

core.int buildCounterGoogleCloudAiplatformV1UndeployIndexRequest = 0;
api.GoogleCloudAiplatformV1UndeployIndexRequest
    buildGoogleCloudAiplatformV1UndeployIndexRequest() {
  final o = api.GoogleCloudAiplatformV1UndeployIndexRequest();
  buildCounterGoogleCloudAiplatformV1UndeployIndexRequest++;
  if (buildCounterGoogleCloudAiplatformV1UndeployIndexRequest < 3) {
    o.deployedIndexId = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1UndeployIndexRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1UndeployIndexRequest(
    api.GoogleCloudAiplatformV1UndeployIndexRequest o) {
  buildCounterGoogleCloudAiplatformV1UndeployIndexRequest++;
  if (buildCounterGoogleCloudAiplatformV1UndeployIndexRequest < 3) {
    unittest.expect(
      o.deployedIndexId!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1UndeployIndexRequest--;
}

core.Map<core.String, core.int> buildUnnamed319() => {
      'x': 42,
      'y': 42,
    };

void checkUnnamed319(core.Map<core.String, core.int> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals(42),
  );
  unittest.expect(
    o['y']!,
    unittest.equals(42),
  );
}

core.int buildCounterGoogleCloudAiplatformV1UndeployModelRequest = 0;
api.GoogleCloudAiplatformV1UndeployModelRequest
    buildGoogleCloudAiplatformV1UndeployModelRequest() {
  final o = api.GoogleCloudAiplatformV1UndeployModelRequest();
  buildCounterGoogleCloudAiplatformV1UndeployModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1UndeployModelRequest < 3) {
    o.deployedModelId = 'foo';
    o.trafficSplit = buildUnnamed319();
  }
  buildCounterGoogleCloudAiplatformV1UndeployModelRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1UndeployModelRequest(
    api.GoogleCloudAiplatformV1UndeployModelRequest o) {
  buildCounterGoogleCloudAiplatformV1UndeployModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1UndeployModelRequest < 3) {
    unittest.expect(
      o.deployedModelId!,
      unittest.equals('foo'),
    );
    checkUnnamed319(o.trafficSplit!);
  }
  buildCounterGoogleCloudAiplatformV1UndeployModelRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1UnmanagedContainerModel = 0;
api.GoogleCloudAiplatformV1UnmanagedContainerModel
    buildGoogleCloudAiplatformV1UnmanagedContainerModel() {
  final o = api.GoogleCloudAiplatformV1UnmanagedContainerModel();
  buildCounterGoogleCloudAiplatformV1UnmanagedContainerModel++;
  if (buildCounterGoogleCloudAiplatformV1UnmanagedContainerModel < 3) {
    o.artifactUri = 'foo';
    o.containerSpec = buildGoogleCloudAiplatformV1ModelContainerSpec();
    o.predictSchemata = buildGoogleCloudAiplatformV1PredictSchemata();
  }
  buildCounterGoogleCloudAiplatformV1UnmanagedContainerModel--;
  return o;
}

void checkGoogleCloudAiplatformV1UnmanagedContainerModel(
    api.GoogleCloudAiplatformV1UnmanagedContainerModel o) {
  buildCounterGoogleCloudAiplatformV1UnmanagedContainerModel++;
  if (buildCounterGoogleCloudAiplatformV1UnmanagedContainerModel < 3) {
    unittest.expect(
      o.artifactUri!,
      unittest.equals('foo'),
    );
    checkGoogleCloudAiplatformV1ModelContainerSpec(o.containerSpec!);
    checkGoogleCloudAiplatformV1PredictSchemata(o.predictSchemata!);
  }
  buildCounterGoogleCloudAiplatformV1UnmanagedContainerModel--;
}

core.int buildCounterGoogleCloudAiplatformV1UpdateExplanationDatasetRequest = 0;
api.GoogleCloudAiplatformV1UpdateExplanationDatasetRequest
    buildGoogleCloudAiplatformV1UpdateExplanationDatasetRequest() {
  final o = api.GoogleCloudAiplatformV1UpdateExplanationDatasetRequest();
  buildCounterGoogleCloudAiplatformV1UpdateExplanationDatasetRequest++;
  if (buildCounterGoogleCloudAiplatformV1UpdateExplanationDatasetRequest < 3) {
    o.examples = buildGoogleCloudAiplatformV1Examples();
  }
  buildCounterGoogleCloudAiplatformV1UpdateExplanationDatasetRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1UpdateExplanationDatasetRequest(
    api.GoogleCloudAiplatformV1UpdateExplanationDatasetRequest o) {
  buildCounterGoogleCloudAiplatformV1UpdateExplanationDatasetRequest++;
  if (buildCounterGoogleCloudAiplatformV1UpdateExplanationDatasetRequest < 3) {
    checkGoogleCloudAiplatformV1Examples(o.examples!);
  }
  buildCounterGoogleCloudAiplatformV1UpdateExplanationDatasetRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest = 0;
api.GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest
    buildGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest() {
  final o = api.GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest();
  buildCounterGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest++;
  if (buildCounterGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest(
    api.GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest o) {
  buildCounterGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest++;
  if (buildCounterGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest < 3) {}
  buildCounterGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1UploadModelRequest = 0;
api.GoogleCloudAiplatformV1UploadModelRequest
    buildGoogleCloudAiplatformV1UploadModelRequest() {
  final o = api.GoogleCloudAiplatformV1UploadModelRequest();
  buildCounterGoogleCloudAiplatformV1UploadModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1UploadModelRequest < 3) {
    o.model = buildGoogleCloudAiplatformV1Model();
    o.modelId = 'foo';
    o.parentModel = 'foo';
    o.serviceAccount = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1UploadModelRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1UploadModelRequest(
    api.GoogleCloudAiplatformV1UploadModelRequest o) {
  buildCounterGoogleCloudAiplatformV1UploadModelRequest++;
  if (buildCounterGoogleCloudAiplatformV1UploadModelRequest < 3) {
    checkGoogleCloudAiplatformV1Model(o.model!);
    unittest.expect(
      o.modelId!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.parentModel!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.serviceAccount!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1UploadModelRequest--;
}

core.List<api.GoogleCloudAiplatformV1IndexDatapoint> buildUnnamed320() => [
      buildGoogleCloudAiplatformV1IndexDatapoint(),
      buildGoogleCloudAiplatformV1IndexDatapoint(),
    ];

void checkUnnamed320(core.List<api.GoogleCloudAiplatformV1IndexDatapoint> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1IndexDatapoint(o[0]);
  checkGoogleCloudAiplatformV1IndexDatapoint(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1UpsertDatapointsRequest = 0;
api.GoogleCloudAiplatformV1UpsertDatapointsRequest
    buildGoogleCloudAiplatformV1UpsertDatapointsRequest() {
  final o = api.GoogleCloudAiplatformV1UpsertDatapointsRequest();
  buildCounterGoogleCloudAiplatformV1UpsertDatapointsRequest++;
  if (buildCounterGoogleCloudAiplatformV1UpsertDatapointsRequest < 3) {
    o.datapoints = buildUnnamed320();
    o.updateMask = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1UpsertDatapointsRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1UpsertDatapointsRequest(
    api.GoogleCloudAiplatformV1UpsertDatapointsRequest o) {
  buildCounterGoogleCloudAiplatformV1UpsertDatapointsRequest++;
  if (buildCounterGoogleCloudAiplatformV1UpsertDatapointsRequest < 3) {
    checkUnnamed320(o.datapoints!);
    unittest.expect(
      o.updateMask!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1UpsertDatapointsRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1UpsertDatapointsResponse = 0;
api.GoogleCloudAiplatformV1UpsertDatapointsResponse
    buildGoogleCloudAiplatformV1UpsertDatapointsResponse() {
  final o = api.GoogleCloudAiplatformV1UpsertDatapointsResponse();
  buildCounterGoogleCloudAiplatformV1UpsertDatapointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1UpsertDatapointsResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1UpsertDatapointsResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1UpsertDatapointsResponse(
    api.GoogleCloudAiplatformV1UpsertDatapointsResponse o) {
  buildCounterGoogleCloudAiplatformV1UpsertDatapointsResponse++;
  if (buildCounterGoogleCloudAiplatformV1UpsertDatapointsResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1UpsertDatapointsResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1UserActionReference = 0;
api.GoogleCloudAiplatformV1UserActionReference
    buildGoogleCloudAiplatformV1UserActionReference() {
  final o = api.GoogleCloudAiplatformV1UserActionReference();
  buildCounterGoogleCloudAiplatformV1UserActionReference++;
  if (buildCounterGoogleCloudAiplatformV1UserActionReference < 3) {
    o.dataLabelingJob = 'foo';
    o.method = 'foo';
    o.operation = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1UserActionReference--;
  return o;
}

void checkGoogleCloudAiplatformV1UserActionReference(
    api.GoogleCloudAiplatformV1UserActionReference o) {
  buildCounterGoogleCloudAiplatformV1UserActionReference++;
  if (buildCounterGoogleCloudAiplatformV1UserActionReference < 3) {
    unittest.expect(
      o.dataLabelingJob!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.method!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.operation!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1UserActionReference--;
}

core.int buildCounterGoogleCloudAiplatformV1Value = 0;
api.GoogleCloudAiplatformV1Value buildGoogleCloudAiplatformV1Value() {
  final o = api.GoogleCloudAiplatformV1Value();
  buildCounterGoogleCloudAiplatformV1Value++;
  if (buildCounterGoogleCloudAiplatformV1Value < 3) {
    o.doubleValue = 42.0;
    o.intValue = 'foo';
    o.stringValue = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1Value--;
  return o;
}

void checkGoogleCloudAiplatformV1Value(api.GoogleCloudAiplatformV1Value o) {
  buildCounterGoogleCloudAiplatformV1Value++;
  if (buildCounterGoogleCloudAiplatformV1Value < 3) {
    unittest.expect(
      o.doubleValue!,
      unittest.equals(42.0),
    );
    unittest.expect(
      o.intValue!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.stringValue!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1Value--;
}

core.int buildCounterGoogleCloudAiplatformV1VideoMetadata = 0;
api.GoogleCloudAiplatformV1VideoMetadata
    buildGoogleCloudAiplatformV1VideoMetadata() {
  final o = api.GoogleCloudAiplatformV1VideoMetadata();
  buildCounterGoogleCloudAiplatformV1VideoMetadata++;
  if (buildCounterGoogleCloudAiplatformV1VideoMetadata < 3) {
    o.endOffset = 'foo';
    o.startOffset = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1VideoMetadata--;
  return o;
}

void checkGoogleCloudAiplatformV1VideoMetadata(
    api.GoogleCloudAiplatformV1VideoMetadata o) {
  buildCounterGoogleCloudAiplatformV1VideoMetadata++;
  if (buildCounterGoogleCloudAiplatformV1VideoMetadata < 3) {
    unittest.expect(
      o.endOffset!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startOffset!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1VideoMetadata--;
}

core.List<api.GoogleCloudAiplatformV1NfsMount> buildUnnamed321() => [
      buildGoogleCloudAiplatformV1NfsMount(),
      buildGoogleCloudAiplatformV1NfsMount(),
    ];

void checkUnnamed321(core.List<api.GoogleCloudAiplatformV1NfsMount> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1NfsMount(o[0]);
  checkGoogleCloudAiplatformV1NfsMount(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1WorkerPoolSpec = 0;
api.GoogleCloudAiplatformV1WorkerPoolSpec
    buildGoogleCloudAiplatformV1WorkerPoolSpec() {
  final o = api.GoogleCloudAiplatformV1WorkerPoolSpec();
  buildCounterGoogleCloudAiplatformV1WorkerPoolSpec++;
  if (buildCounterGoogleCloudAiplatformV1WorkerPoolSpec < 3) {
    o.containerSpec = buildGoogleCloudAiplatformV1ContainerSpec();
    o.diskSpec = buildGoogleCloudAiplatformV1DiskSpec();
    o.machineSpec = buildGoogleCloudAiplatformV1MachineSpec();
    o.nfsMounts = buildUnnamed321();
    o.pythonPackageSpec = buildGoogleCloudAiplatformV1PythonPackageSpec();
    o.replicaCount = 'foo';
  }
  buildCounterGoogleCloudAiplatformV1WorkerPoolSpec--;
  return o;
}

void checkGoogleCloudAiplatformV1WorkerPoolSpec(
    api.GoogleCloudAiplatformV1WorkerPoolSpec o) {
  buildCounterGoogleCloudAiplatformV1WorkerPoolSpec++;
  if (buildCounterGoogleCloudAiplatformV1WorkerPoolSpec < 3) {
    checkGoogleCloudAiplatformV1ContainerSpec(o.containerSpec!);
    checkGoogleCloudAiplatformV1DiskSpec(o.diskSpec!);
    checkGoogleCloudAiplatformV1MachineSpec(o.machineSpec!);
    checkUnnamed321(o.nfsMounts!);
    checkGoogleCloudAiplatformV1PythonPackageSpec(o.pythonPackageSpec!);
    unittest.expect(
      o.replicaCount!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudAiplatformV1WorkerPoolSpec--;
}

core.Map<core.String, api.GoogleCloudAiplatformV1FeatureValue>
    buildUnnamed322() => {
          'x': buildGoogleCloudAiplatformV1FeatureValue(),
          'y': buildGoogleCloudAiplatformV1FeatureValue(),
        };

void checkUnnamed322(
    core.Map<core.String, api.GoogleCloudAiplatformV1FeatureValue> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1FeatureValue(o['x']!);
  checkGoogleCloudAiplatformV1FeatureValue(o['y']!);
}

core.int buildCounterGoogleCloudAiplatformV1WriteFeatureValuesPayload = 0;
api.GoogleCloudAiplatformV1WriteFeatureValuesPayload
    buildGoogleCloudAiplatformV1WriteFeatureValuesPayload() {
  final o = api.GoogleCloudAiplatformV1WriteFeatureValuesPayload();
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesPayload++;
  if (buildCounterGoogleCloudAiplatformV1WriteFeatureValuesPayload < 3) {
    o.entityId = 'foo';
    o.featureValues = buildUnnamed322();
  }
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesPayload--;
  return o;
}

void checkGoogleCloudAiplatformV1WriteFeatureValuesPayload(
    api.GoogleCloudAiplatformV1WriteFeatureValuesPayload o) {
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesPayload++;
  if (buildCounterGoogleCloudAiplatformV1WriteFeatureValuesPayload < 3) {
    unittest.expect(
      o.entityId!,
      unittest.equals('foo'),
    );
    checkUnnamed322(o.featureValues!);
  }
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesPayload--;
}

core.List<api.GoogleCloudAiplatformV1WriteFeatureValuesPayload>
    buildUnnamed323() => [
          buildGoogleCloudAiplatformV1WriteFeatureValuesPayload(),
          buildGoogleCloudAiplatformV1WriteFeatureValuesPayload(),
        ];

void checkUnnamed323(
    core.List<api.GoogleCloudAiplatformV1WriteFeatureValuesPayload> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1WriteFeatureValuesPayload(o[0]);
  checkGoogleCloudAiplatformV1WriteFeatureValuesPayload(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1WriteFeatureValuesRequest = 0;
api.GoogleCloudAiplatformV1WriteFeatureValuesRequest
    buildGoogleCloudAiplatformV1WriteFeatureValuesRequest() {
  final o = api.GoogleCloudAiplatformV1WriteFeatureValuesRequest();
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1WriteFeatureValuesRequest < 3) {
    o.payloads = buildUnnamed323();
  }
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1WriteFeatureValuesRequest(
    api.GoogleCloudAiplatformV1WriteFeatureValuesRequest o) {
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesRequest++;
  if (buildCounterGoogleCloudAiplatformV1WriteFeatureValuesRequest < 3) {
    checkUnnamed323(o.payloads!);
  }
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1WriteFeatureValuesResponse = 0;
api.GoogleCloudAiplatformV1WriteFeatureValuesResponse
    buildGoogleCloudAiplatformV1WriteFeatureValuesResponse() {
  final o = api.GoogleCloudAiplatformV1WriteFeatureValuesResponse();
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesResponse++;
  if (buildCounterGoogleCloudAiplatformV1WriteFeatureValuesResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1WriteFeatureValuesResponse(
    api.GoogleCloudAiplatformV1WriteFeatureValuesResponse o) {
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesResponse++;
  if (buildCounterGoogleCloudAiplatformV1WriteFeatureValuesResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1WriteFeatureValuesResponse--;
}

core.List<api.GoogleCloudAiplatformV1WriteTensorboardRunDataRequest>
    buildUnnamed324() => [
          buildGoogleCloudAiplatformV1WriteTensorboardRunDataRequest(),
          buildGoogleCloudAiplatformV1WriteTensorboardRunDataRequest(),
        ];

void checkUnnamed324(
    core.List<api.GoogleCloudAiplatformV1WriteTensorboardRunDataRequest> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1WriteTensorboardRunDataRequest(o[0]);
  checkGoogleCloudAiplatformV1WriteTensorboardRunDataRequest(o[1]);
}

core.int
    buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest =
    0;
api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest
    buildGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest() {
  final o = api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest();
  buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest <
      3) {
    o.writeRunDataRequests = buildUnnamed324();
  }
  buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest(
    api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest o) {
  buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest <
      3) {
    checkUnnamed324(o.writeRunDataRequests!);
  }
  buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest--;
}

core.int
    buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse =
    0;
api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse
    buildGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse() {
  final o = api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse();
  buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse <
      3) {}
  buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse(
    api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse o) {
  buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse <
      3) {}
  buildCounterGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse--;
}

core.List<api.GoogleCloudAiplatformV1TimeSeriesData> buildUnnamed325() => [
      buildGoogleCloudAiplatformV1TimeSeriesData(),
      buildGoogleCloudAiplatformV1TimeSeriesData(),
    ];

void checkUnnamed325(core.List<api.GoogleCloudAiplatformV1TimeSeriesData> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudAiplatformV1TimeSeriesData(o[0]);
  checkGoogleCloudAiplatformV1TimeSeriesData(o[1]);
}

core.int buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataRequest = 0;
api.GoogleCloudAiplatformV1WriteTensorboardRunDataRequest
    buildGoogleCloudAiplatformV1WriteTensorboardRunDataRequest() {
  final o = api.GoogleCloudAiplatformV1WriteTensorboardRunDataRequest();
  buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataRequest < 3) {
    o.tensorboardRun = 'foo';
    o.timeSeriesData = buildUnnamed325();
  }
  buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataRequest--;
  return o;
}

void checkGoogleCloudAiplatformV1WriteTensorboardRunDataRequest(
    api.GoogleCloudAiplatformV1WriteTensorboardRunDataRequest o) {
  buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataRequest++;
  if (buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataRequest < 3) {
    unittest.expect(
      o.tensorboardRun!,
      unittest.equals('foo'),
    );
    checkUnnamed325(o.timeSeriesData!);
  }
  buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataRequest--;
}

core.int buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataResponse = 0;
api.GoogleCloudAiplatformV1WriteTensorboardRunDataResponse
    buildGoogleCloudAiplatformV1WriteTensorboardRunDataResponse() {
  final o = api.GoogleCloudAiplatformV1WriteTensorboardRunDataResponse();
  buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataResponse--;
  return o;
}

void checkGoogleCloudAiplatformV1WriteTensorboardRunDataResponse(
    api.GoogleCloudAiplatformV1WriteTensorboardRunDataResponse o) {
  buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataResponse++;
  if (buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataResponse < 3) {}
  buildCounterGoogleCloudAiplatformV1WriteTensorboardRunDataResponse--;
}

core.int buildCounterGoogleCloudAiplatformV1XraiAttribution = 0;
api.GoogleCloudAiplatformV1XraiAttribution
    buildGoogleCloudAiplatformV1XraiAttribution() {
  final o = api.GoogleCloudAiplatformV1XraiAttribution();
  buildCounterGoogleCloudAiplatformV1XraiAttribution++;
  if (buildCounterGoogleCloudAiplatformV1XraiAttribution < 3) {
    o.blurBaselineConfig = buildGoogleCloudAiplatformV1BlurBaselineConfig();
    o.smoothGradConfig = buildGoogleCloudAiplatformV1SmoothGradConfig();
    o.stepCount = 42;
  }
  buildCounterGoogleCloudAiplatformV1XraiAttribution--;
  return o;
}

void checkGoogleCloudAiplatformV1XraiAttribution(
    api.GoogleCloudAiplatformV1XraiAttribution o) {
  buildCounterGoogleCloudAiplatformV1XraiAttribution++;
  if (buildCounterGoogleCloudAiplatformV1XraiAttribution < 3) {
    checkGoogleCloudAiplatformV1BlurBaselineConfig(o.blurBaselineConfig!);
    checkGoogleCloudAiplatformV1SmoothGradConfig(o.smoothGradConfig!);
    unittest.expect(
      o.stepCount!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleCloudAiplatformV1XraiAttribution--;
}

core.List<api.GoogleCloudLocationLocation> buildUnnamed326() => [
      buildGoogleCloudLocationLocation(),
      buildGoogleCloudLocationLocation(),
    ];

void checkUnnamed326(core.List<api.GoogleCloudLocationLocation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleCloudLocationLocation(o[0]);
  checkGoogleCloudLocationLocation(o[1]);
}

core.int buildCounterGoogleCloudLocationListLocationsResponse = 0;
api.GoogleCloudLocationListLocationsResponse
    buildGoogleCloudLocationListLocationsResponse() {
  final o = api.GoogleCloudLocationListLocationsResponse();
  buildCounterGoogleCloudLocationListLocationsResponse++;
  if (buildCounterGoogleCloudLocationListLocationsResponse < 3) {
    o.locations = buildUnnamed326();
    o.nextPageToken = 'foo';
  }
  buildCounterGoogleCloudLocationListLocationsResponse--;
  return o;
}

void checkGoogleCloudLocationListLocationsResponse(
    api.GoogleCloudLocationListLocationsResponse o) {
  buildCounterGoogleCloudLocationListLocationsResponse++;
  if (buildCounterGoogleCloudLocationListLocationsResponse < 3) {
    checkUnnamed326(o.locations!);
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudLocationListLocationsResponse--;
}

core.Map<core.String, core.String> buildUnnamed327() => {
      'x': 'foo',
      'y': 'foo',
    };

void checkUnnamed327(core.Map<core.String, core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o['x']!,
    unittest.equals('foo'),
  );
  unittest.expect(
    o['y']!,
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.Object?> buildUnnamed328() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed328(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted67 = (o['x']!) as core.Map;
  unittest.expect(casted67, unittest.hasLength(3));
  unittest.expect(
    casted67['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted67['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted67['string'],
    unittest.equals('foo'),
  );
  var casted68 = (o['y']!) as core.Map;
  unittest.expect(casted68, unittest.hasLength(3));
  unittest.expect(
    casted68['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted68['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted68['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleCloudLocationLocation = 0;
api.GoogleCloudLocationLocation buildGoogleCloudLocationLocation() {
  final o = api.GoogleCloudLocationLocation();
  buildCounterGoogleCloudLocationLocation++;
  if (buildCounterGoogleCloudLocationLocation < 3) {
    o.displayName = 'foo';
    o.labels = buildUnnamed327();
    o.locationId = 'foo';
    o.metadata = buildUnnamed328();
    o.name = 'foo';
  }
  buildCounterGoogleCloudLocationLocation--;
  return o;
}

void checkGoogleCloudLocationLocation(api.GoogleCloudLocationLocation o) {
  buildCounterGoogleCloudLocationLocation++;
  if (buildCounterGoogleCloudLocationLocation < 3) {
    unittest.expect(
      o.displayName!,
      unittest.equals('foo'),
    );
    checkUnnamed327(o.labels!);
    unittest.expect(
      o.locationId!,
      unittest.equals('foo'),
    );
    checkUnnamed328(o.metadata!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleCloudLocationLocation--;
}

core.List<core.String> buildUnnamed329() => [
      'foo',
      'foo',
    ];

void checkUnnamed329(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleIamV1Binding = 0;
api.GoogleIamV1Binding buildGoogleIamV1Binding() {
  final o = api.GoogleIamV1Binding();
  buildCounterGoogleIamV1Binding++;
  if (buildCounterGoogleIamV1Binding < 3) {
    o.condition = buildGoogleTypeExpr();
    o.members = buildUnnamed329();
    o.role = 'foo';
  }
  buildCounterGoogleIamV1Binding--;
  return o;
}

void checkGoogleIamV1Binding(api.GoogleIamV1Binding o) {
  buildCounterGoogleIamV1Binding++;
  if (buildCounterGoogleIamV1Binding < 3) {
    checkGoogleTypeExpr(o.condition!);
    checkUnnamed329(o.members!);
    unittest.expect(
      o.role!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleIamV1Binding--;
}

core.List<api.GoogleIamV1Binding> buildUnnamed330() => [
      buildGoogleIamV1Binding(),
      buildGoogleIamV1Binding(),
    ];

void checkUnnamed330(core.List<api.GoogleIamV1Binding> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleIamV1Binding(o[0]);
  checkGoogleIamV1Binding(o[1]);
}

core.int buildCounterGoogleIamV1Policy = 0;
api.GoogleIamV1Policy buildGoogleIamV1Policy() {
  final o = api.GoogleIamV1Policy();
  buildCounterGoogleIamV1Policy++;
  if (buildCounterGoogleIamV1Policy < 3) {
    o.bindings = buildUnnamed330();
    o.etag = 'foo';
    o.version = 42;
  }
  buildCounterGoogleIamV1Policy--;
  return o;
}

void checkGoogleIamV1Policy(api.GoogleIamV1Policy o) {
  buildCounterGoogleIamV1Policy++;
  if (buildCounterGoogleIamV1Policy < 3) {
    checkUnnamed330(o.bindings!);
    unittest.expect(
      o.etag!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.version!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleIamV1Policy--;
}

core.int buildCounterGoogleIamV1SetIamPolicyRequest = 0;
api.GoogleIamV1SetIamPolicyRequest buildGoogleIamV1SetIamPolicyRequest() {
  final o = api.GoogleIamV1SetIamPolicyRequest();
  buildCounterGoogleIamV1SetIamPolicyRequest++;
  if (buildCounterGoogleIamV1SetIamPolicyRequest < 3) {
    o.policy = buildGoogleIamV1Policy();
  }
  buildCounterGoogleIamV1SetIamPolicyRequest--;
  return o;
}

void checkGoogleIamV1SetIamPolicyRequest(api.GoogleIamV1SetIamPolicyRequest o) {
  buildCounterGoogleIamV1SetIamPolicyRequest++;
  if (buildCounterGoogleIamV1SetIamPolicyRequest < 3) {
    checkGoogleIamV1Policy(o.policy!);
  }
  buildCounterGoogleIamV1SetIamPolicyRequest--;
}

core.List<core.String> buildUnnamed331() => [
      'foo',
      'foo',
    ];

void checkUnnamed331(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleIamV1TestIamPermissionsResponse = 0;
api.GoogleIamV1TestIamPermissionsResponse
    buildGoogleIamV1TestIamPermissionsResponse() {
  final o = api.GoogleIamV1TestIamPermissionsResponse();
  buildCounterGoogleIamV1TestIamPermissionsResponse++;
  if (buildCounterGoogleIamV1TestIamPermissionsResponse < 3) {
    o.permissions = buildUnnamed331();
  }
  buildCounterGoogleIamV1TestIamPermissionsResponse--;
  return o;
}

void checkGoogleIamV1TestIamPermissionsResponse(
    api.GoogleIamV1TestIamPermissionsResponse o) {
  buildCounterGoogleIamV1TestIamPermissionsResponse++;
  if (buildCounterGoogleIamV1TestIamPermissionsResponse < 3) {
    checkUnnamed331(o.permissions!);
  }
  buildCounterGoogleIamV1TestIamPermissionsResponse--;
}

core.List<api.GoogleLongrunningOperation> buildUnnamed332() => [
      buildGoogleLongrunningOperation(),
      buildGoogleLongrunningOperation(),
    ];

void checkUnnamed332(core.List<api.GoogleLongrunningOperation> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkGoogleLongrunningOperation(o[0]);
  checkGoogleLongrunningOperation(o[1]);
}

core.int buildCounterGoogleLongrunningListOperationsResponse = 0;
api.GoogleLongrunningListOperationsResponse
    buildGoogleLongrunningListOperationsResponse() {
  final o = api.GoogleLongrunningListOperationsResponse();
  buildCounterGoogleLongrunningListOperationsResponse++;
  if (buildCounterGoogleLongrunningListOperationsResponse < 3) {
    o.nextPageToken = 'foo';
    o.operations = buildUnnamed332();
  }
  buildCounterGoogleLongrunningListOperationsResponse--;
  return o;
}

void checkGoogleLongrunningListOperationsResponse(
    api.GoogleLongrunningListOperationsResponse o) {
  buildCounterGoogleLongrunningListOperationsResponse++;
  if (buildCounterGoogleLongrunningListOperationsResponse < 3) {
    unittest.expect(
      o.nextPageToken!,
      unittest.equals('foo'),
    );
    checkUnnamed332(o.operations!);
  }
  buildCounterGoogleLongrunningListOperationsResponse--;
}

core.Map<core.String, core.Object?> buildUnnamed333() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed333(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted69 = (o['x']!) as core.Map;
  unittest.expect(casted69, unittest.hasLength(3));
  unittest.expect(
    casted69['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted69['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted69['string'],
    unittest.equals('foo'),
  );
  var casted70 = (o['y']!) as core.Map;
  unittest.expect(casted70, unittest.hasLength(3));
  unittest.expect(
    casted70['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted70['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted70['string'],
    unittest.equals('foo'),
  );
}

core.Map<core.String, core.Object?> buildUnnamed334() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed334(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted71 = (o['x']!) as core.Map;
  unittest.expect(casted71, unittest.hasLength(3));
  unittest.expect(
    casted71['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted71['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted71['string'],
    unittest.equals('foo'),
  );
  var casted72 = (o['y']!) as core.Map;
  unittest.expect(casted72, unittest.hasLength(3));
  unittest.expect(
    casted72['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted72['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted72['string'],
    unittest.equals('foo'),
  );
}

core.int buildCounterGoogleLongrunningOperation = 0;
api.GoogleLongrunningOperation buildGoogleLongrunningOperation() {
  final o = api.GoogleLongrunningOperation();
  buildCounterGoogleLongrunningOperation++;
  if (buildCounterGoogleLongrunningOperation < 3) {
    o.done = true;
    o.error = buildGoogleRpcStatus();
    o.metadata = buildUnnamed333();
    o.name = 'foo';
    o.response = buildUnnamed334();
  }
  buildCounterGoogleLongrunningOperation--;
  return o;
}

void checkGoogleLongrunningOperation(api.GoogleLongrunningOperation o) {
  buildCounterGoogleLongrunningOperation++;
  if (buildCounterGoogleLongrunningOperation < 3) {
    unittest.expect(o.done!, unittest.isTrue);
    checkGoogleRpcStatus(o.error!);
    checkUnnamed333(o.metadata!);
    unittest.expect(
      o.name!,
      unittest.equals('foo'),
    );
    checkUnnamed334(o.response!);
  }
  buildCounterGoogleLongrunningOperation--;
}

core.int buildCounterGoogleProtobufEmpty = 0;
api.GoogleProtobufEmpty buildGoogleProtobufEmpty() {
  final o = api.GoogleProtobufEmpty();
  buildCounterGoogleProtobufEmpty++;
  if (buildCounterGoogleProtobufEmpty < 3) {}
  buildCounterGoogleProtobufEmpty--;
  return o;
}

void checkGoogleProtobufEmpty(api.GoogleProtobufEmpty o) {
  buildCounterGoogleProtobufEmpty++;
  if (buildCounterGoogleProtobufEmpty < 3) {}
  buildCounterGoogleProtobufEmpty--;
}

core.Map<core.String, core.Object?> buildUnnamed335() => {
      'x': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
      'y': {
        'list': [1, 2, 3],
        'bool': true,
        'string': 'foo'
      },
    };

void checkUnnamed335(core.Map<core.String, core.Object?> o) {
  unittest.expect(o, unittest.hasLength(2));
  var casted73 = (o['x']!) as core.Map;
  unittest.expect(casted73, unittest.hasLength(3));
  unittest.expect(
    casted73['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted73['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted73['string'],
    unittest.equals('foo'),
  );
  var casted74 = (o['y']!) as core.Map;
  unittest.expect(casted74, unittest.hasLength(3));
  unittest.expect(
    casted74['list'],
    unittest.equals([1, 2, 3]),
  );
  unittest.expect(
    casted74['bool'],
    unittest.equals(true),
  );
  unittest.expect(
    casted74['string'],
    unittest.equals('foo'),
  );
}

core.List<core.Map<core.String, core.Object?>> buildUnnamed336() => [
      buildUnnamed335(),
      buildUnnamed335(),
    ];

void checkUnnamed336(core.List<core.Map<core.String, core.Object?>> o) {
  unittest.expect(o, unittest.hasLength(2));
  checkUnnamed335(o[0]);
  checkUnnamed335(o[1]);
}

core.int buildCounterGoogleRpcStatus = 0;
api.GoogleRpcStatus buildGoogleRpcStatus() {
  final o = api.GoogleRpcStatus();
  buildCounterGoogleRpcStatus++;
  if (buildCounterGoogleRpcStatus < 3) {
    o.code = 42;
    o.details = buildUnnamed336();
    o.message = 'foo';
  }
  buildCounterGoogleRpcStatus--;
  return o;
}

void checkGoogleRpcStatus(api.GoogleRpcStatus o) {
  buildCounterGoogleRpcStatus++;
  if (buildCounterGoogleRpcStatus < 3) {
    unittest.expect(
      o.code!,
      unittest.equals(42),
    );
    checkUnnamed336(o.details!);
    unittest.expect(
      o.message!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleRpcStatus--;
}

core.int buildCounterGoogleTypeDate = 0;
api.GoogleTypeDate buildGoogleTypeDate() {
  final o = api.GoogleTypeDate();
  buildCounterGoogleTypeDate++;
  if (buildCounterGoogleTypeDate < 3) {
    o.day = 42;
    o.month = 42;
    o.year = 42;
  }
  buildCounterGoogleTypeDate--;
  return o;
}

void checkGoogleTypeDate(api.GoogleTypeDate o) {
  buildCounterGoogleTypeDate++;
  if (buildCounterGoogleTypeDate < 3) {
    unittest.expect(
      o.day!,
      unittest.equals(42),
    );
    unittest.expect(
      o.month!,
      unittest.equals(42),
    );
    unittest.expect(
      o.year!,
      unittest.equals(42),
    );
  }
  buildCounterGoogleTypeDate--;
}

core.int buildCounterGoogleTypeExpr = 0;
api.GoogleTypeExpr buildGoogleTypeExpr() {
  final o = api.GoogleTypeExpr();
  buildCounterGoogleTypeExpr++;
  if (buildCounterGoogleTypeExpr < 3) {
    o.description = 'foo';
    o.expression = 'foo';
    o.location = 'foo';
    o.title = 'foo';
  }
  buildCounterGoogleTypeExpr--;
  return o;
}

void checkGoogleTypeExpr(api.GoogleTypeExpr o) {
  buildCounterGoogleTypeExpr++;
  if (buildCounterGoogleTypeExpr < 3) {
    unittest.expect(
      o.description!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.expression!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.location!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.title!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleTypeExpr--;
}

core.int buildCounterGoogleTypeInterval = 0;
api.GoogleTypeInterval buildGoogleTypeInterval() {
  final o = api.GoogleTypeInterval();
  buildCounterGoogleTypeInterval++;
  if (buildCounterGoogleTypeInterval < 3) {
    o.endTime = 'foo';
    o.startTime = 'foo';
  }
  buildCounterGoogleTypeInterval--;
  return o;
}

void checkGoogleTypeInterval(api.GoogleTypeInterval o) {
  buildCounterGoogleTypeInterval++;
  if (buildCounterGoogleTypeInterval < 3) {
    unittest.expect(
      o.endTime!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.startTime!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleTypeInterval--;
}

core.int buildCounterGoogleTypeMoney = 0;
api.GoogleTypeMoney buildGoogleTypeMoney() {
  final o = api.GoogleTypeMoney();
  buildCounterGoogleTypeMoney++;
  if (buildCounterGoogleTypeMoney < 3) {
    o.currencyCode = 'foo';
    o.nanos = 42;
    o.units = 'foo';
  }
  buildCounterGoogleTypeMoney--;
  return o;
}

void checkGoogleTypeMoney(api.GoogleTypeMoney o) {
  buildCounterGoogleTypeMoney++;
  if (buildCounterGoogleTypeMoney < 3) {
    unittest.expect(
      o.currencyCode!,
      unittest.equals('foo'),
    );
    unittest.expect(
      o.nanos!,
      unittest.equals(42),
    );
    unittest.expect(
      o.units!,
      unittest.equals('foo'),
    );
  }
  buildCounterGoogleTypeMoney--;
}

core.List<core.String> buildUnnamed337() => [
      'foo',
      'foo',
    ];

void checkUnnamed337(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed338() => [
      'foo',
      'foo',
    ];

void checkUnnamed338(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed339() => [
      'foo',
      'foo',
    ];

void checkUnnamed339(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed340() => [
      'foo',
      'foo',
    ];

void checkUnnamed340(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed341() => [
      'foo',
      'foo',
    ];

void checkUnnamed341(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed342() => [
      'foo',
      'foo',
    ];

void checkUnnamed342(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

core.List<core.String> buildUnnamed343() => [
      'foo',
      'foo',
    ];

void checkUnnamed343(core.List<core.String> o) {
  unittest.expect(o, unittest.hasLength(2));
  unittest.expect(
    o[0],
    unittest.equals('foo'),
  );
  unittest.expect(
    o[1],
    unittest.equals('foo'),
  );
}

void main() {
  unittest.group('obj-schema-GoogleApiHttpBody', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleApiHttpBody();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleApiHttpBody.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleApiHttpBody(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ActiveLearningConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ActiveLearningConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ActiveLearningConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ActiveLearningConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AddContextChildrenRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AddContextChildrenRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AddContextChildrenRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AddContextChildrenRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AddContextChildrenResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AddContextChildrenResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AddContextChildrenResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AddContextChildrenResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AddExecutionEventsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AddExecutionEventsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AddExecutionEventsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AddExecutionEventsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AddExecutionEventsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AddExecutionEventsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AddExecutionEventsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AddExecutionEventsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AddTrialMeasurementRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AddTrialMeasurementRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AddTrialMeasurementRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AddTrialMeasurementRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Annotation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Annotation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Annotation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Annotation(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AnnotationSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AnnotationSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AnnotationSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AnnotationSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Artifact', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Artifact();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Artifact.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Artifact(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1AssignNotebookRuntimeRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AssignNotebookRuntimeRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1AssignNotebookRuntimeRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AssignNotebookRuntimeRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Attribution', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Attribution();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Attribution.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Attribution(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AutomaticResources', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AutomaticResources();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AutomaticResources.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AutomaticResources(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AutoscalingMetricSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AutoscalingMetricSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AutoscalingMetricSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AutoscalingMetricSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1AvroSource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1AvroSource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1AvroSource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1AvroSource(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1BatchCreateFeaturesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchCreateFeaturesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1BatchCreateFeaturesRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchCreateFeaturesRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1BatchDedicatedResources',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchDedicatedResources();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1BatchDedicatedResources.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchDedicatedResources(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchMigrateResourcesRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchMigrateResourcesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchMigrateResourcesRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchMigrateResourcesRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1BatchPredictionJob', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchPredictionJob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1BatchPredictionJob.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchPredictionJob(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchPredictionJobInputConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchPredictionJobInputConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchPredictionJobInputConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchPredictionJobInputConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchPredictionJobInstanceConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchPredictionJobOutputConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchPredictionJobOutputConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchPredictionJobOutputConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchPredictionJobOutputConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchPredictionJobOutputInfo', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchPredictionJobOutputInfo();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchPredictionJobOutputInfo.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchPredictionJobOutputInfo(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchReadFeatureValuesRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1BigQueryDestination', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BigQueryDestination();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1BigQueryDestination.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BigQueryDestination(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1BigQuerySource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BigQuerySource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1BigQuerySource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BigQuerySource(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Blob', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Blob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Blob.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Blob(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1BlurBaselineConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BlurBaselineConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1BlurBaselineConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BlurBaselineConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1BoolArray', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1BoolArray();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1BoolArray.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1BoolArray(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1CancelBatchPredictionJobRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CancelBatchPredictionJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1CancelBatchPredictionJobRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CancelBatchPredictionJobRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CancelCustomJobRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CancelCustomJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CancelCustomJobRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CancelCustomJobRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1CancelDataLabelingJobRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CancelDataLabelingJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1CancelDataLabelingJobRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CancelDataLabelingJobRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CancelNasJobRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CancelNasJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CancelNasJobRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CancelNasJobRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CancelPipelineJobRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CancelPipelineJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CancelPipelineJobRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CancelPipelineJobRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1CancelTrainingPipelineRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CancelTrainingPipelineRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1CancelTrainingPipelineRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CancelTrainingPipelineRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Candidate', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Candidate();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Candidate.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Candidate(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Citation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Citation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Citation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Citation(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CitationMetadata', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CitationMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CitationMetadata.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CitationMetadata(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CompleteTrialRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CompleteTrialRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CompleteTrialRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CompleteTrialRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CompletionStats', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CompletionStats();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CompletionStats.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CompletionStats(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ComputeTokensRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ComputeTokensRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ComputeTokensRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ComputeTokensRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ComputeTokensResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ComputeTokensResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ComputeTokensResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ComputeTokensResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ContainerRegistryDestination', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ContainerRegistryDestination();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ContainerRegistryDestination.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ContainerRegistryDestination(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ContainerSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ContainerSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ContainerSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ContainerSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Content', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Content();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Content.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Content(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Context', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Context();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Context.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Context(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CopyModelRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CopyModelRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CopyModelRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CopyModelRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CountTokensRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CountTokensRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CountTokensRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CountTokensRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CountTokensResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CountTokensResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CountTokensResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CountTokensResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CreateFeatureRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CreateFeatureRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CreateFeatureRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CreateFeatureRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CreatePipelineJobRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CreatePipelineJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CreatePipelineJobRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CreatePipelineJobRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1CreateTensorboardRunRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CreateTensorboardRunRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1CreateTensorboardRunRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CreateTensorboardRunRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CsvDestination', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CsvDestination();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CsvDestination.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CsvDestination(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CsvSource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CsvSource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CsvSource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CsvSource(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CustomJob', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CustomJob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CustomJob.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CustomJob(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1CustomJobSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1CustomJobSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1CustomJobSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1CustomJobSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DataItem', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DataItem();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DataItem.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DataItem(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DataItemView', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DataItemView();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DataItemView.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DataItemView(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DataLabelingJob', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DataLabelingJob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DataLabelingJob.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DataLabelingJob(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Dataset', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Dataset();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Dataset.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Dataset(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DatasetVersion', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DatasetVersion();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DatasetVersion.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DatasetVersion(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DedicatedResources', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DedicatedResources();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DedicatedResources.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DedicatedResources(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeleteFeatureValuesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeleteFeatureValuesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeleteFeatureValuesRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeleteFeatureValuesRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeployIndexRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeployIndexRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeployIndexRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeployIndexRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeployModelRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeployModelRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeployModelRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeployModelRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeployedIndex', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeployedIndex();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeployedIndex.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeployedIndex(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeployedIndexAuthConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeployedIndexAuthConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeployedIndexAuthConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeployedIndexAuthConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeployedIndexRef', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeployedIndexRef();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeployedIndexRef.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeployedIndexRef(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeployedModel', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeployedModel();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeployedModel.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeployedModel(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeployedModelRef', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeployedModelRef();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeployedModelRef.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeployedModelRef(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DeploymentResourcePool',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DeploymentResourcePool();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DeploymentResourcePool.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DeploymentResourcePool(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DestinationFeatureSetting',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DestinationFeatureSetting();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DestinationFeatureSetting.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DestinationFeatureSetting(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DirectPredictRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DirectPredictRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DirectPredictRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DirectPredictRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DirectPredictResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DirectPredictResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DirectPredictResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DirectPredictResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DirectRawPredictRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DirectRawPredictRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DirectRawPredictRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DirectRawPredictRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DirectRawPredictResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DirectRawPredictResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DirectRawPredictResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DirectRawPredictResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DiskSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DiskSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DiskSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DiskSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1DoubleArray', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1DoubleArray();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1DoubleArray.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1DoubleArray(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1EncryptionSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1EncryptionSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1EncryptionSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1EncryptionSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Endpoint', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Endpoint();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Endpoint.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Endpoint(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1EntityIdSelector', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1EntityIdSelector();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1EntityIdSelector.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1EntityIdSelector(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1EntityType', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1EntityType();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1EntityType.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1EntityType(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1EnvVar', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1EnvVar();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1EnvVar.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1EnvVar(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ErrorAnalysisAnnotation',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ErrorAnalysisAnnotation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ErrorAnalysisAnnotation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ErrorAnalysisAnnotation(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1EvaluatedAnnotation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1EvaluatedAnnotation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1EvaluatedAnnotation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1EvaluatedAnnotation(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1EvaluatedAnnotationExplanation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1EvaluatedAnnotationExplanation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1EvaluatedAnnotationExplanation.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1EvaluatedAnnotationExplanation(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Event', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Event();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Event.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Event(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Examples', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Examples();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Examples.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Examples(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExamplesExampleGcsSource',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExamplesExampleGcsSource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExamplesExampleGcsSource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExamplesExampleGcsSource(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExamplesOverride', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExamplesOverride();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExamplesOverride.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExamplesOverride(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExamplesRestrictionsNamespace', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExamplesRestrictionsNamespace();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExamplesRestrictionsNamespace.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExamplesRestrictionsNamespace(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Execution', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Execution();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Execution.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Execution(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExplainRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplainRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExplainRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplainRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExplainResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplainResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExplainResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplainResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Explanation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Explanation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Explanation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Explanation(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExplanationMetadata', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplanationMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExplanationMetadata.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationMetadata(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExplanationMetadataInputMetadata', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadata(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationMetadataOutputMetadata(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExplanationMetadataOverride', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplanationMetadataOverride();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExplanationMetadataOverride.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationMetadataOverride(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExplanationParameters', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplanationParameters();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExplanationParameters.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationParameters(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExplanationSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplanationSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExplanationSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExplanationSpecOverride',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExplanationSpecOverride();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExplanationSpecOverride.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExplanationSpecOverride(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExportDataConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExportDataConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExportDataConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportDataConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExportDataRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExportDataRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExportDataRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportDataRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExportFeatureValuesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExportFeatureValuesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExportFeatureValuesRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportFeatureValuesRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExportFilterSplit', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExportFilterSplit();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExportFilterSplit.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportFilterSplit(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExportFractionSplit', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExportFractionSplit();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExportFractionSplit.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportFractionSplit(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ExportModelRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExportModelRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ExportModelRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportModelRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExportModelRequestOutputConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ExportModelRequestOutputConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExportModelRequestOutputConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportModelRequestOutputConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Feature', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Feature();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Feature.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Feature(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureGroup', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureGroup();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureGroup.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureGroup(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureGroupBigQuery', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureGroupBigQuery();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureGroupBigQuery.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureGroupBigQuery(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureNoiseSigma', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureNoiseSigma();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureNoiseSigma.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureNoiseSigma(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureOnlineStore', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureOnlineStore();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureOnlineStore.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureOnlineStore(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureOnlineStoreBigtable',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureOnlineStoreBigtable();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureOnlineStoreBigtable.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureOnlineStoreBigtable(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureSelector', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureSelector();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureSelector.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureSelector(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureStatsAnomaly', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureStatsAnomaly();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureStatsAnomaly(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureValue', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureValue();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureValue.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureValue(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureValueDestination',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureValueDestination();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureValueDestination.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureValueDestination(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureValueList', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureValueList();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureValueList.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureValueList(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureValueMetadata', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureValueMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureValueMetadata.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureValueMetadata(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureView', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureView();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureView.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureView(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureViewBigQuerySource',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureViewBigQuerySource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureViewBigQuerySource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureViewBigQuerySource(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureViewDataKey', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureViewDataKey();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureViewDataKey.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureViewDataKey(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureViewFeatureRegistrySource(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureViewSync', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureViewSync();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureViewSync.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureViewSync(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureViewSyncConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureViewSyncConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureViewSyncConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureViewSyncConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FeatureViewSyncSyncSummary',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeatureViewSyncSyncSummary();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FeatureViewSyncSyncSummary.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeatureViewSyncSyncSummary(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Featurestore', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Featurestore();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Featurestore.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Featurestore(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeaturestoreMonitoringConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeaturestoreOnlineServingConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FetchFeatureValuesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FetchFeatureValuesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FetchFeatureValuesRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FetchFeatureValuesRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FetchFeatureValuesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FetchFeatureValuesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FetchFeatureValuesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FetchFeatureValuesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FileData', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FileData();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FileData.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FileData(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FilterSplit', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FilterSplit();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FilterSplit.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FilterSplit(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FindNeighborsRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FindNeighborsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FindNeighborsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FindNeighborsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FindNeighborsRequestQuery',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FindNeighborsRequestQuery();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FindNeighborsRequestQuery.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FindNeighborsRequestQuery(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FindNeighborsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FindNeighborsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FindNeighborsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FindNeighborsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1FindNeighborsResponseNeighbor', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FindNeighborsResponseNeighbor();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1FindNeighborsResponseNeighbor.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FindNeighborsResponseNeighbor(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FractionSplit', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FractionSplit();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FractionSplit.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FractionSplit(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FunctionCall', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FunctionCall();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FunctionCall.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FunctionCall(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FunctionDeclaration', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FunctionDeclaration();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FunctionDeclaration.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FunctionDeclaration(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1FunctionResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1FunctionResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1FunctionResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1FunctionResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GcsDestination', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GcsDestination();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GcsDestination.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GcsDestination(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GcsSource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GcsSource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GcsSource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GcsSource(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GenerateContentRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GenerateContentRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GenerateContentRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GenerateContentRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GenerateContentResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GenerateContentResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GenerateContentResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GenerateContentResponsePromptFeedback(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GenerateContentResponseUsageMetadata(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GenerationConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GenerationConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GenerationConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GenerationConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GenieSource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GenieSource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GenieSource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GenieSource(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GroundingAttribution', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GroundingAttribution();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GroundingAttribution.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GroundingAttribution(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GroundingAttributionWeb',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GroundingAttributionWeb();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GroundingAttributionWeb.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GroundingAttributionWeb(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1GroundingMetadata', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1GroundingMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1GroundingMetadata.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1GroundingMetadata(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1HyperparameterTuningJob',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1HyperparameterTuningJob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1HyperparameterTuningJob(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1IdMatcher', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IdMatcher();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1IdMatcher.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IdMatcher(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ImportDataConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ImportDataConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ImportDataConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ImportDataConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ImportDataRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ImportDataRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ImportDataRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ImportDataRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ImportFeatureValuesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ImportFeatureValuesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ImportFeatureValuesRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ImportFeatureValuesRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ImportModelEvaluationRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ImportModelEvaluationRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ImportModelEvaluationRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ImportModelEvaluationRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Index', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Index();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Index.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Index(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1IndexDatapoint', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IndexDatapoint();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1IndexDatapoint.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IndexDatapoint(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1IndexDatapointCrowdingTag',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IndexDatapointCrowdingTag();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1IndexDatapointCrowdingTag.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IndexDatapointCrowdingTag(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1IndexDatapointNumericRestriction', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IndexDatapointNumericRestriction();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1IndexDatapointNumericRestriction.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IndexDatapointNumericRestriction(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1IndexDatapointRestriction',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IndexDatapointRestriction();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1IndexDatapointRestriction.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IndexDatapointRestriction(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1IndexEndpoint', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IndexEndpoint();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1IndexEndpoint.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IndexEndpoint(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1IndexPrivateEndpoints', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IndexPrivateEndpoints();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1IndexPrivateEndpoints.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IndexPrivateEndpoints(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1IndexStats', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IndexStats();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1IndexStats.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IndexStats(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1InputDataConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1InputDataConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1InputDataConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1InputDataConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Int64Array', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Int64Array();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Int64Array.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Int64Array(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1IntegratedGradientsAttribution', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1IntegratedGradientsAttribution();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1IntegratedGradientsAttribution.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1IntegratedGradientsAttribution(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1LargeModelReference', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1LargeModelReference();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1LargeModelReference.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1LargeModelReference(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1LineageSubgraph', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1LineageSubgraph();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1LineageSubgraph.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1LineageSubgraph(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListAnnotationsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListAnnotationsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListAnnotationsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListAnnotationsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListArtifactsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListArtifactsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListArtifactsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListArtifactsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListBatchPredictionJobsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListBatchPredictionJobsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListBatchPredictionJobsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListBatchPredictionJobsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListContextsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListContextsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListContextsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListContextsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListCustomJobsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListCustomJobsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListCustomJobsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListCustomJobsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListDataItemsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListDataItemsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListDataItemsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListDataItemsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListDataLabelingJobsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListDataLabelingJobsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListDataLabelingJobsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListDataLabelingJobsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListDatasetVersionsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListDatasetVersionsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListDatasetVersionsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListDatasetVersionsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListDatasetsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListDatasetsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListDatasetsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListDatasetsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListEndpointsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListEndpointsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListEndpointsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListEndpointsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListEntityTypesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListEntityTypesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListEntityTypesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListEntityTypesResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListExecutionsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListExecutionsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListExecutionsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListExecutionsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListFeatureGroupsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListFeatureGroupsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListFeatureGroupsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListFeatureGroupsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListFeatureViewSyncsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListFeatureViewSyncsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListFeatureViewSyncsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListFeatureViewSyncsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListFeatureViewsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListFeatureViewsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListFeatureViewsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListFeatureViewsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListFeaturesResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListFeaturesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListFeaturesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListFeaturesResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListFeaturestoresResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListFeaturestoresResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListFeaturestoresResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListFeaturestoresResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListIndexEndpointsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListIndexEndpointsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListIndexEndpointsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListIndexEndpointsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListIndexesResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListIndexesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListIndexesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListIndexesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListMetadataSchemasResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListMetadataSchemasResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListMetadataSchemasResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListMetadataSchemasResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListMetadataStoresResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListMetadataStoresResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListMetadataStoresResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListMetadataStoresResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListModelEvaluationsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListModelEvaluationsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListModelEvaluationsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListModelEvaluationsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListModelVersionsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListModelVersionsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListModelVersionsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListModelVersionsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListModelsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListModelsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListModelsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListModelsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListNasJobsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListNasJobsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListNasJobsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListNasJobsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListNasTrialDetailsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListNasTrialDetailsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListNasTrialDetailsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListNasTrialDetailsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListNotebookRuntimesResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListNotebookRuntimesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListNotebookRuntimesResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListNotebookRuntimesResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListOptimalTrialsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListOptimalTrialsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListOptimalTrialsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListOptimalTrialsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListOptimalTrialsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListOptimalTrialsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListOptimalTrialsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListOptimalTrialsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListPipelineJobsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListPipelineJobsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListPipelineJobsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListPipelineJobsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListSavedQueriesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListSavedQueriesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListSavedQueriesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListSavedQueriesResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListSchedulesResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListSchedulesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListSchedulesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListSchedulesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListSpecialistPoolsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListSpecialistPoolsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListSpecialistPoolsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListSpecialistPoolsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListStudiesResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListStudiesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListStudiesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListStudiesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListTensorboardExperimentsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ListTensorboardExperimentsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListTensorboardExperimentsResponse
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListTensorboardExperimentsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListTensorboardRunsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListTensorboardRunsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListTensorboardRunsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListTensorboardRunsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListTensorboardsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListTensorboardsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListTensorboardsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListTensorboardsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ListTrainingPipelinesResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListTrainingPipelinesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ListTrainingPipelinesResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListTrainingPipelinesResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ListTrialsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ListTrialsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ListTrialsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ListTrialsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1LookupStudyRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1LookupStudyRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1LookupStudyRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1LookupStudyRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1MachineSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MachineSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1MachineSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MachineSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ManualBatchTuningParameters', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ManualBatchTuningParameters();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ManualBatchTuningParameters.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ManualBatchTuningParameters(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Measurement', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Measurement();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Measurement.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Measurement(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1MeasurementMetric', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MeasurementMetric();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1MeasurementMetric.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MeasurementMetric(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1MergeVersionAliasesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MergeVersionAliasesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1MergeVersionAliasesRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MergeVersionAliasesRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1MetadataSchema', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MetadataSchema();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1MetadataSchema.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MetadataSchema(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1MetadataStore', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MetadataStore();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1MetadataStore.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MetadataStore(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MetadataStoreMetadataStoreState', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MetadataStoreMetadataStoreState();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MetadataStoreMetadataStoreState.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MetadataStoreMetadataStoreState(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1MigratableResource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MigratableResource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1MigratableResource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigratableResource(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigratableResourceAutomlDataset', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MigratableResourceAutomlDataset();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigratableResourceAutomlDataset.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigratableResourceAutomlDataset(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigratableResourceAutomlModel', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MigratableResourceAutomlModel();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigratableResourceAutomlModel.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigratableResourceAutomlModel(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigratableResourceDataLabelingDataset(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1MigrateResourceRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MigrateResourceRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1MigrateResourceRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigrateResourceRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Model', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Model();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Model.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Model(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelBaseModelSource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelBaseModelSource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelBaseModelSource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelBaseModelSource(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelContainerSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelContainerSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelContainerSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelContainerSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelDataStats', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelDataStats();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelDataStats.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelDataStats(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelDeploymentMonitoringJob', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelEvaluation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelEvaluation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelEvaluation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelEvaluation(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelEvaluationSlice', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelEvaluationSlice();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelEvaluationSlice.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelEvaluationSlice(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelEvaluationSliceSlice',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelEvaluationSliceSlice();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelEvaluationSliceSlice.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelEvaluationSliceSlice(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelExplanation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelExplanation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelExplanation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelExplanation(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelExportFormat', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelExportFormat();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelExportFormat.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelExportFormat(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelGardenSource', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelGardenSource();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelGardenSource.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelGardenSource(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelMonitoringAlertConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelMonitoringAlertConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelMonitoringAlertConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringAlertConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringStatsAnomalies(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelOriginalModelInfo',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelOriginalModelInfo();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelOriginalModelInfo.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelOriginalModelInfo(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ModelSourceInfo', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ModelSourceInfo();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ModelSourceInfo.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ModelSourceInfo(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1MutateDeployedModelRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1MutateDeployedModelRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1MutateDeployedModelRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1MutateDeployedModelRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NasJob', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NasJob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NasJob.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasJob(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NasJobOutput', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NasJobOutput();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NasJobOutput.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasJobOutput(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NasJobSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NasJobSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NasJobSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasJobSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec(
          od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NasTrial', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NasTrial();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NasTrial.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasTrial(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NasTrialDetail', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NasTrialDetail();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NasTrialDetail.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NasTrialDetail(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NearestNeighborQuery', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NearestNeighborQuery();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NearestNeighborQuery.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NearestNeighborQuery(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NearestNeighborQueryEmbedding', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NearestNeighborQueryEmbedding();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NearestNeighborQueryEmbedding.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NearestNeighborQueryEmbedding(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NearestNeighborQueryParameters', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NearestNeighborQueryParameters();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NearestNeighborQueryParameters.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NearestNeighborQueryParameters(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NearestNeighborQueryStringFilter', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NearestNeighborQueryStringFilter();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NearestNeighborQueryStringFilter.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NearestNeighborQueryStringFilter(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NearestNeighbors', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NearestNeighbors();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NearestNeighbors.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NearestNeighbors(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NearestNeighborsNeighbor',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NearestNeighborsNeighbor();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NearestNeighborsNeighbor.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NearestNeighborsNeighbor(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Neighbor', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Neighbor();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Neighbor.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Neighbor(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NetworkSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NetworkSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NetworkSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NetworkSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NfsMount', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NfsMount();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NfsMount.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NfsMount(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NotebookEucConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NotebookEucConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NotebookEucConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NotebookEucConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NotebookIdleShutdownConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NotebookIdleShutdownConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NotebookIdleShutdownConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NotebookIdleShutdownConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1NotebookReservationAffinity', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NotebookReservationAffinity();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1NotebookReservationAffinity.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NotebookReservationAffinity(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NotebookRuntime', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NotebookRuntime();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NotebookRuntime.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NotebookRuntime(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NotebookRuntimeTemplate',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NotebookRuntimeTemplate();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NotebookRuntimeTemplate(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1NotebookRuntimeTemplateRef',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1NotebookRuntimeTemplateRef();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1NotebookRuntimeTemplateRef.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1NotebookRuntimeTemplateRef(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Part', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Part();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Part.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Part(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PauseScheduleRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PauseScheduleRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PauseScheduleRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PauseScheduleRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PersistentDiskSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PersistentDiskSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PersistentDiskSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PersistentDiskSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PipelineJob', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PipelineJob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PipelineJob.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineJob(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PipelineJobDetail', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PipelineJobDetail();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PipelineJobDetail.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineJobDetail(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PipelineJobRuntimeConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PipelineJobRuntimeConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PipelineJobRuntimeConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineJobRuntimeConfig(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PipelineTaskDetail', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PipelineTaskDetail();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PipelineTaskDetail.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineTaskDetail(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PipelineTaskDetailArtifactList', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PipelineTaskDetailArtifactList();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PipelineTaskDetailArtifactList.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineTaskDetailArtifactList(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PipelineTaskExecutorDetail',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PipelineTaskExecutorDetail();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PipelineTaskExecutorDetail.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineTaskExecutorDetail(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PipelineTemplateMetadata',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PipelineTemplateMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PipelineTemplateMetadata.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PipelineTemplateMetadata(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Port', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Port();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Port.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Port(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PredefinedSplit', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PredefinedSplit();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PredefinedSplit.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PredefinedSplit(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PredictRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PredictRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PredictRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PredictRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PredictRequestResponseLoggingConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PredictResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PredictResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PredictResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PredictResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PredictSchemata', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PredictSchemata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PredictSchemata.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PredictSchemata(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Presets', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Presets();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Presets.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Presets(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PrivateEndpoints', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PrivateEndpoints();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PrivateEndpoints.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PrivateEndpoints(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PrivateServiceConnectConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PrivateServiceConnectConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PrivateServiceConnectConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PrivateServiceConnectConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Probe', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Probe();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Probe.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Probe(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ProbeExecAction', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ProbeExecAction();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ProbeExecAction.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ProbeExecAction(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PscAutomatedEndpoints', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PscAutomatedEndpoints();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PscAutomatedEndpoints.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PscAutomatedEndpoints(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PublisherModel', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PublisherModel();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PublisherModel.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModel(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PublisherModelCallToAction',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PublisherModelCallToAction();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PublisherModelCallToAction.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelCallToAction(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PublisherModelCallToActionDeploy', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PublisherModelCallToActionDeploy();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PublisherModelCallToActionDeploy.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelCallToActionDeploy(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelCallToActionDeployGke(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PublisherModelDocumentation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PublisherModelDocumentation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PublisherModelDocumentation.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelDocumentation(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1PublisherModelResourceReference', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PublisherModelResourceReference();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1PublisherModelResourceReference.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PublisherModelResourceReference(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PurgeArtifactsRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PurgeArtifactsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PurgeArtifactsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PurgeArtifactsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PurgeContextsRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PurgeContextsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PurgeContextsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PurgeContextsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PurgeExecutionsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PurgeExecutionsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PurgeExecutionsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PurgeExecutionsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1PythonPackageSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1PythonPackageSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1PythonPackageSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1PythonPackageSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1QueryDeployedModelsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1QueryDeployedModelsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1QueryDeployedModelsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1QueryDeployedModelsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1RawPredictRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1RawPredictRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1RawPredictRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1RawPredictRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ReadFeatureValuesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ReadFeatureValuesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ReadFeatureValuesRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadFeatureValuesRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ReadFeatureValuesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ReadFeatureValuesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ReadFeatureValuesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadFeatureValuesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadFeatureValuesResponseHeader(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ReadIndexDatapointsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ReadIndexDatapointsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ReadIndexDatapointsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadIndexDatapointsRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadIndexDatapointsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ReadIndexDatapointsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadIndexDatapointsResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadIndexDatapointsResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadTensorboardSizeResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ReadTensorboardSizeResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadTensorboardSizeResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadTensorboardSizeResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadTensorboardUsageResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ReadTensorboardUsageResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadTensorboardUsageResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadTensorboardUsageResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1RemoveContextChildrenRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1RemoveContextChildrenRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1RemoveContextChildrenRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1RemoveContextChildrenRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1RemoveContextChildrenResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1RemoveContextChildrenResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1RemoveContextChildrenResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1RemoveContextChildrenResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1RemoveDatapointsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1RemoveDatapointsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1RemoveDatapointsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1RemoveDatapointsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1RemoveDatapointsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1RemoveDatapointsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1RemoveDatapointsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1RemoveDatapointsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ResourcesConsumed', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ResourcesConsumed();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ResourcesConsumed.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ResourcesConsumed(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ResumeScheduleRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ResumeScheduleRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ResumeScheduleRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ResumeScheduleRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SafetyRating', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SafetyRating();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SafetyRating.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SafetyRating(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SafetySetting', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SafetySetting();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SafetySetting.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SafetySetting(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SampleConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SampleConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SampleConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SampleConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SampledShapleyAttribution',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SampledShapleyAttribution();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SampledShapleyAttribution.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SampledShapleyAttribution(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SamplingStrategy', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SamplingStrategy();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SamplingStrategy.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SamplingStrategy(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SavedQuery', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SavedQuery();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SavedQuery.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SavedQuery(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Scalar', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Scalar();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Scalar.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Scalar(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Schedule', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Schedule();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Schedule.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Schedule(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ScheduleRunResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ScheduleRunResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ScheduleRunResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ScheduleRunResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Scheduling', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Scheduling();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Scheduling.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Scheduling(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Schema', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Schema();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Schema.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Schema(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SearchDataItemsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SearchDataItemsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SearchDataItemsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchDataItemsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SearchFeaturesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SearchFeaturesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SearchFeaturesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchFeaturesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1SearchMigratableResourcesRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SearchMigratableResourcesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1SearchMigratableResourcesRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchMigratableResourcesRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1SearchMigratableResourcesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SearchMigratableResourcesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1SearchMigratableResourcesResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchMigratableResourcesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1SearchNearestEntitiesRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SearchNearestEntitiesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1SearchNearestEntitiesRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchNearestEntitiesRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1SearchNearestEntitiesResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SearchNearestEntitiesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1SearchNearestEntitiesResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SearchNearestEntitiesResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Segment', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Segment();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Segment.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Segment(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ShieldedVmConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ShieldedVmConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ShieldedVmConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ShieldedVmConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SmoothGradConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SmoothGradConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SmoothGradConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SmoothGradConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SpecialistPool', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SpecialistPool();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SpecialistPool.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SpecialistPool(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StartNotebookRuntimeRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StartNotebookRuntimeRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StartNotebookRuntimeRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StartNotebookRuntimeRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StopTrialRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StopTrialRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StopTrialRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StopTrialRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StratifiedSplit', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StratifiedSplit();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StratifiedSplit.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StratifiedSplit(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StreamRawPredictRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StreamRawPredictRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StreamRawPredictRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StreamRawPredictRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StreamingPredictRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StreamingPredictRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StreamingPredictRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StreamingPredictRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StreamingPredictResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StreamingPredictResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StreamingPredictResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StreamingPredictResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StringArray', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StringArray();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StringArray.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StringArray(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Study', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Study();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Study.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Study(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StudySpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StudySpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StudySpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec
          .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StudySpecMetricSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StudySpecMetricSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StudySpecMetricSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecMetricSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StudySpecParameterSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StudySpecParameterSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition(
          od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1StudySpecStudyStoppingConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StudySpecStudyStoppingConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1StudySpecStudyStoppingConfig.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudySpecStudyStoppingConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1StudyTimeConstraint', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1StudyTimeConstraint();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1StudyTimeConstraint.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1StudyTimeConstraint(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SuggestTrialsRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SuggestTrialsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SuggestTrialsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SuggestTrialsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SyncFeatureViewRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SyncFeatureViewRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SyncFeatureViewRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SyncFeatureViewRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1SyncFeatureViewResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1SyncFeatureViewResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1SyncFeatureViewResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1SyncFeatureViewResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TFRecordDestination', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TFRecordDestination();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TFRecordDestination.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TFRecordDestination(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Tensor', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Tensor();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Tensor.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Tensor(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Tensorboard', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Tensorboard();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Tensorboard.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Tensorboard(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TensorboardBlob', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TensorboardBlob();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TensorboardBlob.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TensorboardBlob(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TensorboardBlobSequence',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TensorboardBlobSequence();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TensorboardBlobSequence.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TensorboardBlobSequence(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TensorboardExperiment', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TensorboardExperiment();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TensorboardExperiment(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TensorboardRun', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TensorboardRun();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TensorboardRun.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TensorboardRun(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TensorboardTensor', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TensorboardTensor();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TensorboardTensor.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TensorboardTensor(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TensorboardTimeSeries', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TensorboardTimeSeries();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TensorboardTimeSeries(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TensorboardTimeSeriesMetadata(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1ThresholdConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1ThresholdConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1ThresholdConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1ThresholdConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TimeSeriesData', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TimeSeriesData();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TimeSeriesData.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TimeSeriesData(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TimeSeriesDataPoint', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TimeSeriesDataPoint();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TimeSeriesDataPoint.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TimeSeriesDataPoint(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TimestampSplit', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TimestampSplit();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TimestampSplit.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TimestampSplit(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TokensInfo', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TokensInfo();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TokensInfo.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TokensInfo(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Tool', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Tool();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Tool.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Tool(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TrainingConfig', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TrainingConfig();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TrainingConfig.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TrainingConfig(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TrainingPipeline', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TrainingPipeline();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TrainingPipeline.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TrainingPipeline(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Trial', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Trial();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Trial.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Trial(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TrialContext', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TrialContext();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TrialContext.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TrialContext(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1TrialParameter', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1TrialParameter();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1TrialParameter.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1TrialParameter(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1UndeployIndexRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UndeployIndexRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1UndeployIndexRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UndeployIndexRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1UndeployModelRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UndeployModelRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1UndeployModelRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UndeployModelRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1UnmanagedContainerModel',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UnmanagedContainerModel();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1UnmanagedContainerModel.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UnmanagedContainerModel(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1UpdateExplanationDatasetRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UpdateExplanationDatasetRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1UpdateExplanationDatasetRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UpdateExplanationDatasetRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1UploadModelRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UploadModelRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1UploadModelRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UploadModelRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1UpsertDatapointsRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UpsertDatapointsRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1UpsertDatapointsRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UpsertDatapointsRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1UpsertDatapointsResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UpsertDatapointsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1UpsertDatapointsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UpsertDatapointsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1UserActionReference', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1UserActionReference();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1UserActionReference.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1UserActionReference(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1Value', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1Value();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1Value.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1Value(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1VideoMetadata', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1VideoMetadata();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1VideoMetadata.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1VideoMetadata(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1WorkerPoolSpec', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1WorkerPoolSpec();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1WorkerPoolSpec.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1WorkerPoolSpec(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1WriteFeatureValuesPayload',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1WriteFeatureValuesPayload();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1WriteFeatureValuesPayload.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1WriteFeatureValuesPayload(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1WriteFeatureValuesRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1WriteFeatureValuesRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1WriteFeatureValuesRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1WriteFeatureValuesRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1WriteFeatureValuesResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1WriteFeatureValuesResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1WriteFeatureValuesResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1WriteFeatureValuesResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse',
      () {
    unittest.test('to-json--from-json', () async {
      final o =
          buildGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse
              .fromJson(oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1WriteTensorboardRunDataRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1WriteTensorboardRunDataRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1WriteTensorboardRunDataRequest.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1WriteTensorboardRunDataRequest(od);
    });
  });

  unittest.group(
      'obj-schema-GoogleCloudAiplatformV1WriteTensorboardRunDataResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1WriteTensorboardRunDataResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od =
          api.GoogleCloudAiplatformV1WriteTensorboardRunDataResponse.fromJson(
              oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1WriteTensorboardRunDataResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudAiplatformV1XraiAttribution', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudAiplatformV1XraiAttribution();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudAiplatformV1XraiAttribution.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudAiplatformV1XraiAttribution(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudLocationListLocationsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudLocationListLocationsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudLocationListLocationsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudLocationListLocationsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleCloudLocationLocation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleCloudLocationLocation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleCloudLocationLocation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleCloudLocationLocation(od);
    });
  });

  unittest.group('obj-schema-GoogleIamV1Binding', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleIamV1Binding();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleIamV1Binding.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleIamV1Binding(od);
    });
  });

  unittest.group('obj-schema-GoogleIamV1Policy', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleIamV1Policy();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleIamV1Policy.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleIamV1Policy(od);
    });
  });

  unittest.group('obj-schema-GoogleIamV1SetIamPolicyRequest', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleIamV1SetIamPolicyRequest();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleIamV1SetIamPolicyRequest.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleIamV1SetIamPolicyRequest(od);
    });
  });

  unittest.group('obj-schema-GoogleIamV1TestIamPermissionsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleIamV1TestIamPermissionsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleIamV1TestIamPermissionsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleIamV1TestIamPermissionsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleLongrunningListOperationsResponse', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleLongrunningListOperationsResponse();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleLongrunningListOperationsResponse.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleLongrunningListOperationsResponse(od);
    });
  });

  unittest.group('obj-schema-GoogleLongrunningOperation', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleLongrunningOperation();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleLongrunningOperation.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleLongrunningOperation(od);
    });
  });

  unittest.group('obj-schema-GoogleProtobufEmpty', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleProtobufEmpty();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleProtobufEmpty.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleProtobufEmpty(od);
    });
  });

  unittest.group('obj-schema-GoogleRpcStatus', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleRpcStatus();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleRpcStatus.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleRpcStatus(od);
    });
  });

  unittest.group('obj-schema-GoogleTypeDate', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleTypeDate();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleTypeDate.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleTypeDate(od);
    });
  });

  unittest.group('obj-schema-GoogleTypeExpr', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleTypeExpr();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleTypeExpr.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleTypeExpr(od);
    });
  });

  unittest.group('obj-schema-GoogleTypeInterval', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleTypeInterval();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleTypeInterval.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleTypeInterval(od);
    });
  });

  unittest.group('obj-schema-GoogleTypeMoney', () {
    unittest.test('to-json--from-json', () async {
      final o = buildGoogleTypeMoney();
      final oJson = convert.jsonDecode(convert.jsonEncode(o));
      final od = api.GoogleTypeMoney.fromJson(
          oJson as core.Map<core.String, core.dynamic>);
      checkGoogleTypeMoney(od);
    });
  });

  unittest.group('resource-ProjectsLocationsResource', () {
    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudLocationLocation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudLocationLocation(
          response as api.GoogleCloudLocationLocation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudLocationListLocationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudLocationListLocationsResponse(
          response as api.GoogleCloudLocationListLocationsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsBatchPredictionJobsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.batchPredictionJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1CancelBatchPredictionJobRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1CancelBatchPredictionJobRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CancelBatchPredictionJobRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.cancel(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.batchPredictionJobs;
      final arg_request = buildGoogleCloudAiplatformV1BatchPredictionJob();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1BatchPredictionJob.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchPredictionJob(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1BatchPredictionJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1BatchPredictionJob(
          response as api.GoogleCloudAiplatformV1BatchPredictionJob);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.batchPredictionJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.batchPredictionJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1BatchPredictionJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1BatchPredictionJob(
          response as api.GoogleCloudAiplatformV1BatchPredictionJob);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.batchPredictionJobs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListBatchPredictionJobsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListBatchPredictionJobsResponse(response
          as api.GoogleCloudAiplatformV1ListBatchPredictionJobsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsCustomJobsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.customJobs;
      final arg_request = buildGoogleCloudAiplatformV1CancelCustomJobRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1CancelCustomJobRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CancelCustomJobRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.cancel(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.customJobs;
      final arg_request = buildGoogleCloudAiplatformV1CustomJob();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1CustomJob.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CustomJob(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1CustomJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1CustomJob(
          response as api.GoogleCloudAiplatformV1CustomJob);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.customJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.customJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1CustomJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1CustomJob(
          response as api.GoogleCloudAiplatformV1CustomJob);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.customJobs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListCustomJobsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListCustomJobsResponse(
          response as api.GoogleCloudAiplatformV1ListCustomJobsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsCustomJobsOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.customJobs.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.customJobs.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.customJobs.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.customJobs.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.customJobs.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsDataLabelingJobsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.dataLabelingJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1CancelDataLabelingJobRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1CancelDataLabelingJobRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CancelDataLabelingJobRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.cancel(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.dataLabelingJobs;
      final arg_request = buildGoogleCloudAiplatformV1DataLabelingJob();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1DataLabelingJob.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1DataLabelingJob(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1DataLabelingJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1DataLabelingJob(
          response as api.GoogleCloudAiplatformV1DataLabelingJob);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.dataLabelingJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.dataLabelingJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1DataLabelingJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1DataLabelingJob(
          response as api.GoogleCloudAiplatformV1DataLabelingJob);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.dataLabelingJobs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListDataLabelingJobsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListDataLabelingJobsResponse(
          response as api.GoogleCloudAiplatformV1ListDataLabelingJobsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsDataLabelingJobsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .dataLabelingJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .dataLabelingJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .dataLabelingJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .dataLabelingJobs
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .dataLabelingJobs
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsDatasetsResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets;
      final arg_request = buildGoogleCloudAiplatformV1Dataset();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Dataset.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Dataset(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--export', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets;
      final arg_request = buildGoogleCloudAiplatformV1ExportDataRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1ExportDataRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ExportDataRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.export(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets;
      final arg_name = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Dataset());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.get(arg_name, readMask: arg_readMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Dataset(
          response as api.GoogleCloudAiplatformV1Dataset);
    });

    unittest.test('method--import', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets;
      final arg_request = buildGoogleCloudAiplatformV1ImportDataRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1ImportDataRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ImportDataRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.import(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListDatasetsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListDatasetsResponse(
          response as api.GoogleCloudAiplatformV1ListDatasetsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets;
      final arg_request = buildGoogleCloudAiplatformV1Dataset();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Dataset.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Dataset(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Dataset());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Dataset(
          response as api.GoogleCloudAiplatformV1Dataset);
    });

    unittest.test('method--searchDataItems', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets;
      final arg_dataset = 'foo';
      final arg_annotationFilters = buildUnnamed337();
      final arg_annotationsFilter = 'foo';
      final arg_annotationsLimit = 42;
      final arg_dataItemFilter = 'foo';
      final arg_dataLabelingJob = 'foo';
      final arg_fieldMask = 'foo';
      final arg_orderBy = 'foo';
      final arg_orderByAnnotation_orderBy = 'foo';
      final arg_orderByAnnotation_savedQuery = 'foo';
      final arg_orderByDataItem = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_savedQuery = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['annotationFilters']!,
          unittest.equals(arg_annotationFilters),
        );
        unittest.expect(
          queryMap['annotationsFilter']!.first,
          unittest.equals(arg_annotationsFilter),
        );
        unittest.expect(
          core.int.parse(queryMap['annotationsLimit']!.first),
          unittest.equals(arg_annotationsLimit),
        );
        unittest.expect(
          queryMap['dataItemFilter']!.first,
          unittest.equals(arg_dataItemFilter),
        );
        unittest.expect(
          queryMap['dataLabelingJob']!.first,
          unittest.equals(arg_dataLabelingJob),
        );
        unittest.expect(
          queryMap['fieldMask']!.first,
          unittest.equals(arg_fieldMask),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          queryMap['orderByAnnotation.orderBy']!.first,
          unittest.equals(arg_orderByAnnotation_orderBy),
        );
        unittest.expect(
          queryMap['orderByAnnotation.savedQuery']!.first,
          unittest.equals(arg_orderByAnnotation_savedQuery),
        );
        unittest.expect(
          queryMap['orderByDataItem']!.first,
          unittest.equals(arg_orderByDataItem),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['savedQuery']!.first,
          unittest.equals(arg_savedQuery),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1SearchDataItemsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.searchDataItems(arg_dataset,
          annotationFilters: arg_annotationFilters,
          annotationsFilter: arg_annotationsFilter,
          annotationsLimit: arg_annotationsLimit,
          dataItemFilter: arg_dataItemFilter,
          dataLabelingJob: arg_dataLabelingJob,
          fieldMask: arg_fieldMask,
          orderBy: arg_orderBy,
          orderByAnnotation_orderBy: arg_orderByAnnotation_orderBy,
          orderByAnnotation_savedQuery: arg_orderByAnnotation_savedQuery,
          orderByDataItem: arg_orderByDataItem,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          savedQuery: arg_savedQuery,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1SearchDataItemsResponse(
          response as api.GoogleCloudAiplatformV1SearchDataItemsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsDatasetsAnnotationSpecsResource',
      () {
    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.annotationSpecs;
      final arg_name = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1AnnotationSpec());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.get(arg_name, readMask: arg_readMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1AnnotationSpec(
          response as api.GoogleCloudAiplatformV1AnnotationSpec);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsDatasetsAnnotationSpecsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .annotationSpecs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .annotationSpecs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .annotationSpecs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .annotationSpecs
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .annotationSpecs
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsDatasetsDataItemsResource', () {
    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.datasets.dataItems;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListDataItemsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListDataItemsResponse(
          response as api.GoogleCloudAiplatformV1ListDataItemsResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsDatasetsDataItemsAnnotationsResource', () {
    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .annotations;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListAnnotationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListAnnotationsResponse(
          response as api.GoogleCloudAiplatformV1ListAnnotationsResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .annotations
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .annotations
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .annotations
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .annotations
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .annotations
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsDatasetsDataItemsOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .dataItems
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsDatasetsDatasetVersionsResource',
      () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.datasetVersions;
      final arg_request = buildGoogleCloudAiplatformV1DatasetVersion();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1DatasetVersion.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1DatasetVersion(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.datasetVersions;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.datasetVersions;
      final arg_name = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1DatasetVersion());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.get(arg_name, readMask: arg_readMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1DatasetVersion(
          response as api.GoogleCloudAiplatformV1DatasetVersion);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.datasetVersions;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListDatasetVersionsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListDatasetVersionsResponse(
          response as api.GoogleCloudAiplatformV1ListDatasetVersionsResponse);
    });

    unittest.test('method--restore', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.datasetVersions;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.restore(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsDatasetsOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsDatasetsSavedQueriesResource', () {
    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.savedQueries;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.datasets.savedQueries;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListSavedQueriesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListSavedQueriesResponse(
          response as api.GoogleCloudAiplatformV1ListSavedQueriesResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsDatasetsSavedQueriesOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .savedQueries
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .savedQueries
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .savedQueries
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .savedQueries
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .datasets
          .savedQueries
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsDeploymentResourcePoolsResource',
      () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.deploymentResourcePools;
      final arg_request =
          buildGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.deploymentResourcePools;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.deploymentResourcePools;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1DeploymentResourcePool());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1DeploymentResourcePool(
          response as api.GoogleCloudAiplatformV1DeploymentResourcePool);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.deploymentResourcePools;
      final arg_parent = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse(response
          as api.GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse);
    });

    unittest.test('method--queryDeployedModels', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.deploymentResourcePools;
      final arg_deploymentResourcePool = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1QueryDeployedModelsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.queryDeployedModels(arg_deploymentResourcePool,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1QueryDeployedModelsResponse(
          response as api.GoogleCloudAiplatformV1QueryDeployedModelsResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsDeploymentResourcePoolsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .deploymentResourcePools
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .deploymentResourcePools
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .deploymentResourcePools
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .deploymentResourcePools
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .deploymentResourcePools
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsEndpointsResource', () {
    unittest.test('method--computeTokens', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1ComputeTokensRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1ComputeTokensRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ComputeTokensRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ComputeTokensResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.computeTokens(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ComputeTokensResponse(
          response as api.GoogleCloudAiplatformV1ComputeTokensResponse);
    });

    unittest.test('method--countTokens', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1CountTokensRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1CountTokensRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CountTokensRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1CountTokensResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.countTokens(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1CountTokensResponse(
          response as api.GoogleCloudAiplatformV1CountTokensResponse);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1Endpoint();
      final arg_parent = 'foo';
      final arg_endpointId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Endpoint.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Endpoint(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['endpointId']!.first,
          unittest.equals(arg_endpointId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          endpointId: arg_endpointId, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--deployModel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1DeployModelRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1DeployModelRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1DeployModelRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.deployModel(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--directPredict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1DirectPredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1DirectPredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1DirectPredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1DirectPredictResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.directPredict(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1DirectPredictResponse(
          response as api.GoogleCloudAiplatformV1DirectPredictResponse);
    });

    unittest.test('method--directRawPredict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1DirectRawPredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1DirectRawPredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1DirectRawPredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1DirectRawPredictResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.directRawPredict(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1DirectRawPredictResponse(
          response as api.GoogleCloudAiplatformV1DirectRawPredictResponse);
    });

    unittest.test('method--explain', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1ExplainRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1ExplainRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ExplainRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1ExplainResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.explain(arg_request, arg_endpoint, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ExplainResponse(
          response as api.GoogleCloudAiplatformV1ExplainResponse);
    });

    unittest.test('method--generateContent', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1GenerateContentRequest();
      final arg_model = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1GenerateContentRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1GenerateContentRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1GenerateContentResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.generateContent(arg_request, arg_model,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1GenerateContentResponse(
          response as api.GoogleCloudAiplatformV1GenerateContentResponse);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Endpoint());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Endpoint(
          response as api.GoogleCloudAiplatformV1Endpoint);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListEndpointsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListEndpointsResponse(
          response as api.GoogleCloudAiplatformV1ListEndpointsResponse);
    });

    unittest.test('method--mutateDeployedModel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request =
          buildGoogleCloudAiplatformV1MutateDeployedModelRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1MutateDeployedModelRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1MutateDeployedModelRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.mutateDeployedModel(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1Endpoint();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Endpoint.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Endpoint(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Endpoint());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Endpoint(
          response as api.GoogleCloudAiplatformV1Endpoint);
    });

    unittest.test('method--predict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1PredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1PredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1PredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1PredictResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.predict(arg_request, arg_endpoint, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1PredictResponse(
          response as api.GoogleCloudAiplatformV1PredictResponse);
    });

    unittest.test('method--rawPredict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1RawPredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1RawPredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1RawPredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleApiHttpBody());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.rawPredict(arg_request, arg_endpoint, $fields: arg_$fields);
      checkGoogleApiHttpBody(response as api.GoogleApiHttpBody);
    });

    unittest.test('method--serverStreamingPredict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1StreamingPredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1StreamingPredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1StreamingPredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1StreamingPredictResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.serverStreamingPredict(
          arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1StreamingPredictResponse(
          response as api.GoogleCloudAiplatformV1StreamingPredictResponse);
    });

    unittest.test('method--streamGenerateContent', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1GenerateContentRequest();
      final arg_model = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1GenerateContentRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1GenerateContentRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1GenerateContentResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.streamGenerateContent(arg_request, arg_model,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1GenerateContentResponse(
          response as api.GoogleCloudAiplatformV1GenerateContentResponse);
    });

    unittest.test('method--streamRawPredict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1StreamRawPredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1StreamRawPredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1StreamRawPredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleApiHttpBody());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.streamRawPredict(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleApiHttpBody(response as api.GoogleApiHttpBody);
    });

    unittest.test('method--undeployModel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.endpoints;
      final arg_request = buildGoogleCloudAiplatformV1UndeployModelRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1UndeployModelRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1UndeployModelRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.undeployModel(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsEndpointsOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.endpoints.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.endpoints.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.endpoints.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.endpoints.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.endpoints.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsFeatureGroupsResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featureGroups;
      final arg_request = buildGoogleCloudAiplatformV1FeatureGroup();
      final arg_parent = 'foo';
      final arg_featureGroupId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1FeatureGroup.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1FeatureGroup(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['featureGroupId']!.first,
          unittest.equals(arg_featureGroupId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          featureGroupId: arg_featureGroupId, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featureGroups;
      final arg_name = 'foo';
      final arg_force = true;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['force']!.first,
          unittest.equals('$arg_force'),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.delete(arg_name, force: arg_force, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featureGroups;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1FeatureGroup());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1FeatureGroup(
          response as api.GoogleCloudAiplatformV1FeatureGroup);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featureGroups;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListFeatureGroupsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListFeatureGroupsResponse(
          response as api.GoogleCloudAiplatformV1ListFeatureGroupsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featureGroups;
      final arg_request = buildGoogleCloudAiplatformV1FeatureGroup();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1FeatureGroup.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1FeatureGroup(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsFeatureGroupsFeaturesResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.features;
      final arg_request = buildGoogleCloudAiplatformV1Feature();
      final arg_parent = 'foo';
      final arg_featureId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Feature.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Feature(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['featureId']!.first,
          unittest.equals(arg_featureId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          featureId: arg_featureId, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.features;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.features;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Feature());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Feature(
          response as api.GoogleCloudAiplatformV1Feature);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.features;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_latestStatsCount = 42;
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['latestStatsCount']!.first),
          unittest.equals(arg_latestStatsCount),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListFeaturesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          latestStatsCount: arg_latestStatsCount,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListFeaturesResponse(
          response as api.GoogleCloudAiplatformV1ListFeaturesResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.features;
      final arg_request = buildGoogleCloudAiplatformV1Feature();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Feature.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Feature(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsFeatureGroupsFeaturesOperationsResource', () {
    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureGroups
          .features
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureGroups
          .features
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--listWait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureGroups
          .features
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.listWait(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureGroups
          .features
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsFeatureGroupsOperationsResource',
      () {
    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--listWait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.listWait(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureGroups.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsFeatureOnlineStoresResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureOnlineStores;
      final arg_request = buildGoogleCloudAiplatformV1FeatureOnlineStore();
      final arg_parent = 'foo';
      final arg_featureOnlineStoreId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1FeatureOnlineStore.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1FeatureOnlineStore(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['featureOnlineStoreId']!.first,
          unittest.equals(arg_featureOnlineStoreId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          featureOnlineStoreId: arg_featureOnlineStoreId, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureOnlineStores;
      final arg_name = 'foo';
      final arg_force = true;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['force']!.first,
          unittest.equals('$arg_force'),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.delete(arg_name, force: arg_force, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureOnlineStores;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1FeatureOnlineStore());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1FeatureOnlineStore(
          response as api.GoogleCloudAiplatformV1FeatureOnlineStore);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureOnlineStores;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListFeatureOnlineStoresResponse(response
          as api.GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featureOnlineStores;
      final arg_request = buildGoogleCloudAiplatformV1FeatureOnlineStore();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1FeatureOnlineStore.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1FeatureOnlineStore(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsFeatureOnlineStoresFeatureViewsResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews;
      final arg_request = buildGoogleCloudAiplatformV1FeatureView();
      final arg_parent = 'foo';
      final arg_featureViewId = 'foo';
      final arg_runSyncImmediately = true;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1FeatureView.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1FeatureView(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['featureViewId']!.first,
          unittest.equals(arg_featureViewId),
        );
        unittest.expect(
          queryMap['runSyncImmediately']!.first,
          unittest.equals('$arg_runSyncImmediately'),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          featureViewId: arg_featureViewId,
          runSyncImmediately: arg_runSyncImmediately,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--fetchFeatureValues', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews;
      final arg_request =
          buildGoogleCloudAiplatformV1FetchFeatureValuesRequest();
      final arg_featureView = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1FetchFeatureValuesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1FetchFeatureValuesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1FetchFeatureValuesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.fetchFeatureValues(
          arg_request, arg_featureView,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1FetchFeatureValuesResponse(
          response as api.GoogleCloudAiplatformV1FetchFeatureValuesResponse);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1FeatureView());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1FeatureView(
          response as api.GoogleCloudAiplatformV1FeatureView);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListFeatureViewsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListFeatureViewsResponse(
          response as api.GoogleCloudAiplatformV1ListFeatureViewsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews;
      final arg_request = buildGoogleCloudAiplatformV1FeatureView();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1FeatureView.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1FeatureView(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--searchNearestEntities', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews;
      final arg_request =
          buildGoogleCloudAiplatformV1SearchNearestEntitiesRequest();
      final arg_featureView = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1SearchNearestEntitiesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1SearchNearestEntitiesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1SearchNearestEntitiesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.searchNearestEntities(
          arg_request, arg_featureView,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1SearchNearestEntitiesResponse(
          response as api.GoogleCloudAiplatformV1SearchNearestEntitiesResponse);
    });

    unittest.test('method--sync', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews;
      final arg_request = buildGoogleCloudAiplatformV1SyncFeatureViewRequest();
      final arg_featureView = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1SyncFeatureViewRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1SyncFeatureViewRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1SyncFeatureViewResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.sync(arg_request, arg_featureView, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1SyncFeatureViewResponse(
          response as api.GoogleCloudAiplatformV1SyncFeatureViewResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource',
      () {
    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews
          .featureViewSyncs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1FeatureViewSync());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1FeatureViewSync(
          response as api.GoogleCloudAiplatformV1FeatureViewSync);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews
          .featureViewSyncs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListFeatureViewSyncsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListFeatureViewSyncsResponse(
          response as api.GoogleCloudAiplatformV1ListFeatureViewSyncsResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource',
      () {
    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--listWait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.listWait(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .featureViews
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsFeatureOnlineStoresOperationsResource', () {
    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--listWait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.listWait(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featureOnlineStores
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsFeaturestoresResource', () {
    unittest.test('method--batchReadFeatureValues', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_request =
          buildGoogleCloudAiplatformV1BatchReadFeatureValuesRequest();
      final arg_featurestore = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1BatchReadFeatureValuesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchReadFeatureValuesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.batchReadFeatureValues(
          arg_request, arg_featurestore,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_request = buildGoogleCloudAiplatformV1Featurestore();
      final arg_parent = 'foo';
      final arg_featurestoreId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Featurestore.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Featurestore(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['featurestoreId']!.first,
          unittest.equals(arg_featurestoreId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          featurestoreId: arg_featurestoreId, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_name = 'foo';
      final arg_force = true;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['force']!.first,
          unittest.equals('$arg_force'),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.delete(arg_name, force: arg_force, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Featurestore());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Featurestore(
          response as api.GoogleCloudAiplatformV1Featurestore);
    });

    unittest.test('method--getIamPolicy', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_resource = 'foo';
      final arg_options_requestedPolicyVersion = 42;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['options.requestedPolicyVersion']!.first),
          unittest.equals(arg_options_requestedPolicyVersion),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleIamV1Policy());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.getIamPolicy(arg_resource,
          options_requestedPolicyVersion: arg_options_requestedPolicyVersion,
          $fields: arg_$fields);
      checkGoogleIamV1Policy(response as api.GoogleIamV1Policy);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListFeaturestoresResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListFeaturestoresResponse(
          response as api.GoogleCloudAiplatformV1ListFeaturestoresResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_request = buildGoogleCloudAiplatformV1Featurestore();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Featurestore.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Featurestore(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--searchFeatures', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_location = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_query = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['query']!.first,
          unittest.equals(arg_query),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1SearchFeaturesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.searchFeatures(arg_location,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          query: arg_query,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1SearchFeaturesResponse(
          response as api.GoogleCloudAiplatformV1SearchFeaturesResponse);
    });

    unittest.test('method--setIamPolicy', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_request = buildGoogleIamV1SetIamPolicyRequest();
      final arg_resource = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleIamV1SetIamPolicyRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleIamV1SetIamPolicyRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleIamV1Policy());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.setIamPolicy(arg_request, arg_resource,
          $fields: arg_$fields);
      checkGoogleIamV1Policy(response as api.GoogleIamV1Policy);
    });

    unittest.test('method--testIamPermissions', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.featurestores;
      final arg_resource = 'foo';
      final arg_permissions = buildUnnamed338();
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['permissions']!,
          unittest.equals(arg_permissions),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleIamV1TestIamPermissionsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.testIamPermissions(arg_resource,
          permissions: arg_permissions, $fields: arg_$fields);
      checkGoogleIamV1TestIamPermissionsResponse(
          response as api.GoogleIamV1TestIamPermissionsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsFeaturestoresEntityTypesResource',
      () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request = buildGoogleCloudAiplatformV1EntityType();
      final arg_parent = 'foo';
      final arg_entityTypeId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1EntityType.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1EntityType(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['entityTypeId']!.first,
          unittest.equals(arg_entityTypeId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          entityTypeId: arg_entityTypeId, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_name = 'foo';
      final arg_force = true;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['force']!.first,
          unittest.equals('$arg_force'),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.delete(arg_name, force: arg_force, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--deleteFeatureValues', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request =
          buildGoogleCloudAiplatformV1DeleteFeatureValuesRequest();
      final arg_entityType = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1DeleteFeatureValuesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1DeleteFeatureValuesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.deleteFeatureValues(
          arg_request, arg_entityType,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--exportFeatureValues', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request =
          buildGoogleCloudAiplatformV1ExportFeatureValuesRequest();
      final arg_entityType = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ExportFeatureValuesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ExportFeatureValuesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.exportFeatureValues(
          arg_request, arg_entityType,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1EntityType());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1EntityType(
          response as api.GoogleCloudAiplatformV1EntityType);
    });

    unittest.test('method--getIamPolicy', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_resource = 'foo';
      final arg_options_requestedPolicyVersion = 42;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['options.requestedPolicyVersion']!.first),
          unittest.equals(arg_options_requestedPolicyVersion),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleIamV1Policy());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.getIamPolicy(arg_resource,
          options_requestedPolicyVersion: arg_options_requestedPolicyVersion,
          $fields: arg_$fields);
      checkGoogleIamV1Policy(response as api.GoogleIamV1Policy);
    });

    unittest.test('method--importFeatureValues', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request =
          buildGoogleCloudAiplatformV1ImportFeatureValuesRequest();
      final arg_entityType = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ImportFeatureValuesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ImportFeatureValuesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.importFeatureValues(
          arg_request, arg_entityType,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListEntityTypesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListEntityTypesResponse(
          response as api.GoogleCloudAiplatformV1ListEntityTypesResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request = buildGoogleCloudAiplatformV1EntityType();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1EntityType.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1EntityType(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1EntityType());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1EntityType(
          response as api.GoogleCloudAiplatformV1EntityType);
    });

    unittest.test('method--readFeatureValues', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request =
          buildGoogleCloudAiplatformV1ReadFeatureValuesRequest();
      final arg_entityType = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ReadFeatureValuesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ReadFeatureValuesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ReadFeatureValuesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.readFeatureValues(arg_request, arg_entityType,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ReadFeatureValuesResponse(
          response as api.GoogleCloudAiplatformV1ReadFeatureValuesResponse);
    });

    unittest.test('method--setIamPolicy', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request = buildGoogleIamV1SetIamPolicyRequest();
      final arg_resource = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleIamV1SetIamPolicyRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleIamV1SetIamPolicyRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleIamV1Policy());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.setIamPolicy(arg_request, arg_resource,
          $fields: arg_$fields);
      checkGoogleIamV1Policy(response as api.GoogleIamV1Policy);
    });

    unittest.test('method--streamingReadFeatureValues', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request =
          buildGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest();
      final arg_entityType = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest
            .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1StreamingReadFeatureValuesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ReadFeatureValuesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.streamingReadFeatureValues(
          arg_request, arg_entityType,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ReadFeatureValuesResponse(
          response as api.GoogleCloudAiplatformV1ReadFeatureValuesResponse);
    });

    unittest.test('method--testIamPermissions', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_resource = 'foo';
      final arg_permissions = buildUnnamed339();
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['permissions']!,
          unittest.equals(arg_permissions),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleIamV1TestIamPermissionsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.testIamPermissions(arg_resource,
          permissions: arg_permissions, $fields: arg_$fields);
      checkGoogleIamV1TestIamPermissionsResponse(
          response as api.GoogleIamV1TestIamPermissionsResponse);
    });

    unittest.test('method--writeFeatureValues', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.entityTypes;
      final arg_request =
          buildGoogleCloudAiplatformV1WriteFeatureValuesRequest();
      final arg_entityType = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1WriteFeatureValuesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1WriteFeatureValuesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1WriteFeatureValuesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.writeFeatureValues(arg_request, arg_entityType,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1WriteFeatureValuesResponse(
          response as api.GoogleCloudAiplatformV1WriteFeatureValuesResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsFeaturestoresEntityTypesFeaturesResource', () {
    unittest.test('method--batchCreate', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features;
      final arg_request =
          buildGoogleCloudAiplatformV1BatchCreateFeaturesRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1BatchCreateFeaturesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchCreateFeaturesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.batchCreate(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features;
      final arg_request = buildGoogleCloudAiplatformV1Feature();
      final arg_parent = 'foo';
      final arg_featureId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Feature.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Feature(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['featureId']!.first,
          unittest.equals(arg_featureId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          featureId: arg_featureId, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Feature());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Feature(
          response as api.GoogleCloudAiplatformV1Feature);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_latestStatsCount = 42;
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['latestStatsCount']!.first),
          unittest.equals(arg_latestStatsCount),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListFeaturesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          latestStatsCount: arg_latestStatsCount,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListFeaturesResponse(
          response as api.GoogleCloudAiplatformV1ListFeaturesResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features;
      final arg_request = buildGoogleCloudAiplatformV1Feature();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Feature.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Feature(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Feature());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Feature(
          response as api.GoogleCloudAiplatformV1Feature);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .features
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsFeaturestoresEntityTypesOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .featurestores
          .entityTypes
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsFeaturestoresOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.featurestores.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsHyperparameterTuningJobsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.hyperparameterTuningJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.cancel(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.hyperparameterTuningJobs;
      final arg_request = buildGoogleCloudAiplatformV1HyperparameterTuningJob();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1HyperparameterTuningJob(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1HyperparameterTuningJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1HyperparameterTuningJob(
          response as api.GoogleCloudAiplatformV1HyperparameterTuningJob);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.hyperparameterTuningJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.hyperparameterTuningJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1HyperparameterTuningJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1HyperparameterTuningJob(
          response as api.GoogleCloudAiplatformV1HyperparameterTuningJob);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.hyperparameterTuningJobs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse(response
          as api.GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsHyperparameterTuningJobsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .hyperparameterTuningJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .hyperparameterTuningJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .hyperparameterTuningJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .hyperparameterTuningJobs
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .hyperparameterTuningJobs
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsIndexEndpointsResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_request = buildGoogleCloudAiplatformV1IndexEndpoint();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1IndexEndpoint.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1IndexEndpoint(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--deployIndex', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_request = buildGoogleCloudAiplatformV1DeployIndexRequest();
      final arg_indexEndpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1DeployIndexRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1DeployIndexRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.deployIndex(arg_request, arg_indexEndpoint,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--findNeighbors', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_request = buildGoogleCloudAiplatformV1FindNeighborsRequest();
      final arg_indexEndpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1FindNeighborsRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1FindNeighborsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1FindNeighborsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.findNeighbors(arg_request, arg_indexEndpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1FindNeighborsResponse(
          response as api.GoogleCloudAiplatformV1FindNeighborsResponse);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1IndexEndpoint());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1IndexEndpoint(
          response as api.GoogleCloudAiplatformV1IndexEndpoint);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListIndexEndpointsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListIndexEndpointsResponse(
          response as api.GoogleCloudAiplatformV1ListIndexEndpointsResponse);
    });

    unittest.test('method--mutateDeployedIndex', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_request = buildGoogleCloudAiplatformV1DeployedIndex();
      final arg_indexEndpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1DeployedIndex.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1DeployedIndex(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.mutateDeployedIndex(
          arg_request, arg_indexEndpoint,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_request = buildGoogleCloudAiplatformV1IndexEndpoint();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1IndexEndpoint.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1IndexEndpoint(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1IndexEndpoint());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1IndexEndpoint(
          response as api.GoogleCloudAiplatformV1IndexEndpoint);
    });

    unittest.test('method--readIndexDatapoints', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_request =
          buildGoogleCloudAiplatformV1ReadIndexDatapointsRequest();
      final arg_indexEndpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ReadIndexDatapointsRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ReadIndexDatapointsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ReadIndexDatapointsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.readIndexDatapoints(
          arg_request, arg_indexEndpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ReadIndexDatapointsResponse(
          response as api.GoogleCloudAiplatformV1ReadIndexDatapointsResponse);
    });

    unittest.test('method--undeployIndex', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexEndpoints;
      final arg_request = buildGoogleCloudAiplatformV1UndeployIndexRequest();
      final arg_indexEndpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1UndeployIndexRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1UndeployIndexRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.undeployIndex(arg_request, arg_indexEndpoint,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsIndexEndpointsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.indexEndpoints.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.indexEndpoints.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.indexEndpoints.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.indexEndpoints.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.indexEndpoints.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsIndexesResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes;
      final arg_request = buildGoogleCloudAiplatformV1Index();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Index.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Index(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Index());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Index(
          response as api.GoogleCloudAiplatformV1Index);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListIndexesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListIndexesResponse(
          response as api.GoogleCloudAiplatformV1ListIndexesResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes;
      final arg_request = buildGoogleCloudAiplatformV1Index();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Index.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Index(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--removeDatapoints', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes;
      final arg_request = buildGoogleCloudAiplatformV1RemoveDatapointsRequest();
      final arg_index = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1RemoveDatapointsRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1RemoveDatapointsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1RemoveDatapointsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.removeDatapoints(arg_request, arg_index,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1RemoveDatapointsResponse(
          response as api.GoogleCloudAiplatformV1RemoveDatapointsResponse);
    });

    unittest.test('method--upsertDatapoints', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes;
      final arg_request = buildGoogleCloudAiplatformV1UpsertDatapointsRequest();
      final arg_index = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1UpsertDatapointsRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1UpsertDatapointsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1UpsertDatapointsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.upsertDatapoints(arg_request, arg_index,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1UpsertDatapointsResponse(
          response as api.GoogleCloudAiplatformV1UpsertDatapointsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsIndexesOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.indexes.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsMetadataStoresResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.metadataStores;
      final arg_request = buildGoogleCloudAiplatformV1MetadataStore();
      final arg_parent = 'foo';
      final arg_metadataStoreId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1MetadataStore.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1MetadataStore(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['metadataStoreId']!.first,
          unittest.equals(arg_metadataStoreId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          metadataStoreId: arg_metadataStoreId, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.metadataStores;
      final arg_name = 'foo';
      final arg_force = true;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['force']!.first,
          unittest.equals('$arg_force'),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.delete(arg_name, force: arg_force, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.metadataStores;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1MetadataStore());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1MetadataStore(
          response as api.GoogleCloudAiplatformV1MetadataStore);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.metadataStores;
      final arg_parent = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListMetadataStoresResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListMetadataStoresResponse(
          response as api.GoogleCloudAiplatformV1ListMetadataStoresResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsMetadataStoresArtifactsResource',
      () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.artifacts;
      final arg_request = buildGoogleCloudAiplatformV1Artifact();
      final arg_parent = 'foo';
      final arg_artifactId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Artifact.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Artifact(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['artifactId']!.first,
          unittest.equals(arg_artifactId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Artifact());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          artifactId: arg_artifactId, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Artifact(
          response as api.GoogleCloudAiplatformV1Artifact);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.artifacts;
      final arg_name = 'foo';
      final arg_etag = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['etag']!.first,
          unittest.equals(arg_etag),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.delete(arg_name, etag: arg_etag, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.artifacts;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Artifact());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Artifact(
          response as api.GoogleCloudAiplatformV1Artifact);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.artifacts;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListArtifactsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListArtifactsResponse(
          response as api.GoogleCloudAiplatformV1ListArtifactsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.artifacts;
      final arg_request = buildGoogleCloudAiplatformV1Artifact();
      final arg_name = 'foo';
      final arg_allowMissing = true;
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Artifact.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Artifact(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['allowMissing']!.first,
          unittest.equals('$arg_allowMissing'),
        );
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Artifact());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          allowMissing: arg_allowMissing,
          updateMask: arg_updateMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Artifact(
          response as api.GoogleCloudAiplatformV1Artifact);
    });

    unittest.test('method--purge', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.artifacts;
      final arg_request = buildGoogleCloudAiplatformV1PurgeArtifactsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1PurgeArtifactsRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1PurgeArtifactsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.purge(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--queryArtifactLineageSubgraph', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.artifacts;
      final arg_artifact = 'foo';
      final arg_filter = 'foo';
      final arg_maxHops = 42;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['maxHops']!.first),
          unittest.equals(arg_maxHops),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1LineageSubgraph());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.queryArtifactLineageSubgraph(arg_artifact,
          filter: arg_filter, maxHops: arg_maxHops, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1LineageSubgraph(
          response as api.GoogleCloudAiplatformV1LineageSubgraph);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsMetadataStoresArtifactsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .artifacts
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .artifacts
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .artifacts
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .artifacts
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .artifacts
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsMetadataStoresContextsResource',
      () {
    unittest.test('method--addContextArtifactsAndExecutions', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_request =
          buildGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest();
      final arg_context = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest(
            obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.addContextArtifactsAndExecutions(
          arg_request, arg_context,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse(
          response as api
              .GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse);
    });

    unittest.test('method--addContextChildren', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_request =
          buildGoogleCloudAiplatformV1AddContextChildrenRequest();
      final arg_context = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1AddContextChildrenRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1AddContextChildrenRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1AddContextChildrenResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.addContextChildren(arg_request, arg_context,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1AddContextChildrenResponse(
          response as api.GoogleCloudAiplatformV1AddContextChildrenResponse);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_request = buildGoogleCloudAiplatformV1Context();
      final arg_parent = 'foo';
      final arg_contextId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Context.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Context(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['contextId']!.first,
          unittest.equals(arg_contextId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Context());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          contextId: arg_contextId, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Context(
          response as api.GoogleCloudAiplatformV1Context);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_name = 'foo';
      final arg_etag = 'foo';
      final arg_force = true;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['etag']!.first,
          unittest.equals(arg_etag),
        );
        unittest.expect(
          queryMap['force']!.first,
          unittest.equals('$arg_force'),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name,
          etag: arg_etag, force: arg_force, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Context());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Context(
          response as api.GoogleCloudAiplatformV1Context);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListContextsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListContextsResponse(
          response as api.GoogleCloudAiplatformV1ListContextsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_request = buildGoogleCloudAiplatformV1Context();
      final arg_name = 'foo';
      final arg_allowMissing = true;
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Context.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Context(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['allowMissing']!.first,
          unittest.equals('$arg_allowMissing'),
        );
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Context());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          allowMissing: arg_allowMissing,
          updateMask: arg_updateMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Context(
          response as api.GoogleCloudAiplatformV1Context);
    });

    unittest.test('method--purge', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_request = buildGoogleCloudAiplatformV1PurgeContextsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1PurgeContextsRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1PurgeContextsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.purge(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--queryContextLineageSubgraph', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_context = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1LineageSubgraph());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.queryContextLineageSubgraph(arg_context,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1LineageSubgraph(
          response as api.GoogleCloudAiplatformV1LineageSubgraph);
    });

    unittest.test('method--removeContextChildren', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.contexts;
      final arg_request =
          buildGoogleCloudAiplatformV1RemoveContextChildrenRequest();
      final arg_context = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1RemoveContextChildrenRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1RemoveContextChildrenRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1RemoveContextChildrenResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.removeContextChildren(arg_request, arg_context,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1RemoveContextChildrenResponse(
          response as api.GoogleCloudAiplatformV1RemoveContextChildrenResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsMetadataStoresContextsOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .contexts
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .contexts
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .contexts
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .contexts
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .contexts
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsMetadataStoresExecutionsResource',
      () {
    unittest.test('method--addExecutionEvents', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.executions;
      final arg_request =
          buildGoogleCloudAiplatformV1AddExecutionEventsRequest();
      final arg_execution = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1AddExecutionEventsRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1AddExecutionEventsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1AddExecutionEventsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.addExecutionEvents(arg_request, arg_execution,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1AddExecutionEventsResponse(
          response as api.GoogleCloudAiplatformV1AddExecutionEventsResponse);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.executions;
      final arg_request = buildGoogleCloudAiplatformV1Execution();
      final arg_parent = 'foo';
      final arg_executionId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Execution.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Execution(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['executionId']!.first,
          unittest.equals(arg_executionId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Execution());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          executionId: arg_executionId, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Execution(
          response as api.GoogleCloudAiplatformV1Execution);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.executions;
      final arg_name = 'foo';
      final arg_etag = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['etag']!.first,
          unittest.equals(arg_etag),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.delete(arg_name, etag: arg_etag, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.executions;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Execution());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Execution(
          response as api.GoogleCloudAiplatformV1Execution);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.executions;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListExecutionsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListExecutionsResponse(
          response as api.GoogleCloudAiplatformV1ListExecutionsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.executions;
      final arg_request = buildGoogleCloudAiplatformV1Execution();
      final arg_name = 'foo';
      final arg_allowMissing = true;
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Execution.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Execution(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['allowMissing']!.first,
          unittest.equals('$arg_allowMissing'),
        );
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Execution());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          allowMissing: arg_allowMissing,
          updateMask: arg_updateMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Execution(
          response as api.GoogleCloudAiplatformV1Execution);
    });

    unittest.test('method--purge', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.executions;
      final arg_request = buildGoogleCloudAiplatformV1PurgeExecutionsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1PurgeExecutionsRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1PurgeExecutionsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.purge(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--queryExecutionInputsAndOutputs', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.executions;
      final arg_execution = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1LineageSubgraph());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.queryExecutionInputsAndOutputs(arg_execution,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1LineageSubgraph(
          response as api.GoogleCloudAiplatformV1LineageSubgraph);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsMetadataStoresExecutionsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .executions
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .executions
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .executions
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .executions
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .executions
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsMetadataStoresMetadataSchemasResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .metadataSchemas;
      final arg_request = buildGoogleCloudAiplatformV1MetadataSchema();
      final arg_parent = 'foo';
      final arg_metadataSchemaId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1MetadataSchema.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1MetadataSchema(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['metadataSchemaId']!.first,
          unittest.equals(arg_metadataSchemaId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1MetadataSchema());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          metadataSchemaId: arg_metadataSchemaId, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1MetadataSchema(
          response as api.GoogleCloudAiplatformV1MetadataSchema);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .metadataSchemas;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1MetadataSchema());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1MetadataSchema(
          response as api.GoogleCloudAiplatformV1MetadataSchema);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .metadataStores
          .metadataSchemas;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListMetadataSchemasResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListMetadataSchemasResponse(
          response as api.GoogleCloudAiplatformV1ListMetadataSchemasResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsMetadataStoresOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.metadataStores.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsMigratableResourcesResource', () {
    unittest.test('method--batchMigrate', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.migratableResources;
      final arg_request =
          buildGoogleCloudAiplatformV1BatchMigrateResourcesRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1BatchMigrateResourcesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchMigrateResourcesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.batchMigrate(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--search', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.migratableResources;
      final arg_request =
          buildGoogleCloudAiplatformV1SearchMigratableResourcesRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1SearchMigratableResourcesRequest
            .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1SearchMigratableResourcesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1SearchMigratableResourcesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.search(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1SearchMigratableResourcesResponse(response
          as api.GoogleCloudAiplatformV1SearchMigratableResourcesResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsMigratableResourcesOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .migratableResources
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .migratableResources
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .migratableResources
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .migratableResources
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .migratableResources
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsModelDeploymentMonitoringJobsResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJob();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(
          response as api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(
          response as api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse(
          response as api
              .GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1ModelDeploymentMonitoringJob();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ModelDeploymentMonitoringJob(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--pause', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest(
            obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.pause(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--resume', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest(
            obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.resume(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--searchModelDeploymentMonitoringStatsAnomalies',
        () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest();
      final arg_modelDeploymentMonitoringJob = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest(
            obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.searchModelDeploymentMonitoringStatsAnomalies(
          arg_request, arg_modelDeploymentMonitoringJob,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse(
          response as api
              .GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .modelDeploymentMonitoringJobs
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsModelsResource', () {
    unittest.test('method--copy', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_request = buildGoogleCloudAiplatformV1CopyModelRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1CopyModelRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CopyModelRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.copy(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--deleteVersion', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.deleteVersion(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--export', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_request = buildGoogleCloudAiplatformV1ExportModelRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1ExportModelRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ExportModelRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.export(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Model());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Model(
          response as api.GoogleCloudAiplatformV1Model);
    });

    unittest.test('method--getIamPolicy', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_resource = 'foo';
      final arg_options_requestedPolicyVersion = 42;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['options.requestedPolicyVersion']!.first),
          unittest.equals(arg_options_requestedPolicyVersion),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleIamV1Policy());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.getIamPolicy(arg_resource,
          options_requestedPolicyVersion: arg_options_requestedPolicyVersion,
          $fields: arg_$fields);
      checkGoogleIamV1Policy(response as api.GoogleIamV1Policy);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListModelsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListModelsResponse(
          response as api.GoogleCloudAiplatformV1ListModelsResponse);
    });

    unittest.test('method--listVersions', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListModelVersionsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.listVersions(arg_name,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListModelVersionsResponse(
          response as api.GoogleCloudAiplatformV1ListModelVersionsResponse);
    });

    unittest.test('method--mergeVersionAliases', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_request =
          buildGoogleCloudAiplatformV1MergeVersionAliasesRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1MergeVersionAliasesRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1MergeVersionAliasesRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Model());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.mergeVersionAliases(arg_request, arg_name,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Model(
          response as api.GoogleCloudAiplatformV1Model);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_request = buildGoogleCloudAiplatformV1Model();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Model.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Model(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Model());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Model(
          response as api.GoogleCloudAiplatformV1Model);
    });

    unittest.test('method--setIamPolicy', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_request = buildGoogleIamV1SetIamPolicyRequest();
      final arg_resource = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleIamV1SetIamPolicyRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleIamV1SetIamPolicyRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleIamV1Policy());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.setIamPolicy(arg_request, arg_resource,
          $fields: arg_$fields);
      checkGoogleIamV1Policy(response as api.GoogleIamV1Policy);
    });

    unittest.test('method--testIamPermissions', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_resource = 'foo';
      final arg_permissions = buildUnnamed340();
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['permissions']!,
          unittest.equals(arg_permissions),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleIamV1TestIamPermissionsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.testIamPermissions(arg_resource,
          permissions: arg_permissions, $fields: arg_$fields);
      checkGoogleIamV1TestIamPermissionsResponse(
          response as api.GoogleIamV1TestIamPermissionsResponse);
    });

    unittest.test('method--updateExplanationDataset', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_request =
          buildGoogleCloudAiplatformV1UpdateExplanationDatasetRequest();
      final arg_model = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1UpdateExplanationDatasetRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1UpdateExplanationDatasetRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.updateExplanationDataset(
          arg_request, arg_model,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--upload', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models;
      final arg_request = buildGoogleCloudAiplatformV1UploadModelRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1UploadModelRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1UploadModelRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.upload(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsModelsEvaluationsResource', () {
    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models.evaluations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1ModelEvaluation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ModelEvaluation(
          response as api.GoogleCloudAiplatformV1ModelEvaluation);
    });

    unittest.test('method--import', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models.evaluations;
      final arg_request =
          buildGoogleCloudAiplatformV1ImportModelEvaluationRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ImportModelEvaluationRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ImportModelEvaluationRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1ModelEvaluation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.import(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ModelEvaluation(
          response as api.GoogleCloudAiplatformV1ModelEvaluation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models.evaluations;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListModelEvaluationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListModelEvaluationsResponse(
          response as api.GoogleCloudAiplatformV1ListModelEvaluationsResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsModelsEvaluationsOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .models
          .evaluations
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .models
          .evaluations
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .models
          .evaluations
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .models
          .evaluations
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .models
          .evaluations
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsModelsEvaluationsSlicesResource',
      () {
    unittest.test('method--batchImport', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.models.evaluations.slices;
      final arg_request =
          buildGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.batchImport(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse(
          response as api
              .GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.models.evaluations.slices;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ModelEvaluationSlice());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ModelEvaluationSlice(
          response as api.GoogleCloudAiplatformV1ModelEvaluationSlice);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.models.evaluations.slices;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListModelEvaluationSlicesResponse(response
          as api.GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsModelsOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.models.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsNasJobsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.nasJobs;
      final arg_request = buildGoogleCloudAiplatformV1CancelNasJobRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1CancelNasJobRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CancelNasJobRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.cancel(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.nasJobs;
      final arg_request = buildGoogleCloudAiplatformV1NasJob();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1NasJob.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1NasJob(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1NasJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1NasJob(
          response as api.GoogleCloudAiplatformV1NasJob);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.nasJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.nasJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1NasJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1NasJob(
          response as api.GoogleCloudAiplatformV1NasJob);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.nasJobs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListNasJobsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListNasJobsResponse(
          response as api.GoogleCloudAiplatformV1ListNasJobsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsNasJobsNasTrialDetailsResource',
      () {
    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.nasJobs.nasTrialDetails;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1NasTrialDetail());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1NasTrialDetail(
          response as api.GoogleCloudAiplatformV1NasTrialDetail);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.nasJobs.nasTrialDetails;
      final arg_parent = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListNasTrialDetailsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListNasTrialDetailsResponse(
          response as api.GoogleCloudAiplatformV1ListNasTrialDetailsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsNotebookRuntimeTemplatesResource',
      () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.notebookRuntimeTemplates;
      final arg_request = buildGoogleCloudAiplatformV1NotebookRuntimeTemplate();
      final arg_parent = 'foo';
      final arg_notebookRuntimeTemplateId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1NotebookRuntimeTemplate(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['notebookRuntimeTemplateId']!.first,
          unittest.equals(arg_notebookRuntimeTemplateId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          notebookRuntimeTemplateId: arg_notebookRuntimeTemplateId,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.notebookRuntimeTemplates;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.notebookRuntimeTemplates;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1NotebookRuntimeTemplate());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1NotebookRuntimeTemplate(
          response as api.GoogleCloudAiplatformV1NotebookRuntimeTemplate);
    });

    unittest.test('method--getIamPolicy', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.notebookRuntimeTemplates;
      final arg_resource = 'foo';
      final arg_options_requestedPolicyVersion = 42;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['options.requestedPolicyVersion']!.first),
          unittest.equals(arg_options_requestedPolicyVersion),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleIamV1Policy());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.getIamPolicy(arg_resource,
          options_requestedPolicyVersion: arg_options_requestedPolicyVersion,
          $fields: arg_$fields);
      checkGoogleIamV1Policy(response as api.GoogleIamV1Policy);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.notebookRuntimeTemplates;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse(response
          as api.GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse);
    });

    unittest.test('method--setIamPolicy', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.notebookRuntimeTemplates;
      final arg_request = buildGoogleIamV1SetIamPolicyRequest();
      final arg_resource = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleIamV1SetIamPolicyRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleIamV1SetIamPolicyRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleIamV1Policy());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.setIamPolicy(arg_request, arg_resource,
          $fields: arg_$fields);
      checkGoogleIamV1Policy(response as api.GoogleIamV1Policy);
    });

    unittest.test('method--testIamPermissions', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.notebookRuntimeTemplates;
      final arg_resource = 'foo';
      final arg_permissions = buildUnnamed341();
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['permissions']!,
          unittest.equals(arg_permissions),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleIamV1TestIamPermissionsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.testIamPermissions(arg_resource,
          permissions: arg_permissions, $fields: arg_$fields);
      checkGoogleIamV1TestIamPermissionsResponse(
          response as api.GoogleIamV1TestIamPermissionsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsNotebookRuntimesResource', () {
    unittest.test('method--assign', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.notebookRuntimes;
      final arg_request =
          buildGoogleCloudAiplatformV1AssignNotebookRuntimeRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1AssignNotebookRuntimeRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1AssignNotebookRuntimeRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.assign(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.notebookRuntimes;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.notebookRuntimes;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1NotebookRuntime());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1NotebookRuntime(
          response as api.GoogleCloudAiplatformV1NotebookRuntime);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.notebookRuntimes;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListNotebookRuntimesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListNotebookRuntimesResponse(
          response as api.GoogleCloudAiplatformV1ListNotebookRuntimesResponse);
    });

    unittest.test('method--start', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.notebookRuntimes;
      final arg_request =
          buildGoogleCloudAiplatformV1StartNotebookRuntimeRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1StartNotebookRuntimeRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1StartNotebookRuntimeRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.start(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--upgrade', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.notebookRuntimes;
      final arg_request =
          buildGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.upgrade(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsPipelineJobsResource', () {
    unittest.test('method--batchCancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.pipelineJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchCancelPipelineJobsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.batchCancel(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--batchDelete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.pipelineJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchDeletePipelineJobsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.batchDelete(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.pipelineJobs;
      final arg_request =
          buildGoogleCloudAiplatformV1CancelPipelineJobRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1CancelPipelineJobRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CancelPipelineJobRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.cancel(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.pipelineJobs;
      final arg_request = buildGoogleCloudAiplatformV1PipelineJob();
      final arg_parent = 'foo';
      final arg_pipelineJobId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1PipelineJob.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1PipelineJob(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['pipelineJobId']!.first,
          unittest.equals(arg_pipelineJobId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1PipelineJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          pipelineJobId: arg_pipelineJobId, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1PipelineJob(
          response as api.GoogleCloudAiplatformV1PipelineJob);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.pipelineJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.pipelineJobs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1PipelineJob());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1PipelineJob(
          response as api.GoogleCloudAiplatformV1PipelineJob);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.pipelineJobs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListPipelineJobsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListPipelineJobsResponse(
          response as api.GoogleCloudAiplatformV1ListPipelineJobsResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsPipelineJobsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.pipelineJobs.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.pipelineJobs.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.pipelineJobs.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.pipelineJobs.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.pipelineJobs.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsPublishersModelsResource', () {
    unittest.test('method--computeTokens', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.publishers.models;
      final arg_request = buildGoogleCloudAiplatformV1ComputeTokensRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1ComputeTokensRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ComputeTokensRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ComputeTokensResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.computeTokens(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ComputeTokensResponse(
          response as api.GoogleCloudAiplatformV1ComputeTokensResponse);
    });

    unittest.test('method--countTokens', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.publishers.models;
      final arg_request = buildGoogleCloudAiplatformV1CountTokensRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1CountTokensRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CountTokensRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1CountTokensResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.countTokens(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1CountTokensResponse(
          response as api.GoogleCloudAiplatformV1CountTokensResponse);
    });

    unittest.test('method--generateContent', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.publishers.models;
      final arg_request = buildGoogleCloudAiplatformV1GenerateContentRequest();
      final arg_model = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1GenerateContentRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1GenerateContentRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1GenerateContentResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.generateContent(arg_request, arg_model,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1GenerateContentResponse(
          response as api.GoogleCloudAiplatformV1GenerateContentResponse);
    });

    unittest.test('method--predict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.publishers.models;
      final arg_request = buildGoogleCloudAiplatformV1PredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1PredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1PredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1PredictResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.predict(arg_request, arg_endpoint, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1PredictResponse(
          response as api.GoogleCloudAiplatformV1PredictResponse);
    });

    unittest.test('method--rawPredict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.publishers.models;
      final arg_request = buildGoogleCloudAiplatformV1RawPredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1RawPredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1RawPredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleApiHttpBody());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.rawPredict(arg_request, arg_endpoint, $fields: arg_$fields);
      checkGoogleApiHttpBody(response as api.GoogleApiHttpBody);
    });

    unittest.test('method--serverStreamingPredict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.publishers.models;
      final arg_request = buildGoogleCloudAiplatformV1StreamingPredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1StreamingPredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1StreamingPredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1StreamingPredictResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.serverStreamingPredict(
          arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1StreamingPredictResponse(
          response as api.GoogleCloudAiplatformV1StreamingPredictResponse);
    });

    unittest.test('method--streamGenerateContent', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.publishers.models;
      final arg_request = buildGoogleCloudAiplatformV1GenerateContentRequest();
      final arg_model = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1GenerateContentRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1GenerateContentRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1GenerateContentResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.streamGenerateContent(arg_request, arg_model,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1GenerateContentResponse(
          response as api.GoogleCloudAiplatformV1GenerateContentResponse);
    });

    unittest.test('method--streamRawPredict', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.publishers.models;
      final arg_request = buildGoogleCloudAiplatformV1StreamRawPredictRequest();
      final arg_endpoint = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1StreamRawPredictRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1StreamRawPredictRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleApiHttpBody());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.streamRawPredict(arg_request, arg_endpoint,
          $fields: arg_$fields);
      checkGoogleApiHttpBody(response as api.GoogleApiHttpBody);
    });
  });

  unittest.group('resource-ProjectsLocationsSchedulesResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.schedules;
      final arg_request = buildGoogleCloudAiplatformV1Schedule();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Schedule.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Schedule(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Schedule());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Schedule(
          response as api.GoogleCloudAiplatformV1Schedule);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.schedules;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.schedules;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Schedule());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Schedule(
          response as api.GoogleCloudAiplatformV1Schedule);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.schedules;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListSchedulesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListSchedulesResponse(
          response as api.GoogleCloudAiplatformV1ListSchedulesResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.schedules;
      final arg_request = buildGoogleCloudAiplatformV1Schedule();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Schedule.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Schedule(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Schedule());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Schedule(
          response as api.GoogleCloudAiplatformV1Schedule);
    });

    unittest.test('method--pause', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.schedules;
      final arg_request = buildGoogleCloudAiplatformV1PauseScheduleRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1PauseScheduleRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1PauseScheduleRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.pause(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--resume', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.schedules;
      final arg_request = buildGoogleCloudAiplatformV1ResumeScheduleRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1ResumeScheduleRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ResumeScheduleRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.resume(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });
  });

  unittest.group('resource-ProjectsLocationsSchedulesOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.schedules.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.schedules.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.schedules.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.schedules.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.schedules.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsSpecialistPoolsResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.specialistPools;
      final arg_request = buildGoogleCloudAiplatformV1SpecialistPool();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1SpecialistPool.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1SpecialistPool(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.specialistPools;
      final arg_name = 'foo';
      final arg_force = true;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['force']!.first,
          unittest.equals('$arg_force'),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.delete(arg_name, force: arg_force, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.specialistPools;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1SpecialistPool());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1SpecialistPool(
          response as api.GoogleCloudAiplatformV1SpecialistPool);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.specialistPools;
      final arg_parent = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListSpecialistPoolsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListSpecialistPoolsResponse(
          response as api.GoogleCloudAiplatformV1ListSpecialistPoolsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.specialistPools;
      final arg_request = buildGoogleCloudAiplatformV1SpecialistPool();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1SpecialistPool.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1SpecialistPool(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsSpecialistPoolsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.specialistPools.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.specialistPools.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.specialistPools.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.specialistPools.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.specialistPools.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsStudiesResource', () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies;
      final arg_request = buildGoogleCloudAiplatformV1Study();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Study.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Study(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Study());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Study(
          response as api.GoogleCloudAiplatformV1Study);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Study());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Study(
          response as api.GoogleCloudAiplatformV1Study);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies;
      final arg_parent = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListStudiesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListStudiesResponse(
          response as api.GoogleCloudAiplatformV1ListStudiesResponse);
    });

    unittest.test('method--lookup', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies;
      final arg_request = buildGoogleCloudAiplatformV1LookupStudyRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1LookupStudyRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1LookupStudyRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Study());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.lookup(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Study(
          response as api.GoogleCloudAiplatformV1Study);
    });
  });

  unittest.group('resource-ProjectsLocationsStudiesOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsStudiesTrialsResource', () {
    unittest.test('method--addTrialMeasurement', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_request =
          buildGoogleCloudAiplatformV1AddTrialMeasurementRequest();
      final arg_trialName = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1AddTrialMeasurementRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1AddTrialMeasurementRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Trial());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.addTrialMeasurement(arg_request, arg_trialName,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Trial(
          response as api.GoogleCloudAiplatformV1Trial);
    });

    unittest.test('method--checkTrialEarlyStoppingState', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_request =
          buildGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest();
      final arg_trialName = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.checkTrialEarlyStoppingState(
          arg_request, arg_trialName,
          $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--complete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_request = buildGoogleCloudAiplatformV1CompleteTrialRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1CompleteTrialRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CompleteTrialRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Trial());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.complete(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Trial(
          response as api.GoogleCloudAiplatformV1Trial);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_request = buildGoogleCloudAiplatformV1Trial();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Trial.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Trial(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Trial());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Trial(
          response as api.GoogleCloudAiplatformV1Trial);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Trial());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Trial(
          response as api.GoogleCloudAiplatformV1Trial);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_parent = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListTrialsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListTrialsResponse(
          response as api.GoogleCloudAiplatformV1ListTrialsResponse);
    });

    unittest.test('method--listOptimalTrials', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_request =
          buildGoogleCloudAiplatformV1ListOptimalTrialsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ListOptimalTrialsRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ListOptimalTrialsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListOptimalTrialsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.listOptimalTrials(arg_request, arg_parent,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListOptimalTrialsResponse(
          response as api.GoogleCloudAiplatformV1ListOptimalTrialsResponse);
    });

    unittest.test('method--stop', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_request = buildGoogleCloudAiplatformV1StopTrialRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1StopTrialRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1StopTrialRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleCloudAiplatformV1Trial());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.stop(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Trial(
          response as api.GoogleCloudAiplatformV1Trial);
    });

    unittest.test('method--suggest', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.studies.trials;
      final arg_request = buildGoogleCloudAiplatformV1SuggestTrialsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1SuggestTrialsRequest.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1SuggestTrialsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.suggest(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsStudiesTrialsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.studies.trials.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.studies.trials.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.studies.trials.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.studies.trials.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.studies.trials.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsTensorboardsResource', () {
    unittest.test('method--batchRead', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.tensorboards;
      final arg_tensorboard = 'foo';
      final arg_timeSeries = buildUnnamed342();
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeSeries']!,
          unittest.equals(arg_timeSeries),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.batchRead(arg_tensorboard,
          timeSeries: arg_timeSeries, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse(
          response as api
              .GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.tensorboards;
      final arg_request = buildGoogleCloudAiplatformV1Tensorboard();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Tensorboard.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Tensorboard(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.tensorboards;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.tensorboards;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1Tensorboard());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1Tensorboard(
          response as api.GoogleCloudAiplatformV1Tensorboard);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.tensorboards;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListTensorboardsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListTensorboardsResponse(
          response as api.GoogleCloudAiplatformV1ListTensorboardsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.tensorboards;
      final arg_request = buildGoogleCloudAiplatformV1Tensorboard();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1Tensorboard.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1Tensorboard(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--readSize', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.tensorboards;
      final arg_tensorboard = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ReadTensorboardSizeResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.readSize(arg_tensorboard, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ReadTensorboardSizeResponse(
          response as api.GoogleCloudAiplatformV1ReadTensorboardSizeResponse);
    });

    unittest.test('method--readUsage', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.tensorboards;
      final arg_tensorboard = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ReadTensorboardUsageResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.readUsage(arg_tensorboard, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ReadTensorboardUsageResponse(
          response as api.GoogleCloudAiplatformV1ReadTensorboardUsageResponse);
    });
  });

  unittest.group('resource-ProjectsLocationsTensorboardsExperimentsResource',
      () {
    unittest.test('method--batchCreate', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.experiments;
      final arg_request =
          buildGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest(
            obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.batchCreate(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse(
          response as api
              .GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.experiments;
      final arg_request = buildGoogleCloudAiplatformV1TensorboardExperiment();
      final arg_parent = 'foo';
      final arg_tensorboardExperimentId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1TensorboardExperiment(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['tensorboardExperimentId']!.first,
          unittest.equals(arg_tensorboardExperimentId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1TensorboardExperiment());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          tensorboardExperimentId: arg_tensorboardExperimentId,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardExperiment(
          response as api.GoogleCloudAiplatformV1TensorboardExperiment);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.experiments;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.experiments;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1TensorboardExperiment());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardExperiment(
          response as api.GoogleCloudAiplatformV1TensorboardExperiment);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.experiments;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListTensorboardExperimentsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListTensorboardExperimentsResponse(response
          as api.GoogleCloudAiplatformV1ListTensorboardExperimentsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.experiments;
      final arg_request = buildGoogleCloudAiplatformV1TensorboardExperiment();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1TensorboardExperiment(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1TensorboardExperiment());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardExperiment(
          response as api.GoogleCloudAiplatformV1TensorboardExperiment);
    });

    unittest.test('method--write', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.experiments;
      final arg_request =
          buildGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest();
      final arg_tensorboardExperiment = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.write(arg_request, arg_tensorboardExperiment,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse(
          response as api
              .GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsTensorboardsExperimentsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsTensorboardsExperimentsRunsResource', () {
    unittest.test('method--batchCreate', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs;
      final arg_request =
          buildGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest
            .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.batchCreate(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse(response
          as api.GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs;
      final arg_request = buildGoogleCloudAiplatformV1TensorboardRun();
      final arg_parent = 'foo';
      final arg_tensorboardRunId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1TensorboardRun.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1TensorboardRun(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['tensorboardRunId']!.first,
          unittest.equals(arg_tensorboardRunId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1TensorboardRun());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          tensorboardRunId: arg_tensorboardRunId, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardRun(
          response as api.GoogleCloudAiplatformV1TensorboardRun);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1TensorboardRun());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardRun(
          response as api.GoogleCloudAiplatformV1TensorboardRun);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1ListTensorboardRunsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListTensorboardRunsResponse(
          response as api.GoogleCloudAiplatformV1ListTensorboardRunsResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs;
      final arg_request = buildGoogleCloudAiplatformV1TensorboardRun();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1TensorboardRun.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1TensorboardRun(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1TensorboardRun());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardRun(
          response as api.GoogleCloudAiplatformV1TensorboardRun);
    });

    unittest.test('method--write', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs;
      final arg_request =
          buildGoogleCloudAiplatformV1WriteTensorboardRunDataRequest();
      final arg_tensorboardRun = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1WriteTensorboardRunDataRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1WriteTensorboardRunDataRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1WriteTensorboardRunDataResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.write(arg_request, arg_tensorboardRun,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1WriteTensorboardRunDataResponse(response
          as api.GoogleCloudAiplatformV1WriteTensorboardRunDataResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsTensorboardsExperimentsRunsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource',
      () {
    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries;
      final arg_request = buildGoogleCloudAiplatformV1TensorboardTimeSeries();
      final arg_parent = 'foo';
      final arg_tensorboardTimeSeriesId = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1TensorboardTimeSeries(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['tensorboardTimeSeriesId']!.first,
          unittest.equals(arg_tensorboardTimeSeriesId),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1TensorboardTimeSeries());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.create(arg_request, arg_parent,
          tensorboardTimeSeriesId: arg_tensorboardTimeSeriesId,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardTimeSeries(
          response as api.GoogleCloudAiplatformV1TensorboardTimeSeries);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--exportTensorboardTimeSeries', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries;
      final arg_request =
          buildGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest();
      final arg_tensorboardTimeSeries = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest
                .fromJson(json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.exportTensorboardTimeSeries(
          arg_request, arg_tensorboardTimeSeries,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse(
          response as api
              .GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1TensorboardTimeSeries());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardTimeSeries(
          response as api.GoogleCloudAiplatformV1TensorboardTimeSeries);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_orderBy = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          queryMap['orderBy']!.first,
          unittest.equals(arg_orderBy),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          orderBy: arg_orderBy,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse(response
          as api.GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse);
    });

    unittest.test('method--patch', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries;
      final arg_request = buildGoogleCloudAiplatformV1TensorboardTimeSeries();
      final arg_name = 'foo';
      final arg_updateMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1TensorboardTimeSeries(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['updateMask']!.first,
          unittest.equals(arg_updateMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json
            .encode(buildGoogleCloudAiplatformV1TensorboardTimeSeries());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.patch(arg_request, arg_name,
          updateMask: arg_updateMask, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TensorboardTimeSeries(
          response as api.GoogleCloudAiplatformV1TensorboardTimeSeries);
    });

    unittest.test('method--read', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries;
      final arg_tensorboardTimeSeries = 'foo';
      final arg_filter = 'foo';
      final arg_maxDataPoints = 42;
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['maxDataPoints']!.first),
          unittest.equals(arg_maxDataPoints),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.read(arg_tensorboardTimeSeries,
          filter: arg_filter,
          maxDataPoints: arg_maxDataPoints,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse(response
          as api.GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse);
    });

    unittest.test('method--readBlobData', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries;
      final arg_timeSeries = 'foo';
      final arg_blobIds = buildUnnamed343();
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['blobIds']!,
          unittest.equals(arg_blobIds),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.readBlobData(arg_timeSeries,
          blobIds: arg_blobIds, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ReadTensorboardBlobDataResponse(response
          as api.GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .tensorboards
          .experiments
          .runs
          .timeSeries
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsTensorboardsOperationsResource',
      () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res =
          api.AiplatformApi(mock).projects.locations.tensorboards.operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-ProjectsLocationsTrainingPipelinesResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.trainingPipelines;
      final arg_request =
          buildGoogleCloudAiplatformV1CancelTrainingPipelineRequest();
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj =
            api.GoogleCloudAiplatformV1CancelTrainingPipelineRequest.fromJson(
                json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1CancelTrainingPipelineRequest(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.cancel(arg_request, arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--create', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.trainingPipelines;
      final arg_request = buildGoogleCloudAiplatformV1TrainingPipeline();
      final arg_parent = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final obj = api.GoogleCloudAiplatformV1TrainingPipeline.fromJson(
            json as core.Map<core.String, core.dynamic>);
        checkGoogleCloudAiplatformV1TrainingPipeline(obj);

        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1TrainingPipeline());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.create(arg_request, arg_parent, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TrainingPipeline(
          response as api.GoogleCloudAiplatformV1TrainingPipeline);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.trainingPipelines;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.trainingPipelines;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1TrainingPipeline());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1TrainingPipeline(
          response as api.GoogleCloudAiplatformV1TrainingPipeline);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).projects.locations.trainingPipelines;
      final arg_parent = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_readMask = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['readMask']!.first,
          unittest.equals(arg_readMask),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(
            buildGoogleCloudAiplatformV1ListTrainingPipelinesResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_parent,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          readMask: arg_readMask,
          $fields: arg_$fields);
      checkGoogleCloudAiplatformV1ListTrainingPipelinesResponse(
          response as api.GoogleCloudAiplatformV1ListTrainingPipelinesResponse);
    });
  });

  unittest.group(
      'resource-ProjectsLocationsTrainingPipelinesOperationsResource', () {
    unittest.test('method--cancel', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .trainingPipelines
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.cancel(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--delete', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .trainingPipelines
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleProtobufEmpty());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.delete(arg_name, $fields: arg_$fields);
      checkGoogleProtobufEmpty(response as api.GoogleProtobufEmpty);
    });

    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .trainingPipelines
          .operations;
      final arg_name = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });

    unittest.test('method--list', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .trainingPipelines
          .operations;
      final arg_name = 'foo';
      final arg_filter = 'foo';
      final arg_pageSize = 42;
      final arg_pageToken = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['filter']!.first,
          unittest.equals(arg_filter),
        );
        unittest.expect(
          core.int.parse(queryMap['pageSize']!.first),
          unittest.equals(arg_pageSize),
        );
        unittest.expect(
          queryMap['pageToken']!.first,
          unittest.equals(arg_pageToken),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleLongrunningListOperationsResponse());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.list(arg_name,
          filter: arg_filter,
          pageSize: arg_pageSize,
          pageToken: arg_pageToken,
          $fields: arg_$fields);
      checkGoogleLongrunningListOperationsResponse(
          response as api.GoogleLongrunningListOperationsResponse);
    });

    unittest.test('method--wait', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock)
          .projects
          .locations
          .trainingPipelines
          .operations;
      final arg_name = 'foo';
      final arg_timeout = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['timeout']!.first,
          unittest.equals(arg_timeout),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp = convert.json.encode(buildGoogleLongrunningOperation());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response =
          await res.wait(arg_name, timeout: arg_timeout, $fields: arg_$fields);
      checkGoogleLongrunningOperation(
          response as api.GoogleLongrunningOperation);
    });
  });

  unittest.group('resource-PublishersModelsResource', () {
    unittest.test('method--get', () async {
      final mock = HttpServerMock();
      final res = api.AiplatformApi(mock).publishers.models;
      final arg_name = 'foo';
      final arg_languageCode = 'foo';
      final arg_view = 'foo';
      final arg_$fields = 'foo';
      mock.register(unittest.expectAsync2((http.BaseRequest req, json) {
        final path = req.url.path;
        var pathOffset = 0;
        core.int index;
        core.String subPart;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 1),
          unittest.equals('/'),
        );
        pathOffset += 1;
        unittest.expect(
          path.substring(pathOffset, pathOffset + 3),
          unittest.equals('v1/'),
        );
        pathOffset += 3;
        // NOTE: We cannot test reserved expansions due to the inability to reverse the operation;

        final query = req.url.query;
        var queryOffset = 0;
        final queryMap = <core.String, core.List<core.String>>{};
        void addQueryParam(core.String n, core.String v) =>
            queryMap.putIfAbsent(n, () => []).add(v);

        if (query.isNotEmpty) {
          for (var part in query.split('&')) {
            final keyValue = part.split('=');
            addQueryParam(
              core.Uri.decodeQueryComponent(keyValue[0]),
              core.Uri.decodeQueryComponent(keyValue[1]),
            );
          }
        }
        unittest.expect(
          queryMap['languageCode']!.first,
          unittest.equals(arg_languageCode),
        );
        unittest.expect(
          queryMap['view']!.first,
          unittest.equals(arg_view),
        );
        unittest.expect(
          queryMap['fields']!.first,
          unittest.equals(arg_$fields),
        );

        final h = {
          'content-type': 'application/json; charset=utf-8',
        };
        final resp =
            convert.json.encode(buildGoogleCloudAiplatformV1PublisherModel());
        return async.Future.value(stringResponse(200, h, resp));
      }), true);
      final response = await res.get(arg_name,
          languageCode: arg_languageCode, view: arg_view, $fields: arg_$fields);
      checkGoogleCloudAiplatformV1PublisherModel(
          response as api.GoogleCloudAiplatformV1PublisherModel);
    });
  });
}
